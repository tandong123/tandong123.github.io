{"meta":{"title":"TD","subtitle":"TDの博客","description":"湖南应用技术学院 | 软件技术专业 | 软件开发","author":"TD","url":"https://gitee.com/td278121","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"https://gitee.com/td278121/404.html","excerpt":"","text":""},{"title":"","date":"2021-09-14T05:00:02.323Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://gitee.com/td278121/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-09-14T05:00:24.099Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://gitee.com/td278121/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"https://gitee.com/td278121/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"categories/index.html","permalink":"https://gitee.com/td278121/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"census/index.html","permalink":"https://gitee.com/td278121/census/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"archives/index.html","permalink":"https://gitee.com/td278121/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"about/index.html","permalink":"https://gitee.com/td278121/about/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"contact/index.html","permalink":"https://gitee.com/td278121/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"tags/index.html","permalink":"https://gitee.com/td278121/tags/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"https://gitee.com/td278121/resource/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-05-03T05:27:07.212Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/index.html","permalink":"https://gitee.com/td278121/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"https://gitee.com/td278121/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"https://gitee.com/td278121/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://gitee.com/td278121/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-05-03T05:27:07.213Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-05-03T05:27:07.213Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-05-03T05:27:07.214Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-05-03T05:27:07.214Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-05-03T05:27:07.215Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-05-03T05:27:07.216Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-05-03T05:27:07.214Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-05-03T05:27:07.217Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-05-03T05:27:07.216Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-05-03T05:27:07.217Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-05-03T05:27:07.218Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-05-03T05:27:07.218Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""}],"posts":[{"title":"AJAX","slug":"AJAX","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:18:26.876Z","comments":true,"path":"posts/ea4e9745.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9745.html","excerpt":"","text":"简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 伪造Ajax我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function(){ var myDate = new Date(); document.getElementById('currentTime').innerText = myDate.getTime(); }; function LoadPage(){ var targetUrl = document.getElementById('url').value; console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; } &lt;/script&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" value=\"https://www.baidu.com/\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage()\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3、使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 ….等等 jQuery.ajax纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;beanclass=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 2、编写一个AjaxController @Controller public class AjaxController { @RequestMapping(\"/a1\") public void ajax1(String name , HttpServletResponse response) throwsIOException { if (\"admin\".equals(name)){ response.getWriter().print(\"true\"); }else{ response.getWriter().print(\"false\"); } } } 3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入 &lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; 4、编写index.jsp测试 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt;--%&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ &lt;%-- 这里的$是jQuery的缩写--%&gt; $.post({ url:\"${pageContext.request.contextPath}/a1\", data:{'name':$(\"#txtName\").val()}, success:function (data,status) { &lt;%-- 这里的data是后台controller返回的数据--%&gt; alert(data); alert(status); } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;%--onblur：失去焦点触发事件--%&gt; 用户名:&lt;input type=\"text\" id=\"txtName\" onblur=\"a1()\"/&gt; &lt;/body&gt; &lt;/html&gt; 5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ Springmvc实现实体类user @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 我们来获取一个集合对象，展示到前端页面 @RequestMapping(\"/a2\") public List&lt;User&gt; ajax2(){ List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(\"秦疆1号\",3,\"男\")); list.add(new User(\"秦疆2号\",3,\"男\")); list.add(new User(\"秦疆3号\",3,\"男\")); return list; //由于@RestController注解，将list转成json格式返回 } 前端页面 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" id=\"btn\" value=\"获取数据\"/&gt; &lt;table width=\"80%\" align=\"center\"&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;tbody id=\"content\"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () { $(\"#btn\").click(function () { $.post(\"${pageContext.request.contextPath}/a2\",function (data) { console.log(data) var html=\"\"; for (var i = 0; i &lt;data.length ; i++) { html+= \"&lt;tr&gt;\" + \"&lt;td&gt;\" + data[i].name + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].age + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].sex + \"&lt;/td&gt;\" + \"&lt;/tr&gt;\" } $(\"#content\").html(html); }); }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 成功实现了数据回显！可以体会一下Ajax的好处！ 注册提示效果我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化 我们写一个Controller @RequestMapping(\"/a3\") public String ajax3(String name,String pwd){ String msg = \"\"; //模拟数据库中存在数据 if (name!=null){ if (\"admin\".equals(name)){ msg = \"OK\"; }else { msg = \"用户名输入错误\"; } } if (pwd!=null){ if (\"123456\".equals(pwd)){ msg = \"OK\"; }else { msg = \"密码输入有误\"; } } return msg; //由于@RestController注解，将msg转成json格式返回 } 前端页面 login.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ $.post({ url:\"${pageContext.request.contextPath}/a3\", data:{'name':$(\"#name\").val()}, success:function (data) { if (data.toString()=='OK'){ $(\"#userInfo\").css(\"color\",\"green\"); }else { $(\"#userInfo\").css(\"color\",\"red\"); } $(\"#userInfo\").html(data); } }); } function a2(){ $.post({ url:\"${pageContext.request.contextPath}/a3\", data:{'pwd':$(\"#pwd\").val()}, success:function (data) { if (data.toString()=='OK'){ $(\"#pwdInfo\").css(\"color\",\"green\"); }else { $(\"#pwdInfo\").css(\"color\",\"red\"); } $(\"#pwdInfo\").html(data); } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 用户名:&lt;input type=\"text\" id=\"name\" onblur=\"a1()\"/&gt; &lt;span id=\"userInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 密码:&lt;input type=\"text\" id=\"pwd\" onblur=\"a2()\"/&gt; &lt;span id=\"pwdInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 【记得处理json乱码问题】 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 测试一下效果，动态请求响应，局部刷新，就是如此！ 获取baidu接口Demo&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;JSONP百度搜索&lt;/title&gt; &lt;style&gt; #q{ width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; } #ul{ width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; } #ul li{ line-height: 30px; padding: 0 10px; } #ul li:hover{ background-color: #f60; color: #fff; } &lt;/style&gt; &lt;script&gt; // 2.步骤二 // 定义demo函数 (分析接口、数据) function demo(data){ var Ul = document.getElementById('ul'); var html = ''; // 如果搜索数据存在 把内容添加进去 if (data.s.length) { // 隐藏掉的ul显示出来 Ul.style.display = 'block'; // 搜索到的数据循环追加到li里 for(var i = 0;i&lt;data.s.length;i++){ html += '&lt;li&gt;'+data.s[i]+'&lt;/li&gt;'; } // 循环的li写入ul Ul.innerHTML = html; } } // 1.步骤一 window.onload = function(){ // 获取输入框和ul var Q = document.getElementById('q'); var Ul = document.getElementById('ul'); // 事件鼠标抬起时候 Q.onkeyup = function(){ // 如果输入框不等于空 if (this.value != '') { // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ // 创建标签 var script = document.createElement('script'); //给定要跨域的地址 赋值给src //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src ='https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='+this.value+'&amp;cb=demo'; // 将组合好的带src的script标签追加到body里 document.body.appendChild(script); } } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" id=\"q\" /&gt; &lt;ul id=\"ul\"&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; Ajax在我们开发中十分重要，一定要学会使用！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"HTML5","slug":"HTML","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:22:28.201Z","comments":true,"path":"posts/ea4e9723.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9723.html","excerpt":"","text":"HTML51、什么是HTML？HTML（Hyper Text Markup Language）：超文本标记语言 超文本包括：文字、图片、音频、视频、动画等。 1.1、W3C标准1.1.1、W3C World Wide Web Consortium （万维网联盟） 成立于1994年，Web技术领域最具权威和影响力的国际中立性技术标准机构 http://www.w3.org/ http://wwwchinaw3c.org/ 1.1.2、W3C标准包括 结构化标准语言（HTML、XML） 表现标准语言（CSS） 行为标准（DOM、ECMAScript） 1.2、HTML基本结构 、等成对出现的标签，分别叫做开放标签和闭合标签， 单独呈现的标签（空元素），如 ,意为用/来关闭空元素 1.3、HTML基本信息 DOCTYPE声明：告诉浏览器我们使用什么规范 title标签 meta标签 &lt;!--告诉浏览器我们使用什么规范--&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;!--head标签代表网页头部--&gt; &lt;head&gt; &lt;!--meta描述性标签,用来描述网页的基本信息,一般用来做SEO--&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"keyword\" content=\"第一次写HTML\"&gt; &lt;meta name=\"description\" content=\"学习\"&gt; &lt;!--title网页标题--&gt; &lt;title&gt;我的第一个HTML&lt;/title&gt; &lt;/head&gt; &lt;!--body标签代表网页主体--&gt; &lt;body&gt; 我的第一个网页 &lt;/body&gt; &lt;/html&gt; 2、网页基本标签2.1、标题标签&lt;!--标题标签--&gt; &lt;h1&gt;一级标签&lt;/h1&gt; &lt;h2&gt;二级标签&lt;/h2&gt; &lt;h3&gt;三级标签&lt;/h3&gt; &lt;h4&gt;四级标签&lt;/h4&gt; &lt;h5&gt;五级标签&lt;/h5&gt; &lt;h6&gt;六级标签&lt;/h6&gt; 2.2、段落标签&lt;!--段落标签--&gt; &lt;p&gt;两只老虎，两只老虎，&lt;/p&gt; &lt;p&gt;跑得快，跑得快，&lt;/p&gt; &lt;p&gt;一只没有眼睛，&lt;/p&gt; &lt;p&gt;一只没有尾巴，&lt;/p&gt; &lt;p&gt;真奇怪！真奇怪！。&lt;/p&gt; 2.3、换行标签&lt;!--换行标签--&gt; 两只老虎，两只老虎，&lt;br/&gt; 跑得快，跑得快，&lt;br/&gt; 一只没有眼睛，&lt;br/&gt; 一只没有尾巴，&lt;br/&gt; 真奇怪！真奇怪！。&lt;br/&gt; 2.4、水平线标签&lt;!--水平线标签--&gt; &lt;hr/&gt; 2.5、字体样式标签&lt;!--粗体斜体--&gt; &lt;h1&gt;字体标签&lt;/h1&gt; 粗体：&lt;strong&gt;I Love You&lt;/strong&gt; 斜体：&lt;em&gt;I Love You&lt;/em&gt; 2.6、注释和特殊符号&lt;!--特殊符号--&gt; &lt;!--特殊符号记忆方式： &amp;开头，;结尾--&gt; 空格：&amp;nbsp;&lt;br/&gt; 大于：&amp;gt;&lt;br/&gt; 小于：&amp;lt;&lt;br/&gt; 版权：&amp;copy;&lt;br/&gt; 3、图像标签 src：图片地址（必填） 相对路径:../表示上一级目录 ​ 绝对路径 alt：图片加载失败时显示的文字（必填） title：鼠标悬停文字 width=”1920” height=”1024”：图片的大小 &lt;img src=\"../resources/img/1.jpg\" alt=\"背景\" title=\"悬停文字\" width=\"1920\" height=\"1024\"&gt; 4、链接标签href：连接地址，跳转的地址（必填） target：表示窗口在哪打开 _blank：在新标签中打开网页 _self：在自己的网页中打开 &lt;a href=\"我的第一个网页.html\" target=\"_blank\"&gt;点击我跳转到我的第一个网页&lt;/a&gt; &lt;a href=\"http://www.baidu.com/\" target=\"_parent\"&gt;点击我跳转到百度&lt;/a&gt; &lt;br/&gt; &lt;p&gt;&lt;a href=\"我的第一个网页.html\"&gt; &lt;img src=\"../resources/img/1.jpg\" alt=\"点击我跳转到我的第一个网页\" title=\"点击我跳转到我的第一个网页\" width=\"500\" height=\"300\"&gt; &lt;/a&gt;&lt;/p&gt; 锚链接 1.需要一个锚标记 2.跳转到标记 &lt;!--使用name作为标记--&gt; &lt;a name=\"top\"&gt;顶部&lt;/a&gt; &lt;a href=\"#down\"&gt;回到顶部&lt;/a&gt; ··· ··· ··· &lt;a href=\"#top\"&gt;回到顶部&lt;/a&gt; &lt;a name=\"down\"&gt;底部&lt;/a&gt; 功能性链接 邮件链接：mailto：邮箱 QQ链接：百度QQ推广获取 &lt;a href=\"mailto:935074243@qq.com\"&gt;点击&lt;/a&gt; &lt;a target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3&amp;uin=935074243&amp;site=qq&amp;menu=yes\"&gt; &lt;img border=\"0\" src=\"http://wpa.qq.com/pa?p=2:935074243:53\" alt=\"点击这里给我发消息\" title=\"点击这里给我发消息\"/&gt; &lt;/a&gt; 5、块元素和行内元素块元素：无论内容多少，该元素独占一行，如：p、h1-h6 行内元素：内容撑开度，左右都是行内元素的可以排在一行，如：a.strong.em 6、列表标签6.1、有序列表 运用范围：考试、应答 &lt;ol&gt; &lt;li&gt;Java&lt;/li&gt; &lt;li&gt;Python&lt;/li&gt; &lt;li&gt;C++&lt;/li&gt; &lt;li&gt;运维&lt;/li&gt; &lt;/ol&gt; 6.2、无序列表 运用范围：导航、侧边栏 &lt;ul&gt; &lt;li&gt;Java&lt;/li&gt; &lt;li&gt;Python&lt;/li&gt; &lt;li&gt;C++&lt;/li&gt; &lt;li&gt;运维&lt;/li&gt; &lt;/ul&gt; 6.3、自定义列表 dl：标签 dt：列表名称 dd：列表内容 运用范围：网站底部 &lt;dl&gt; &lt;dt&gt;科目&lt;/dt&gt; &lt;dd&gt;Java&lt;/dd&gt; &lt;dd&gt;Python&lt;/dd&gt; &lt;dd&gt;C++&lt;/dd&gt; &lt;dd&gt;运维&lt;/dd&gt; &lt;dt&gt;位置&lt;/dt&gt; &lt;dd&gt;西安&lt;/dd&gt; &lt;dd&gt;甘肃&lt;/dd&gt; &lt;dd&gt;新疆&lt;/dd&gt; &lt;dd&gt;宁夏&lt;/dd&gt; &lt;/dl&gt; 7、表格标签行：tr 列：td border：分割线 &lt;table border=\"1px\"&gt; &lt;tr&gt; &lt;!--colspan=\"4\":跨列--&gt; &lt;td colspan=\"4\"&gt;1-1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--rowspan=\"2\"：跨行--&gt; &lt;td rowspan=\"2\"&gt;2-1&lt;/td&gt; &lt;td&gt;2-2&lt;/td&gt; &lt;td&gt;2-3&lt;/td&gt; &lt;td&gt;2-4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3-1&lt;/td&gt; &lt;td&gt;3-2&lt;/td&gt; &lt;td&gt;3-3&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 8、媒体元素src：资源路径 controls：控制器，有它才能看到 autoplay：自动播放 8.1、视频标签video&lt;video src=\"../resources/video/【狂神说Java】HTML09：媒体元素.mp4\" controls autoplay&gt;&lt;/video&gt; 8.2、音频标签audio&lt;audio src=\"../resources/audio/HTML09：媒体元素.m4a\" controls autoplay&gt;&lt;/audio&gt; 9、页面结构分析 &lt;header&gt; &lt;h2&gt;网页头部&lt;/h2&gt; &lt;/header&gt; &lt;section&gt; &lt;h2&gt;网页主体&lt;/h2&gt; &lt;/section&gt; &lt;footer&gt; &lt;h2&gt;网页脚部&lt;/h2&gt; &lt;/footer&gt; 10、iframe内联框架 src：地址 width、height:宽度高度 name：框架标示名 &lt;iframe src=\"\" name=\"hello\" width=\"1000px\" height=\"500px\"&gt;&lt;/iframe&gt; &lt;a href=\"https://space.bilibili.com/95256449/\" target=\"hello\"&gt;点击跳转&lt;/a&gt; 11、表单 action：表单提交的位置，可以是网站，可以是一个请求处理地址 method：post，get 提交方式 ​ get方式提交可以在URL中看到我们提交的信息，不安全，但高效 ​ post方式提交，比较安全，传输大文件 11.1、表单元素格式 &lt;h1&gt;注册&lt;/h1&gt; &lt;form action=\"我的第一个网页.html\" method=\"get\"&gt; &lt;!--文本输入框：input type=\"text\" value=\"\":默认初始值 maxlength=\"8\"：最长能写几个字符 size=\"30\"：文本框长度--&gt; &lt;p&gt;名字：&lt;input type=\"text\" name=\"username\"&gt;&lt;/p&gt; &lt;!--密码框：input type=\"password\"--&gt; &lt;p&gt;密码：&lt;input type=\"password\" name=\"password\"&gt;&lt;/p&gt; &lt;!--单选框标签：input type=\"radio\" value：单选框的值 name：表示组 checked：默认选中--&gt; &lt;p&gt;性别： &lt;input type=\"radio\" value=\"boy\" name=\"sex\"/&gt;男 &lt;input type=\"radio\" value=\"girl\" name=\"sex\"/&gt;女 &lt;/p&gt; &lt;!--多选框：input type=\"checkbox--&gt; &lt;p&gt;爱好： &lt;input type=\"checkbox\" value=\"sleep\" name=\"hobby\"&gt;睡觉 &lt;input type=\"checkbox\" value=\"code\" name=\"hobby\"&gt;敲代码 &lt;input type=\"checkbox\" value=\"chat\" name=\"hobby\"&gt;聊天 &lt;input type=\"checkbox\" value=\"game\" name=\"hobby\"&gt;游戏 &lt;/p&gt; &lt;!--按钮 input type=\"button\"：普通按钮 input type=\"image\"：图片按钮 input type=\"submit\"：提交按钮 input type=\"reset\"：重置按钮 --&gt; &lt;input type=\"button\" name=\"btn1\" value=\"点击边长\"&gt; &lt;!--&lt;input type=\"image\" src=\"../resources/img/1.jpg\"&gt;--&gt; &lt;!--下拉框、列表框--&gt; &lt;p&gt;国家： &lt;select name=\"列表名称\"&gt; &lt;option value=\"china\"&gt;中国&lt;/option&gt; &lt;option value=\"us\"&gt;美国&lt;/option&gt; &lt;option value=\"yd\"&gt;印度&lt;/option&gt; &lt;option value=\"rd\" selected&gt;瑞士&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;!--文件域：input type=\"file\" name=\"files\"--&gt; &lt;p&gt; &lt;input type=\"file\" name=\"files\"&gt; &lt;input type=\"button\" value=\"upload\"&gt; &lt;/p&gt; &lt;!--文本域：textarea cols=\"50\" rows=\"10\" cols=\"50\"：行 rows=\"10\"：列 --&gt; &lt;p&gt; &lt;textarea name=\"textarea\" id=\"\" cols=\"50\" rows=\"10\"&gt;文本内容&lt;/textarea&gt; &lt;/p&gt; &lt;!--邮件验证：input type=\"email\"--&gt; &lt;p&gt;邮箱： &lt;input type=\"email\" name=\"email\"&gt; &lt;/p&gt; &lt;!--url验证：input type=\"url\"--&gt; &lt;p&gt;url： &lt;input type=\"url\" name=\"url\"&gt; &lt;/p&gt; &lt;!--数字验证：input type=\"number\"--&gt; &lt;p&gt;number： &lt;input type=\"number\" name=\"number\" max=\"9\" min=\"0\" step=\"2\"&gt; &lt;/p&gt; &lt;!--滑块：input type=\"range\" min=\"0\" max=\"100\" step=\"2\"--&gt; &lt;p&gt;音量： &lt;input type=\"range\" min=\"0\" max=\"100\" step=\"2\" name=\"voice\"&gt; &lt;/p&gt; &lt;!--搜索框：input type=\"search\"--&gt; &lt;p&gt;搜索： &lt;input type=\"search\" name=\"search\"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"submit\"&gt; &lt;input type=\"reset\"&gt; &lt;/p&gt; &lt;/form&gt; 隐藏域：hidden 只读：readonly 禁用：disable 11.2、表单的初级验证placeholder：提示信息 required：非空判断 pattern：正则表达式 正则表达式速查表：https://www.jb51.net/tools/regexsc.htm &lt;!--自定义邮箱--&gt; &lt;p&gt;自定义邮箱： &lt;input type=\"text\" name=\"diymail\" pattern=\"^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\"&gt; &lt;/p&gt; 12、总结","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"JSON","slug":"JSON","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:24:09.480Z","comments":true,"path":"posts/ea4e9729.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9729.html","excerpt":"","text":"什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"QinJiang\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试1、新建一个module ，springmvc-05-json ， 添加web的支持 2、在web目录下新建一个 json-1.html ， 编写测试内容 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSON_秦疆&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; //编写一个js的对象 var user = { name:\"秦疆\", age:3, sex:\"男\" }; //将js对象转换成json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象 var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3、在IDEA中使用浏览器打开，查看控制台输出！ Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; 配置SpringMVC需要的配置 web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; springmvc-servlet.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； package com.kuang.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; //需要导入lombok @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； @Controller public class UserController { @RequestMapping(\"/json1\") @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 配置Tomcat ， 启动测试一下！ http://localhost:8080/json1 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMaping的produces属性来实现，修改下代码 //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\") 再次测试， http://localhost:8080/json1 ， 乱码问题OK！ 【注意：使用json记得处理乱码问题】 代码优化 乱码统一解决上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 返回json字符串统一解决在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ @RestController public class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\") public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 启动tomcat测试，结果都正常输出！ 测试集合输出 增加一个新的方法 @RequestMapping(\"/json2\") public String json2() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str; } 运行结果 : 十分完美，没有任何问题！ 输出时间对象 增加一个新的方法 @RequestMapping(\"/json3\") public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str; } 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 @RequestMapping(\"/json4\") public String json4() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str; } 运行结果 : 成功的输出了时间！ 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 package com.kuang.utils; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import java.text.SimpleDateFormat; public class JsonUtils { public static String getJson(Object object) { return getJson(object,\"yyyy-MM-dd HH:mm:ss\"); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 我们使用工具类，代码就更加简洁了！ @RequestMapping(\"/json5\") public String json5() throws JsonProcessingException { Date date = new Date(); String json = JsonUtils.getJson(date); return json; } 大功告成！完美！ FastJsonfastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt; &lt;/dependency&gt; fastjson 三个主要的类： JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组 内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 package com.kuang.controller; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.kuang.pojo.User; import java.util.ArrayList; import java.util.List; public class FastJsonDemo { public static void main(String[] args) { //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\"*******Java对象 转 JSON字符串*******\"); String str1 = JSON.toJSONString(list); System.out.println(\"JSON.toJSONString(list)==&gt;\"+str1); String str2 = JSON.toJSONString(user1); System.out.println(\"JSON.toJSONString(user1)==&gt;\"+str2); System.out.println(\"\\n****** JSON字符串 转 Java对象*******\"); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\"JSON.parseObject(str2,User.class)==&gt;\"+jp_user1); System.out.println(\"\\n****** Java对象 转 JSON对象 ******\"); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\"(JSONObject) JSON.toJSON(user2)==&gt;\"+jsonObject1.getString(\"name\")); System.out.println(\"\\n****** JSON对象 转 Java对象 ******\"); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\"JSON.toJavaObject(jsonObject1, User.class)==&gt;\"+to_java_user); } } 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"排序算法","slug":"排序算法","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:38:13.028Z","comments":true,"path":"posts/ea4e979k.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e979k.html","excerpt":"","text":"冒泡排序int[] a={8,9,6,2,4}; int temp; for (int i = 0; i &lt; a.length-1; i++) { for (int j = 0; j &lt; a.length-1-i; j++) { if(a[j]&gt;a[j+1]){ temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } for (int i = 0; i &lt; a.length; i++) { System.out.print(a[i]+\"\\t\"); } 选择排序int[] a={8,9,6,2,4}; int temp; int k=1; for (int i = 0; i &lt; a.length-1; i++) { for (int j = k; j &lt;= a.length-1; j++) { if(a[i]&gt;a[j]){ temp=a[i]; a[i]=a[j]; a[j]=temp; } } k++; } for (int i = 0; i &lt; a.length; i++) { System.out.print(a[i]+\"\\t\"); } 插入排序int[] a={8,9,6,2,4}; int temp; for (int i = 1; i &lt; a.length; i++) { for (int j = i; j &gt; 0; j--) { if(a[j]&lt;a[j-1]){ temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; }else{ break;//优化性能，不写也不会报错 } } } for (int i = 0; i &lt; a.length; i++) { System.out.print(a[i]+\"\\t\"); } 万年历public class CalendarTest { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 1. 2021-7月的万年历 System.out.print(\"请输入年份：\"); int year = in.nextInt(); System.out.print(\"请输入月份：\"); int month = in.nextInt(); //1.关键点1：解决这个月的1号是星期几？ int sum = 0; //1.1整年的天数（1900年+1901+2020年） for (int i = 1900; i &lt;year; i++) { if(i%4==0&amp;&amp;i%100!=0||i%400==0) {//年份能被4整除并且不能被100整除 或者能被400整除 sum+=366; }else { sum+=365; } } //1.2.整月的天数（1月+2月+....+6月） for (int i = 1; i &lt; month; i++) { if(i==2) {//二月 if(year%4==0&amp;&amp;year%100!=0||year%400==0) { sum+=29; }else { sum+=28; } }else if(i==4||i==6||i==9||i==11) {//小月：4 6 9 11 sum+=30; }else {//大月：1，3，5，7，8，10，12 sum+=31; } } //1.3 加上1号那一天 sum++; //2.输出万年历 System.out.println(year+\"年\"+month+\"月的1号是星期：\"+sum%7); System.out.println(\"\\t\\t\\t\" + year + \"年\" + month + \"月\"); System.out.println(\"日\\t一\\t二\\t三\\t四\\t五\\t六\"); //2.1确定1号的位置 for(int i=1;i&lt;=sum%7;i++) { System.out.print(\"\\t\"); } //3.关键点2：确定当前月(month)份天数 int days = 0; if(month==2) {//二月 if(year%4==0&amp;&amp;year%100!=0||year%400==0) { days=29; }else { days=28; } }else if(month==4||month==6||month==9||month==11) {//小月：4 6 9 11 days=30; }else {//大月：1，3，5，7，8，10，12 days=31; } for (int i = 1; i &lt;=days; i++) { System.out.print(i+\"\\t\"); if((sum++)%7==6) { System.out.println(); } } } }","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"CSS3","slug":"CSS3","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:18:33.661Z","comments":true,"path":"posts/ea4e9748.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9748.html","excerpt":"","text":"CSS3HTML+CSS+JavaScript 结构+表项+交互 如何学习？ CSS是什么 CSS怎么用（快速入门） CSS选择器（重点+难点） 美化网页（文字、阴影、超链接、列表、渐变…） 盒子模型 浮动 定位 网页动画（特效效果） 1、初识CSS1.1、什么是CSSCascading Style Sheet（层叠样式表） CSS：表现（美化网页） 字体、颜色、边距、高度、宽度、背景图片、网页定位、网页浮动… 1.2、发展史CSS1.0CSS2.0 DIV（块）+CSS，HTML与CSS结构分离，网页变得简单，利于SEOCSS2.1 浮动和定位CSS3.0 圆角边框、阴影、动画…. 浏览器兼容性 1.3、快速入门 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 规范 &lt;style&gt;&lt;/style&gt;内可以编写html代码,每一个声明最好以分号结尾 语法： 选择器{ 声明1: ; 声明2: ; 声明3: ; } --&gt; &lt;style&gt; h1{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 建议使用这种规范 CSS优势： 内容和表现分离 网页结构表现统一，可以实现复用 样式十分丰富 建议使用独立于HTML的css文件 利于SEO，容易被搜索引擎收录 1.4、css的三种导入方式&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--2.内部样式表--&gt; &lt;style&gt; h1{ color:green; } &lt;/style&gt; &lt;!--3.外部样式--&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;!--优先级：就近原则--&gt; &lt;!--1.行内样式：在标签元素中编写一个style属性，编写样式即可--&gt; &lt;h1 style=\"color: red;\"&gt;我是标题&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 拓展：外部样式两种写法： 链接式： &lt;!--外部样式--&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt; 导入式： @import是CSS2.1特有的 &lt;!--导入式--&gt; &lt;style&gt; @import url(\"style.css\"); &lt;/style&gt; 2、选择器 作用：选择页面上的某一种元素或者某一类元素 2.1、基本选择器2.1.1、标签选择器选择一类标签 语法： ​ 标签名{ ​ 声明1：xx； ​ 声明2：xx； ​ } &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*标签选择器会选中页面上的所有这个标签*/ h1{ color: #dcff4f; background: deepskyblue; border-radius: 14px; } p{ font-size: 80px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;学Java&lt;/h1&gt; &lt;h1&gt;学Java&lt;/h1&gt; &lt;p&gt;狂神说&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 2.1.2、类选择器 class选中所有class属性一致的标签，可以跨标签 语法： ​ . 类名{ ​ 声明1：； ​ 声明2：； ​ } &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*类选择器格式：.class的名称{} 好处：可以多个标签归类，是同一个class，可以复用 */ .one{ color:wheat; } .two{ color:red; } .three{ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=\"one\"&gt;标题1&lt;/h1&gt; &lt;h1 class=\"two\"&gt;标题2&lt;/h1&gt; &lt;h1 class=\"three\"&gt;标题3&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 2.1.3、id选择器全局唯一 语法： ​ #id名{ ​ 声明1：； ​ 声明2：； ​ } &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*id选择器格式：#id名称{} id必须保证全局唯一 不遵循就近原则，固定的优先级：id选择器&gt;类选择器&gt;标签选择器 */ #one{ color: aquamarine; } .style1{ color:red; } h1{ color: #dcff4f; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id=\"one\" class=\"style1\"&gt;标题1&lt;/h1&gt; &lt;h1 class=\"style1\"&gt;标题2&lt;/h1&gt; &lt;h1 class=\"style1\"&gt;标题3&lt;/h1&gt; &lt;h1&gt;标题4&lt;/h1&gt; &lt;h1&gt;标题5&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 优先级：不遵循就近原则，固定的：id选择器&gt;类选择器&gt;标签选择器 使用！important 可以打破这个规定 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*id选择类型的后代选择器*/ #div1 div{ color: #222222; /*黑色*/ } .t1{ color: #00fda2; /*青色*/ } .t2{ color: #cb1919 !important; /*红色*/ } &lt;/style&gt; &lt;body&gt; &lt;div id=\"div1\" test=\"\"&gt; &lt;div class=\"t1\"&gt;未使用important&lt;/div&gt; &lt;div class=\"t2\"&gt;使用important&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2.2、层次选择器 HTML &lt;body&gt; &lt;p&gt;p0&lt;/p&gt; &lt;p class=\"active\"&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p4&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;p5&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;p6&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 2.2.1、后代选择器在某个元素的后面 ：祖爷爷 爷爷 爸爸 我（所有同类标签） /*后代选择器*/ body p{ background: red; } 2.2.2、子选择器选择当前选择元素的下一代 /*子选择器*/ body &gt; p{ background: blueviolet; } 2.2.3、相邻兄弟选择器同辈（同级） （相邻）向下，只有一个 /*相邻兄弟选择器*/ .active + p{ background: cadetblue; } 2.2.4、通用选择器当前选中元素的（同级）向下的所有元素 /*通用兄弟选择器*/ .active ~ p{ background: green; } 2.3、结构伪类选择器伪类： 标签：条件{ 声明：xx； } &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--避免使用class和id选择器--&gt; &lt;style&gt; /*ul的第一个子元素*/ ul li:first-child{ background: #dcff4f; } /*ul的第最后一个子元素*/ ul li:last-child{ background: blueviolet; } /*选中p1:定位到父元素，选中当前的第一个子元素 选中当前元素的父级元素，选中父级元素的第n个子元素（把不同类的子标签也算进去），但第n个子元素必须是当前同类元素，否则选不中 */ p:nth-child(3){ background: cadetblue; } /*先选中当前元素的父级元素，然后选中父级元素的第n个和当前元素同类型的子元素*/ p:nth-of-type(3){ background: wheat; } /*鼠标移动到上面会发生变化*/ a:hover{ background: black; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a&gt;12231&lt;/a&gt; &lt;h1&gt;h1&lt;/h1&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt;li1&lt;/li&gt; &lt;li&gt;li2&lt;/li&gt; &lt;li&gt;li3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 2.4、属性选择器（常用）css标签可以自定义属性，可以随便添加属性，主要用于属性选择器的选择。 class+id结合 属性名 属性名 = 属性值（正则） **= 绝对等于 ** *= 包含 ^= 以…开头 $= 以…结尾 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .demo a{ float: left; display: block; height: 50px; width: 50px; border-radius: 10px; background: blue; text-align: center; color: gainsboro; text-decoration: none; margin-right: 5px; font: bold 20px/50px Arial; } /* 1.属性名 2.属性名=属性值（正则） 3. = 是绝对等于 *= 是包含 4. ^= 以...开头 5. $= 以...结尾 */ /*选中存在id属性的元素 a[]{} */ a[id]{ background: #2be24e; } /*选中存在test属性的元素 a[]{} test属性是自定义的*/ a[test]{ } /*选中id=first*/ a[id=first]{ background: #ff0b2f; } /*class中有link的*/ a[class *= \"link\"]{ background: cadetblue; } /*选中href中以http开头的*/ a[href^=http]{ background: #ff0b2f; } /* 选中href中以pdf结尾的*/ a[href$=pdf]{ background: #2be24e; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"demo\"&gt; &lt;a href=\"http://www.baidu.com/\" class=\"link item first\" id=\"first\"&gt;1&lt;/a&gt; &lt;a href=\"\" class=\"links item active\" target=\"_blank\" title=\"test\"&gt;2&lt;/a&gt; &lt;a href=\"images/123.html\" class=\"link item\"&gt;3&lt;/a&gt; &lt;a href=\"images/123.png\" class=\"link item\"&gt;4&lt;/a&gt; &lt;a href=\"images/123.jpg\" class=\"link item\"&gt;5&lt;/a&gt; &lt;a href=\"abc\" class=\"link item\"&gt;6&lt;/a&gt; &lt;a href=\"/a.pdf\" class=\"link item\"&gt;7&lt;/a&gt; &lt;a href=\"/abc.pdf\" class=\"link item\"&gt;8&lt;/a&gt; &lt;a href=\"abc.doc\" class=\"link item\"&gt;9&lt;/a&gt; &lt;a href=\"abcd.doc\" class=\"link item last\"&gt;10&lt;/a&gt; &lt;a href=\"abcd.doc\" test=\"\"&gt;11&lt;/a&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 3、美化网页元素3.1、为什么要美化网页 有效的传递页面信息 美化网页，页面漂亮才能吸引用户 凸显页面主题 提高用户体验 span标签：重点要突出的字，使用span套起来 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #title1{ font-size: 50px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; 欢迎学习&lt;span id=\"title1\"&gt;java&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 3.2、字体样式 &lt;!-- font-family: 字体 font-size: 字体大小 font-weight: 字体粗细 color: 字体颜色 --&gt; &lt;style&gt; body{ font-family: \"Arial Black\", 楷体; } h1{ font-size: 50px; color: #ff0b2f; } .p1{ font-weight: bold; } &lt;/style&gt; &lt;!--font：字体风格 字体粗细 字体大小 字体种类 --&gt; &lt;style&gt; p{ font: oblique bolder 16px \"楷体\" ; } &lt;/style&gt; 3.3、文本样式 颜色 color:RGB/RGBA/单词; 对齐方式 text-align: center;水平居中 首行缩进 text-indent: 2em;段首缩进 行高 height: 300px;块高 ​ line-height: 300px;行高 ​ 行高和块高度一致，就可以实现单行文本上下居中 装饰划线 text-decoration: 文本图片水平对齐 vertical-align: middle; &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 颜色： 单词 RGB：0~F RGBA ：A：0~1 透明度 text-align: center;排版 水平居中 text-indent: 2em;段落首行缩进 height: 300px; line-height: 300px;行高和块高度一致，就可以上下居中 --&gt; &lt;style&gt; h1{ color: rgba(0,255,255,0.9); text-align: center;/*文本居中*/ } .p1{ text-indent: 2em; } .p3{ background: blue; height: 300px; line-height: 300px; } /*下划线*/ .l1{ text-decoration: underline; } /*中划线*/ .l2{ text-decoration: line-through; } /*上划线*/ .l3{ text-decoration: overline; } /*超链接去下划线*/ a{ text-decoration: none; } /*水平对齐 需要参照物：a和b a，b{ 声明：xxxx； } */ img,span{ vertical-align: middle; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"\"&gt;123&lt;/a&gt; &lt;p class=\"l1\"&gt;123123&lt;/p&gt; &lt;p class=\"l2\"&gt;123123&lt;/p&gt; &lt;p class=\"l3\"&gt;123123&lt;/p&gt; &lt;h1&gt;《魁拔》&lt;/h1&gt; &lt;p class=\"p1\"&gt; 是2008年北京青青树动漫科技有限公司以系列动画电影的第一部《魁拔之十万火急》为基础，重新剪辑而成的TV动画。 由王川执导，田博、马华等编剧，刘婧荦，竹内顺子等配音。 &lt;/p&gt; &lt;p class=\"p3\"&gt; TV版完整保留了电影的世界观、人物设定、故事内容和情节主线，但重制了片头曲。 《魁拔妖侠传》是魁拔系列电影的前传，主要讲述的是有关卡拉肖克潘家族的故事，与电影关系并不大。 目前大家所说的魁拔通常指魁拔系列动画电影。 &lt;/p&gt; &lt;p&gt; &lt;img src=\"a.png\" alt=\"\"&gt; &lt;span&gt;jdlajsdajldjalsjd&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 3.4、超链接伪类和阴影&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*默认颜色*/ a{ text-decoration: none; color: black; } /*鼠标悬浮的状态*/ a:hover{ color: orange; font-size: 20px; } /*鼠标按住未释放状态*/ a:active{ color: #2be24e; } /*text-shadow:阴影颜色 水平偏移 垂直偏移 阴影半径*/ #price{ text-shadow: cadetblue 5px 5px 1px; } p:hover{ background: blueviolet; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"#\"&gt; &lt;img src=\"images/1.jpg\" alt=\"\"&gt; &lt;/a&gt; &lt;p&gt; &lt;a href=\"#\"&gt;码出高效：Java开发手册&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;a href=\"#\"&gt;作者：孤尽老师&lt;/a&gt; &lt;/p&gt; &lt;p id=\"price\"&gt;￥99&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 3.5、列表#nav{ width: 300px; background: darkgrey; } .title{ font-size: 18px; font-weight: bold; text-indent: 1em; line-height: 35px; background: #ff0b2f; } /* list-style: none;去掉圆点 circle；空心圆 decimal：数字 square：正方形 */ /*ul{*/ /* background: darkgrey;*/ /*}*/ ul li{ height: 30px; list-style: none; text-indent: 1em; } a{ text-decoration: none; font-size: 14px; color: black; } a:hover{ color: orange; text-decoration: underline; } 3.6、背景图像背景颜色 背景图片 div{ width: 1400px; height: 700px; border: 1px solid red; background-image: url(\"images/1.jpg\"); /*默认平铺 repeat*/ } .div1{ background-repeat: repeat-x;/*水平平铺*/ } .div2{ background-repeat: repeat-y;/*竖直平铺*/ } .div3{ background-repeat: no-repeat;/*不平铺*/ } /* background：颜色 图片链接 位置 平铺方式 background: red url(\"images/a.jpg\") 270px 10px no-repeat */ 3.7、渐变推荐网站：https://www.grabient.com/ background-color: #FFFFFF; background-image: linear-gradient(124deg, #FFFFFF 0%, #6284FF 50%, #FF0000 100%); 4、盒子模型 4.1、什么是盒子 margan：外边距 padding：内边距 border：边框 4.2、边框 边框的粗细 边框的样式 边框的颜色 /*body总有一个默认的外边距margin：8dp*/ body{ margin: 0; } #app{ width: 300px; border: 1px solid red;/*粗细 样式 颜色*/ } h2{ font-size: 16px; background: cadetblue; line-height: 30px; margin: 0; color: #FFFFFF; } form{ background: cadetblue; } /* 设置第一个input，因为大的div下没有input标签，所以就找了小的div的input标签 */ div:nth-of-type(1)&gt;input{ border: 3px solid black; } div:nth-of-type(2)&gt;input{ border: 3px dashed #be0be2; } div:nth-of-type(2)&gt;input{ border: 2px dashed #2be24e; } 4.3、内外边距&lt;!--外边距可以使居中--&gt; &lt;style&gt; /*body总有一个默认的外边距margin：8dp*/ body{ margin: 0; } /* margin:0;一个参数为上下左右 margin: 0 auto;上下为0，左右自动，实现水平居中 margin:0 1px 2px 3px;四个参数为上右下左，顺时针 */ #app{ width: 300px; border: 1px solid red;/*粗细 样式 颜色*/ margin: 0 auto; } h2{ font-size: 16px; background: cadetblue; line-height: 30px; margin: 0; color: #FFFFFF; } form{ background: cadetblue; } input{ border: 1px solid black; } div:nth-of-type(1){ padding: 10px; } 盒子的计算方式：这个元素到底多大？ ​ 元素大小：margin+border+padding+内容宽度 4.4、圆角边框&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- border-radius: 50px 20px; 左上右下 右上左下--&gt; &lt;!-- border-radius: 100px 100px 0 0; 左上 右上 右下 左下--&gt; &lt;!--圆圈：圆角 = 半径 --&gt; &lt;style&gt; div{ width: 100px; height: 50px; border: 10px solid red; border-radius: 100px 100px 0 0; } img{ border-radius: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;img src=\"images/1.jpg\" alt=\"\"&gt; &lt;/body&gt; &lt;/html&gt; 4.5、盒子阴影&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- margin：0 auto;居中要求：外面是一个块元素，块元素有固定的宽度，body有无限宽度 一般和text-align：center 配合使用 --&gt; &lt;style&gt; div{ width: 1000px; height: 500px; text-align: center; } img{ border-radius: 100px; box-shadow: 10px 10px 100px yellow; margin: 0 auto; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;img src=\"images/1.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 回到顶部 5、浮动5.1、标准文档流块级元素：独占一行 h1~h6 p div 列表... 行内元素：不独占一行 span a img strong... 行内元素可以被包含在块级元素中，反之则不可以 5.2、display&lt;!--display: block;块元素 inline;行内元素 inline-block;是块元素，但是可以内联，在同一行 none;不显示 --&gt; &lt;style&gt; div{ width: 100px; height: 100px; border: red solid 1px; display: inline; } span{ width: 100px; height: 100px; border: red solid 1px; display: inline-block; } &lt;/style&gt; 这个也是一种能够实现行内元素排列的方式，但是我们很多情况都使用float 5.3、float左右浮动 div{ margin: 10px; padding: 5px; } #father{ border: 1px solid red; } .layer01{ border: 1px dashed black; display: inline-block; float: left; } .layer02{ border: 1px dashed green; display: inline-block; float: left; } .layer03{ border: 1px dashed blue; display: inline-block; float: left; } .layer04{ border: 1px dashed paleturquoise; font-size: 12px; line-height: 23px; display: inline-block; float: left; clear: both; } 5.4、父级边框塌陷问题clear clear: right; 右侧不允许有浮动元素 left; 左侧不允许有浮动元素 both;两侧都不允许有浮动元素 解决方案： 设置父级元素高度 #father{ border: 1px solid red; height: 800px; } 增加一个空的div子标签，清除浮动 &lt;div class=\"clear\"&gt;&lt;/div&gt; .clear{ clear: both; margin: 0; padding: 0; } overflow 在父级元素中增加一个 overflow: hidden; 父类添加一个伪类 after #father:after{ content: ''; display: block; clear: both; } 小结： 浮动元素后面增加空的div 简单，代码中尽量避免空的div 设置父元素的高度 简单，元素假设有了固定的高度，就会被限制 overflow 简单，下拉的一些场景避免使用 父类添加一个伪类：after（推荐） 写法稍微复杂一点，但是没有副作用，推荐使用 5.5、对比 display 方向不可控制 float 浮动起来会脱离标准文档流，所以要解决父级塌陷的问题 6、定位6.1、相对定位相对定位：position: relative; 相对于原来的位置，进行指定的偏移,相对定位的话，它仍然在标准文档流中，原来的位置会被保留 top: -20px; left: 20px; bottom: -10px; right: 20px; &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!--相对定位：相对于自己原来的位置进行定位--&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body{ padding: 20px; } div{ margin: 10px; padding: 5px; font-size: 12px; line-height: 15px; } #father{ border: 1px solid red; padding: 0; } #first{ background-color: #23ff66; border: 1px dashed #23ff98; position: relative;/*相对定位：上下左右*/ top: -20px; left: 20px; } #second{ background-color: #34cedd; border: 1px dashed #34ceff; } #third{ background-color: #ff8299; border: 1px dashed #ff82fc; position: relative; bottom: -10px; right: 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"father\"&gt; &lt;div id=\"first\"&gt;第一个盒子&lt;/div&gt; &lt;div id=\"second\"&gt;第二个盒子&lt;/div&gt; &lt;div id=\"third\"&gt;第三个盒子&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 练习：方块定位 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #box{ width: 300px; height: 300px; border: red 1px solid; padding: 10px; } a{ width: 100px; height: 100px; text-decoration: none; background: pink; line-height: 100px; text-align: center; color: #FFFFFF; display: block; } a:hover{ background: #6284FF; } .a2,.a4{ position: relative; left: 200px; top: -100px; } .a5{ position: relative; top: -300px; right: -100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"box\"&gt; &lt;a href=\"#\" class=\"a1\"&gt;链接1&lt;/a&gt; &lt;a href=\"#\" class=\"a2\"&gt;链接2&lt;/a&gt; &lt;a href=\"#\" class=\"a3\"&gt;链接3&lt;/a&gt; &lt;a href=\"#\" class=\"a4\"&gt;链接4&lt;/a&gt; &lt;a href=\"#\" class=\"a5\"&gt;链接5&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 6.2、绝对定位定位：基于xxx定位，上下左右 没有父级元素定位的前提下，相对于浏览器定位 假设父级元素存在定位，通常相对于父级元素进行偏移 在父级元素范围内移动 相对于父级或者浏览器的位置，进行指定的偏移,绝对定位的话，它不在在标准文档流中，原来的位置不会被保留 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div{ margin: 10px; padding: 5px; font-size: 12px; line-height: 15px; } #father{ border: 1px solid red; padding: 0; position: relative; } #first{ background-color: #23ff66; border: 1px dashed #23ff98; } #second{ background-color: #34cedd; border: 1px dashed #34ceff; position: absolute; right: 30px; } #third{ background-color: #ff8299; border: 1px dashed #ff82fc; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"father\"&gt; &lt;div id=\"first\"&gt;第一个盒子&lt;/div&gt; &lt;div id=\"second\"&gt;第二个盒子&lt;/div&gt; &lt;div id=\"third\"&gt;第三个盒子&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 6.3、固定定位 fixed&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body{ height: 1000px; } div:nth-of-type(1){ /*绝对定位，相对于浏览器初始位置*/ width: 100px; height: 100px; background: #6284FF; position: absolute; right: 0; bottom: 0; } div:nth-of-type(2){/*fixed,固定定位，一直定在那*/ width: 50px; height: 50px; background: #2be24e; position: fixed; right: 0; bottom: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div1&lt;/div&gt; &lt;div&gt;div2&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 6.4、z-index图层~ z-index：默认是0，最高无限制 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li class=\"tipText\"&gt;大家好&lt;/li&gt; &lt;li class=\"tipBg\"&gt;&lt;/li&gt; &lt;li&gt;时间：2099-1-1&lt;/li&gt; &lt;li&gt;地点：月球一号基地&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; opacity: 0.5; /*背景透明度*/ #content{ width: 380px; padding: 0; margin: 0; overflow: hidden; font-size: 12px; line-height: 25px; border: 1px solid red; } ul,li{ margin: 0; padding: 0; list-style: none; } /*父级元素相对定位*/ #content ul{ position: relative; } .tipText,.tipBg{ position: absolute; width: 380px; height: 25px; top: 200px; } .tipBg{ background: #05e29b; opacity: 0.5;/*背景透明度*/ } .tipText{ z-index: 999; } 7、变形在CSS3中，可以利用transform功能来实现文字或图像的旋转、缩放、倾斜、移动这四种类型的变形处理，本文将对此做详细介绍。 7.1、旋转 rotate用法：transform: rotate(45deg); 共一个参数“角度”，单位deg为度的意思，正数为顺时针旋转，负数为逆时针旋转，上述代码作用是顺时针旋转45度。 7.2、缩放 scale用法：transform: scale(0.5) 或者 transform: scale(0.5, 2); 参数表示缩放倍数； 一个参数时：表示水平和垂直同时缩放该倍率 两个参数时：第一个参数指定水平方向的缩放倍率，第二个参数指定垂直方向的缩放倍率。 7.3、倾斜 skew用法：transform: skew(30deg) 或者 transform: skew(30deg, 30deg); 参数表示倾斜角度，单位deg 一个参数时：表示水平方向的倾斜角度； 两个参数时：第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度。 关于skew倾斜角度的计算方式表面上看并不是那么直观，这里借鉴某大拿绘制的图举例说明一下： 首先需要说明的是skew的默认原点transform-origin是这个物件的中心点 skewX(30deg) 如下图： skewY(10deg) 如下图： skew(30deg, 10deg) 如下图： 我当初就是看到此图瞬间理解的。 7.4、移动 translate用法：transform: translate(45px) 或者 transform: translate(45px, 150px); 参数表示移动距离，单位px， 一个参数时：表示水平方向的移动距离； 两个参数时：第一个参数表示水平方向的移动距离，第二个参数表示垂直方向的移动距离。 7.5、基准点 transform-origin在使用transform方法进行文字或图像的变形时，是以元素的中心点为基准点进行的。使用transform-origin属性，可以改变变形的基准点。 用法：transform-origin: 10px 10px; 共两个参数，表示相对左上角原点的距离，单位px，第一个参数表示相对左上角原点水平方向的距离，第二个参数表示相对左上角原点垂直方向的距离； 两个参数除了可以设置为具体的像素值，其中第一个参数可以指定为left、center、right，第二个参数可以指定为top、center、bottom。 7.6、多方法组合变形上面我们介绍了使用transform对元素进行旋转、缩放、倾斜、移动的方法，这里讲介绍综合使用这几个方法来对一个元素进行多重变形。 用法：transform: rotate(45deg) scale(0.5) skew(30deg, 30deg) translate(100px, 100px); 这四种变形方法顺序可以随意，但不同的顺序导致变形结果不同，原因是变形的顺序是从左到右依次进行，这个用法中的执行顺序为1.rotate 2.scalse 3.skew 4.translate 8、总结","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"GUI编程","slug":"GUI","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:22:00.894Z","comments":true,"path":"posts/ea4e9722.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9722.html","excerpt":"","text":"GUI编程GUI：图形用户界面编程 GUI编程学习路线 GUI是什么 GUI怎么写 GUI使用场景 组件 监听 弹窗 面板 鼠标 键盘 按钮 1.简介GUI核心技术：Swing AWT 缺点： 不美观 需要jre环境 为什么要学习 可以写出一些自己用的小工具 可能会涉及到swing的维护工作 -&gt; 破解 了解MVC架构，了解监听 2.AWT2.1.AWT介绍 AWT：抽象的窗口工具，包含了很多的类和接口 元素：窗口、按钮、文本框 java.awt包下 2.2.组件和容器1.Frameimport java.awt.*; //GUI的第一个界面 public class TestFrame { public static void main(String[] args) { Frame frame = new Frame(\"frame标题\"); // 设置窗口可见 frame.setVisible(true); // 设置大小 frame.setSize(400,400); // 设置背景颜色 frame.setBackground(Color.BLACK); // 设置初始位置 frame.setLocation(400,400); // 设置大小固定 frame.setResizable(false); } } 问题：关闭按钮无反应，关闭程序进程才会关闭窗口 封装打开多个实现： import java.awt.*; public class TestFrame2 { public static void main(String[] args) { new MyFrame(100,100,200,200,Color.BLACK); new MyFrame(300,100,200,200,Color.BLUE); new MyFrame(100,300,200,200,Color.YELLOW); new MyFrame(300,300,200,200,Color.WHITE); } } class MyFrame extends Frame{ // 计数器 private static int id = 0; public MyFrame(int x,int y,int w,int h,Color color){ super(\"MyFrame+\"+id++); this.setBounds(x,y,w,h); this.setBackground(color); this.setVisible(true); } } 2.Panelimport java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(\"带面板的Frame\"); Panel panel = new Panel(); frame.setBounds(400,400,500,500); frame.setBackground(Color.BLACK); frame.setLayout(null); panel.setBounds(100,100,300,300); panel.setBackground(Color.YELLOW); // 将面板放入frame中 frame.add(panel); frame.setVisible(true); // 添加监听 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 2.3.布局管理器流式布局 FlowLayout import java.awt.*; //流式布局 public class TestFlowLayout { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); frame.setBounds(400,400,500,500); Button button1 = new Button(\"按钮1\"); Button button2 = new Button(\"按钮2\"); Button button3 = new Button(\"按钮3\"); frame.add(button1); frame.add(button2); frame.add(button3); frame.setLayout(new FlowLayout(FlowLayout.RIGHT)); } } 东西南北中 BorderLayout import java.awt.*; public class TestBorderLayout { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); frame.setBounds(400,400,500,500); Button east = new Button(\"East\"); Button west = new Button(\"West\"); Button south = new Button(\"South\"); Button north = new Button(\"North\"); Button center = new Button(\"Center\"); frame.add(east,BorderLayout.EAST); frame.add(west,BorderLayout.WEST); frame.add(south,BorderLayout.SOUTH); frame.add(north,BorderLayout.NORTH); // frame.add(center,BorderLayout.CENTER); } } 表格式布局 GridLayout import java.awt.*; public class TestGridLayout { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); // frame.setBounds(400,400,500,500); Button button1 = new Button(\"but1\"); Button button2 = new Button(\"but2\"); Button button3 = new Button(\"but3\"); Button button4 = new Button(\"but4\"); Button button5 = new Button(\"but5\"); Button button6 = new Button(\"but6\"); frame.add(button1); frame.add(button2); frame.add(button3); frame.add(button4); frame.add(button5); frame.add(button6); frame.setLayout(new GridLayout(3,2)); // 自动布局大小,测试过程中发现不能在第一行写这个，需要在添加完毕后增加会分配默认size frame.pack(); } } 实现效果： 嵌套布局： import java.awt.*; public class TestDemo1 { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); frame.setBounds(100,100,800,800); Button button1 = new Button(\"button1\"); Button button2 = new Button(\"button2\"); Button button3 = new Button(\"button3\"); Button button4 = new Button(\"button4\"); Button button5 = new Button(\"button5\"); Button button6 = new Button(\"button6\"); Button button7 = new Button(\"button7\"); Button button8 = new Button(\"button8\"); Button button9 = new Button(\"button9\"); Button button10 = new Button(\"button10\"); frame.setLayout(null); Panel panel1 = new Panel(new GridLayout(1,1)); panel1.setBounds(0,0,200,400); panel1.add(button1); Panel panel3 = new Panel(new GridLayout(2,1)); panel3.setBounds(200,0,400,400); panel3.add(button2); panel3.add(button3); Panel panel4 = new Panel(new GridLayout(1,1)); panel4.setBounds(600,0,200,400); panel4.add(button4); Panel panel2 = new Panel(new GridLayout()); panel2.setBounds(0,400,200,400); panel2.add(button5); Panel panel5 = new Panel(new GridLayout(2,2)); panel5.setBounds(200,400,400,400); panel5.add(button6); panel5.add(button7); panel5.add(button8); panel5.add(button9); Panel panel6 = new Panel(new GridLayout()); panel6.setBounds(600,400,200,400); panel6.add(button10); frame.add(panel1); frame.add(panel3); frame.add(panel4); frame.add(panel2); frame.add(panel5); frame.add(panel6); } } 2.4.监听器 一个按钮可以添加多个监听 import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEvent1 { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); frame.setBounds(100,100,500,500); // 一个按钮可以同时添加多个监听 Button button = new Button(); button.addActionListener((actionEvent) -&gt; System.out.println(\"1\")); button.addActionListener((actionEvent) -&gt; System.out.println(\"2\")); frame.add(button,BorderLayout.NORTH); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 一个监听可以给多个按钮共同使用 import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEvent2 { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); frame.setBounds(100,100,500,500); // 顶一个一个监听可以多个按钮共同使用 ActionListener actionListener = new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println(e.getActionCommand()); } }; Button button1 = new Button(\"1\"); // 可以为按钮带参数来控制同一个监听执行不同按钮的方法 button1.setActionCommand(\"11111111111111\"); button1.addActionListener(actionListener); Button button2 = new Button(\"2\"); button2.addActionListener(actionListener); frame.add(button1,BorderLayout.NORTH); frame.add(button2,BorderLayout.SOUTH); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 总结 frame是一个顶级容器 panel面板不能单独存在，需要放到容器中使用 布局管理器 流式布局 东西南北中 表格布局 监听器 // 添加监听 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); 2.5输入框监听import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEvent3 { public static void main(String[] args) { new MyFrame(); } } class MyFrame extends Frame{ public MyFrame(){ TextField textArea = new TextField(); textArea.addActionListener((event)-&gt; { System.out.println(textArea.getText()); textArea.setText(\"\"); }); this.setVisible(true); this.setBounds(100,100,500,500); add(textArea); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 2.6.简易计算器import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestCalc { public static void main(String[] args) { Calc calc = new Calc(); } } class Calc extends Frame{ public Calc(){ TextField jia1 = new TextField(\"10\"); TextField jia2 = new TextField(\"10\"); TextField rest = new TextField(\"20\"); setLayout(new FlowLayout()); add(jia1); add(new Label(\"+\")); add(jia2); Button button = new Button(\"=\"); button.addActionListener(e -&gt; { int jia = Integer.parseInt(jia1.getText()); int beijia = Integer.parseInt(jia2.getText()); rest.setText(jia+beijia+\"\"); jia1.setText(\"\"); jia2.setText(\"\"); }); add(button); add(rest); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); setVisible(true); pack(); } } 2.7.画笔import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestPaint { public static void main(String[] args) { new MyPaint().loadMyPaint(); } } class MyPaint extends Frame{ public void loadMyPaint(){ setVisible(true); setBounds(100,100,800,600); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } @Override public void paint(Graphics g) { // super.paint(g); g.setColor(Color.blue); g.drawOval(100,100,100,100); g.fillOval(100,200,100,100); g.fillRect(100,300,200,100); } } 2.8.鼠标监听目的：想要实现鼠标画画 import java.awt.*; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.util.ArrayList; import java.util.Iterator; import java.util.List; //测试鼠标监听 public class TestMouseListenter { public static void main(String[] args) { new Paint(\"画图\").loadMyPaint(); } } class Paint extends Frame { private List&lt;Point&gt; pointList; private Paint cuttorPaint; public Paint(String title){ super(title); cuttorPaint = this; pointList = new ArrayList&lt;&gt;(); } public void loadMyPaint(){ setVisible(true); setBounds(100,100,800,600); addMouseListener(new MyMouseListenter()); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } @Override public void paint(Graphics g) { Iterator&lt;Point&gt; iterator = pointList.iterator(); while (iterator.hasNext()){ Point point = iterator.next(); //循环画列表的点坐标 g.fillOval(point.x,point.y,10,10); } } private class MyMouseListenter extends MouseAdapter{ // 按下鼠标时触发 @Override public void mousePressed(MouseEvent e) { pointList.add(new Point(e.getX(),e.getY())); //画笔重新画点 cuttorPaint.repaint(); } } } 2.9.窗口监听import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestWindow { public static void main(String[] args) { new MyWindow().loadMyPaint(); } } class MyWindow extends Frame{ public MyWindow(){ super(\"默认窗口名称\"); } public void loadMyPaint(){ setVisible(true); setBounds(100,100,800,600); addWindowListener(new WindowAdapter() { // 点击窗口关闭按钮 @Override public void windowClosing(WindowEvent e) { System.exit(0); } @Override public void windowDeactivated(WindowEvent e) { System.out.println(\"窗口失去焦点\"); } // 打开窗口时执行 @Override public void windowOpened(WindowEvent e) { System.out.println(\"windowOpened\"); } @Override public void windowClosed(WindowEvent e) { System.out.println(\"windowClosed\"); } @Override public void windowIconified(WindowEvent e) { System.out.println(\"缩小\"); } @Override public void windowDeiconified(WindowEvent e) { System.out.println(\"缩小对应的弹出窗口\"); } @Override public void windowActivated(WindowEvent e) { setTitle(\"被激活了窗口\"); } @Override public void windowStateChanged(WindowEvent e) { System.out.println(\"windowStateChanged\"); } @Override public void windowGainedFocus(WindowEvent e) { System.out.println(\"windowGainedFocus\"); } @Override public void windowLostFocus(WindowEvent e) { System.out.println(\"windowLostFocus\"); } }); } } 2.10.键盘监听import java.awt.*; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestKeyListener { public static void main(String[] args) { new MyKeyFrame().loadMyPaint(); } } class MyKeyFrame extends Frame{ public MyKeyFrame(){ super(\"默认窗口名称\"); } public void loadMyPaint(){ setVisible(true); setBounds(100,100,800,600); addKeyListener(new KeyAdapter() { // 按下键时执行 @Override public void keyPressed(KeyEvent e) { int keyCode = e.getKeyCode(); System.out.println(keyCode); if(keyCode == KeyEvent.VK_ENTER){ System.out.println(\"按了回车\"); } } }); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 3.SwingSwing是AWT的封装演化， 3.1.窗口 JFrameimport javax.swing.*; import java.awt.Container; import static java.awt.Color.YELLOW; public class TestJFrame1 { public static void main(String[] args) { JFrame jFrame = new JFrame(); jFrame.setBounds(10,10,400,400); jFrame.setVisible(true); JLabel jLabel = new JLabel(\"测试标签\"); // jFrame.setBackground(Color.BLACK); Container contentPane = jFrame.getContentPane(); contentPane.setBackground(YELLOW); //标签居中 jLabel.setHorizontalAlignment(SwingConstants.CENTER); jFrame.add(jLabel); // 不设置，默认是隐藏窗口 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } 3.2弹窗 JDialog import javax.swing.*; import java.awt.*; import static java.awt.Color.YELLOW; public class TestJFrame2 { public static void main(String[] args) { JFrame jFrame = new JFrame(); jFrame.setBounds(10,10,400,400); jFrame.setVisible(true); JButton jLabel = new JButton(\"测试按钮\"); // jFrame.setBackground(Color.BLACK); Container contentPane = jFrame.getContentPane(); contentPane.setBackground(YELLOW); // 设置居中 jLabel.setHorizontalAlignment(SwingConstants.CENTER); jLabel.addActionListener(e -&gt; new Mydiglog() ); contentPane.setLayout(null); jLabel.setLocation(50,50); jLabel.setSize(200,50); contentPane.add(jLabel); // 不设置，默认是隐藏窗口 jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } } class Mydiglog extends JDialog{ public Mydiglog(){ setVisible(true); setBounds(10,10,500,500); // 弹窗默认带了关闭，不需要写 // setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); JLabel jLabel = new JLabel(\"测试弹窗标签2 \"); Container container = getContentPane(); container.setLayout(null); jLabel.setLocation(10,10); jLabel.setSize(100,20); container.add(jLabel); } } 3.3 图标Iconpackage com.duan.lesson03; import javax.swing.*; import java.awt.*; public class IconFrame1 { public static void main(String[] args) { JFrame jFrame = new JFrame(); jFrame.setBounds(10,10,400,400); jFrame.setVisible(true); JLabel jButton = new JLabel(\" 标签\",new MyIconDemo(10,10),SwingConstants.CENTER); // 不设置，默认是隐藏窗口 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jButton.setSize(100,100); jFrame.add(jButton); } } class MyIconDemo implements Icon{ private int iconWiddth; private int iconHeight; public MyIconDemo(int iconWiddth,int iconHeight){ this.iconWiddth = iconWiddth; this.iconHeight = iconHeight; } @Override public void paintIcon(Component c, Graphics g, int x, int y) { g.fillOval(x,y,iconWiddth,iconHeight); } @Override public int getIconWidth() { return iconWiddth; } @Override public int getIconHeight() { return iconHeight; } } 其他创建和使用与awt类似，类名加J前缀，增加了一些快捷实现 3.4滚动条面板import javax.swing.*; import java.awt.*; import java.io.File; import java.net.MalformedURLException; public class TestPanle4 { public static void main(String[] args) { JFrame jFrame = new JFrame(); jFrame.setBounds(10,10,400,400); jFrame.setVisible(true); JTextArea jTextArea = new JTextArea(50,50); // 滚动条面板 JScrollPane jButton = new JScrollPane(jTextArea); jFrame.add(jButton); } } 4.贪吃蛇帧，如果时间片足够小，就是动画 一秒三时帧，连起来是动画 拆开就是图片 键盘监听 addKeyListener 需要注意 如果是面板添加监听需要设置当前面板获取焦点 setFocusable (true); 定时器Timer import javax.swing.*; import java.awt.*; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import java.io.File; import java.net.MalformedURLException; import java.net.URL; import java.util.Random; public class StartGame { public static void main(String[] args) { JFrame jFrame = new JFrame(\"贪吃蛇\"); jFrame.add(new GamePanel()); // 设置窗口不可拉伸 jFrame.setResizable(false); // 固定大小 jFrame.setBounds(100,100,900,750); jFrame.setVisible(true); jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } } //游戏面板 class GamePanel extends JPanel{ private int length = 3; private int fx; private int[][] zuobiao = new int[2][850]; private boolean isStart = false; private boolean isError = false; private int[] foot = new int[2]; Random random = new Random(); private Timer timer = new Timer(100,e -&gt; { if(isStart &amp;&amp; !isError){ if(zuobiao[0][0] == foot[0] &amp;&amp; zuobiao[1][0] == foot[1]){ length++; setRandomFoot(); } for (int i = length - 1; i &gt; 0; i--) { zuobiao[0][i] = zuobiao[0][i-1]; zuobiao[1][i] = zuobiao[1][i-1]; } switch (fx){ case KeyEvent.VK_RIGHT: zuobiao[0][0] = zuobiao[0][0]+25; if(zuobiao[0][0] &gt;= 875)zuobiao[0][0]=25; break; case KeyEvent.VK_LEFT: zuobiao[0][0] = zuobiao[0][0]-25; if(zuobiao[0][0] &lt; 25)zuobiao[0][0]=850; break; case KeyEvent.VK_UP: zuobiao[1][0] = zuobiao[1][0]-25; if(zuobiao[1][0] &lt;= 70)zuobiao[1][0]=675; break; case KeyEvent.VK_DOWN: zuobiao[1][0] = zuobiao[1][0]+25; if(zuobiao[1][0] &gt;= 675)zuobiao[1][0]=70; break; } // 失败条件 for (int i = 1; i &lt; length; i++) { if(zuobiao[0][0] == zuobiao[0][i] &amp;&amp; zuobiao[1][0] == zuobiao[1][i]){ isError = true; } } repaint(); } }); public GamePanel(){ addKeyListener(new KeyAdapter() { @Override public void keyPressed(KeyEvent e) { switch (e.getKeyCode()){ case KeyEvent.VK_ENTER: isError = false; timer.stop(); init(); break; case KeyEvent.VK_SPACE: if(!isError){ isStart = !isStart; repaint(); } break; case KeyEvent.VK_UP: if(fx != KeyEvent.VK_DOWN)fx = KeyEvent.VK_UP; break; case KeyEvent.VK_DOWN: if(fx != KeyEvent.VK_UP)fx = KeyEvent.VK_DOWN; break; case KeyEvent.VK_LEFT: if(fx != KeyEvent.VK_RIGHT)fx = KeyEvent.VK_LEFT; break; case KeyEvent.VK_RIGHT: if(fx != KeyEvent.VK_LEFT)fx = KeyEvent.VK_RIGHT; break; } } }); init(); } public void init(){ length = 3; zuobiao[0][0] = 100; zuobiao[1][0] = 95; for (int i = 1; i &lt; length; i++) { zuobiao[0][i] = zuobiao[0][0]-i*25; zuobiao[1][i] = zuobiao[1][0]; } setRandomFoot(); // 默认向右 fx = KeyEvent.VK_RIGHT; setFocusable(true); // timer.setDelay(1); timer.start(); } //设置事物随机坐标 private void setRandomFoot() { foot[0] = 25 + 25*random.nextInt(34); foot[1] = 70 + 25*random.nextInt(24); for (int i = 0; i &lt; length; i++) { if(zuobiao[0][i] == foot[0] &amp;&amp; zuobiao[1][i] == foot[1]){ setRandomFoot(); } } } // 画板 @Override protected void paintComponent(Graphics g) { super.paintComponent(g); setBackground(Color.white); GameData.header.paintIcon(this,g ,25,0); g.fillRect(25,70,850,625); GameData.food.paintIcon(this,g ,foot[0],foot[1]); switch (fx){ case KeyEvent.VK_RIGHT: GameData.right.paintIcon(this,g,zuobiao[0][0],zuobiao[1][0]); break; case KeyEvent.VK_LEFT: GameData.left.paintIcon(this,g,zuobiao[0][0],zuobiao[1][0]); break; case KeyEvent.VK_UP: GameData.up.paintIcon(this,g,zuobiao[0][0],zuobiao[1][0]); break; case KeyEvent.VK_DOWN: GameData.dowm.paintIcon(this,g,zuobiao[0][0],zuobiao[1][0]); break; } for (int i = 1; i &lt; length; i++) { GameData.body.paintIcon(this,g,zuobiao[0][i],zuobiao[1][i]); } if(!isStart){ g.setColor(Color.YELLOW); g.setFont(new Font(\"微软雅黑\",Font.BOLD,48)); g.drawString(\"按空格开启游戏\",250,500); } if(isError){ g.setColor(Color.RED); g.setFont(new Font(\"微软雅黑\",Font.BOLD,48)); g.drawString(\"游戏失败,按回车开启游戏\",250,500); } } } //游戏图标类 class GameData{ private static URL bodyurl; private static URL downurl; private static URL foodurl; private static URL headerurl; private static URL lefturl; private static URL righturl; private static URL upurl; static { try { bodyurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\body.png\").toURL(); foodurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\food.png\").toURL(); headerurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\header.png\").toURL(); upurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\up.png\").toURL(); downurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\down.png\").toURL(); lefturl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\left.png\").toURL(); righturl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\right.png\").toURL(); } catch (MalformedURLException e) { e.printStackTrace(); } } public static ImageIcon header = new ImageIcon(headerurl); public static ImageIcon body = new ImageIcon(bodyurl); public static ImageIcon food = new ImageIcon(foodurl); public static ImageIcon up = new ImageIcon(upurl); public static ImageIcon dowm = new ImageIcon(downurl); public static ImageIcon left = new ImageIcon(lefturl); public static ImageIcon right = new ImageIcon(righturl); } \\\\img\\\\statics\\\\body.png\").toURL(); foodurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\food.png\").toURL(); headerurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\header.png\").toURL(); upurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\up.png\").toURL(); downurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\down.png\").toURL(); lefturl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\left.png\").toURL(); righturl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\right.png\").toURL(); } catch (MalformedURLException e) { e.printStackTrace(); } } public static ImageIcon header = new ImageIcon(headerurl); public static ImageIcon body = new ImageIcon(bodyurl); public static ImageIcon food = new ImageIcon(foodurl); public static ImageIcon up = new ImageIcon(upurl); public static ImageIcon dowm = new ImageIcon(downurl); public static ImageIcon left = new ImageIcon(lefturl); public static ImageIcon right = new ImageIcon(righturl); }","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"MyBatisPlus概述","slug":"MyBatis-Plus笔记","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:26:53.641Z","comments":true,"path":"posts/ea4e975t.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e975t.html","excerpt":"","text":"1、MyBatisPlus概述为什么要学习它呢？MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成！ JPA 、 tk-mapper、MyBatisPlus 1.1、简介是什么？ MyBatis 本来就是简化 JDBC 操作的！ 官网：https://mp.baomidou.com/ MyBatis Plus，简化 MyBatis ！ 1.2、特性无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作， BaseMapper 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分CRUD 操作，更有强大的条件构造器，满足各类使用需求, 以后简单的CRUD操作，它不用自己编写了！ 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（自动帮你生成代码） 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 1.3、快速入门地址：https://mp.baomidou.com/guide/quick-start.html 使用第三方组件： 导入对应的依赖 研究依赖如何配置 代码如何编写 提高扩展技术能力！ 1.4、步骤1、创建数据库 mybatis_plus 2、创建user表 DROP TABLE IF EXISTS user; CREATE TABLE user ( id BIGINT(20) NOT NULL COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); INSERT INTO user (id, name, age, email) VALUES (1, 'Jone', 18, 'test1@baomidou.com'), (2, 'Jack', 20, 'test2@baomidou.com'), (3, 'Tom', 28, 'test3@baomidou.com'), (4, 'Sandy', 21, 'test4@baomidou.com'), (5, 'Billie', 24, 'test5@baomidou.com'); -- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified 3、编写项目，初始化项目！使用SpringBoot初始化！ 4、导入依赖 &lt;!-- 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;!-- mybatis-plus 是自己开发，并非官方的！ --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; 说明：我们使用 mybatis-plus 可以节省我们大量的代码，尽量不要同时导入 mybatis 和 mybatis plus！版本的差异！ 5、连接数据库！这一步和 mybatis 相同！ # mysql 5 驱动不同 com.mysql.jdbc.Driver # mysql 8 驱动不同com.mysql.cj.jdbc.Driver、需要增加时区的配置 serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=981204 spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 6、传统方式pojo-dao（连接mybatis，配置mapper.xml文件）-service-controller 6、使用了mybatis-plus 之后 pojo @Data @AllArgsConstructor @NoArgsConstructor public class User { //对应数据库中的主键(uuid、自塘id、 雪花算法、redis、 zookeeper! ) private Long id; private String name; private Integer age; private String email; } mapper // 在对应的Mapper上面继承基本的类 BaseMapper @Repository // 代表持久层 public interface UserMapper extends BaseMapper&lt;User&gt; {//泛型类型代表pojo类 // 所有的CRUD操作都已经编写完成了 // 你不需要像以前的配置一大堆文件了！ } 注意点，我们需要在主启动类上去扫描我们的mapper包下的所有接口 @MapperScan(\"com.kuang.mapper\") 7、测试类中测试 @SpringBootTest class MybatisPlusApplicationTests { // 继承了BaseMapper，所有的方法都来自己父类 // 我们也可以编写自己的扩展方法！ @Autowired private UserMapper userMapper; @Test void contextLoads() { // 参数是一个 Wrapper ，条件构造器，这里我们先不用 null // 查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); } } 8、结果 1.5、思考问题？1、SQL谁帮我们写的 ? MyBatis-Plus 都写好了 2、方法哪里来的？ MyBatis-Plus 都写好了 2、配置日志我们所有的sql现在是不可见的，我们希望知道它是怎么执行的，所以我们必须要看日志！ #配置日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 配置完毕日志之后，后面的学习就需要注意这个自动生成的SQL，你们就会喜欢上 MyBatis-Plus！ 3、CRUD扩展3.1、插入操作 Insert 插入 // 测试插入 @Test public void testInsert() { User user = new User(); user.setName(\"狂神说Java\"); user.setAge(3); user.setEmail(\"24736743@qq.com\"); int result = userMapper.insert(user);// 帮我们自动生成id System.out.println(result);// 受影响的行数 System.out.println(user); // 发现，id会自动回填 } 数据库插入的id的默认值为：全局的唯一id 3.2、主键生成策略 默认 ID_WORKER 全局唯一id 分布式系统唯一id生成：https://www.cnblogs.com/haoxinyue/p/5208136.html 雪花算法：(mybatis使用的id生成默认是雪花算法) snowflflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！ 主键自增 我们需要配置主键自增： 1、实体类id字段上 @TableId(type = IdType.AUTO) 2、数据库字段一定要是自增！ 3、再次测试插入即可！ 其余的源码解释 public enum IdType { AUTO(0), // 数据库id自增 NONE(1), // 未设置主键 INPUT(2), // 手动输入 ID_WORKER(3), // 默认的全局唯一id （注意看源码，有些版本默认是none，如果表设置了主键，就得自己设值，否则会出现异常，第一次插入是0，第二次抛出异常） UUID(4), // 全局唯一id uuid ID_WORKER_STR(5); //ID_WORKER 字符串表示法 } 3.3、更新操作// 测试更新 @Test public void testUpdate() { User user = new User(); //通过条件自动拼接动态sql user.setId(6L); user.setName(\"关注公众号：狂神说\"); /*user.setAge(18);*/ //注意：updateById 但是参数是一个 对象！ int i = userMapper.updateById(user); System.out.println(i); } 所有的sql都是自动帮你动态配置的！ 自动填充 创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！ 阿里巴巴开发手册：所有的数据库表：gmt_create(数据创建时间)、gmt_modifified（数据修改时间）几乎所有的表都要配置上！而且需要自动化！ 方式一：数据库级别（工作中不允许你修改数据库） 1、在表中新增字段 create_time, update_time 2、再次测试插入方法，我们需要先把实体类同步！ private Date createTime; private Date updateTime; 3、再次更新查看结果即可 方式二：代码级别 1、删除数据库的默认值、更新操作！ 2、实体类字段属性上需要增加注解 // 字段添加填充内容 @TableField(fill = FieldFill.INSERT) private Date createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private Date updateTime; 3、编写处理器来处理这个注解即可！ package com.kuang.handle; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import lombok.extern.slf4j.Slf4j; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.util.Date; @Slf4j @Component // 一定不要忘记把处理器加到IOC容器中！ public class MyMetaObjectHandler implements MetaObjectHandler { // 插入时的填充策略 @Override public void insertFill(MetaObject metaObject) { log.info(\"start insert fill.....\"); // setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject this.setFieldValByName(\"createTime\", new Date(), metaObject); this.setFieldValByName(\"updateTime\", new Date(), metaObject); } // 更新时的填充策略 @Override public void updateFill(MetaObject metaObject) { log.info(\"start update fill.....\"); this.setFieldValByName(\"updateTime\", new Date(), metaObject); } } 4、测试插入 5、测试更新、观察时间即可！ 3.4、乐观锁在面试过程中，我们经常会被问道乐观锁，悲观锁！这个其实非常简单！ 乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试 悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！ 我们这里主要讲解 乐观锁机制！ 乐观锁实现方式： 取出记录时，获取当前 version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 乐观锁：1、先查询，获得版本号 version = 1 -- A update user set name = \"kuangshen\", version = version + 1 where id = 2 and version = 1 -- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！ update user set name = \"kuangshen\", version = version + 1 where id = 2 and version = 1 测试一下Mybatis-Plus的乐观锁插件 1、给数据库中增加version字段！ 2、我们实体类加对应的字段 @Version //乐观锁Version注解 private Integer version; 3、注册组件 // 扫描我们的 mapper 文件夹 @MapperScan(\"com.kuang.mapper\") @EnableTransactionManagement @Configuration // 配置类 public class MyBatisPlusConfig { // 注册乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() { return new OptimisticLockerInterceptor(); } } 4、测试一下！ // 测试乐观锁成功！ @Test public void testOptimisticLocker() { // 1、查询用户信息 User user = userMapper.selectById(1L); // 2、修改用户信息 user.setName(\"小樱\"); user.setEmail(\"24736743@qq.com\"); // 3、执行更新操作 userMapper.updateById(user); } // 测试乐观锁失败！多线程下 @Test public void testOptimisticLocker2() { // 线程 1 User user = userMapper.selectById(1L); user.setName(\"kuangshen111\"); user.setEmail(\"24736743@qq.com\"); // 模拟另外一个线程执行了插队操作 User user2 = userMapper.selectById(1L); user2.setName(\"kuangshen222\"); user2.setEmail(\"24736743@qq.com\"); userMapper.updateById(user2); // 自旋锁来多次尝试提交！ userMapper.updateById(user); // 如果没有乐观锁就会覆盖插队线程的值！ } 3.5、查询操作// 测试查询 @Test public void testSelectById() { User user = userMapper.selectById(1L); System.out.println(user); } // 测试批量查询！ @Test public void testSelectByBatchId() { List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3)); users.forEach(System.out::println); } // 按条件查询之一使用map操作 @Test public void testSelectByBatchIds() { HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 自定义要查询 map.put(\"name\", \"狂神说Java\"); map.put(\"age\", 3); List&lt;User&gt; users = userMapper.selectByMap(map); users.forEach(System.out::println); } 3.6、分页查询分页在网站使用的十分之多！ 1、原始的 limit 进行分页2、pageHelper 第三方插件3、MyBatisPlus 其实也内置了分页插件！ 如何使用！ 1、配置拦截器组件即可 // 分页插件 @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); } 2、直接使用Page对象即可！ // 测试分页查询 @Test public void testPage(){ // 参数一：当前页 // 参数二：页面大小 // 使用了分页插件之后，所有的分页操作也变得简单的！ Page&lt;User&gt; page = new Page&lt;&gt;(2,5); userMapper.selectPage(page,null); page.getRecords().forEach(System.out::println); System.out.println(page.getTotal());//获取表的所有数据行数 } 3.7、删除操作1、根据 id 删除记录 // 测试删除 @Test public void testDeleteById() { userMapper.deleteById(1259423899561529348L); } // 通过id批量删除 @Test public void testDeleteBatchId() { userMapper.deleteBatchIds(Arrays.asList(1259423899561529345l, 1259423899561529346l)); } // 通过map删除 @Test public void testDeleteMap() { HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"狂神说Java\"); userMapper.deleteByMap(map); } 我们在工组中会遇到一些问题：逻辑删除！ 3.8、逻辑删除 物理删除 ：从数据库中直接移除 逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ deleted = 0 =&gt; deleted = 1 管理员可以查看被删除的记录！防止数据的丢失，类似于回收站！ 测试一下： 1、在数据表中增加一个 deleted 字段 2、实体类中增加属性@TableLogic //逻辑删除 private Integer deleted; 3、配置！MyBatisPlusConfig.java // 逻辑删除组件！ @Bean public ISqlInjector sqlInjector() { return new LogicSqlInjector(); } application.properties # 配置逻辑删除 mybatis-plus.global-config.db-config.logic-delete-value=1 mybatis-plus.global-config.db-config.logic-not-delete-value=0 4、测试一下删除！// 测试查询 @Test public void testSelectById() { User user = userMapper.selectById(1L); System.out.println(user); } 记录依旧在数据库，但是值确已经变化了！ 以上的所有CRUD操作及其扩展操作，我们都必须精通掌握！会大大提高你的工作和写项目的效率！ 3.9、性能分析插件我们在平时的开发中，会遇到一些慢sql。测试！ druid,,,,, 作用：性能分析拦截器，用于输出每条 SQL 语句及其执行时间 MP也提供性能分析插件，如果超过这个时间就停止运行！ 1、导入插件/** * SQL执行效率插件 */ @Bean @Profile({\"dev\", \"test\"})// 设置 dev test 环境开启，保证我们的效率 public PerformanceInterceptor performanceInterceptor() { PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100); // ms设置sql执行的最大时间，如果超过了则不 执行 performanceInterceptor.setFormat(true); // 是否格式化代码 return performanceInterceptor; } 记住，要在SpringBoot中配置环境为dev或者 test 环境！ 2、测试使用！@Test void contextLoads() { // 参数是一个 Wrapper ，条件构造器，这里我们先不用 null // 查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); } 使用性能分析插件，可以帮助我们提高效率！ 3.10、条件构造器十分重要：Wrapper wapper介绍 Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 ​ QueryWrapper ： Entity 对象封装操作类，不是用lambda语法 ​ UpdateWrapper ： Update 条件封装，用于Entity对象更新操作 AbstractLambdaWrapper ： Lambda 语法使用 Wrapper统一处理解析 lambda 获取 column。 ​ LambdaQueryWrapper ：看名称也能明白就是用于Lambda语法使用的查询Wrapper ​ LambdaUpdateWrapper ： Lambda 更新封装Wrapper 我们写一些复杂的sql就可以使用它来替代！ 1、测试一，记住查看输出的SQL进行分析 @Test void test1() { // 查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.isNotNull(\"name\").isNotNull(\"email\").ge(\"age\", 12); userMapper.selectList(wrapper).forEach(System.out::println); // 和我们刚才学习 的map对比一下 } 2、测试二，记住查看输出的SQL进行分析 @Test void test2() { // 查询名字狂神说 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(\"name\", \"狂神说\"); User user = userMapper.selectOne(wrapper); // 查询一个数据，出现多个结果使用List 或者 Map System.out.println(user); } 3、测试三，记住查看输出的SQL进行分析 @Test void test3() { // 查询年龄在 20 ~ 30 岁之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.between(\"age\", 20, 30); // 区间 Integer count = userMapper.selectCount(wrapper);// 查询结果数 System.out.println(count); } 4、测试四，记住查看输出的SQL进行分析 // 模糊查询 @Test void test4() { // 查询年龄在 20 ~ 30 岁之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 左和右 t% wrapper.notLike(\"name\", \"e\").likeRight(\"email\", \"t\"); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper); maps.forEach(System.out::println); } 5、测试五，记住查看输出的SQL进行分析 // 模糊查询 @Test void test5() { QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // id 在子查询中查出来 // inSql(\"id\", \"select id from table where id &lt; 3\")---&gt;id in (select id from table where id &lt; 3) wrapper.inSql(\"id\", \"select id from user where id&lt;3\"); List&lt;Object&gt; objects = userMapper.selectObjs(wrapper); objects.forEach(System.out::println); } 6、测试六，记住查看输出的SQL进行分析 //测试六 @Test void test6() { QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 通过id进行排序 wrapper.orderByAsc(\"id\");//升序 wrapper.orderByDesc(\"id\");//降序 List&lt;User&gt; users = userMapper.selectList(wrapper); users.forEach(System.out::println); } 7、or、and 注意：这里使用的是 UpdateWrapper 不调用or则默认为使用 and 连 @Test public void testUpdate1() { //修改值 User user = new User(); user.setAge(99); user.setName(\"Andy\"); //修改条件 UpdateWrapper&lt;User&gt; userUpdateWrapper = new UpdateWrapper&lt;&gt;(); userUpdateWrapper .like(\"name\", \"h\") .or() .between(\"age\", 20, 30); int result = userMapper.update(user, userUpdateWrapper); System.out.println(result); } UPDATE user SET name=?, age=?, update_time=? WHERE deleted=0 AND name LIKE ? OR age BETWEEN ? AND ? 8、嵌套or、嵌套and 这里使用了lambda表达式，or中的表达式最后翻译成sql时会被加上圆括号 @Test public void testUpdate2() { //修改值 User user = new User(); user.setAge(99); user.setName(\"Andy\"); //修改条件 UpdateWrapper&lt;User&gt; userUpdateWrapper = new UpdateWrapper&lt;&gt;(); userUpdateWrapper .like(\"name\", \"h\") .or(i -&gt; i.eq(\"name\", \"李白\").ne(\"age\", 20)); int result = userMapper.update(user, userUpdateWrapper); System.out.println(result); } UPDATE user SET name=?, age=?, update_time=? WHERE deleted=0 AND name LIKE ? OR ( name = ? AND age &lt;&gt; ? ) 3.11、代码自动生成器dao、pojo、service、controller都给我自己去编写完成！ AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。 测试 public class KuangCode { public static void main(String[] args) { // 需要构建一个 代码自动生成器 对象 AutoGenerator mpg = new AutoGenerator(); // 配置策略 // 1、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\");//获取用户目录 gc.setOutputDir(projectPath + \"/src/main/java\");//项目输出路径 gc.setAuthor(\"狂神说\"); gc.setOpen(false);//是否打开资源管理器 gc.setFileOverride(false);// 是否覆盖原来生成的 gc.setServiceName(\"%sService\");//通过正则表达式去Service的I前缀（服务名字） gc.setIdType(IdType.ID_WORKER);//生成策略，默认初始算法 gc.setDateType(DateType.ONLY_DATE);//设置日期类型，仅仅只是时间 gc.setSwagger2(true);//自动配置Swagger文档 mpg.setGlobalConfig(gc);//全局配置放到自动生成器 //2、设置数据源 DataSourceConfig dsc = new DataSourceConfig(); //jdbc:oracle:thin:@localhost:1521:orcl /*dsc.setUrl(\"jdbc:oracle:thin:@192.168.7.26:1521:testgkdb\"); dsc.setDriverName(\"oracle.jdbc.driver.OracleDriver\"); dsc.setUsername(\"FASP2020\"); dsc.setPassword(\"FASP2020\"); dsc.setDbType(DbType.ORACLE);*/ dsc.setUrl(\"jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"981204\"); dsc.setDbType(DbType.MYSQL);//设置数据库类型 mpg.setDataSource(dsc);//数据源放到自动生成器 //3、包的配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(\"blog\");//设置包名 pc.setParent(\"com.kuang\");//放在哪个包下 pc.setEntity(\"entity\");//要自动生成的 pc.setMapper(\"mapper\"); pc.setService(\"service\"); pc.setController(\"controller\"); mpg.setPackageInfo(pc);//数据源放到自动生成器 //4、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(\"user\"); // 设置要映射的表名 strategy.setNaming(NamingStrategy.underline_to_camel);//表名转驼峰 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//字段名转驼峰 strategy.setEntityLombokModel(true);//自动生成使用lombok strategy.setLogicDeleteFieldName(\"deleted\");//逻辑删除字段自动配置 // 自动填充配置 TableFill gmtCreate = new TableFill(\"gmt_create\", FieldFill.INSERT);//自动创建时间执行insert操作 TableFill gmtModified = new TableFill(\"gmt_modified\", FieldFill.INSERT_UPDATE);//自动修改时间执行insert操作 ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills);// 自动填充配置到策略中 // 乐观锁 strategy.setVersionFieldName(\"version\"); strategy.setRestControllerStyle(true);//开启Restful的驼峰命名 strategy.setControllerMappingHyphenStyle(true);// localhost:8080/hello_id_2 //Controlle的的链接请求设置 mpg.setStrategy(strategy); mpg.execute(); //执行 } } 效果 4、使用Oracle数据库的代码自动生成器1、&lt;!--连接Oracle数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--客户端全球化--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.easyproject&lt;/groupId&gt; &lt;artifactId&gt;orai18n&lt;/artifactId&gt; &lt;version&gt;12.1.0.2.0&lt;/version&gt; &lt;/dependency&gt; 2、spring.datasource.url=jdbc\\:oracle\\:thin\\:@192.168.7.26\\:1521\\:testgkdb spring.datasource.username=FASP2020 spring.datasource.password=FASP2020 spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver 3、public class KuangCode { public static void main(String[] args) { // 需要构建一个 代码自动生成器 对象 AutoGenerator mpg = new AutoGenerator(); // 配置策略 // 1、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\"); gc.setAuthor(\"狂神说\"); gc.setOpen(false); gc.setFileOverride(false);// 是否覆盖 gc.setServiceName(\"%sService\");// 去Service的I前缀 gc.setIdType(IdType.ID_WORKER); gc.setDateType(DateType.ONLY_DATE); /* gc.setSwagger2(true);*/ mpg.setGlobalConfig(gc); //2、设置数据源 DataSourceConfig dsc = new DataSourceConfig(); //jdbc:oracle:thin:@localhost:1521:orcl dsc.setUrl(\"jdbc:oracle:thin:@192.168.7.26:1521:testgkdb\"); dsc.setDriverName(\"oracle.jdbc.driver.OracleDriver\"); dsc.setUsername(\"FASP2020\"); dsc.setPassword(\"FASP2020\"); dsc.setDbType(DbType.ORACLE); mpg.setDataSource(dsc); //3、包的配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(\"blog\"); pc.setParent(\"com.kuang\"); pc.setEntity(\"entity\"); pc.setMapper(\"mapper\"); pc.setService(\"service\"); pc.setController(\"controller\"); mpg.setPackageInfo(pc); //4、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(\"GLB_BAL\"); // 设置要映射的表名 strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); /*strategy.setEntityLombokModel(true);*/ // 自动lombok； strategy.setLogicDeleteFieldName(\"deleted\"); // 自动填充配置 TableFill gmtCreate = new TableFill(\"gmt_create\", FieldFill.INSERT); TableFill gmtModified = new TableFill(\"gmt_modified\", FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills); // 乐观锁 strategy.setVersionFieldName(\"version\"); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true);// localhost:8080/hello_id_2 mpg.setStrategy(strategy); mpg.execute(); //执行 } }","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"整合SSM","slug":"SSM笔记 狂神","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:31:26.384Z","comments":true,"path":"posts/ea4e912k.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e912k.html","excerpt":"","text":"整合SSM数据库环境创建一个存放书籍数据的数据库表 CREATE DATABASE `ssmbuild`; USE `ssmbuild`; DROP TABLE IF EXISTS `books`; CREATE TABLE `books` ( `bookId` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id', `bookName` VARCHAR(100) NOT NULL COMMENT '书名', `bookCounts` INT(11) NOT NULL COMMENT '数量', `detail` VARCHAR(200) NOT NULL COMMENT '描述', KEY `bookId` (`bookId`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `books`(`bookId`,`bookName`,`bookCounts`,`detail`)VALUES (1,'Java',1,'从入门到放弃'), (2,'MySQL',10,'从删库到跑路'), (3,'Linux',5,'从进门到进牢'); 基本环境搭建1、新建一Maven项目！ssmbuild ， 添加web的支持 2、导入相关的pom依赖！ &lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop切入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、Maven资源过滤设置 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 4、建立基本结构和配置框架！ com.kuang.pojo com.kuang.dao com.kuang.service com.kuang.controller mybatis-config.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;/configuration&gt; applicationContext.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; Mybatis层编写1、数据库配置文件 database.properties jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT jdbc.username=root jdbc.password=admin 2、IDEA关联数据库 3、编写MyBatis的核心配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name=\"com.xu.pojo\"/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper class=\"com.xu.mapper.BookMapper\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 4、编写数据库对应的实体类 com.kuang.pojo.Books 使用lombok插件！ package com.kuang.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class Books { private int bookID; private String bookName; private int bookCounts; private String detail; } 5、编写Dao层的 Mapper接口！ package com.xu.mapper; import com.xu.pojo.Books; import org.apache.ibatis.annotations.Param; import java.util.List; public interface BookMapper { //增加一本书 int addBook(Books book); //根据id删除一本书 int deleteBook(@Param(\"id\") int bookId); //更新一本书 int updateBook(Books book); //根据id查询书 Books findBookById(@Param(\"id\") int bookId); //查询所有书 List&lt;Books&gt; findAllBook(); //按书籍名称查询 Books queryBookByName(@Param(\"bookName\") String bookName); } 6、编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包； &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.xu.mapper.BookMapper\"&gt; &lt;insert id=\"addBook\" parameterType=\"Books\"&gt; insert into books (bookId,bookName,bookCounts,detail) values (#{bookId},#{bookName},#{bookCounts},#{detail}); &lt;/insert&gt; &lt;delete id=\"deleteBook\" parameterType=\"int\"&gt; delete from books where bookId=#{id} &lt;/delete&gt; &lt;update id=\"updateBook\" parameterType=\"Books\"&gt; update books set bookName = #{bookName},bookCounts = #{bookCounts},detail = #{detail} where bookId = #{bookId} &lt;/update&gt; &lt;select id=\"findBookById\" resultType=\"Books\"&gt; select * from ssmbuild.books where bookId = #{id} &lt;/select&gt; &lt;select id=\"findAllBook\" resultType=\"Books\"&gt; SELECT * from ssmbuild.books &lt;/select&gt; &lt;select id=\"queryBookByName\" resultType=\"Books\"&gt; select * from books where bookName=#{bookName}; &lt;/select&gt; &lt;/mapper&gt; 7、编写Service层的接口和实现类 接口： package com.kuang.service; import com.kuang.pojo.Books; import java.util.List; //BookService:底下需要去实现,调用dao层 public interface BookService { //增加一本书 int addBook(Books book); //根据id删除一本书 int deleteBook(int bookId); //更新一本书 int updateBook(Books book); //根据id查询书 Books findBookById(int bookId); //查询所有书 List&lt;Books&gt; findAllBook(); //按书籍名称查询 Books queryBookByName( String bookName); } 实现类： package com.kuang.service; import com.kuang.dao.BookMapper; import com.kuang.pojo.Books; import java.util.List; public class BookServiceImpl implements BookService { //调用dao层的操作，设置一个set接口，方便Spring管理 private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } @Override public int addBook(Books book) { return bookMapper.addBook(book); } @Override public int deleteBook(int bookId) { return bookMapper.deleteBook(bookId); } @Override public int updateBook(Books book) { return bookMapper.updateBook(book); } @Override public Books findBookById(int bookId) { return bookMapper.findBookById(bookId); } @Override public List&lt;Books&gt; findAllBook() { return bookMapper.findAllBook(); } @Override public Books queryBookByName(String bookName) { return bookMapper.queryBookByName(bookName); } } OK，到此，底层需求操作编写完毕！ Spring层1、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池； 2、我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1.关联数据库文件 --&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=\"driverClass\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"jdbcUrl\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"user\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=\"maxPoolSize\" value=\"30\"/&gt; &lt;property name=\"minPoolSize\" value=\"10\"/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=\"autoCommitOnClose\" value=\"false\"/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=\"checkoutTimeout\" value=\"10000\"/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=\"acquireRetryAttempts\" value=\"2\"/&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt; &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=\"basePackage\" value=\"com.xu.mapper\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 3、Spring整合service层 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 扫描service相关的bean --&gt; &lt;context:component-scan base-package=\"com.xu.service\" /&gt; &lt;!--BookServiceImpl注入到IOC容器中--&gt; &lt;bean id=\"BookServiceImpl\" class=\"com.xu.service.BookServiceImpl\"&gt; &lt;property name=\"bookMapper\" ref=\"bookMapper\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\"class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- aop事务织入--&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id=\"interceptor\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务切入 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.xu.mapper.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"interceptor\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！ SpringMVC层1、web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--encodingFilter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;/web-app&gt; 2、spring-mvc.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" /&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=\"com.xu.controller\" /&gt; &lt;/beans&gt; 3、Spring配置整合文件，applicationContext.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"spring-dao.xml\"/&gt; &lt;import resource=\"spring-service.xml\"/&gt; &lt;import resource=\"spring-mvc.xml\"/&gt; &lt;/beans&gt; Controller 和 视图层编写1、BookController 类编写 ， 方法一：查询全部书籍 @Controller @RequestMapping(\"/book\") public class BookController { @Autowired @Qualifier(\"BookServiceImpl\") private Bookservice bookservice; //向上转型 @RequestMapping(\"/findAll\") public String findAllBook(Model model) { List&lt;Books&gt; booksList = bookservice.findAllBook(); model.addAttribute(\"booksList\", booksList); return \"findAllBook\"; } } 2、编写首页 index.jsp &lt;%-- User: win10 Date: 2020/6/24 Time: 15:51 --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;style type=\"text/css\"&gt; h3 { width: 150px; height: 40px; margin: 100px auto; text-align: center; text-decoration: none; background-color: burlywood; border-radius: 8px; line-height: 40px; } a { text-decoration: none; color: black; font-size: 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt; &lt;a href=\"${pageContext.request.contextPath}/book/findAll\"&gt;查找所有书籍&lt;/a&gt; &lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 3、书籍列表页面 findAllBook.jsp &lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;%-- User: win10 Date: 2020/6/24 Time: 16:52 --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;书籍列表&lt;/title&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 column\"&gt; &lt;a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/book/toAddBook\"&gt;新增书籍&lt;/a&gt; &lt;a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/book/findAll\"&gt;查询所有书籍&lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-md-8 column\"&gt; &lt;form action=\"${pageContext.request.contextPath}/book/queryBookByName\" method=\"post\" style=\"float: right\" class=\"form-inline\"&gt; &lt;span style=\"color: red;font-weight: bold\" &gt;${msg}&lt;/span&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" name=\"bookName\" placeholder=\"输入书籍名称查询\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;table class=\"table table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;/th&gt; &lt;th&gt;书籍名字&lt;/th&gt; &lt;th&gt;书籍数量&lt;/th&gt; &lt;th&gt;书籍详情&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach var=\"book\" items=\"${booksList}\"&gt; &lt;tr&gt; &lt;th&gt;${book.bookId}&lt;/th&gt; &lt;th&gt;${book.bookName}&lt;/th&gt; &lt;th&gt;${book.bookCounts}&lt;/th&gt; &lt;th&gt;${book.detail}&lt;/th&gt; &lt;th&gt;&lt;a href=\"${pageContext.request.contextPath}/book/toUpdatePage?bookId=${book.bookId}\"&gt;修改&lt;/a&gt; | &lt;a href=\"${pageContext.request.contextPath}/book/deleteBook/${book.bookId}\"&gt;删除&lt;/a&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 4、BookController 类编写 ， 方法二：添加书籍 @RequestMapping(\"/toAddBook\") public String toAddBookPage() { return \"addBook\"; } @RequestMapping(\"/addBook\") public String addBook(Books book) { System.out.println(\"------addBook------\"); System.out.println(book); bookservice.addBook(book); return \"redirect:/book/findAll\"; } 5、添加书籍页面：addBook.jsp &lt;%-- User: win10 Date: 2020/6/24 Time: 22:33 --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;添加书籍&lt;/title&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;增加书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=\"/book/addBook\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍名称：&lt;/label&gt; &lt;input type=\"text\" name=\"bookName\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍数量：&lt;/label&gt; &lt;input type=\"text\" name=\"bookCounts\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍详情：&lt;/label&gt; &lt;input type=\"text\" name=\"detail\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"submit\" value=\"添加\" class=\"form-control\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 6、BookController 类编写 ， 方法三：修改书籍 @RequestMapping(\"/toUpdatePage\") public String toUpdatePage(int bookId, Model model) { Books book = bookservice.findBookById(bookId); model.addAttribute(\"QBook\", book); return \"updateBook\"; } @RequestMapping(\"/updateBook\") public String updateBook(Books book) { System.out.println(\"updatebook=&gt;\" + book); int i = bookservice.updateBook(book); if (i &gt; 0) { System.out.println(\"updateBook 成功\" + book); } return \"redirect:/book/findAll\"; } 7、修改书籍页面 updateBook.jsp &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; &lt;%-- User: win10 Date: 2020/6/25 Time: 9:22 --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;修改书籍&lt;/title&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;修改书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=\"${pageContext.request.contextPath}/book/updateBook\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"bookId\" value=\"${QBook.bookId}\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍名称：&lt;/label&gt; &lt;input type=\"text\" name=\"bookName\" class=\"form-control\" required value=\"${QBook.bookName}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍数量：&lt;/label&gt; &lt;input type=\"text\" name=\"bookCounts\" class=\"form-control\" required value=\"${QBook.bookCounts}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍详情：&lt;/label&gt; &lt;input type=\"text\" name=\"detail\" class=\"form-control\" required value=\"${QBook.detail}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"submit\" value=\"修改\" class=\"form-control\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 8、BookController 类编写 ， 方法四：删除书籍 @RequestMapping(\"/deleteBook/{bookId}\") public String deleteBook(@PathVariable(\"bookId\") int bookId) { bookservice.deleteBook(bookId); return \"redirect:/book/findAll\"; } 9、BookController 类编写 ， 方法五：按书籍名称查询书籍（mapper 和 service 层都要进行添加方法） @RequestMapping(\"/queryBookByName\") public String queryBookByName(String bookName, Model model) { Books book = bookservice.queryBookByName(bookName); System.err.println(book); List&lt;Books&gt; list = new ArrayList&lt;Books&gt;(); list.add(book); if (book == null) { list = bookservice.findAllBook(); model.addAttribute(\"msg\", \"未找到匹配书籍\"); } model.addAttribute(\"booksList\", list); return \"findAllBook\"; } 配置Tomcat，进行运行！ 到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，大家需要保证，不看任何东西，自己也可以完整的实现出来！ 项目结构图","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"ElasticSearch概述","slug":"ElasticSearch","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:21:24.385Z","comments":true,"path":"posts/ea4e9759.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9759.html","excerpt":"","text":"ElasticSearch概述Lucene 和 ElasticSearch 关系： ElasticSearch 是基于 Lucene 做了一些封装和增强 Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别（大数据时代）的数据。es也使用 Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。 使用 维基百科，类似百度百科，全文检索，高亮，搜索推荐/2 （权重，百度！） The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜） Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和 回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案 GitHub（开源代码管理），搜索上千亿行代码 电商网站，检索商品 日志数据分析，logstash采集日志，ES进行复杂的数据分析，ELK技术（ elasticsearch+logstash+kibana） 商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如 说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买。 BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近 3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，**区，最近3年，每年消费 金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘， Kibana进行数据可视化 国内：站内搜索（电商，招聘，门户，等等），IT系统搜索（OA，CRM，ERP，等等），数据分析 （ES热门 的一个使用场景） ES和Solr的差别Elasticsearch简介Elasticsearch是一个实时分布式搜索和分析引擎。它让你以前所未有的速度处理大数据成为可能。它用于全文搜索、结构化搜索、分析以及将这三者混合使用：维基百科使用Elasticsearch提供全文搜索并高亮关键字，以及输入实时搜索(search-asyou-type)和搜索纠错(did-you-mean)等搜索建议功能。英国卫报使用Elasticsearch结合用户日志和社交网络数据提供给他们的编辑以实时的反馈，以便及时了解公众对新发表的文章的回应。StackOverflow结合全文搜索与地理位置查询，以及more-like-this功能来找到相关的问题和答案。Github使用Elasticsearch检索1300亿行的代码。 但是Elasticsearch不仅用于大型企业，它还让像DataDog以及Klout这样的创业公司将最初的想法变成可扩展的解决方案。Elasticsearch可以在你的笔记本上运行，也可以在数以百计的服务器上处理PB级别的数据 。 Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。 但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 Solr简介Solr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化 Solr可以独立运行，运行在Jetty、Tomcat等这些Servlet容器中，Solr 索引的实现方法很简单，用 POST方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。Solr不提供构建UI的功能，Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。 solr是基于lucene开发企业级搜索服务器，实际上就是封装了lucene。 Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的文件，生成索引；也可以通过提出查找请求，并得到返回结果。 Lucene简介Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具 包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引 引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单 易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索 引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提 供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。人们 经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。 Lucene是一个全文检索引擎的架构。那什么是全文搜索引擎？ 全文搜索引擎是名副其实的搜索引擎，国外具代表性的有Google、Fast/AllTheWeb、AltaVista、 Inktomi、Teoma、WiseNut等，国内著名的有百度（Baidu）。它们都是通过从互联网上提取的各个网 站的信息（以网页文字为主）而建立的数据库中，检索与用户查询条件匹配的相关记录，然后按一定的 排列顺序将结果返回给用户，因此他们是真正的搜索引擎。 从搜索结果来源的角度，全文搜索引擎又可细分为两种，一种是拥有自己的检索程序（Indexer），俗称 “蜘蛛”（Spider）程序或“机器人”（Robot）程序，并自建网页数据库，搜索结果直接从自身的数据库中 调用，如上面提到的7家引擎；另一种则是租用其他引擎的数据库，并按自定的格式排列搜索结果，如 Lycos引擎。 Elasticsearch和Solr比较 比较总结 1、es基本是开箱即用（解压就可以用 ! ），非常简单。Solr安装略微复杂一丢丢！ 2、Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。 3、Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持 json文件格式。 4、Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提 供，例如图形化界面需要kibana友好支撑~! 5、Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用； ES建立索引快（即查询慢），即实时性查询快，用于facebook新浪等搜索。 Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。 6、Solr比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而 Elasticsearch相对开发维护者较少，更新太快，学习使用成本较高。（趋势！） ElasticSearch安装声明：JDK1.8 ，最低要求！ ElasticSearch 客户端，界面工具！ Java开发，ElasticSearch 的版本和我们之后对应的 Java 的核心jar包！ 版本对应！JDK 环境是正常！ 下载 官网：https://www.elastic.co/ 下载地址：https://www.elastic.co/cn/downloads/elasticsearch window 下安装！ 解压就可以使用了！ 熟悉目录！ bin 启动文件 config 配置文件 log4j2 日志配置文件 jvm.options java 虚拟机相关的配置 elasticsearch.yml elasticsearch 的配置文件！ 默认 9200 端口！ 跨域！ lib 相关jar包 logs 日志！ modules 功能模块 plugins 插件！ 启动，访问9200； 启动不起来在elasticsearch.yml末尾添加 xpack.ml.enabled: false 访问测试！ 安装可视化界面 es head的插件 需要node.js环境 下载地址：https://github.com/mobz/elasticsearch-head/ 启动 npm install npm run start 连接测试发现，存在跨域问题：配置 es 的 yml 配置文件 http.cors.enabled: true http.cors.allow-origin: \"*\" 重启es服务器，然后再次连接 初学，就把es当做一个数据库！ （可以建立索引（库），文档（库中的数据！）） 这个head我们就把它当做数据展示工具！我们后面所有的查询，Kibana！ 了解 ELK ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。市面上也被成为ElasticStack。其中Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为 es。Logstash是ELK的中央数据流引擎，用于从不同目标（文件/数据存储/MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件/MQ/redis/elasticsearch/kafka等）。Kibana可以将Elasticsearch 的数据通过友好的页面展示出来，提供实时分析的功能。 市面上很多开发只要提到ELK能够一致说出它是一个日志分析架构技术栈总称，但实际上ELK不仅仅适用于日志分析，它还可以支持其它任何数据分析和收集的场景，日志分析和收集只是更具有代表性。并非唯一性。 安装Kibana Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测 官网：https://www.elastic.co/cn/kibana Kibana 版本要和 Es 一致！ 启动测试： 解压后端的目录 启动 访问测试 开发工具！ （Post、curl、head、谷歌浏览器插件测试！） 汉化！自己修改kibana配置即可！ zh-CN！ kibaba.yml文件末尾添加 i18n.locale: \"zn-CH\" ES核心概念 索引 字段类型（mapping） 文档（documents） 概述 在前面的学习中，我们已经掌握了es是什么，同时也把es的服务已经安装启动，那么es是如何去存储数据，数据结构是什么，又是如何实现搜索的呢？我们先来聊聊ElasticSearch的相关概念吧！ 集群，节点，索引，类型，文档，分片，映射是什么？ elasticsearch是面向文档，关系型数据库 和 elasticsearch 客观的对比！一切都是JSON！ Relational DB Elasticsearch 数据库(database) 索引(indices) 表(tables) types 行(rows) documents 字段(columns) fields elasticsearch(集群)中可以包含多个索引(数据库)，每个索引中可以包含多个类型(表)，每个类型下又包含多个文档(行)，每个文档中又包含多个字段(列)。 物理设计： elasticsearch 在后台把每个索引划分成多个分片，每个分片可以在集群中的不同服务器间迁移 一个人就是一个集群！默认的集群名称就是 elaticsearh 逻辑设计： 一个索引类型中，包含多个文档，比如说文档1，文档2。 当我们索引一篇文档时，可以通过这样的顺序找到 它: 索引 ▷ 类型 ▷ 文档ID ，通过这个组合我们就能索引到某个具体的文档。 注意:ID不必是整数，实际上它是个字符串。 文档 就是我们的一条条数据 user 1 zhangsan 18 2 kuangshen 3 之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch中，文档有几个 重要属性 : 自我包含，一篇文档同时包含字段和对应的值，也就是同时包含 key:value！ 可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的！ {就是一个json对象！fastjson进行自动转换！} 灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。 尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型。 类型 类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。 类型中对于字段的定义称为映射，比如 name 映射为字符串类型。 我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch会认为它是整形。 但是elasticsearch也可能猜不对， 所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别整什么幺蛾子。 索引 就是数据库！ 索引是映射类型的容器，elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。 然后它们被存储到了各个分片上了。 我们来研究下分片是如何工作的。 物理设计 ：节点和分片 如何工作 一个集群至少有一个节点，而一个节点就是一个elasricsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片 ( primary shard ,又称主分片 ) 构成的，每一个主分片会有一个副本 ( replica shard ,又称复制分片 ) 上图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内，这样有利于某个节点挂掉 了，数据也不至于丢失。 实际上，一个分片是一个Lucene索引，一个包含倒排索引的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。 不过倒排索引是什么? 倒排索引 elasticsearch使用的是一种称为倒排索引的结构，采用Lucene倒排索作为底层。这种结构适用于快速的全文搜索， 一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。 例如，现在有两个文档， 每个文档包含如下内容： Study every day, good good up to forever # 文档1包含的内容 To forever, study every day, good good up # 文档2包含的内容 为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens)，然后创建一个包含所有不重复的词条的排序列表，然后列出每个词条出现在哪个文档 : term doc_1 doc_2 Study √ x To x x every √ √ forever √ √ day √ √ study x √ good √ √ every √ √ to √ x up √ √ 现在，我们试图搜索 to forever，只需要查看包含每个词条的文档 score term doc_1 doc_2 to √ × forever √ √ total 2 1 两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，现在，这两个包含关键字的文档都将返回。 再来看一个示例，比如我们通过博客标签来搜索博客文章。那么倒排索引列表就是这样的一个结构 : 如果要搜索含有 python 标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要 查看标签这一栏，然后获取相关的文章ID即可。完全过滤掉无关的所有数据，提高效率！ elasticsearch的索引和Lucene的索引对比 在elasticsearch中， 索引 （库）这个词被频繁使用，这就是术语的使用。 在elasticsearch中，索引被分为多个分片，每份分片是一个Lucene的索引。所以一个elasticsearch索引是由多个Lucene索引组成的。别问为什么，谁让elasticsearch使用Lucene作为底层呢! 如无特指，说起索引都是指elasticsearch的索引。 IK分词器插件 什么是IK分词器？ 分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，比如 “我爱狂神” 会被分为”我”,”爱”,”狂”,”神”，这显然是不符合要求的，所以我们需要安装中文分词器ik来解决这个问题。 如果要使用中文，建议使用ik分词器！ IK提供了两个分词算法：ik_smart 和 ik_max_word，其中 ik_smart 为最少切分，ik_max_word为最细粒度划分！ 安装 https://github.com/medcl/elasticsearch-analysis-ik 下载完毕之后，放入到我们的elasticsearch 插件即可！ 重启观察ES，可以看到ik分词器被加载了！ elasticsearch-plugin 可以通过这个命令来查看加载进来的插件 使用kibana测试！ 查看不同的分词效果 其中 ik_smart 为最少切分 ik_max_word为最细粒度划分！穷尽词库的可能！字典！ 我们输入 超级喜欢狂神说Java 发现问题：狂神说被拆开了！ 这种自己需要的词，需要自己加到我们的分词器的字典中！ ik 分词器增加自己的配置！ 重启es，看细节！ 再次测试一下狂神说，看下效果！ Rest风格说明一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 基本Rest命令说明： method url地址 描述 PUT localhost:9200/索引名称/类型名称/文档id 创建文档（指定文档id） POST localhost:9200/索引名称/类型名称 创建文档（随机文档id） POST localhost:9200/索引名称/类型名称/文档id/_update 修改文档 DELETE localhost:9200/索引名称/类型名称/文档id 删除文档 GET localhost:9200/索引名称/类型名称/文档id 查询文档通过文档id POST localhost:9200/索引名称/类型名称/_search 查询所有数据 关于索引的基本操作创建一个索引PUT /索引名/~类型名~/文档id { 请求体 } 完成了自动增加了索引！数据也成功的添加了，这就是我说大家在初期可以把它当做数据库学习的原因！ 那么 name 这个字段用不用指定类型呢。毕竟我们关系型数据库 是需要指定类型的啊 ! 字符串类型 text 、 keyword 数值类型 long, integer, short, byte, double, float, half_float, scaled_float 日期类型 date 布尔值类型 boolean 二进制类型 binary 等等….. 指定字段的类型 获得这个规则！ 可以通过 GET 请求获取具体的信息！ 查看默认的信息 如果自己的文档字段没有指定，那么es 就会给我们默认配置字段类型！ 扩展： 通过命令 elasticsearch 索引情况！ 通过GET _cat/ 可以获得es的当前的很多信息！ 修改索引曾经是用PUT，如果字段写不全（少写字段就会被丢弃）也就是覆盖原来的数据！ 现在的方法用POST，相应请求后面要加 _update ，只会更新提交的字段！ 删除索引通过DELETE 命令实现删除、 根据你的请求来判断是删除索引还是删除文档记录！ 使用RESTFUL 风格是ES推荐大家使用的！ 关于文档的基本操作（重点）基本操作添加数据PUT /kuangshen/user/1 { \"name\": \"狂神说\", \"age\": 23, \"desc\": \"一顿操作猛如虎，一看工资2500\", \"tags\": [\"技术宅\",\"温暖\",\"直男\"] } 获取数据 GET 更新数据 PUT Post _update , 推荐使用这种更新方式！ 使用 POST 后面没有加 _update 其他没有被提交的字段会被置空，然后新添加了doc.name字段 使用 POST 后面加 _update 提交的字段值被更新了，没有被提交的字段还是原来的值 简单地搜索GET kuangshen/user/1 简答的条件查询，可以根据默认的映射规则，产生基本的查询！ 复杂操作搜索select ( 排序，分页，高亮，模糊查询，精准查询！) 输出结果，不想要那么多！ 我们之后使用Java操作es ，所有的方法和对象就是这里面的 key！ 排序！ 分页查询！ 数据下标还是从0开始的，和学的所有数据结构是一样的！ /search/{current}/{pagesize} 布尔值查询 must （and），所有的条件都要符合 where id = 1 and name = xxx should（or），所有的条件都要符合 where id = 1 or name = xxx must_not （not） 过滤器 filter gt 大于 gte 大于等于 lt 小于 lte 小于等于！ 匹配多个条件！ 精确查询！ term 查询是直接通过倒排索引指定的词条进程精确查找的！ 关于分词： term ，直接查询精确的 match，会使用分词器解析！（先分析文档，然后在通过分析的文档进行查询！） 两个类型 text keyword (text类型的会被分词，keyword类型的不会被分词) 多个值匹配精确查询 高亮查询！ 集成SpringBoot 找官方文档！ 找到原生的依赖 &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.6.2&lt;/version&gt; &lt;/dependency&gt; 找对象 分析这个类中的方法即可！ 配置基本的项目 问题：一定要保证 我们的导入的依赖和我们的 es 版本一致 源码中提供对象！ 虽然这里导入3个类，静态内部类，核心类就一个！ /** * Elasticsearch rest client infrastructure configurations. * * @author Brian Clozel * @author Stephane Nicoll */ class RestClientConfigurations { @Configuration(proxyBeanMethods = false) static class RestClientBuilderConfiguration { // RestClientBuilder @Bean @ConditionalOnMissingBean RestClientBuilder elasticsearchRestClientBuilder(RestClientProperties properties, ObjectProvider&lt;RestClientBuilderCustomizer&gt; builderCustomizers) { HttpHost[] hosts = properties.getUris().stream().map(HttpHost::create).toArray(HttpHost[]::new); RestClientBuilder builder = RestClient.builder(hosts); PropertyMapper map = PropertyMapper.get(); map.from(properties::getUsername).whenHasText().to((username) -&gt; { CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); Credentials credentials = new UsernamePasswordCredentials(properties.getUsername(), properties.getPassword()); credentialsProvider.setCredentials(AuthScope.ANY, credentials); builder.setHttpClientConfigCallback( (httpClientBuilder) -&gt; httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider)); }); builder.setRequestConfigCallback((requestConfigBuilder) -&gt; { map.from(properties::getConnectionTimeout).whenNonNull().asInt(Duration::toMill is) .to(requestConfigBuilder::setConnectTimeout); map.from(properties::getReadTimeout).whenNonNull().asInt(Duration::toMillis) .to(requestConfigBuilder::setSocketTimeout); return requestConfigBuilder; }); builderCustomizers.orderedStream().forEach((customizer) -&gt; customizer.customize(builder)); return builder; } } @Configuration(proxyBeanMethods = false) @ConditionalOnClass(RestHighLevelClient.class) static class RestHighLevelClientConfiguration { // RestHighLevelClient 高级客户端，也是我们这里要讲，后面项目会用到的客户端 @Bean @ConditionalOnMissingBean RestHighLevelClient elasticsearchRestHighLevelClient(RestClientBuilder restClientBuilder) { return new RestHighLevelClient(restClientBuilder); } @Bean @ConditionalOnMissingBean RestClient elasticsearchRestClient(RestClientBuilder builder, ObjectProvider&lt;RestHighLevelClient&gt; restHighLevelClient) { RestHighLevelClient client = restHighLevelClient.getIfUnique(); if (client != null) { return client.getLowLevelClient(); } return builder.build(); } } @Configuration(proxyBeanMethods = false) static class RestClientFallbackConfiguration { // RestClient 普通的客户端！ @Bean @ConditionalOnMissingBean RestClient elasticsearchRestClient(RestClientBuilder builder) { return builder.build(); } } } 具体的Api测试！ 创建索引 判断索引是否存在 删除索引 创建文档 crud文档！ 配置类 @Configuration public class RestHighLevelClientConfiguration { @Bean public RestHighLevelClient restHighLevelClient() { RestHighLevelClient client = new RestHighLevelClient( RestClient.builder( new HttpHost(\"localhost\", 9200, \"http\"))); return client; } } 测试类 @SpringBootTest class KuangshenEsApiApplicationTests { // 面向对象来操作 @Autowired @Qualifier(\"restHighLevelClient\") private RestHighLevelClient client; // 测试索引的创建 Request PUT kuang_index @Test void testCreateIndex() throws IOException { // 1、创建索引请求 CreateIndexRequest request = new CreateIndexRequest(\"kuang_index\"); // 2、客户端执行请求 IndicesClient,请求后获得响应 CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT); System.out.println(createIndexResponse); } // 测试获取索引,判断其是否存在 @Test void testExistIndex() throws IOException { GetIndexRequest request = new GetIndexRequest(\"kuang_index2\"); boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); System.out.println(exists); } // 测试删除索引 @Test void testDeleteIndex() throws IOException { DeleteIndexRequest request = new DeleteIndexRequest(\"kuang_index\"); // 删除 AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT); System.out.println(delete.isAcknowledged()); } // 测试添加文档 @Test void testAddDocument() throws IOException { // 创建对象 User user = new User(\"狂神说\", 3); // 创建请求 IndexRequest request = new IndexRequest(\"kuang_index\"); // 规则 put /kuang_index/_doc/1 request.id(\"1\"); request.timeout(TimeValue.timeValueSeconds(1)); request.timeout(\"1s\"); // 将我们的数据放入请求 json request.source(JSON.toJSONString(user), XContentType.JSON); // 客户端发送请求 , 获取响应的结果 IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT); System.out.println(indexResponse.toString()); // System.out.println(indexResponse.status()); // 对应我们命令返回的状态CREATED } // 获取文档，判断是否存在 get /index/doc/1 @Test void testIsExists() throws IOException { GetRequest getRequest = new GetRequest(\"kuang_index\", \"1\"); // 不获取返回的 _source 的上下文了 getRequest.fetchSourceContext(new FetchSourceContext(false)); getRequest.storedFields(\"_none_\"); boolean exists = client.exists(getRequest, RequestOptions.DEFAULT); System.out.println(exists); } // 获得文档的信息 @Test void testGetDocument() throws IOException { GetRequest getRequest = new GetRequest(\"kuang_index\", \"1\"); GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT); System.out.println(getResponse.getSourceAsString()); // 打印文档的内容 System.out.println(getResponse); // 返回的全部内容和命令式一样的 } // 更新文档的信息 @Test void testUpdateRequest() throws IOException { UpdateRequest updateRequest = new UpdateRequest(\"kuang_index\",\"1\"); updateRequest.timeout(\"1s\"); User user = new User(\"狂神说Java\", 18); updateRequest.doc(JSON.toJSONString(user),XContentType.JSON); UpdateResponse updateResponse = client.update(updateRequest, RequestOptions.DEFAULT); System.out.println(updateResponse.status()); } // 删除文档记录 @Test void testDeleteRequest() throws IOException { DeleteRequest request = new DeleteRequest(\"kuang_index\",\"1\"); request.timeout(\"1s\"); DeleteResponse deleteResponse = client.delete(request, RequestOptions.DEFAULT); System.out.println(deleteResponse.status()); } // 特殊的，真的项目一般都会批量插入数据！ @Test void testBulkRequest() throws IOException { BulkRequest bulkRequest = new BulkRequest(); bulkRequest.timeout(\"10s\"); ArrayList&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(\"kuangshen1\",3)); userList.add(new User(\"kuangshen2\",3)); userList.add(new User(\"kuangshen3\",3)); userList.add(new User(\"qinjiang1\",3)); userList.add(new User(\"qinjiang1\",3)); userList.add(new User(\"qinjiang1\",3)); // 批处理请求 for (int i = 0; i &lt; userList.size() ; i++) { // 批量更新和批量删除，就在这里修改对应的请求就可以了 bulkRequest.add( new IndexRequest(\"kuang_index\") .id(\"\"+(i+1)) .source(JSON.toJSONString(userList.get(i)),XContentType.JSON)); } BulkResponse bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT); System.out.println(bulkResponse.hasFailures()); // 是否失败，返回 false 代表成功！ } // 查询 // SearchRequest 搜索请求 // SearchSourceBuilder 条件构造 // HighlightBuilder 构建高亮 // TermQueryBuilder 精确查询 // MatchAllQueryBuilder // xxx QueryBuilder 对应我们刚才看到的命令！ @Test void testSearch() throws IOException { SearchRequest searchRequest = new SearchRequest(\"kuang_index\"); // 构建搜索条件 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); sourceBuilder.highlighter() // 查询条件，我们可以使用 QueryBuilders 工具来实现 // QueryBuilders.termQuery 精确 // QueryBuilders.matchAllQuery() 匹配所有 TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(\"name\", \"qinjiang1\"); // MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery(); sourceBuilder.query(termQueryBuilder); sourceBuilder.timeout(new TimeValue(60,TimeUnit.SECONDS)); searchRequest.source(sourceBuilder); SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT); System.out.println(JSON.toJSONString(searchResponse.getHits())); System.out.println(\"=================================\"); for (SearchHit documentFields : searchResponse.getHits().getHits()) { System.out.println(documentFields.getSourceAsMap()); } } } 爬虫1、导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.11.2&lt;/version&gt; &lt;/dependency&gt; 2、编写工具类 package com.xu.utils; import com.xu.pojo.Content; import org.jsoup.Jsoup; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element; import org.jsoup.select.Elements; import org.springframework.stereotype.Component; import java.net.URL; import java.util.ArrayList; @Component public class JsoupUtils { public static void main(String[] args) throws Exception { new JsoupUtils().getContent(\"心理学\").forEach(System.out::println); } public ArrayList&lt;Content&gt; getContent(String keyword) throws Exception{ //请求url https://search.jd.com/Search?keyword=java String url = \"https://search.jd.com/Search?keyword=\"+keyword+\"&amp;enc=utf-8\"; //返回的就是浏览器document对象 Document document = Jsoup.parse(new URL(url), 30000); //获取一个大的div Element element = document.getElementById(\"J_goodsList\"); //获取div里的所有li Elements elements = element.getElementsByTag(\"li\"); // System.out.println(elements.html()); ArrayList&lt;Content&gt; list = new ArrayList&lt;&gt;(); for (Element el : elements) { String img = el.getElementsByTag(\"img\").get(0).attr(\"data-lazy-img\"); String price = el.getElementsByClass(\"p-price\").get(0).text(); String title = el.getElementsByClass(\"p-name\").get(0).text(); Content content = new Content(title, price, img); list.add(content); } return list; } } 3、业务编写 package com.xu.service; import com.alibaba.fastjson.JSON; import com.xu.pojo.Content; import com.xu.utils.JsoupUtils; import org.elasticsearch.action.bulk.BulkRequest; import org.elasticsearch.action.bulk.BulkResponse; import org.elasticsearch.action.index.IndexRequest; import org.elasticsearch.action.search.SearchRequest; import org.elasticsearch.action.search.SearchResponse; import org.elasticsearch.client.RequestOptions; import org.elasticsearch.client.RestHighLevelClient; import org.elasticsearch.common.text.Text; import org.elasticsearch.common.unit.TimeValue; import org.elasticsearch.common.xcontent.XContentType; import org.elasticsearch.index.query.QueryBuilders; import org.elasticsearch.index.query.TermQueryBuilder; import org.elasticsearch.search.SearchHit; import org.elasticsearch.search.builder.SearchSourceBuilder; import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder; import org.elasticsearch.search.fetch.subphase.highlight.HighlightField; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.concurrent.TimeUnit; //业务编写 @Service public class ContentService { @Autowired private RestHighLevelClient restHighLevelClient; //解析数据放入 es 索引中 public boolean parseContent(String keyword) throws Exception { ArrayList&lt;Content&gt; contents = new JsoupUtils().getContent(keyword); //把查询的数据放入es中 BulkRequest bulkRequest = new BulkRequest(); bulkRequest.timeout(new TimeValue(60, TimeUnit.SECONDS)); for (int i = 0; i &lt; contents.size(); i++) { bulkRequest.add(new IndexRequest(\"jd_index\").source(JSON.toJSONString(contents.get(i)), XContentType.JSON)); } BulkResponse bulkResponse = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT); return !bulkResponse.hasFailures(); } //获取es里数据实现，实现搜索功能 public List&lt;Map&lt;String, Object&gt;&gt; searchPage(String keyword, int pageNo, int pageSize) throws IOException { if (pageNo&lt;=0){ pageNo = 1; } //条件搜索 SearchRequest searchRequest = new SearchRequest(\"jd_index\"); SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //分页 sourceBuilder.from((pageNo - 1) * pageSize); sourceBuilder.size(pageSize); //精确查找 TermQueryBuilder termQuery = QueryBuilders.termQuery(\"title\", keyword); sourceBuilder.query(termQuery); sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); //高亮 HighlightBuilder highlightBuilder = new HighlightBuilder(); highlightBuilder.field(\"title\"); highlightBuilder.requireFieldMatch(false);//false 多个高亮开启 默认就是false highlightBuilder.preTags(\"&lt;span style='color:red'&gt;\"); highlightBuilder.postTags(\"&lt;/span&gt;\"); sourceBuilder.highlighter(highlightBuilder); //执行搜索 searchRequest.source(sourceBuilder); SearchResponse response = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT); //解析结果 ArrayList&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;(); for (SearchHit hit : response.getHits().getHits()) { Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields(); HighlightField title = highlightFields.get(\"title\"); Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();//原来的数据 //解析高亮字段,将原来的字段换为高亮字段 if (title != null) { Text[] texts = title.getFragments(); String newTitle = \"\"; for (Text text : texts) { newTitle += text; } sourceAsMap.put(\"title\", newTitle); } list.add(sourceAsMap); } return list; } }","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:22:51.111Z","comments":true,"path":"posts/ea4e9725.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9725.html","excerpt":"","text":"JavaScriptJavaScript 作者只用了10天就开出来 行为层（JavaScript）JavaScript是一门弱类型的脚本语言，其源代码在发往客户端之前不需要经过编译，而是将文本格式的字符代码发送给浏览器，由浏览器解释运行 Native 原生 JS 开发 原生 JS 开发，也就是让我们按照【ECMAScript】标准开发方式，简称 ES ，特点是所有浏览器都支持。 TypeScript 微软标准 TypeScript 是一种由微软开发和开源的编程语言，他是JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。 UI框架 Ant-Design：阿里出品，基于React的UI框架 ElementUI. iview、ice：饿了么出品，基于Vue的UI框架 BootStrap：Twitter推出的一个用于前端开发的开源工具包 AmazeUI：又叫”妹子UI“，一款HTML5跨屏的前端框架 JavaScript 构建工具 Babel：JS编译工具，主要用于浏览器不支持的ES新特性 WebPack：模块打包器，主要作用是打包、压缩、合并和按序加载 1、什么是JavaScript1.1、概述JavaScript是一门世界上最流行的脚本语言 一个合格的后端人员，必须要精通javaScript 1.2、历史ECMAScript可以理解为是JavaScript的一个标准。 最新版本已经到了ES6版本 但是大部分浏览器还只停留在支持ES5代码上 开发环境–先上环境，版本不一致 2、快速入门2.1、引入JavaScriptscript标签内不用显示定义type，也默认就是JavaScript 2.1.1、内部标签&lt;script&gt; alert('hello world'); &lt;/script&gt; 2.1.2、外部引入abs.js alert('hello world'); test.html &lt;!--注意script必须成对出现--&gt; &lt;script src=\"abc.js\"&gt;&lt;/script&gt; 测试代码 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--script标签内写JavaScript代码--&gt; &lt;!--&lt;script&gt;--&gt; &lt;!-- alert('hello world');--&gt; &lt;!--&lt;/script&gt;--&gt; &lt;!--外部引入--&gt; &lt;!--注意script必须成对出现，如果&lt;script&gt;标签中使用src属性，那么该标签中封装的 javascript代码不会被执行。--&gt; &lt;script src=\"js/qj.js\"&gt;&lt;/script&gt; &lt;!--不用显示定义type，也默认就是JavaScript--&gt; &lt;script type=\"javascript\"&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--这里也可以存放--&gt; &lt;/body&gt; &lt;/html&gt; 2.2、基本语法入门&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--javaScript严格区分大小写--&gt; &lt;script&gt; // 1.定义变量 var score=70; // 2.条件控制 if (score&gt;60&amp;&amp;score&lt;70){ alert(\"60~70\"); }else if(score&gt;70&amp;&amp;score&lt;80){ alert(\"70~80\") }else{ alert(\"other\"); } //console.log(score) 在浏览器的控制台打印变量，相当于System.out.println() /* * dasdasda */ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 浏览器必备调试须知： 2.3、数据类型数值、文本、图形、音频、视频… 变量 var 变量名='变量值'; 不能以数字开头！ number js不区分小数跟整数，统一用number 123 //整数 123.1 //浮点数 1.23e3 //科学技术法 -99 //负数 NaN //not a number Infinity //表示无限大 字符串 'abc' \"abc\" 布尔值 true false 算术运算符 + 、- 、* 、/ 、% 、++ 、-- 赋值运算符 = 、 += 、-= 、 *= 、 /= 、 %= 逻辑运算符 &amp;&amp; //两个都为真，结果为真 || //一个为真，结果为真 ! //真即假，假即真 比较运算符 &gt; 、&lt;、 &gt;=、 &lt;=、 != = //赋值 == //等于（类型不一样，值一样，也会判断为true） === //绝对等于（类型一样，值一样，结果为true） 这是一个js缺陷，坚持不要使用== 须知： NaN===NaN,这个与所有的数值都不相等，包括自己 只能通过isNaN(NaN)来判断这个数值是否为NaN 位运算符 &amp; 、 | 、 ^ 、 &gt;&gt; 、 &lt;&lt; 、 &gt;&gt;&gt; /* 左移几位就是该数据乘以2的几次方（左移运算符&lt;&lt;）（右移相反&gt;&gt;:除以，高位空缺的位高位是什么就补什么）； 无符号右移&gt;&gt;&gt;：数据进行右移时，高位出现空缺，无论高位是什么都补0。 */ 三元运算符 ? : 浮点数问题： console.log((1/3)===(1-2/3)); //输出 false 尽量避免使用浮点数进行计算，存在精度问题 console.log(Math.abs(1/3-(1-2/3))&lt;0.000000001); //输出 true null和undefined null 空 undefined 未定义，其实它就是一个常量。 var xx; alert(xx); // undefined alert(xx==undefined); //true 其他一些注意点 alert(\"12\"-1);//11 alert(\"12\"+1);//121 alert(true+1);//2 ，因为在js中false就是0，或者null，非0、非null就是true。默认用1表示。 alert(\"a=\"+a/1000*1000);//a=3710;进行除运算不会进行取整 数组 java的数组必须是一系列相同类型的对象，js中不需要这样 //保证代码的可读性，尽量使用[] var arr = [1, 2, 3, 4, 5, \"hello\", null, true]; new Array(1, 2, 3, 4, 5, \"hello\"); 取数组下标，如果越界了，就会undefined 对象 对象是{}，数组是[] 每个属性之间使用逗号隔开，最后一个不需要 var person={ name:'lisi', age:3, tags:['js','java','web'] } 取对象的值 2.4、严格检查模式 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--前提：IDEA需要设置支持使用ES6语法 'use strict';严格检查模式，预防JavaScript的随意性导致产生的一些问题，必须写在JavaScript的第一行 局部变量建议使用let定义 --&gt; &lt;script&gt; //严格检查模式 'use strict'; //全局变量 var i=1; //ES6 中局部变量使用let定义 let j=1; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 3、数据类型3.1、字符串 1、正常字符串使用单引号或者双引号包裹 2、注意转义字符 \\ \\' \\n \\t \\u4e2d \\u#### Unicode字符 \\x41 Ascll字符 3、多行字符串编写 //tab 上面的那个piao~ var msg=` helloworld 你好 你好呀 `; console.log(msg); 4、模板字符串 var name=\"lisi\"; var age=3; var msg=`你好，${name}`; console.log(msg); 5、字符串长度 str.length 6、字符串的可变性,不可变 7、大小写转换 //转大写，注意这里是方法，不是属性 str.toUpperCase(); //转小写 str.toLowerCase(); 8、输出指定字符的位置 str.indexOf(\"t\"); 9、substring从第x个字符截取到第y个字符，包含第一个，不包含最后一个 str.substring(x,y); 3.2、数组Array可以包含任意类型的数据 var arr=[1,2,3,4,5,6];//通过下标取值和赋值 arr[0]; arr[0]=1; 1、长度 arr.length; 注意：假如给arr.length赋值，数组大小就会发生变化，如果赋值过小，元素就会丢失 2、indexOf，通过元素获得下表索引 arr.indexOf(2); 字符串的1和数字1是不同的 3、slice() 截取Array的一部分，返回一个新的数组，类似于String中的subString 4、push()、pop() push:压入到尾部 pop:弹出尾部的一个元素 5、unshift()，shift() unshift:压入到头部 shift:弹出头部的一个元素 6、排序用sort() 7、元素反转 reverse() 8、concat() 注意：concat()并没有修改数组，只是返回了一个新的数组 9、连接符 join 打印拼接数组，使用特定的字符串连接 &gt;&gt; arr.join(\"-\"); &lt;- \"c-b-a\" 10、多维数组 &gt;&gt; arr=[[1,2],[3,4],[5,6]]; &gt;&gt; arr[1][1] &lt;- 4 数组：存储数据（如何存，如何取，方法都可以自己实现！） js中的数组定义的两种方式： // 1、直接定义 var arr = []; var arr = [3,1,5,8]; // 2、使用了javascript中的Array对象来完成的定义。 var arr = new Array(); //var arr = []; var arr1 = new Array(5); //数组定义并长度是5. var arr2 = new Array(5,6,7); //定义一个数组，元素是5,6,7 alert(typeof(arr));//对象类型是Object 3.3、对象若干个键值对 var 对象名 = { 属性名 : 属性值, .... , 属性名 : 属性值 }; //定义了一个person对象，他有四个属性 var person = { name: 'lisi', age: 3, email: '123456@qq.com', score: 0 }; js中的对象，{…}表示一个对象，键值对描述属性xxx:xxx，多个属性之间使用逗号隔开，最后一个属性不加逗号。 JavaScript中所有的键都是字符串，值是任意对象！ 1、对象赋值问题 &gt;&gt; person.name='wangwu'; &lt;- \"wangwu\" &gt;&gt; person &lt;- Object { name: \"wangwu\", age: 3, email: \"123456@qq.com\", score: 0 } 2、使用一个不存在的对象属性不会报错 undefined &gt;&gt; person.haha &lt;- undefined 3、动态的删减属性，通过delete来删除对象的属性 &gt;&gt; delete person.name &lt;- true &gt;&gt; person &lt;- Object { age: 3, email: \"123456@qq.com\", score: 0 } 4、动态的添加属性，直接给新的属性添加值即可 &gt;&gt; person.haha='hahah' &lt;- \"hahah\" &gt;&gt; person &lt;- Object { age: 3, email: \"123456@qq.com\", score: 0, haha: \"hahah\" } 5、判断属性值是否在这个对象中，xxx in xxx &gt;&gt; 'age' in person &lt;- true //继承 &gt;&gt; 'toString' in person &lt;- true 6、判断一个属性是否是自身拥有的 hasOwnProperty &gt;&gt; person.hasOwnProperty('toString'); &lt;- false &gt;&gt; person.hasOwnProperty('age'); &lt;- true 3.4、流程控制 if判断 let age=3; if(age&lt;=3){ alert('haha'); }else if(age&gt;3&amp;&amp;age&lt;5){ alert('kua'); }else{ alert('lili'); } 循环 while循环，尽量避免程序死循环 while(age&lt;100){ age=age+1; console.log(age); } do{ age=age+1; console.log(age); }while(age&lt;100) for循环 var age=[12,35,26,45,38]; for (let i=0;i&lt;age.length;i++){ console.log(age[i]); } for (let number of age) { console.log(number); } forEach循环 ES5.1引入的 var age=[12,35,26,45,38]; //函数 age.forEach(function (value) { console.log(value) }) for…in var age=[12,35,26,45,38]; //索引 for(let index in object){} for (let number in age) { console.log(age[number]); } 3.5、Map和Set ES6的新特性 Map: //SE6 //学生的成绩，学生的名字 let map=new Map([['tom',100],['jack',90],['haha',88]]); let name = map.get('tom');//通过key获得value map.set('admin',60); //新增或修改 map.delete('tom'); //删除 console.log(map); Set:无序不重复的集合 let set=new Set([3,1,1,1,1]);//set可以去重 set.add(2); //添加 set.delete(3); //删除 console.log(set.has(1));//判断是否包含 console.log(set); 3.6、iterator ES6的新特性 遍历迭代Map和Set 遍历数组 let arr=[9,6,7,2]; for (let number of arr) { console.log(number); } 遍历Map let map=new Map([['tom',100],['jack',90],['haha',88]]); for (let mapElement of map) { console.log(mapElement); } 遍历Set let set=new Set([3,1,1,2,6]);//set可以去重 for (let number of set) { console.log(number); } 4、函数及面向对象4.1、定义函数 定义方式一 绝对值函数 function abs(x){ if(x&gt;=0){ return x; }else{ return -x; } } 一旦执行return，代表函数结束，返回结果 如果没有执行return，函数执行完也会返回结果，结果为undefined。 定义方式二 var abs=function(x){ if(x&gt;=0){ return x; }else{ return -x; } } function(x){…}这是一个匿名函数，但是可以把结果赋值给abs，通过abs就可以调用 两种方法等价 调用函数 abs(10) //10 abs(-10) //10 var sum = getSum; //getSum本身是一个函数名，而函数本身在js中就是一个对象。getSum就是这个函数对象的引用.将getSum这个引用的地址赋值给sum。这时sum也指向了这个函数对象。相当于这个函数对象有两个函数名称。 参数问题： JavaScript可以传任意个参数，也可以不传参数 参数进来是否存在的问题？假设不存在参数，如何规避 var abs=function(x){ //手动抛出异常 if(typeof x!=='number'){ throw 'Not a number'; } if(x&gt;=0){ return x; }else{ return -x; } } arguments arguments是JS免费赠送的关键字 代表传进来的所有的参数是一个数组 var abs=function(x){ console.log(\"x==&gt;\",x); for (let i = 0; i &lt; arguments.length; i++) { console.log(arguments[i]); } if(x&gt;=0){ return x; }else{ return -x; } } 问题：arguments包含所有的参数，有时候想用多余的参数来进行附加操作，需要排除已有参数 rest 以前： if(arguments.length&gt;2){ for(let i=2;i&lt;arguments.length;i++){ //... } } ES6引入的新特性，获取除了已经定义的参数之外的所有参数 …rest function a(a,b,...rest){ console.log(\"a===&gt;\",a); console.log(\"b===&gt;\",b); console.log(rest); } rest参数只能写在最后面，必须用…标识 4.2、变量作用域在JavaScript中，var定义的变量实际是有作用域的 假设在函数体中声明，则在函数体外不可以使用（非要实现，可以使用闭包） `use strict`; function f() { var x=1; x=x+1; } x=x+2;//ReferenceError: x is not defined 如果两个函数使用了相同的变量名，只要在函数内部，不冲突 `use strict`; function f() { var x=1; x=x+1; } function f1() { var x=2; } 内部函数可以访问外部函数的成员，反之，则不行 function f() { var x=1; //内部函数可以访问外部函数的成员，反之，则不行 function f1() { var y=x+1; } var z=y+1;//ReferenceError: y is not defined } 假设内部函数变量和外部函数变量重名， function f() { var x=1; //内部函数可以访问外部函数的成员，反之，则不行 function f1() { var x='A'; console.log('inner==&gt;'+x);//inner==&gt;A } console.log('outer==&gt;'+x);//outer==&gt;1 f1(); } f(); 在JavaScript中，函数查找变量从自身函数开始，由“内”向“外”查找，假设外部存在这个同名的函数变量，则内部函数会屏蔽外部函数的变量。 提升变量的作用域 function f() { var x='x'+y; console.log(x); var y='y'; } 结果：xundefined 输出x和undefined拼接 说明js执行引擎自动提升了y的声明，不会提升y的赋值，等价于 function f2() { var y; var x='x'+y; console.log(x); y='y'; } 全局函数 //全局变量 x=1; function f() { console.log(x); } f(); console.log(x); 全局对象window var x='xxx'; alert(x); alert(window.x);//默认所有的全局变量都会自动绑定在window对象下 alert()这个函数本身也是一个window变量 var x='xxx'; window.alert(x); var old_alert=window.alert; //old_alert(x); window.alert=function () { }; //发现alert失效了 window.alert(123); //恢复 window.alert=old_alert; window.alert(456); JavaScript实际上只有一个全局作用域，任何变量（函数也可视为变量），假设没有在函数作用范围内找到，就会向外查找，如果在全局作用域都没有找到，就会报ReferenceError 规范 由于所有的全局变量都会绑定到Windows上，如果不同的js使用了相同的全局变量，冲突-&gt;如何减少冲突？ //唯一全局变量，用来装自己定义的全局变量 var Mapp={}; //定义全局变量 Mapp.name='lisi'; Mapp.add=function(a,b){ return a+b; } 把自己的代码全部放入自己定义的唯一空间名字中，降低全局命名冲突问题 局部作用域 let 使用var定义 function aaa() { for (var i = 0; i &lt; 100; i++) { console.log(i); } console.log(i+1);//i出了作用域还可以使用 } ES6使用let关键字，解决局部作用域冲突问题 function aaa() { for (let i = 0; i &lt; 100; i++) { console.log(i); } console.log(i+1);//ReferenceError: i is not defined } 建议大家都使用let去定义局部作用域的变量 ​ 常量const 在ES6之前定义常量：只要用全部大写字母命名的变量就是常量，建议不要修改这样的值 var PI=3.14; console.log(PI); PI='213';//可以改变这个值 console.log(PI); 在ES6引入了常量关键字const const PI=3.14;//只读变量 console.log(PI); PI=354;// TypeError: invalid assignment to const `PI' ，失败 4.3、方法 定义方法 方法就是把函数放在对象里面，队形只有两个东西：属性跟方法 var a = { name: 'lisi', birth: 2000, //方法 age: function () { //今年-出生年月 let year = new Date().getFullYear(); return year - this.birth; } } //属性 a.name //方法，一定要带（） a.age() this代表什么？拆开上面的代码看看 function getAge() { //今年-出生年月 let year = new Date().getFullYear(); return year - this.birth; } var a = { name: 'lisi', birth: 2000, //方法 age: getAge }; //a.age() ok //getAge() NaN window 这个this是无法指向的，默认指向调用他的那个对象 apply 在js中可以控制this的指向 function getAge() { //今年-出生年月 let year = new Date().getFullYear(); return year - this.birth; } var a2 = { name: 'lisi', birth: 2000, //方法 age: getAge }; getAge.apply(a2,[]);//this指向了a2这个对象，参数为空 想要获取谁就指向谁 5、内部对象 标准对象 &gt;&gt; typeof 123 &lt;- \"number\" &gt;&gt; typeof '123' &lt;- \"string\" &gt;&gt; typeof true &lt;- \"boolean\" &gt;&gt; typeof NaN &lt;- \"number\" &gt;&gt; typeof [] &lt;- \"object\" &gt;&gt; typeof {} &lt;- \"object\" &gt;&gt; typeof Math.abs &lt;- \"function\" &gt;&gt; typeof undefined &lt;- \"undefined\" 5.1、Date 基本使用 let date = new Date();//Date Tue Jun 09 2020 10:49:38 GMT+0800 (中国标准时间) console.log(date); date.getFullYear();//年 date.getMonth();//月 0-11 代表月 date.getDate();//日 date.getDay();//星期 date.getHours();//时 date.getMinutes();//分 date.getSeconds();//秒 date.getMilliseconds();//毫秒 date.getTime();//时间戳 全世界统一 1970.1.1 00:00:00 毫秒数 console.log(new Date(1591671532754));//时间戳转时间 转换 &gt;&gt; var now=new Date(1591671532754); &gt;&gt; console.log(now); &lt;- Date Tue Jun 09 2020 10:58:52 GMT+0800 (中国标准时间) &gt;&gt; now.toLocaleString()//注意调用是一个方法，不是属性 &lt;- \"2020/6/9 上午10:58:52\" &gt;&gt; now.toGMTString() &lt;- \"Tue, 09 Jun 2020 02:58:52 GMT\" 5.2、Math /* * 演示Math对象。该对象的中的方法都是静态的。不需要new，直接Math调用即 可。 */ var num1 = Math.ceil(12.34);//返回大于等于指定参数的最小整数。 var num2 = Math.floor(12.34);//返回小于等于指定数据的最大整数。 var num3 = Math.round(12.54);//四舍五入 var num4 = Math.pow(10,2); //平方 5.3、Json Json是什么 早期，所有的数据传输习惯使用xml文件 JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在JavaScript中，一切皆为对象，任何js支持的类型都可以用 JSON 来表示 格式： 对象都用 {} 数组都用 [] 所有的键值对都使用 key:value JSON 字符串和 JavaScript 对象的转换 var user={ name:'lisi', age:3, sex:'男' }; //对象转换为JSON let jsonUser = JSON.stringify(user);//{\"name\":\"lisi\",\"age\":3,\"sex\":\"男\"} //JSON字符串转换为对象,参数为JSON字符串 let object = JSON.parse(jsonUser);//Object { name: \"lisi\", age: 3, sex: \"男\" } 很多人搞不清楚，JSON 和 JS 对象的区别 var object={a:'hello',b:'hellob'}; var json='{\"a\":\"hello\",\"b\":\"hellob\"}'; 5.4、Ajax 原生的js写法：xhr 异步请求 jQuery封装好的方法 $(“#name”).ajax(“”) axios 请求 6、面向对象编程 原型对象 JavaScript、java、c#…面向对象；JavaScript有一些区别 类：模板 原型 对象：具体的实例 在JavaScript中，这个需要换一下思维方式 原型： var Student={ name:'lisi', age:3, sex:'男', run:function () { console.log(this.name+' run...'); } }; var xiaoming={ name:'xiaoming' }; //xiaoming的原型是Student xiaoming.__proto__=Student; var bird={ fly:function(){ console.log(this.name+' fly...'); } }; //xiaoming的原型是bird xiaoming.__proto__=bird; class 继承 以前： function student(name) { this.name=name; } //给student新增一个方法 student.prototype.hello=function () { alert('hello'); }; class关键字是在ES6引入的 1、定义一个类，属性，方法 //ES6之后 //定义一个类 class Student{ constructor(name) { this.name=name; } hello(){ alert('hello'); } } var xiaoming=new Student(\"小明\"); var xiaohong=new Student(\"小红\"); xiaoming.hello(); 2、继承 class Student{ constructor(name) { this.name=name; } hello(){ alert('hello'); } } class XiaoStudent extends Student{ constructor(name,grade) { super(name); this.grade=grade; } myGrade(){ alert('我是一个小学生'); } } var xiaoming=new Student(\"小明\"); var xiaohong=new XiaoStudent(\"小红\",1); 本质：查看对向原型 原型链 __ proto __: 7、操作Bom元素BOM：Browser Object Model（浏览器对象模型） 浏览器介绍 JavaScript和浏览器关系：JavaScript诞生就是为了让他在浏览器中运行 浏览器内核： IE 6-11 Chrome Safari FireFox 三方 QQ浏览器 360浏览器 7.1、window（重要） window代表浏览器窗口 &gt;&gt; window.innerHeight &lt;- 244 &gt;&gt; window.innerWidth &lt;- 1536 &gt;&gt; window.outerHeight &lt;- 848 &gt;&gt; window.outerWidth &lt;- 1550 //可以调整浏览器窗口大小试试 7.2、Navigator Navigator封装了浏览器的信息 &gt;&gt; navigator.appName &lt;- \"Netscape\" &gt;&gt; navigator.appVersion &lt;- \"5.0 (Windows)\" &gt;&gt; navigator.userAgent &lt;- \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0\" &gt;&gt; navigator.platform &lt;- \"Win32 大多数时候不会使用navigator对象，因为会被人为修改，建议使用这些属性来判断和编写代码 7.3、screen 代表屏幕的尺寸（像素px） &gt;&gt; screen.width &lt;- 1536 &gt;&gt; screen.height &lt;- 864 7.4、location（重要） 代表当前页面的URL信息 host: \"www.baidu.com\" //主机 href: \"https://www.baidu.com/\" //地址 protocol: \"https:\" //协议 reload: function reload() //重新加载 //设置新的地址 &gt;&gt; location.assign(\"https://www.csdn.net/\") 7.5、Document Document代表当前页面 HTML DOM文档树 &gt;&gt; document.title &lt;- \"百度一下，你就知道\" &gt;&gt; document.title=\"hahah\" &lt;- \"hahah\" 获取具体的文档树节点 &lt;dl id=\"app\"&gt; &lt;dt&gt;Java&lt;/dt&gt; &lt;dd&gt;JavaEE&lt;/dd&gt; &lt;dd&gt;JavaSE&lt;/dd&gt; &lt;/dl&gt; &lt;script&gt; let dl = document.getElementById('app'); console.log(dl); &lt;/script&gt; 获取cookie &gt;&gt; document.cookie &lt;- \"BAIDUID=4ABFE152F04D1B1C0AA7208BF816637D:FG=1; BIDUPSID=4ABFE152F04D1B1C0AA7208BF816637D; PSTM=1589766046; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; BD_HOME=1; H_PS_PSSID=31724_1461_31325_21082_31780_31271_30823_31848_22160; BD_UPN=13314752; ORIGIN=1; ISSW=1; ISSW=1\" 劫持cookie原理 &lt;script src=\"aaa.js\"&gt;&lt;/script&gt; &lt;!--恶意人员获取用户的cookie，上传到他的服务器--&gt; 服务器端可以设置cookie：httpOnly，防止 cookie 泄露 7.6、History（不建议使用） 代表浏览器的历史记录 history.forward();//前进 history.back();//后退 7.7、Window 对象的一些方法&lt;script type=\"text/javascript\"&gt; var timeid；//全局变量，如果写在某个方法的话别的方法就不能使用 function windowMethodDemo(){ var b = confirm(\"你真的确定要点击吗？\"); //这里的方法都省略了window. alert(\"b=\"+b); //上面confirm方法会弹出一个窗口，点击按钮会返回值 setTimeout(\"alert('time out run')\",4000); //设置多少毫秒弹出 timeid = setInterval(\"alert('interval run')\",3000); //返回的Integer对象clearInterval方法用，该方法的作用是每多少毫秒就弹出 } function stopTime(){ clearInterval(timeid); //取消setInterval方法的调用 } function windowMove(){ // moveBy(10,10); 窗口移动多少像素 // moveTo(40,40); 窗口移动到哪个坐标 for (var x = 0; x &lt; 700; x++){ //该代码段就是抖动窗口的功能 moveBy(20, 0); moveBy(0, 20); moveBy(-20,0); moveBy(0,-20); } } function windowOpen(){ open(\"ad.html\",\"_blank\",\"height=400,width=400,status（状态栏）=no,toolbar（工具栏）=no,menubar（菜单栏）=no,location（地址栏）=no\"); //第一个参数是打开的链接，第二个参数窗口target属性，第三个参数设置窗口的其他属性 // close(); 弹出窗口后关闭该窗口 } &lt;/script&gt; &lt;input type=\"button\" value=\"演示window对象的方法\" onclick=\"windowOpen()\"/&gt; &lt;input type=\"button\" value=\"停止\" onclick=\"stopTime()\"/&gt; 7.8、Window 对象的一些事件&lt;script type=\"text/javascript\"&gt; /* onunload = function(){ //窗口关闭后弹出 alert(\"onunload run\"); } onload = function(){ //窗口加载后弹出 alert(\"onload run\"); } onbeforeunload = function(){ //窗口关闭时弹出 alert(\"onbeforeunload run\"); } 已过时？ */ onload = function(){ window.status = \"啊！，加载完毕啦\"; //设置窗口加载后状态栏的信息 } &lt;/script&gt; 8、操作Dom对象（重点）DOM：Document Object Model（文档对象模型） DOM用来将标记型文档封装成对象，并将标记型文档中的所有的内容(标签，文本，属性等)都封装成对象。封装成对象的目的是为了更为方便的操作这些文档以及文档中的所有内容。因为对象的出现就可以有属性和行为被调用。文档对象模型 文档：标记型文档。 对象：封装了属性和行为的实例，可以被直接调用。 模型：所有标记型文档都具备一些共性特征的一个体现。标记型文档(标签，属性，标签中封装的数据)，只要是标记型文档，DOM这种技术都可以对其进行操作。常见的标记型文档：html xml DOM技术的解析方式：将标记型文档解析一棵DOM树，并将树中的内容都封装成节点对象。注意：这个DOM解析方式的好处：可以对树中的节点进行任意操作，比如：增删改查。弊端：这种解析需要将整个标记型文档加载进内存。意味着如果标记型文档的体积很大，较为浪费内存空间。 简介另一种解析方式：SAX：是由一些组织定义的一种民间常用的解析方式，并不是w3c标准，而DOM是W3C的标准。SAX解析的方式：基于事件驱动的解析。获取数据的速度很快，但是不能对标记进行增删改。 DOM模型有三种： DOM level 1：将html文档封装成对象。 DOM level 2：在leve 1基础上加入了新功能，比如解析名称空间。 DOM level 3：将xml文档封装成了对象。 DHTML:动态的HTML。不是一门语言：是多项技术综合体的简称.其中包含了HTML,CSS,DOM,JavaScript。 这四个技术在动态html页面效果定义时，都处于什么样角色呢？负责什么样的职责呢？ HTML:负责提供标签，对数据进行封装，目的是便于对该标签中的数据进行操作。简单说：用标签封装数据。 CSS:负责提供样式属性，对标签中的数据进行样式的定义。 简单说：对数据进行样式定义 DOM:负责将标签型文档以及文档中的所有内容进行解析，并封装成对象，在对象中定义了更多的属性和行为，便于对对象操作。简单说：将文档和标签以及其他内容变成对象。 JS:负责提供程序设计语言，对页面中的对象进行逻辑操作。简单说：负责页面的行为定义。就是页面的动态效果。 所以javascript是动态效果的主力编程语言。 DHTML+XMLhttpRequest = AJAX 8.1、核心浏览器网页就是一个Dom树形结构 更新：更新Dom节点 遍历：得到Dom节点 删除：删除Dom节点 添加：添加一个新的Dom节点 要操作一个Dom节点，就要先获得这个Dom节点 8.2、获得Dom节点/* 获取节点的方法： 1，getElementById():通过标签的id属性值获取该标签节点。返回该标签节点。一般容器型节点都有ID属性，所以就用这个获取。 2，getElementsByName(): 通过标签的name属性获取节点，因为name有相同，所以返回的一个数组。 3，getElementsByTagName(): 通过标签名获取节点。因为标签名会重复，所以返回的是一个数组。 */ //对应CSS选择器 let byTagName = document.getElementsByTagName(\"h1\"); console.log(byTagName); let byId = document.getElementById('p1'); console.log(byId); let byClassName = document.getElementsByClassName('p2'); console.log(byClassName); let father = document.getElementById('father'); let children = father.children;//获取父节点下的所有子节点 let child=father.children[index];//获取第index个子节点 let firstChild = father.firstChild;//第一个子节点 let lastChild = father.lastChild;//最后一个子节点 这是原生代码，之后我们都尽量使用jQuery 8.3、更新Dom&lt;div id=\"id1\"&gt;&lt;/div&gt; &lt;script&gt; let id1 = document.getElementById('id1'); &lt;/script&gt; 操作文本 id1.innerText='456';修改文本的值 id1.innerHTML='123';可以解析HTML文本标签 操作css &gt;&gt; id1.style.color='red' //属性使用字符串 &lt;- \"red\" &gt;&gt; id1.style.fontSize='100px' //下划线转驼峰命名问题 &lt;- \"100px\" &gt;&gt; id1.style.padding='2em' &lt;- \"2em\" 8.4、删除Dom删除节点的步骤：先获取父节点，再通过父节点删除自己 &lt;div id=\"father\"&gt; &lt;h1&gt;标题1&lt;/h1&gt; &lt;p id=\"p1\"&gt;p1&lt;/p&gt; &lt;p class=\"p2\"&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let self = document.getElementById('p1'); let father = self.parentElement; father.removeChild(self); //删除是一个动态的过程 father.removeChildren(father.children[0]); &lt;/script&gt; 注意：删除多个节点的时候，children的位置是时刻变化的。 8.5、插入Dom当获得了某个Dom节点，假设这个Dom节点是空的，通过innerHTML就可以增加一个元素，但是如果这个Dom节点已经存在元素了，就不能这么干，会覆盖。 将已有的标签追加到后面 &lt;p id=\"js\"&gt;JavaScript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let js = document.getElementById('js'); let list = document.getElementById('list'); list.append(js);//追加到后面 &lt;/script&gt; 效果： 创建一个新的标签，实现插入 &lt;p id=\"js\"&gt;JavaScript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let js = document.getElementById('js');//已存在的节点 let list = document.getElementById('list'); list.append(js); //通过js创建一个节点 let newP = document.createElement('p');//创建一个p标签 newP.id='newP'; newP.innerText='hello'; list.append(newP); //创建一个标签节点 let myScript = document.createElement('script'); myScript.setAttribute('type','text/javascript'); list.appendChild(myScript); //可以创建一个style标签 let myStyle = document.createElement('style');//创建了一个空style标签 myStyle.setAttribute(\"type\",'text/css');//设置type为text/css myStyle.innerHTML='body{background: antiquewhite;}';//设置标签内容 let head = document.getElementsByTagName('head');//将style追加到头部 head[0].appendChild(myStyle);//head的第0个才是head &lt;/script&gt; 效果： 插入到前面 insertBefore //insertBefore(newNode,targetNode) let js = document.getElementById('js');//新的节点 let list = document.getElementById('list');//包含的父节点 let ee = document.getElementById('ee');//目标节点 list.insertBefore(js,ee); 9、操作表单（验证）9.1、表单是什么 文本框 text 下拉框 &lt; select &gt; 单选框 radio 多选框 checkbox 隐藏域 hidden 密码框 password …. 表单的目的：提交信息 9.2、获得要提交的信息&lt;form action=\"\" method=\"post\"&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;input type=\"text\" id=\"username\"&gt; &lt;!--多选框的值就是value的值--&gt; &lt;p&gt; &lt;span&gt;性别&lt;/span&gt; &lt;input type=\"radio\" name=\"sex\" value=\"man\" id=\"boy\"&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"women\" id=\"girl\"&gt;女 &lt;/p&gt; &lt;/form&gt; &lt;script&gt; let username = document.getElementById('username'); let boy = document.getElementById('boy'); let girl = document.getElementById('girl'); //得到输入框的值 username.value; //修改输入框的值 username.value = '123'; //对于单选框，多选框等固定的值，用.value只能取到当前的值 boy.value; boy.checked;//查看返回的结果是否为true，如果为true，则为选中 boy.checked=true;//赋值 &lt;/script&gt; 9.3、提交表单 md5加密密码 md5在线cdn：https://www.bootcdn.cn/blueimp-md5/ &lt;!--表单绑定提交事件 onsubmit 绑定一个提交检测函数 true false 将这个结果返回表单，使用onsubmit接收 onsubmit=\"return check()\"--&gt; &lt;form action=\"https://www.baidu.com/\" method=\"post\" onsubmit=\"return check()\"&gt; &lt;p&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码&lt;/span&gt; &lt;input type=\"password\" id=\"input-password\"&gt; &lt;!--隐藏域作用:如果直接把input-password加密，在提交表单的一瞬间密码会变长，因 为进行了加密，加隐藏域可以保持密码长度不变，服务器获取的数据也应该是id为 md5-password的数据，id为input-password只是过渡作用--&gt; &lt;input type=\"hidden\" id=\"md5-password\" name=\"password\"&gt; &lt;/p&gt; &lt;!--绑定事件 onclick 被点击--&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; function check() { let username = document.getElementById('username'); let input_password = document.getElementById('input-password'); let md5_password = document.getElementById('md5-password'); // MD5算法 md5_password.value=md5(input_password.value); //可以检验表单内容，true通过，false阻止 return true; } &lt;/script&gt; 10、jQueryJavaScript jQuery库，里面存在大量的JavaScript函数 引入jQuery （官网：https://jquery.com/） （文档：https://jquery.cuishifeng.cn/index.html） （在线cdn：https://www.bootcdn.cn/jquery/） 10.1、初识jQuery公式：$(选择器).事件函数() &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--cdn引入--&gt; &lt;!--&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js\"&gt;&lt;/script&gt;--&gt; &lt;script src=\"lib/jquery-3.5.1.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 公式：$(selector).action() --&gt; &lt;a href=\"\" id=\"test-jquery\"&gt;点我&lt;/a&gt; &lt;script&gt; //选择器就是css选择器 $('#test-jquery').click(function () { alert('hello jquery'); }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 10.2、选择器文档工具站：https://jquery.cuishifeng.cn/index.html //原生js，选择器少，麻烦不好记 //标签 document.getElementsByTagName(); //id document.getElementById(); //类 document.getElementsByClassName(); //jquery css中的选择器，他都能用 $('p').click();//标签选择器 $('#id1').click();//id选择器 $('.class1').click();//类选择器 10.3、事件鼠标事件，键盘事件，其他事件 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"lib/jquery-3.5.1.js\"&gt;&lt;/script&gt; &lt;style&gt; #divMove{ width: 500px; height: 500px; border: red solid 1px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--获取鼠标当前的坐标--&gt; mouse：&lt;span id=\"mouseMove\"&gt;&lt;/span&gt; &lt;div id=\"divMove\"&gt; 在这里移动鼠标试试 &lt;/div&gt; &lt;script&gt; //当网页元素加载完毕之后响应事件 $(function () { $('#divMove').mousemove(function (e) { $('#mouseMove').text('x:'+e.pageX+\" y:\"+e.pageY); }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 10.4、操作DOM 文本节点操作 &lt;ul id=\"test-ul\"&gt; &lt;li class=\"js\"&gt;javascript&lt;/li&gt; &lt;li name=\"python\"&gt;python&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $('#test-ul li[name=python]').text();//获得值 $('#test-ul li[name=python]').text(\"123\");//设置值 $('#test-ul').html();//获得值 $('#test-ul').html(\"&lt;strong&gt;123&lt;/strong&gt;\");//设置值 &lt;/script&gt; css操作 $('#test-ul li[name=python]').css({'color':'red','fontSize':'30px'}); 元素的显示和隐藏 本质：display:none $('#test-ul li[name=python]').hide();//隐藏 $('#test-ul li[name=python]').show();//显示 $('#test-ul li[name=python]').toggle();//隐藏显示轮换，调用一次换一次 娱乐测试 $(window).width();//浏览器窗口 $(window).height(); 小技巧 1、如何巩固 JS 看jQuery框架源码 看游戏源码 2、巩固HTML、CSS 扒网站，全部down下来，然后对应修改，看效果","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"注解与反射","slug":"注解与反射","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:32:55.843Z","comments":true,"path":"posts/ea4e459k.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e459k.html","excerpt":"","text":"注解与反射注解什么是注解？Annotation是从JDK5.0开始引入的新技术，Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。 作用： 不是程序本身，可以对程序作出解释（这一点和注释comment没什么区别） 可以被其他程序（如编译器）读取 Annotation格式： 注解是以“@注释名”在代码重尊在的，还可以添加一些参数值，例如：@SuppressWarnings（value=”unchecked”） Annotation在哪里使用？ 可以附加在package，class，method，filed等上面，相当给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 内置注解 @Override：定义在java.lang.Override中， 此注解只适用于修辞方法，表示一个方法打算重写超类中的另一个方法声明 @Deprecated：定义在java.lang.Deprecated中，此注解可以用于修辞方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为他很危险或者存在更好的选择。标记过时方法。 @SuppressWarnings：定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息，指示编译器去忽略注解中声明的警告。 与前两个不同，需要添加一个参数才能够正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了 @SupressWarnings（“all”） @SupressWarnings(“unchecked”) @SupressWarnings(value = { “unchecked”, “ deprecation”}) 元注解 元注解的作用是负责注解其他注解，Java定义了4个标准的meta-annotation类型，它们被用来提供对其他annotation类型作说明 这些类型和他们所支持的类在java.lang.annotation包中可以找到。（**@Target， **@Retention， @Documented， @Inherited） @Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） @Target 有下面的取值 @Target(ElementType.TYPE) 可以有多个取值 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。一般写runtime 。 它参数的取值如下：**@Retention(RetentionPolicy.RUNTIME)只能有一个取值** RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 （SOURCE &lt; CLASS &lt; RUNTIME） @Documented：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的注解 从 Java 7 开始，额外添加了 3 个注解: @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 自定义注解 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口 分析 @interface用来声明一个注解，格式： public @interface 注解名 {定义内容} 其中的每一个方法实际上是声明了一个配置参数 方法的名称就是参数的名称 返回值类型就是参数的类型（返回值只能是基本类：Class（不是class）, String, enum） 可以通过default来声明参数的默认值 如果只有一个参数成员，一般参数名为value 注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值。 import java.lang.annotation.*; @MyAnnotation public class Test01 { /* * 如果只有一个参数的话，我们如果将参数名设置为value，那么我们在复制的时候 * 可以省略key，直接写value。否则不可以省略key。 * */ @MyAnnotation3(\"wo\") public void test3(){} /* * 注解如果有默认值的话， 那我们可以不进行赋值，也可以进行显式赋值 * 如果没有默认值的话，我们就必须要进行赋值 * */ @MyAnnotation2(woc = 231.2f)//多参数注解 public void test2(){} @MyAnnotation public void test(){} } @Target(value = {ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation3{ /* * 如果只有一个参数的话，我们如果将参数名设置为value，那么我们在复制的时候 * 可以省略key，直接写value。否则不可以省略key。 * */ String value(); } @Target(value = {ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation2{ // 注释的参数 ： 参数类型 + 参数名 (); String name() default \"\";//默认值为空，有默认值就可以不写该参数 int age() default 0; int id() default -1; //如果默认值为 -1， 代表不存在 String[] schools() default {\"清华大学\"}; //数组，可以多个参数，参数类型为string ，如果数组名为value在注解写参数时可以不用 写“value= ” float woc(); } @Target(value = {ElementType.METHOD, ElementType.TYPE}) @Retention(value = RetentionPolicy.RUNTIME) @Documented @Inherited @interface MyAnnotation{ } 反射机制反射概述静态语言 VS 动态语言 动态语言 是一类在运行时，可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。 主要动态语言：Object-C， C#， JavaScript， PHP， Python等 静态语言 与动态语言对应，运行时结构不可变的语言就是静态语言，如C，C++, Java; Java不是动态语言，但Java可以称为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让Java编程的时候更加灵活。 Java获取了一定的动态性，作为代价就失去了一部分的安全性。 Java Reflection Reflection 是Java被视为动态语言的关键，反射机制允许程序在执行期间借助Reflection API取得任何类的内部信息，并且能直接操作任意对象的内部属性及方法。 Class c = Class.forName(\"java.lang.String\"); 记载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构。所以，我们形象的称之为：反射。 Java反射机制研究及应用 Java反射机制提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 生成动态代理 …… 反射优缺点 优点：可以实现动态创建对象和编译，体现出很大的灵活性 缺点：对性能有影响。使用反射基本上是一种解释性操作，我们可以告诉JVM，我们希望做什么并且它会满足我们的需求，这类操作总是慢于直接执行相同的操作。 取得反射对象反射 API Java.lang.Class：代表一个类 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Constructor：代表类的构造器 Class类在Object类中定义了以下方法，此方法被所有的子类继承 public final Class getClass(); 该方法返回值的类型是Class类，此类是Java反射的源头，实际上所谓的反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称 反射对象可以得到的信息 某个类的属性、方法和构造器 某个类到底实现了哪个接口 对于每个类而言，JRE都为其保留了一个不变的Class对象。一个Class对象包含了特定某个结构（class / interface / enum / annotation / primitive type / void / []）的有关信息： Class对象本身也是一个类 Class对象只能由系统建立对象 一个加载的类在JVM中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个Class实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得的相应的Class对象 得到Class类的实例 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高： Class class = Person.class; 已知某个各类的实例，调用该实例的getClass()方法获取Class对象： Class class = person.getClass(); 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName（）获取，可能抛出ClassNotFoundException Class class = Class.forName(\"demo01.Student\"); 内置基本数据类型可以直接用类名.Type 还可以利用 ClassLoader 我们之后讲解。 哪些类可以有Class对象 外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。 interface：接口 []：数组 只要元素类型和维度一样， 就是同一个Class enum：枚举 annotation：注解@interface primitive type：基本数据类型 void 类的加载 当程序主动使用某个类的时候，如果该类还没有被加载到内存中，则系统会通过如下三个步骤对该类进行初始化。 加载：将class字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 验证：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为类变量（static）分配内存并设置类变量默认值的阶段，这些内存都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 初始化： 执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造信息的，不是构造该类对象的构造器）。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发父类的初始化。 虚拟机会保证一个类的()方法在多线程环境中被正确的加锁和同步 public class test3 { public static void main(String[] args) { System.out.println(A.m); // 100 // m=100 如果写在静态代码快上面的话 m就是300； } } class A { //在类文件被加载时，产生Class对象 //在链接时进行代码校验后，把类变量（static）分配内存并设置默认初始值，此时m为0 //接着初始化，不同于创建对象时的初始化，执行类构造器&lt;clinit&gt;()方法的过程， // 该类构造器由执行类变量（static）的赋值和静态代码块中的语句合并产生 //语句按代码顺序执行 static { System.out.println(\"A被初始化\"); m = 300; } static int m = 100; } 类什么时候会发生初始化？public class Test06 { static { System.out.println(\"Main类被加载\"); } public static void main(String[] args) throws ClassNotFoundException { //下面每个部分都会添加一段代码在这个部分进行执行 } } class Father{ static{ System.out.println(\"Father类被加载\"); } static int b = 2; } class Son extends Father{ static { System.out.println(\"Son类被加载\"); } static int m = 100; static final int M = 1; } 类的主动引用（一定会发生类的初始化） 当虚拟机启动，先初始化main方法所在类 主类中的静态代码块就会被执行 //Main类被加载 new一个类的对象 Son son = new Son(); /* Main类被加载 Father类被加载 Son类被加载 */ 调用类的静态成员（除了final常量）和静态方法 System.out.println(Son.m); /* Main类被加载 Father类被加载 Son类被加载 100 */ 使用java.lang.reflect包的方法对类进行反射调用 Class.forName(\"javalearning.reflection.Son\"); /* Main类被加载 Father类被加载 Son类被加载 */ 当初始化一个类，如果其父类没有被初始化，则会先初始化它的父类。 //上述Demo都是在加载子类之前先加载了父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引父类的静态变量，不会导致子类初始化。 System.out.println(Son.b); /* Main类被加载 Father类被加载 2 因为是父类声明了静态变量b，子类只是从父类身上继承了下来，子类并不是声明该字段的类，所以会去找子类的爸爸，和子类没太大关系（子类算是个中介吧） */ 通过数组定义引用，不会触发此类的初始化。 Son[] son = new Son[10]; /* Main类被加载 只是开辟了一个这个类型的空间，并没有用到这个类做任何事情 */ 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） System.out.println(Son.M); /* Main类被加载 1 */ public class test5 { static { System.out.println(\"main 被初始化\"); } public static void main(String[] args) throws ClassNotFoundException { Son son = new Son();//子父类都初始化 Class.forName(\"reflection.Son\");//子父类都初始化 System.out.println(Son.m);//子父类都初始化 System.out.println(Son.f);//初始化父类 Class c = Son.class;//只初始化main System.out.println(Son.s);//只初始化main Son[ ] array = new Son[ 3];//只初始化main } } class Father { static int f =1000; static { System.out.println(\"father 被初始化\"); } } class Son extends Father { static final int s = 100; static int m = 10; static { System.out.println(\"son 被初始化\"); } } 类加载器的作用 类加载的作用：将class文件字节码内容加载到内存中，并将在这些静态数据转换成方法去的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载中，它将维持加载（缓存）一段时间。不过JVM GC机制可以回收这些Class对象 类加载作用是用来把类（class）装载进内存的。JVM规范定义了如下类型的类加载器 引导类加载器（Bootstap Classloader）：用C++编写的，是JVM自带的类加载器，负责Java平台核心库（rt.jar），用来装载核心类库。该加载去无法直接获取 拓展类加载器（Extension Classloader）：负责jre/lib/ext目录下的jar包或 -D java.ext.dirs指定目录下的jar包 装入工作库 系统类加载器（System Classloader / Application Classloader）：负责 java -classpath 或 -D java.class.path所指的目录下的类与jar包装入工作，是最常用的加载器。 双亲委派机制：如果java需要加载一个类，例如java.lang.String ，然鹅你自己也想写一个同名的。他会从低级类加载器到高级类加载器逐渐寻找，如果在高层找到了那个类，那么你手写的同名包就不会被调用。（你不配重写我的类 —-Sun公司） 双亲委派机制 工作原理：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。 好处：Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子类ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。 public class Test07 { public static void main(String[] args) throws ClassNotFoundException { // 获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); // 获取系统类加载器的父类加载器 ---》 拓展类加载器 ClassLoader parent = systemClassLoader.getParent(); System.out.println(parent); // 获取拓展类加载器的父类加载器 ---》 根加载器（C / C++） ClassLoader parent1 = parent.getParent(); System.out.println(parent1); // 查看当前类是哪个加载器加载的 ClassLoader classLoader = Class.forName(\"javalearning.reflection.Test07\").getClassLoader(); System.out.println(classLoader); // 测试JDK内置的类是谁加载的 classLoader = Class.forName(\"java.lang.Object\").getClassLoader(); System.out.println(classLoader); //如何获取系统类加载器可以加载的路径 System.out.println(System.getProperty(\"java.class.path\")); /* * E:\\ProjectFiles\\IJproject\\JavaLearning\\out\\production\\JavaLearning; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.transaction.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.persistence.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.resource.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.ejb.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.servlet.jsp.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.servlet.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.jms.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.annotation.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.servlet.jsp.jstl.jar; * * */ } } /* jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733d jdk.internal.loader.ClassLoaders$PlatformClassLoader@506e1b77 null jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733d null //根加载器我们JVM无法读取， 所以是null */ 创建运行时类的完整结构通过反射获取运行时类的完整结构： Field、Method、Constructor、Superclass、Interface、Annotation 实现的全部结构 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 …… import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; // 获得类的信息 public class Test08 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException { Class c1 = Class.forName(\"javalearning.reflection.User\"); //获得类的名字 System.out.println(c1.getName()); // 包名 + 类名 System.out.println(c1.getSimpleName());// 类名 //获得类的属性 System.out.println(\"===================================\"); Field[] fields = c1.getFields(); //只能获取自身以及父类的公共属性 for (Field field : fields){ System.out.println(field); } System.out.println(\"===================================\"); fields = c1.getDeclaredFields(); //能获取自身所有属性 for (Field field : fields){ System.out.println(field); } //获取指定的属性的值 System.out.println(\"======================================\"); Field name = c1.getDeclaredField(\"name\"); System.out.println(name); System.out.println(\"======================================\"); Method[] methods = c1.getMethods(); //获得本类及其父类的所有public方法 for (Method method : methods){ System.out.println(method); } methods = c1.getDeclaredMethods(); //获得本类的所有方法 for (Method method : methods){ System.out.println(method); } System.out.println(\"======================================\"); // 获取指定的方法 //重载 通过参数类型判断是哪个方法 Method getName = c1.getMethod(\"getName\", null); Method setName = c1.getMethod(\"setName\", String.class); System.out.println(getName); System.out.println(setName); System.out.println(\"======================================\"); //获得构造器 Constructor[] constructors = c1.getConstructors(); // 获得本类和父类public构造方法 for (Constructor constructor : constructors){ System.out.println(constructor); } // 获得本类所有构造方法 constructors = c1.getDeclaredConstructors(); for (Constructor constructor : constructors){ System.out.println(\"#\"+ constructor); } System.out.println(\"指定构造器\" + c1.getDeclaredConstructor(String.class, int.class, int.class)); } } 小结 在实际操作中，取得类的信息的操作代码，并不会经常开发 一定要熟悉java.lang.reflect包的作用，反射机制。 如何取得属性、方法、构造器的名称、修饰符等 有了Class对象之后，能做什么？ 创建类的对象：调用Class对象的newInstance（）方法 类必须有一个无参数的构造器 类的构造器的访问权限需要足够 思考？：难道没有无参的构造器就不能创建对象了吗？ 只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作 步骤如下： 通过Class的 getDeclaredConstructor（Class … parameterTypes）取得本类的指定形参类型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需要的各个参数 通过Constructor实例化对象 调用指定的方法通过反射，调用类中的方法，通过Method类完成。 通过Class类的getMethod（String name， Class … parameterTypes）方法取得一个Method对象，并设置此方法操作时所需要的参数类型。 之后使用Object invoke（Object obj， Object[] args）进行调用，并向方法中传递要设置的obj对象的参数信息 Object invoke(Object obj, Obj ... args) Object对应方法的返回值，若原方法无返回值，此时返回null 若原方法为静态方法，此时形参Object obj可为null 若原方法形参列表为空，则Object[] args 为null 若原方法声明为private，则需要再调用此invoke（）方法前，显式调用方法对象的setAccessible（true）方法，将可访问private的方法。 setAccessible Method和Field、Constructor对象都有setAccessible（）方法 setAccesible作用是启动和禁用访问安全检查的开关。 参数值为true， 指示反射的对象在使用时应该取消Java语言访问检查。 提高反射的效率。如果代码中必须使用反射，而该句代码需要频繁的被调用，那么请设置为true 使得原本无法访问的私有成员也可以访问 参数值为false，指示反谁的对象应该是是java语言的访问检查 import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Test09 { public static void main(String[] args) throws Exception { Class c1 = Class.forName(\"javalearning.reflection.User\"); // User user = (User) c1.newInstance(); //本质是调用了类的无参构造器，无参数构造函数不需要获取构造函数对象 // System.out.println(user); //通过构造器创建对象 Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class); System.out.println(constructor); User user1 = (User) constructor.newInstance(\"岛市老八\", 1, 18); System.out.println(user1); //通过反射调用普通方法 //获取一个对象 User user2 = (User)c1.newInstance(); //通过反射获取一个方法 Method setName = c1.getDeclaredMethod(\"setName\", String.class); //invoke： 激活 // (对象， \"方法的值\") setName.invoke(user2, \"奥里给\"); System.out.println(user2.getName()); //通过反射操作属性 User user3 = (User) c1.newInstance(); Field name = c1.getDeclaredField(\"name\"); //取消私有属性的安全检测 name.setAccessible(true); name.set(user3, \"wocao\"); System.out.println(user3.getName()); } } 性能分析import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; //分析性能问题 public class Test10 { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { test01(); test02(); test03(); } //普通方式调用 public static void test01(){ User user = new User(); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++){ user.getName(); } long endTime = System.currentTimeMillis(); System.out.println(\"普通方法: \" + (endTime - startTime) + \" ms\"); } //反射方法调用 public static void test02() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(\"getName\", null); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++){ getName.invoke(user, null); } long endTime = System.currentTimeMillis(); System.out.println(\"反射方法: \" + (endTime - startTime) + \" ms\"); } //反射方式调用 关闭私有属性安全检测 public static void test03() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(\"getName\", null); getName.setAccessible(true); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++){ getName.invoke(user, null); } long endTime = System.currentTimeMillis(); System.out.println(\"关闭检测方法: \" + (endTime - startTime) + \" ms\"); } } /* 普通方法: 4 ms 反射方法: 330 ms 关闭检测方法: 159 ms */ 反射确实会降低程序执行的性能，关闭安全检查可以较为显著地提升性能。 反射操作泛型 Java采用泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题。但是，一旦编译完成，所有和泛性有关的类型全部擦除。 为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType 几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型 ParameterizedType：表示一种参数化类型，比如Collection GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型 TypeVariable：是各种类型变量的公共父接口 WildcardType：代表一种通配符类型表达式 import java.lang.reflect.Method; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.util.List; import java.util.Map; //通过反射获取泛型 public class Test11 { public static void main(String[] args) throws NoSuchMethodException { Method method = Test11.class.getMethod(\"test01\", Map.class, List.class); //返回函数的参数列表 Type[] genericExceptionTypes = method.getGenericParameterTypes(); //遍历每一项参数 for (Type genericExceptionType : genericExceptionTypes){ System.out.println(\"#\"+ genericExceptionType); //判断每一项的泛型的参数类型是否为结构化参数类型 if (genericExceptionType instanceof ParameterizedType){ //强制转换为结构化参数类型，然后用函数获得其真实类型数组 Type[] actualTypeArguments = ((ParameterizedType) genericExceptionType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments){ System.out.println(actualTypeArgument); } } } method = Test11.class.getDeclaredMethod(\"test02\"); //这个方法获取的是返回值类型，别的和上面的逻辑没啥区别 Type genericReturnType = method.getGenericReturnType(); if (genericReturnType instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments){ System.out.println(actualTypeArgument); } } } public void test01(Map&lt;String, User&gt; map, List&lt;User&gt; list){ System.out.println(\"test01\"); } public Map&lt;String,User&gt; test02(){ System.out.println(\"test02\"); return null; } } 反射操作注解 getAnnotations getAnnotation import java.lang.annotation.*; import java.lang.reflect.Field; //联系反射操作注解 public class test12 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { Class c1 = Class.forName(\"javalearning.reflection.Student2\"); //通过反射获取注解 Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations){ System.out.println(annotation); } /* @javalearning.reflection.TableName(value=\"db_student\") */ //获取注解value的值 //获取指定注解，传入注解的Class 返回类型是Annotation类型的，然后强转为目标类型 TableName tableName = (TableName) c1.getAnnotation(TableName.class); String value = tableName.value(); //通过.value()就能获取了 System.out.println(value); /* db_student */ // 获取类指定的注解 Field field = c1.getDeclaredField(\"name\"); FieldName annotation = field.getAnnotation(FieldName.class); System.out.println(annotation.columnName()); System.out.println(annotation.type()); System.out.println(annotation.length()); /* db_name varchar 3 */ } } @TableName(\"db_student\") class Student2{ @FieldName(columnName = \"db_id\", type=\"int\", length=10) private int id; @FieldName(columnName = \"db_age\", type=\"int\", length=10) private int age; @FieldName(columnName = \"db_name\", type=\"varchar\", length=3) private String name; public Student2() { } public Student2(int id, int age, String name) { this.id = id; this.age = age; this.name = name; } public void setId(int id) { this.id = id; } public void setAge(int age) { this.age = age; } public void setName(String name) { this.name = name; } public int getId() { return id; } public int getAge() { return age; } public String getName() { return name; } @Override public String toString() { return \"Student2{\" + \"id=\" + id + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } //类名的注解 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @interface TableName{ String value(); } //表属性的注解 @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @interface FieldName{ String columnName(); String type(); int length(); }","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"多线程","slug":"多线程","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:32:31.887Z","comments":true,"path":"posts/ea4e999k.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e999k.html","excerpt":"","text":"线程创建三种创建线程的方式 继承Thread.start() 方法启动线程执行的是 run() 里的线程体！ 测试一： // 创建线程方式一：继承Thread类，重写run()方法，调用start开启线程 //总结：注意，线程开启不一定立即执行，由cpu调度执行 public class TestThread1 extends Thread{ @Override public void run(){ //run方法线程体 for (int i = 0;i&lt;20;i++){ System.out.println(\"我在看代码-----\"+i); } } public static void main(String[] args){ //main线程，主线程 //创建一个线程对象 TestThread1 testThread1 = new TestThread1(); //调用start()方法开启线程 testThread1.start(); for(int i= 0 ;i&lt;200;i++){ System.out.println(\"我在学习多线程----\"+i); } } } 输出结果： 可以发现 start() 开启的线程和主线程是交替执行的！！！ 而直接调用 run() 方法，会发现先执行run()方法，再执行主线程： public static void main(String[] args){ //main线程，主线程 //创建一个线程对象 TestThread1 testThread1 = new TestThread1(); //调用run()方法开启线程 testThread1.run(); for(int i= 0 ;i&lt;200;i++){ System.out.println(\"我在学习多线程----\"+i); } } 输出结果 以上对比直接调用 run() 和调用 start()可以得出以下结论： 为了更好地验证上述结论，我们进行测试二： 测试二： //练习Thread,实现多线程同步下载图片 public class TestThread2 extends Thread { private String url; //网络图片地址 private String name; //保存的文件名 public TestThread2(String url,String name){ this.url=url; this.name=name; } //下载图片的线程执行体 @Override public void run(){ WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url,name); System.out.println(\"下载的文件名为：\"+name); } public static void main(String[] args) { TestThread2 t1 = new TestThread2(\"https://pics7.baidu.com/feed/a50f4bfbfbedab64cddfc490f31fc9c578311ee4.jpeg?token=d6cc78140999ca5390cd8002a754d9a4\",\"1.jpg\"); TestThread2 t2 = new TestThread2(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628161248586-632368241.png\",\"2.jpg\"); TestThread2 t3 = new TestThread2(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628162624243-370438535.png\",\"3.jpg\"); t1.start(); t2.start(); t3.start(); } } //下载器 class WebDownloader{ //下载方法 public void downloader(String url,String name){ try{ FileUtils.copyURLToFile(new URL(url),new File(name)); }catch (IOException e){ e.printStackTrace(); System.out.println(\"IO异常，downloader方法出现问题\"); } } 下载结果为：（发现并不是按1，2，3的顺序下载） 从而更好的说明，start() 方法开启的子线程和主线程是并行交替执行的！ 实现Runnable 测试一： //创建线程方式2：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类Thread中，调用start()。 public class TestThread3 implements Runnable{ @Override public void run(){ //run方法线程体 for (int i = 0;i&lt;20;i++){ System.out.println(\"我在看代码-----\"+i); } } public static void main(String[] args){ //创建runnable接口的实现类对象 TestThread3 testThread3 = new TestThread3(); //创建线程对象，通过线程对象来开启我们的线程，代理 Thread thread = new Thread(testThread3); thread.start(); for(int i= 0 ;i&lt;200;i++){ System.out.println(\"我在学习多线程----\"+i); } } } 输出结果： 测试二：让TestThread2实现Runnable接口下载图片，而非继承Thread //实现Runnable接口下载图片 public class TestThread2 implements Runnable { private String url; //网络图片地址 private String name; //保存的文件名 public TestThread2(String url,String name){ this.url=url; this.name=name; } //下载图片的线程执行体 @Override public void run(){ WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url,name); System.out.println(\"下载的文件名为：\"+name); } public static void main(String[] args) { TestThread2 t1 = new TestThread2(\"https://pics7.baidu.com/feed/a50f4bfbfbedab64cddfc490f31fc9c578311ee4.jpeg?token=d6cc78140999ca5390cd8002a754d9a4\",\"1.jpg\"); TestThread2 t2 = new TestThread2(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628161248586-632368241.png\",\"2.jpg\"); TestThread2 t3 = new TestThread2(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628162624243-370438535.png\",\"3.jpg\"); new Thread(t1).start(); new Thread(t2).start(); new Thread(t3).start(); } } 下载结果：（交替下载，而非顺序下载） 小结 初识并发问题//多个线程同时操作同一个对象 //买车票的例子 //发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱 public class TestThread4 implements Runnable { //票数 private int ticketNums = 10; @Override public void run(){ while(true){ if (ticketNums&lt;=0){ break; } //模拟延时 try{ Thread.sleep(200); }catch (InterruptedException e){ e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"拿到了第\"+ticketNums--+\"张票\"); } } public static void main(String[] args) { TestThread4 ticket = new TestThread4(); new Thread(ticket,\"小明\").start(); new Thread(ticket,\"老师\").start(); new Thread(ticket,\"黄牛\").start(); } } 输出结果：（发现线程不安全） 案例：龟兔赛跑—Race //模拟龟兔赛跑 public class Race implements Runnable { //胜利者 private static String winner; @Override public void run(){ for (int i = 1; i&lt;=100 ; i++){ //模拟兔子休息 if(Thread.currentThread().getName().equals(\"兔子\") &amp;&amp; i%10==0){ try{ Thread.sleep(10); }catch (InterruptedException e){ e.printStackTrace(); } } //判断比赛是否结束 boolean flag = gameOver(i); //如果比赛结束了，就停止程序 if (flag){ break; } System.out.println(Thread.currentThread().getName()+\"----&gt;跑了\"+i+\"步\"); } } //判断是否完成比赛 private boolean gameOver(int steps){ //判断是否有胜利者 if (winner!=null){ //已经有胜利者 return true; }else{ if (steps&gt;=100){ winner = Thread.currentThread().getName(); System.out.println(\"winner is \"+winner); return true; } } return false; } public static void main(String[] args) { Race race = new Race(); new Thread(race,\"兔子\").start(); new Thread(race,\"乌龟\").start(); } } 实现Callable接口（了解即可） //线程创建方式三：实现callable接口 /* * callable的好处 * 1.可以定义返回值 * 2.可以抛出异常 * */ public class TestCallable implements Callable&lt;Boolean&gt; { private String url; //网络图片地址 private String name; //保存的文件名 public TestCallable(String url,String name){ this.url=url; this.name=name; } //下载图片的线程执行体 @Override public Boolean call(){ WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url,name); System.out.println(\"下载的文件名为：\"+name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable t1 = new TestCallable(\"https://pics7.baidu.com/feed/a50f4bfbfbedab64cddfc490f31fc9c578311ee4.jpeg?token=d6cc78140999ca5390cd8002a754d9a4\",\"1.jpg\"); TestCallable t2 = new TestCallable(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628161248586-632368241.png\",\"2.jpg\"); TestCallable t3 = new TestCallable(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628162624243-370438535.png\",\"3.jpg\"); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(3); //提交执行 Future&lt;Boolean&gt; r1 = ser.submit(t1); Future&lt;Boolean&gt; r2 = ser.submit(t2); Future&lt;Boolean&gt; r3 = ser.submit(t3); //获取结果 boolean rs1 = r1.get(); boolean rs2 = r2.get(); boolean rs3 = r3.get(); System.out.println(rs1); System.out.println(rs2); System.out.println(rs3); //关闭服务 ser.shutdownNow(); } } //下载器 class WebDownloader{ //下载方法 public void downloader(String url,String name){ try{ FileUtils.copyURLToFile(new URL(url),new File(name)); }catch (IOException e){ e.printStackTrace(); System.out.println(\"IO异常，downloader方法出现问题\"); } } } 下载结果： 静态代理 //静态代理模式总结： //真实对象和代理对象都要实现同一个接口 //代理对象要代理真实角色 //好处： //代理对象可以做很多真实对象做不了的事情 //真实对象专注做自己的事情 public class StaticProxy { public static void main(String[] args) { You you = new You();//你要结婚 WeddingCompany weddingCompany = new WeddingCompany(you); weddingCompany.HappyMarry(); } } interface Marry{ void HappyMarry(); } //真实角色，你去结婚 class You implements Marry{ @Override public void HappyMarry(){ System.out.println(\"秦老师要结婚了，超开心\"); } } //代理角色，帮助你结婚 class WeddingCompany implements Marry{ //代理谁-&gt; 真实目标角色 private Marry target; public WeddingCompany(Marry target){ this.target = target; } @Override public void HappyMarry(){ before(); this.target.HappyMarry(); //这就是真实对象 after(); } private void after(){ System.out.println(\"结婚后，收尾款\"); } private void before(){ System.out.println(\"结婚前，布置现场\"); } 和上文实现Runnable接口创建线程作对比： ​ Marry接口——&gt;Runnable接口 ​ 实现Marry接口的You类——&gt;实现Runnable接口的TestThread3类 ​ 实现Marry接口的WeddingCompany类——&gt;实现Runnable接口的Thread类 Lambda表达式 /** * 推导lambda表达式: * 1.创建外部类——&gt;2.创建静态内部类——&gt;3.创建局部内部类——&gt;4.创建匿名内部类——&gt;5.使用lambda表达式 */ public class TestLambda { //3.静态内部类 static class Like2 implements ILike{ @Override public void lambda(){ System.out.println(\"I like lambda2\"); } } public static void main(String[] args) { //调用外部类创建对象 ILike like1 = new Like(); like1.lambda(); //调用静态内部类创建对象 ILike like2 = new Like2(); like2.lambda(); //4.局部内部类 class Like3 implements ILike{ @Override public void lambda(){ System.out.println(\"I like lambda3\"); } } ILike like3 = new Like3(); like3.lambda(); //5.匿名内部类，没有类名字，必须借助接口或者父类 ILike like4 = new ILike() { @Override public void lambda() { System.out.println(\"I like lambda4\"); } }; like4.lambda(); //6.用lambda简化 ILike like5 = ()-&gt;{ System.out.println(\"I like lambda5\"); }; like5.lambda(); } } //1.定义一个函数接口 interface ILike{ void lambda(); } //2.实现外部类 class Like implements ILike{ @Override public void lambda(){ System.out.println(\"I like lambda\"); } } 在函数式接口的抽象函数有参数的情况下，使用lambda表达式： public class TestLambda2 { public static void main(String[] args) { //使用lambda表达式，不做任何化简 ILove love1 = (int a)-&gt;{ System.out.println(\"I love you--&gt;\"+a); }; love1.love(1); //1.简化参数类型 ILove love2 = (a)-&gt;{ System.out.println(\"I love you--&gt;\"+a); }; love2.love(2); //2.简化括号和参数类型 ILove love3 = a-&gt;{ System.out.println(\"I love you--&gt;\"+a); }; love2.love(3); //3.简化括号和参数类型和花括号 ILove love4 = a-&gt;System.out.println(\"I love you--&gt;\"+a); love4.love(4); //总结： //lambda表达式只能在方法体有一行代码的情况下才能简化成为一行(即去掉花括号)，如果有多行，那么就用代码块包裹(即使用花括号) //lambda的使用前提是接口为函数式接口（即接口里只有一个函数方法） //多个参数也可以去掉参数类型(参数类型不同也可以)，要去掉就都去掉，但必须加括号 //当使用lambda有返回值时，方法体即使只有一行代码，也要用花括号包裹！ } } //函数式接口 interface ILove{ void love(int a); } 线程状态线程的五大状态 停止线程 使用我们自定义的stop方法，通过改变标志位让线程停止： //测试stop //1.建议线程正常停止————&gt;利用次数，不建议死循环 //2.建议使用标志位————&gt;设置一个标志位 //3.不要使用stop或者destroy等过时或者JDK不建议使用的方法 public class TestStop implements Runnable{ //1.设置一个标识位 private boolean flag = true; @Override public void run(){ int i = 0; while(flag){ System.out.println(\"run ..... Thread\"+i++); } } //2.设置一个公开的方法停止线程，转换标志位 public void stop(){ this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i=0;i&lt;1000;i++){ System.out.println(\"main\"+i); if (i==900){ //调用 stop方法切换标志位，让线程停止 testStop.stop(); System.out.println(\"线程该停止了！！！\"); } } } } 线程在执行第1060次时停止： 线程休眠 import com.ztx.dem01.TestThread4; //模拟网络延时：放大问题的发生行 public class TestSleep implements Runnable{ //票数 private int ticketNums = 10; @Override public void run(){ while(true){ if (ticketNums&lt;=0){ break; } //模拟延时 try{ Thread.sleep(200); }catch (InterruptedException e){ e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"拿到了第\"+ticketNums--+\"张票\"); } } public static void main(String[] args) { TestThread4 ticket = new TestThread4(); new Thread(ticket,\"小明\").start(); new Thread(ticket,\"老师\").start(); new Thread(ticket,\"黄牛\").start(); } } //模拟倒计时 public class TestSleep2 { public static void main(String[] args) { try { tenDown(); }catch (InterruptedException e){ e.printStackTrace(); } } //模拟倒计时 public static void tenDown() throws InterruptedException{ int num = 10; while(true){ Thread.sleep(1000); System.out.println(num--); if (num&lt;=0){ break; } } } } //模拟倒计时 public class TestSleep2 { public static void main(String[] args) { //打印当前系统时间 Date startTime = new Date(System.currentTimeMillis());//获取当前系统时间 while(true){ try{ Thread.sleep(1000); System.out.println(new SimpleDateFormat(\"HH:MM:SS\").format(startTime)); startTime = new Date(System.currentTimeMillis());//更新当前系统时间 }catch (InterruptedException e){ e.printStackTrace(); } } } } 线程礼让 //测试礼让线程 //礼让不一定成功，看cpu心情 public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield,\"a\").start(); new Thread(myYield,\"b\").start(); } } class MyYield implements Runnable{ @Override public void run(){ System.out.println(Thread.currentThread().getName()+\"线程开始执行\"); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+\"线程停止执行\"); } } 理想情况下，当把 Thread.yield(); 注释掉，输出情况应为：（实际上，不可能这么理想！） 加上礼让代码后，输出情况可能就不会很规整：（让执行的线程暂停，但不阻塞） join //测试join方法 //想象为插队 public class TestJoin implements Runnable{ @Override public void run(){ for (int i=0;i&lt;1000;i++){ System.out.println(\"线程vip来了\"+i); } } public static void main(String[] args) throws InterruptedException { //启动我们的线程 TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); thread.start(); //主线程 for(int i=0;i&lt;500;i++){ if (i==200){ thread.join();//插队 } System.out.println(\"main\"+i); } } } 输出结果：（在“main199”之前，线程是交替执行的，main199之后，线程VIP开始插队直到执行结束，main在开始继续执行！！！） 线程状态观测 //观测线程的状态 public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-&gt;{ for (int i=0;i&lt;10;i++){ try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } System.out.println(\"///////\"); }); //观察状态 Thread.State state = thread.getState(); System.out.println(state); //状态为：new，即新生的 //观察启动后的状态 thread.start();//启动线程 state = thread.getState(); System.out.println(state);//状态应为：run while(state!=Thread.State.TERMINATED){//只要线程不终止，就一直输出状态 Thread.sleep(1000); state = thread.getState(); //更新线程状态 System.out.println(state); } thread.start(); } } 线程优先级 测试线程优先级： //测试线程的优先级 public class TestPriority { public static void main(String[] args) { //主线程默认优先级 System.out.println(Thread.currentThread().getName()+\"---&gt;\"+Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); Thread t6 = new Thread(myPriority); //先设置优先级，再启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(4); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); t5.setPriority(8); t5.start(); t6.setPriority(7); t6.start(); } } class MyPriority implements Runnable{ @Override public void run(){ System.out.println(Thread.currentThread().getName()+\"---&gt;\"+Thread.currentThread().getPriority()); } } 运行结果： 守护(daemon)线程 测试守护线程： //测试守护线程 //上帝守护你 public class TestDaemon { public static void main(String[] args) { God god = new God(); You you = new You(); Thread thread = new Thread(god); thread.setDaemon(true); //默认为false表示用户线程，正常的线程都是用户线程 thread.start();//上帝守护线程开启 new Thread(you).start();//you 用户线程开启 } } //上帝 class God implements Runnable{ @Override public void run(){ //这里设置为一直循环，但虚拟机不会等到该线程执行结束(该线程也不会自动结束)，就会将其停止，它只要确保用户线程执行完毕即可 while(true){ System.out.println(\"s上帝保佑着你！\"); } } } //你 class You implements Runnable{ @Override public void run(){ for (int i=0;i&lt;36500;i++){ System.out.println(\"你一生都开心的活着\"); } System.out.println(\"======goodbye! world!=======\"); } } 输出结果： 这里的用户线程执行完毕后，守护线程依旧执行是因为虚拟机完毕需要时间，在这期间守护线程还可以一直运行！ 线程同步多个线程操作同一个资源 并发：同一个对象被多个线程同时操作 队列和锁：实现线程同步需要队列和锁 队列和锁的理解可以联想排队上厕所：队列就像等待上厕所的队伍，锁就像蹲坑的门，当你进去时把门关上，则其他人就进不去了，如果没有门（锁）就不能独占资源，也就没有了安全性 三大不安全案例//不安全的买票 public class UnsafeBuyTicket { public static void main(String[] args) { // TODO Auto-generated method stub BuyTicket station = new BuyTicket(); new Thread(station,\"苦逼的我\").start(); new Thread(station,\"牛逼的大家\").start(); new Thread(station,\"可恶的黄牛\").start(); } } class BuyTicket implements Runnable{ //票 private int ticketNums = 10; boolean flag = true;//外部停止方式 @Override public void run() { //买票 while(flag) { try{ buy(); }catch(InterruptedException e) { e.printStackTrace(); } } } private void buy() throws InterruptedException{ //判断是否有票 if(ticketNums&lt;=0) { return; } //模拟延时 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+\"拿到了\"+ticketNums--+\"票\"); } } 输出结果：（拿票混乱，且出现负数） //不安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { // TODO Auto-generated method stub Account a = new Account(100,\"结婚基金\"); Drawing you = new Drawing(a,50,\"你\"); Drawing girl = new Drawing(a,100,\"girl\"); you.start(); girl.start(); } } //账户 class Account{ int money;//余额 String name;//卡名 public Account(int money,String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ Account account;//账户 int drawingMoney;//取了多少钱 int nowMoney;//现在手里有多少钱 public Drawing(Account account,int drawingMoney,String name) { super(name); //定义线程名 this.account = account; this.drawingMoney = drawingMoney; } //取钱 @Override public void run() { //判断有没有钱 if(account.money-drawingMoney&lt;0) { System.out.println(Thread.currentThread().getName()+\"钱不够\"); return; } //sleep可以放大问题的发生性 try { Thread.sleep(1000); }catch(Exception e) { e.printStackTrace(); } //卡内余额=余额-你取的钱 account.money = account.money-drawingMoney; //你手里的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为\"+account.money); //这两个操作等价 //this.getName()=Thread.currentThread().getName() System.out.println(this.getName()+\"手里的钱\"+nowMoney); } } 输出结果：（存款为负数） //线程不安全的集合 public class UnsafeList { public static void main(String[] args) { // TODO Auto-generated method stub List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) { new Thread(()-&gt;{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(3000); }catch(Exception e) { e.printStackTrace(); } System.out.println(list.size()); } } 输出结果：（不足10000，因为存在多个线程同时看到一个标志，于是name就存在被覆盖掉的可能） 同步方法及同步块(synchronized)(把不安全的改成安全的) //加锁，同步方法，实现安全的买票 public class UnsafeBuyTicket { public static void main(String[] args) { // TODO Auto-generated method stub BuyTicket station = new BuyTicket(); new Thread(station,\"苦逼的我\").start(); new Thread(station,\"牛逼的大家\").start(); new Thread(station,\"可恶的黄牛\").start(); } } class BuyTicket implements Runnable{ //票 private int ticketNums = 10; boolean flag = true;//外部停止方式 @Override public void run() { //买票 while(flag) { try{ buy(); }catch(InterruptedException e) { e.printStackTrace(); } } } //同步方法，锁的是BuyTicket类实例出的对象 private synchronized void buy() throws InterruptedException{ //判断是否有票 if(ticketNums&lt;=0) { return; } //模拟延时 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+\"拿到了\"+ticketNums--+\"票\"); } } 输出结果:（输出结果整洁有序，没有重复，没有负数） 同步方法的弊端 同步块 //使用方法块，找准修改的对象作为同步监视器来实现安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { // TODO Auto-generated method stub Account a = new Account(100,\"结婚基金\"); Drawing you = new Drawing(a,50,\"你\"); Drawing girl = new Drawing(a,100,\"girl\"); you.start(); girl.start(); } } //账户 class Account{ int money;//余额 String name;//卡名 public Account(int money,String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ Account account;//账户 int drawingMoney;//取了多少钱 int nowMoney;//现在手里有多少钱 public Drawing(Account account,int drawingMoney,String name) { super(name); //定义线程名 this.account = account; this.drawingMoney = drawingMoney; } //取钱 // 如果直接在run方法前加锁，默认是锁的是调用该方法的对象，即Drawing类的实例化对象， // 而我们这里实际上是对account这个共享资源做修改，故应该对account加锁 @Override public void run() { // 是对account加锁，account称之为同步监视器 // 锁的对象就是变化的量，需要增删改操作的对象 synchronized (account){ //判断有没有钱 if(account.money-drawingMoney&lt;0) { System.out.println(Thread.currentThread().getName()+\"钱不够\"); return; } //sleep可以放大问题的发生性 try { Thread.sleep(1000); }catch(Exception e) { e.printStackTrace(); } //卡内余额=余额-你取的钱 account.money = account.money-drawingMoney; //你手里的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为\"+account.money); //这两个操作等价 //System.out.println(this.getName()+Thread.currentThread().getName()); System.out.println(this.getName()+\"手里的钱\"+nowMoney); } } } 输出结果：（不会出现负数了） //使用同步块实现线程安全的集合 public class UnsafeList { public static void main(String[] args) { // TODO Auto-generated method stub List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) { new Thread(()-&gt;{ //使用同步块 synchronized (list){ list.add(Thread.currentThread().getName()); } }).start(); } try { Thread.sleep(3000); }catch(Exception e) { e.printStackTrace(); } System.out.println(list.size()); } } 输出结果：（size正确） CopyOnWriteArrayListimport java.util.concurrent.CopyOnWriteArrayList; //测试JUC安全类型的集合,使用juc下的集合不用添加同步块就可实现线程的同步 public class TestJUC { public static void main(String[] args) { // TODO Auto-generated method stub CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) { new Thread(()-&gt;{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(3000); }catch(Exception e) { e.printStackTrace(); } System.out.println(list.size()); } } 死锁 注意：一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”问题！ 制造死锁： //死锁：多个线程相互抱着对方需要的资源，然后形成死锁 public class DeadLock { public static void main(String[] args) { Makeup g1 = new Makeup(0,\"灰姑娘\"); Makeup g2 = new Makeup(1,\"白雪公主\"); g1.start(); g2.start(); } } //口红 class Lipstick{ } //镜子 class Mirror{ } class Makeup extends Thread{ //需要的资源只有一份，用static来保证只有一份 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice; //选择 String girlName; //使用化妆品的人 Makeup(int chioce,String girlName){ this.choice = chioce; this.girlName = girlName; } @Override public void run(){ //化妆 try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } //化妆，互相持有对方的锁，就是需要拿到对象的资源 private void makeup() throws InterruptedException { if (choice==0){ synchronized (lipstick){ System.out.println(this.girlName+\"获得口红的锁\"); Thread.sleep(1000); //下面代码是在synchronized (lipstick){}里面 synchronized (mirror){ //一秒钟后想获得镜子 System.out.println(this.girlName+\"获得镜子的锁\"); } } }else{ synchronized (mirror){ //获得镜子的锁、 System.out.println(this.girlName+\"获得镜子的锁\"); Thread.sleep(2000); //下面代码是在synchronized (mirror){}里面 synchronized (lipstick){ //一秒后想获得镜子 System.out.println(this.girlName+\"获得口红的锁\"); } } } } } 这种代码就是产生死锁的关键点：(一个同步块包含两个对象) synchronized (lipstick){ System.out.println(this.girlName+\"获得口红的锁\"); Thread.sleep(1000); //下面代码是在synchronized (lipstick){}里面 synchronized (mirror){ //一秒钟后想获得镜子 System.out.println(this.girlName+\"获得镜子的锁\"); } 输出结果：(发生死锁) 解除死锁： //解除死锁 public class DeadLock { public static void main(String[] args) { Makeup g1 = new Makeup(0,\"灰姑娘\"); Makeup g2 = new Makeup(1,\"白雪公主\"); g1.start(); g2.start(); } } //口红 class Lipstick{ } //镜子 class Mirror{ } class Makeup extends Thread{ //需要的资源只有一份，用static来保证只有一份 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice; //选择 String girlName; //使用化妆品的人 Makeup(int chioce,String girlName){ this.choice = chioce; this.girlName = girlName; } @Override public void run(){ //化妆 try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } //化妆，互相持有对方的锁，就是需要拿到对象的资源 private void makeup() throws InterruptedException { if (choice==0){ synchronized (lipstick){ System.out.println(this.girlName+\"获得口红的锁\"); Thread.sleep(1000); } //将下面代码从上面同步块中拿出，即可化解死锁 synchronized (mirror){ //一秒钟后想获得镜子 System.out.println(this.girlName+\"获得镜子的锁\"); } }else{ synchronized (mirror){ //获得镜子的锁、 System.out.println(this.girlName+\"获得镜子的锁\"); Thread.sleep(2000); } //将下面代码从上面同步块中拿出，即可化解死锁 synchronized (lipstick){ //一秒后想获得镜子 System.out.println(this.girlName+\"获得口红的锁\"); } } } } 输出结果：（不发生死锁） 避免死锁的方法 Lock(锁) 下面使用可重入锁ReentrantLock对共享资源进行显示加锁、解锁： import java.util.concurrent.locks.ReentrantLock; public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); } } class TestLock2 implements Runnable{ int ticketNums = 10; //定义lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run(){ while(true){ try { lock.lock(); //加锁 if (ticketNums&gt;0){ try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } System.out.println(ticketNums--); }else{ break; } }finally { lock.unlock(); //解锁 } } } } 输出结果： synchronized与Lock的对比 线程协作生产者消费者问题 线程通信 解决方式1 //测试:生产者消费者模型 ---&gt;利用缓存区解决：管程法 public class TestPC { public static void main(String[] args) { SyncContainer container = new SyncContainer(); new ProviderThread(container).start(); new ConsumerThread(container).start(); } } //生产者 class ProviderThread extends Thread { //创建好的缓冲区 private SyncContainer syncContainer; public ProviderThread(SyncContainer syncContainer) { this.syncContainer = syncContainer; } @Override public void run() { for (int i = 1; i &lt;= 100; i++) { syncContainer.push(new Product(i)); System.out.println(\"生产了第\" + i + \"只鸡!\"); } } } //消费者 class ConsumerThread extends Thread { private SyncContainer syncContainer; public ConsumerThread(SyncContainer syncContainer) { this.syncContainer = syncContainer; } @Override public void run() { for (int i = 1; i &lt;= 100; i++) { Product pop = syncContainer.pop(); System.out.println(\"消费了第\"+ pop.getId() + \"号产品\"); } } } //产品 class Product { private int id; public Product(int id) { this.id = id; } public int getId() { return id; } public void setId(int id) { this.id = id; } } //缓冲区 class SyncContainer { //容器大小，product[0]为空，不使用，即最多放10件产品 Product[] products = new Product[11]; //容器计数器 int count = 0; //生产者放入产品 public synchronized void push(Product product){ //如果容器满了,就要等待消费者 //这里为什么减2才能实现最多连续存储10只鸡，而减1会出现最多连续存储11只鸡，我不清楚，比较费解 if(count == products.length-2) { //等待消费者消费,生产者等待 try { this.wait(); } catch (InterruptedException e){ e.printStackTrace(); } } //如果容器没有满,我们就要丢入产品 count++; products[count] = product; //可以通知消费者消费 this.notifyAll(); } //消费者消费产品 public synchronized Product pop(){ //判断容器是否为空 if(count == 0){ //等待生产者生产.消费者等待 try { this.wait(); } catch (InterruptedException e){ e.printStackTrace(); } } //如果可以消费 Product product = products[count]; count--; //通知生产者生产 this.notifyAll(); return product; } } 小疑问： count == products.length-2 //容器实际能存放10件产品，数组长度为11，减2则count为9，对应product[9],而实际可以存放至product[10],因为下标为0时，不存放产品。为什么-2才能最大连续打至出生产了第10只鸡，而-1会连续打印至生产第11只鸡 输出结果：（符合要求） 解决方式2 //测试生产者消费者问题2：信号灯法，标志位解决 public class TestPC2 { public static void main(String[] args) { TV tv = new TV(); new Player(tv).start(); new Watcher(tv).start(); } } //生产者--&gt;演员 class Player extends Thread{ TV tv; public Player(TV tv){ this.tv = tv; } @Override public void run(){ for (int i = 0;i&lt;20;i++){ if (i%2==0){ this.tv.play(\"快乐大本营播放中\"); }else{ this.tv.play(\"抖音：记录美好生活\"); } } } } //消费之--&gt;观众 class Watcher extends Thread{ TV tv; public Watcher(TV tv){ this.tv = tv; } @Override public void run(){ for (int i=0;i&lt;20;i++){ tv.watch(); } } } //产品--&gt;节目 class TV { //演员表演，观众等待 T //观众观看，演员等待 F String voice; //表演的节目 boolean flag = true; //flag为真时，观众等待，为假时演员等待 //表演 public synchronized void play(String voice){ if (!flag){ try{ this.wait(); }catch (InterruptedException e){ e.printStackTrace(); } } System.out.println(\"演员表演了：\"+voice); //通知观众观看 this.notifyAll(); //通知唤醒 this.voice = voice; this.flag = !this.flag; } //观看 public synchronized void watch(){ if (flag){ try { this.wait(); }catch (InterruptedException e){ e.printStackTrace(); } } System.out.println(\"观看了：\"+voice); //通知演员表演 this.notifyAll(); this.flag = !this.flag; } } 输出结果： 使用线程池 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; //测试线程池 public class TestPool { public static void main(String[] args) { //1.创建服务，创建线程池 //newFixedThreadPool 参数为线程池大小 ExecutorService service = Executors.newFixedThreadPool(10); //执行runnable接口实现类对象 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //2.关闭连接 service.shutdown(); } } class MyThread implements Runnable{ @Override public void run(){ System.out.println(Thread.currentThread().getName()); } } 输出结果： package com.ztx.gaoji; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; //JUC并发编程 import java.util.concurrent.*; public class TestCallable implements Callable&lt;Boolean&gt; { private String url; private String name; public TestCallable(String url,String name){ this.url = url; this.name = name; } @Override public Boolean call() throws Exception { //下载图片 WebDownloader webDownloader = new WebDownloader();//下载器 webDownloader.downloader(url,name);//下载文件的方式 System.out.println(\"下载了图片--&gt;\"+name); return true; } //启动线程 public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable t1 = new TestCallable(\"https://img2020.cnblogs.com/blog/1732557/202006/1732557-20200617142339091-966351471.png\",\"你好1.jpg\"); TestCallable t2 = new TestCallable(\"https://img2020.cnblogs.com/blog/1732557/202006/1732557-20200617142428143-1598758167.png\",\"你好2.jpg\"); TestCallable t3 = new TestCallable(\"https://img2020.cnblogs.com/blog/1732557/202006/1732557-20200617142459110-1793347461.png\",\"你好3.jpg\"); //创建执行服务： ExecutorService ser = Executors.newFixedThreadPool(3); //提交执行： Future&lt;Boolean&gt; result1 = ser.submit(t1); Future&lt;Boolean&gt; result2 = ser.submit(t2); Future&lt;Boolean&gt; result3 = ser.submit(t3); //获取结果 boolean r1 = result1.get(); boolean r2 = result2.get(); boolean r3 = result3.get(); //判断线程是否顺利结束或者有异常 System.out.println(r1); System.out.println(r2); System.out.println(r3); //关闭服务 ser.shutdownNow(); } } //下载图片 class WebDownloader{ //下载方法 public void downloader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); //输出异常信息 System.out.println(\"downloader方法出现异常\"); } } } 输出结果：","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Linux基础","slug":"Linux基础","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:26:15.391Z","comments":true,"path":"posts/ea4e9711.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9711.html","excerpt":"","text":"入门概述 我们为什么要学习Linux linux诞生了这么多年，以前还喊着如何能取代windows系统，现在这个口号已经小多了，任何事物发展都有其局限性都有其天花板。就如同在国内再搞一个社交软件取代腾讯一样，想想而已基本不可能，因为用户已经习惯于使用微信交流，不是说技术上实现不了解而是老百姓已经习惯了，想让他们不用，即使他们自己不用亲戚朋友还是要用，没有办法的事情。 用习惯了windows操作系统，再让大家切换到别的操作系统基本上是不可能的事情，改变一个人已经养成的习惯太难。没有办法深入到普通老百姓的生活中，并不意味着linux就没有用武之地了。在服务器端，在开发领域linux倒是越来越受欢迎，很多程序员都觉得不懂点linux都觉得不好意思，linux在开源社区的地位依然岿然不动。 尤其是作为一个后端程序员，是必须要掌握Linux的，因为这都成为了你找工作的基础门槛了，所以不得不学习！ Linux 简介 Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux 发行版 Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。 Linux 应用领域 今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。 目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。 巴西联邦政府由于支持 Linux 而世界闻名。 有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。 印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。 中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。 在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。 葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。 法国和德国同样开始逐步采用 Linux。 Linux vs Windows 环境搭建Linux 的安装，安装步骤比较繁琐，现在其实云服务器挺普遍的，价格也便宜，如果直接不想搭建，也可以直接买一台学习用用！ 安装CentOS（虚拟机安装，耗资源） 1、可以通过镜像进行安装！ 2、可以使用我已经制作好的镜像！视频中讲解了该种方式！ 3、安装 VMware 虚拟机软件，然后打开我们的镜像即可使用！ 购买云服务器（推荐） 虚拟机安装后占用空间，也会有些卡顿，我们作为程序员其实可以选择购买一台自己的服务器，这样的话更加接近真实线上工作； 1、阿里云购买服务器：https://www.aliyun.com/minisite/goods?userCode=0phtycgr 2、购买完毕后，获取服务器的ip地址，重置服务器密码，就可以远程登录了 3、下载 xShell 工具，进行远程连接使用！连接成功效果如下： 注意事项： 如果要打开端口，需要在阿里云的安全组面板中开启对应的出入规则，不然的话会被阿里拦截！ 如果前期不好操作，可以推荐安装宝塔面板，傻瓜式管理服务器 安装教程：https://www.bt.cn/bbs/thread-19376-1-1.html 1、开启对应的端口 2、一键安装 3、安装完毕后会得到远程面板的地址，账号，密码，就可以登录了 4、登录之后就可以可视化的安装环境和部署网站！ 关于域名 如果自己的网站想要上线，就一定要购买一个域名然后进行备案； 备案的话需要一些认证和时间，备完完毕后，就可以解析到自己的网站了，这个时候就可以使用域名来进行服务器的访问！ 走近Linux系统 开机登录 开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。 开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！ 一般来说，用户的登录方式有三种： 命令行登录 ssh登录 图形界面登录 最高权限账户为 root，可以操作一切！ 关机 在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。 关机指令为：shutdown ； sync # 将数据由内存同步到硬盘中。shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机shutdown –h now # 立马关机shutdown –h 20:25 # 系统会在今天20:25关机shutdown –h +10 # 十分钟后关机shutdown –r now # 系统立马重启shutdown –r +10 # 系统十分钟后重启reboot # 就是重启，等同于 shutdown –r nowhalt # 关闭系统，等同于shutdown –h now 和 poweroff 最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。 系统目录结构 登录系统后，在当前命令窗口下输入命令： ls / 你会看到如下图所示： 树状目录结构：（Linux的一切资源都挂载在这个 / 根节点下） 以下是对这些目录的解释： /bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 /tmp：这个目录是用来存放一些临时文件的。 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。 目录管理 绝对路径和相对路径 我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。 其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。 在开始本教程前我们需要先知道什么是绝对路径与相对路径。 绝对路径： 路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。 相对路径： 路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！ 处理目录的常用命令 接下来我们就来看几个常见的处理目录的命令吧： ls: 列出目录 cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称 你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。 ls （列出目录） 在Linux系统当中， ls 命令可能是最常被运行的。 语法： [root@www ~]# ls [-aAdfFhilnrRSt] 目录名称 选项与参数： -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 将目录下的所有文件列出来(含属性与隐藏档) [root@www ~]# ls -al ~ cd （切换目录） cd是Change Directory的缩写，这是用来变换工作目录的命令。 语法： cd [相对路径或绝对路径] 测试： # 切换到用户目录下[root@kuangshen /]# cd home # 使用 mkdir 命令创建 kuangstudy 目录[root@kuangshen home]# mkdir kuangstudy# 进入 kuangstudy 目录[root@kuangshen home]# cd kuangstudy# 回到上一级[root@kuangshen kuangstudy]# cd ..# 回到根目录[root@kuangshen kuangstudy]# cd /# 表示回到自己的家目录，亦即是 /root 这个目录[root@kuangshen kuangstudy]# cd ~ 接下来大家多操作几次应该就可以很好的理解 cd 命令的。 pwd ( 显示目前所在的目录 ) pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。 [root@kuangshen kuangstudy]#pwd [-P] 选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。 测试： # 单纯显示出目前的工作目录[root@kuangshen ~]# pwd/root# 如果是链接，要显示真实地址，可以使用 -P参数[root@kuangshen /]# cd bin[root@kuangshen bin]# pwd -P/usr/bin mkdir （创建新目录） 如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。 mkdir [-mp] 目录名称 选项与参数： -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ 测试： # 进入我们用户目录下[root@kuangshen /]# cd /home# 创建一个 test 文件夹[root@kuangshen home]# mkdir test# 创建多层级目录[root@kuangshen home]# mkdir test1/test2/test3/test4mkdir: cannot create directory ‘test1/test2/test3/test4’:No such file or directory # &lt;== 没办法直接创建此目录啊！# 加了这个 -p 的选项，可以自行帮你创建多层目录！[root@kuangshen home]# mkdir -p test1/test2/test3/test4# 创建权限为 rwx--x--x 的目录。[root@kuangshen home]# mkdir -m 711 test2[root@kuangshen home]# ls -ldrwxr-xr-x 2 root root 4096 Mar 12 21:55 testdrwxr-xr-x 3 root root 4096 Mar 12 21:56 test1drwx--x--x 2 root root 4096 Mar 12 21:58 test2 rmdir ( 删除空的目录 ) 语法： rmdir [-p] 目录名称 选项与参数：**-p ：**连同上一级『空的』目录也一起删除 测试： # 看看有多少目录存在？[root@kuangshen home]# ls -ldrwxr-xr-x 2 root root 4096 Mar 12 21:55 testdrwxr-xr-x 3 root root 4096 Mar 12 21:56 test1drwx--x--x 2 root root 4096 Mar 12 21:58 test2# 可直接删除掉，没问题[root@kuangshen home]# rmdir test# 因为尚有内容，所以无法删除！[root@kuangshen home]# rmdir test1rmdir: failed to remove ‘test1’: Directory not empty# 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。[root@kuangshen home]# rmdir -p test1/test2/test3/test4 注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录，后面我们会将！ cp ( 复制文件或目录 ) 语法： [root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory 选项与参数： -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -r：递归持续复制，用於目录的复制行为；(常用) -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。 -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ 测试： # 找一个有文件的目录，我这里找到 root目录[root@kuangshen home]# cd /root[root@kuangshen ~]# lsinstall.sh[root@kuangshen ~]# cd /home# 复制 root目录下的install.sh 到 home目录下[root@kuangshen home]# cp /root/install.sh /home[root@kuangshen home]# lsinstall.sh# 再次复制，加上-i参数，增加覆盖询问？[root@kuangshen home]# cp -i /root/install.sh /homecp: overwrite ‘/home/install.sh’? y # n不覆盖，y为覆盖 rm ( 移除文件或目录 ) 语法： rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ 测试： # 将刚刚在 cp 的实例中创建的 install.sh删除掉！[root@kuangshen home]# rm -i install.shrm: remove regular file ‘install.sh’? y# 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！# 尽量不要在服务器上使用 rm -rf / mv ( 移动文件与目录，或修改名称 ) 语法： [root@www ~]# mv [-fiu] source destination[root@www ~]# mv [options] source1 source2 source3 .... directory 选项与参数： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 测试： # 复制一个文件到当前目录[root@kuangshen home]# cp /root/install.sh /home# 创建一个文件夹 test[root@kuangshen home]# mkdir test# 将复制过来的文件移动到我们创建的目录，并查看[root@kuangshen home]# mv install.sh test[root@kuangshen home]# lstest[root@kuangshen home]# cd test[root@kuangshen test]# lsinstall.sh# 将文件夹重命名，然后再次查看！[root@kuangshen test]# cd ..[root@kuangshen home]# mv test mvtest[root@kuangshen home]# lsmvtest 基本属性 看懂文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： 实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档 ( link file )； 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图）： 从左至右用0-9这些数字来表示。 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中： 第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限； 第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限； 第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。 修改文件属性 1、chgrp：更改文件属组 chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 2、chown：更改文件属主，也可以同时更改文件属组 chown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名 3、chmod：更改文件9个属性 chmod [-R] xyz 文件或目录 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 chmod 770 filename 可以自己下去多进行测试！ 文件内容查看 概述 Linux系统中使用以下命令来查看文件的内容： cat 由第一行开始显示文件内容 》 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。 cat 由第一行开始显示文件内容 语法： cat [-AbEnTv] 选项与参数： -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 测试： # 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/[root@kuangshen ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0BOOTPROTO=dhcpONBOOT=yes tac tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如： [root@kuangshen ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0ONBOOT=yesBOOTPROTO=dhcpDEVICE=eth0 nl 显示行号 语法： nl [-bnw] 文件 选项与参数： -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 测试： [root@kuangshen ~]# nl /etc/sysconfig/network-scripts/ifcfg-eth01DEVICE=eth02BOOTPROTO=dhcp3ONBOOT=yes more 一页一页翻动 在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 [root@kuangshen etc]# more /etc/csh.login....(中间省略)....--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令 less 一页一页翻动，以下实例输出/etc/man.config文件的内容： less运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序； [root@kuangshen etc]# more /etc/csh.login....(中间省略)....: # 这里可以等待你输入命令！ head 取出文件前面几行 语法： head [-n number] 文件 选项与参数：**-n** 后面接数字，代表显示几行的意思！ 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样： [root@kuangshen etc]# head -n 20 /etc/csh.login tail 取出文件后面几行 语法： tail [-n number] 文件 选项与参数： -n ：后面接数字，代表显示几行的意思 默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样： [root@kuangshen etc]# tail -n 20 /etc/csh.login 拓展：Linux 链接概念 Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。 情况下，ln 命令产生硬链接。 硬连接 硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 软连接 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 测试： [root@kuangshen /]# cd /home[root@kuangshen home]# touch f1 # 创建一个测试文件f1[root@kuangshen home]# lsf1[root@kuangshen home]# ln f1 f2 # 创建f1的一个硬连接文件f2[root@kuangshen home]# ln -s f1 f3 # 创建f1的一个符号连接文件f3[root@kuangshen home]# ls -li # -i参数显示文件的inode节点信息397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f1397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f2397248 lrwxrwxrwx 1 root root 2 Mar 13 00:50 f3 -&gt; f1 从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。 # echo 字符串输出 &gt;&gt; f1 输出到 f1文件[root@kuangshen home]# echo \"I am f1 file\" &gt;&gt;f1[root@kuangshen home]# cat f1I am f1 file[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3I am f1 file[root@kuangshen home]# rm -f f1[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3cat: f3: No such file or directory 通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效； 依此您可以做一些相关的测试，可以得到以下全部结论： 删除符号连接f3,对f1,f2无影响； 删除硬连接f2，对f1,f3也无影响； 删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 同时删除原文件f1,硬连接f2，整个文件会真正的被删除。 什么是Vim编辑器 Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。 vim 键盘图： 三种使用模式 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。这三种模式的作用分别是： 命令模式： 用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式： 在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 简单的说，我们可以将这三个模式想成底下的图标来表示： 上手体验一下，在home目录下测试 如果你想要使用 vi 来建立一个名为 kuangstudy.txt 的文件时，你可以这样做： [root@kuangshen home]# vim kuangstudy.txt 然后就会进入文件 按下 i 进入输入模式(也称为编辑模式)，开始编辑文字 在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！ 在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。 这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。 按下 ESC 按钮回到一般模式 好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！ 在一般模式中按下 :wq 储存后离开 vim！ OK! 这样我们就成功创建了一个 kuangstudy.txt 的文件。 Vim 按键说明 除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n&lt; space&gt; 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！(常用) n&lt; Enter&gt; n 为数字。光标向下移动 n 行(常用) 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 删除、复制与粘贴 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 第二部分：一般模式切换到编辑模式的可用的按钮说明 进入输入或取代的编辑模式 i, I 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用) a, A 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) o, O 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用) r, R 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) [Esc] 退出编辑模式，回到一般模式中(常用) 第三部分：一般模式切换到指令行模式的可用的按钮说明 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！ :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ 账号管理 简介 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个唯一的用户名和各自的口令。 用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 用户账号的管理 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。 添加账号 useradd useradd 选项 用户名 参数说明： 选项 : -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -m 使用者目录如不存在则自动建立。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名 : 指定新账号的登录名。 测试： # 此命令创建了一个用户kuangshen，其中-m选项用来为登录名kuangshen产生一个主目录 /home/kuangshen[root@kuangshen home]# useradd -m kuangshen 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 Linux下如何切换用户 1.切换用户的命令为：su username 【username是你的用户名哦】 2.从普通用户切换到root用户，还可以使用命令：sudo su 3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令 4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】 $表示普通用户 #表示超级用户，也就是root用户 删除帐号 如果一个用户的账号不再使用，可以从系统中删除。 删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。 删除一个已有的用户账号使用userdel命令，其格式如下： userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 [root@kuangshen home]# userdel -r kuangshen 此命令删除用户kuangshen在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 修改帐号 修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 修改已有用户的信息使用usermod命令，其格式如下： usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 例如： # usermod -s /bin/ksh -d /home/z –g developer kuangshen 此命令将用户kuangshen的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。 用户口令的管理 用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。 命令的格式为： passwd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 如果默认用户名，则修改当前用户的口令。 例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令： $ passwdOld password:******New password:*******Re-enter new password:******* 如果是超级用户，可以用下列形式指定任何用户的口令： # passwd kuangshenNew password:*******Re-enter new password:******* 普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。 为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。 为用户指定空口令时，执行下列形式的命令： # passwd -d kuangshen 此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。 passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如： # passwd -l kuangshen 用户组管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 增加一个新的用户组使用groupadd命令 groupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 实例1： # groupadd group1 此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。 实例2： # groupadd -g 101 group2 此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。 如果要删除一个已有的用户组，使用groupdel命令 groupdel 用户组 例如： # groupdel group1 此命令从系统中删除组group1。 修改用户组的属性使用groupmod命令 groupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 # 此命令将组group2的组标识号修改为102。groupmod -g 102 group2# 将组group2的标识号改为10000，组名修改为group3。groupmod –g 10000 -n group3 group2 切换组 如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如： $ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。 /etc/passwd 完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。 下面分别介绍这些文件的内容。 /etc/passwd文件是用户管理工作涉及的最重要的一个文件。 Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。 这个文件对所有用户都是可读的。它的内容类似下面的例子： ＃ cat /etc/passwdroot:x:0:0:Superuser:/:daemon:x:1:1:System daemons:/etc:bin:x:2:2:Owner of system commands:/bin:sys:x:3:3:Owner of system files:/usr/sys:adm:x:4:4:System accounting:/usr/adm:uucp:x:5:5:UUCP administrator:/usr/lib/uucp:auth:x:7:21:Authentication administrator:/tcb/files/auth:cron:x:9:16:Cron daemon:/usr/spool/cron:listen:x:37:4:Network daemon:/usr/net/nls:lp:x:71:18:Printer administrator:/usr/spool/lp: 从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 1）”用户名”是代表用户账号的字符串。 通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。 为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。 2）“口令”一些系统中，存放着加密后的用户口令字。 虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。 3）“用户标识号”是一个整数，系统内部用它来标识用户。 一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。 通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。 4）“组标识号”字段记录的是用户所属的用户组。 它对应着/etc/group文件中的一条记录。 5)“注释性描述”字段记录着用户的一些个人情况。 例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。 6)“主目录”，也就是用户的起始工作目录。 它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。 7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。 Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。 系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。 用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。 利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。 8)系统中有一类用户称为伪用户（pseudo users）。 这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。 常见的伪用户如下所示： 伪 用 户 含 义bin 拥有可执行的用户命令文件sys 拥有系统文件adm 拥有帐户文件uucp UUCP使用lp lp或lpd子系统使用nobody NFS使用 /etc/shadow 1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。 由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。 2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生 它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是： 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 “登录名”是与/etc/passwd文件中的登录名相一致的用户账号 “口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。 “最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。 “最小时间间隔”指的是两次修改口令之间所需的最小天数。 “最大时间间隔”指的是口令保持有效的最大天数。 “警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。 “不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。 “失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。 /etc/group 用户组的所有信息都存放在/etc/group文件中。 将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。 每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。 当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。 用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。 用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 “组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 “口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。 “组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。 “组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 磁盘管理 概述 Linux磁盘管理好坏直接关系到整个系统的性能问题。 Linux磁盘管理常用命令为 df、du。 df ：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 df df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 语法： df [-ahikHTm] [目录或文件名] 选项与参数： -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； -k ：以 KBytes 的容量显示各文件系统； -m ：以 MBytes 的容量显示各文件系统； -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -H ：以 M=1000K 取代 M=1024K 的进位方式； -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出； -i ：不用硬盘容量，而以 inode 的数量来显示 测试： # 将系统内所有的文件系统列出来！# 在 Linux 底下如果 df 没有加任何选项# 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！[root@kuangshen /]# dfFilesystem 1K-blocks Used Available Use% Mounted ondevtmpfs 889100 0 889100 0% /devtmpfs 899460 704 898756 1% /dev/shmtmpfs 899460 496 898964 1% /runtmpfs 899460 0 899460 0% /sys/fs/cgroup/dev/vda1 41152812 6586736 32662368 17% /tmpfs 179896 0 179896 0% /run/user/0 # 将容量结果以易读的容量格式显示出来[root@kuangshen /]# df -hFilesystem Size Used Avail Use% Mounted ondevtmpfs 869M 0 869M 0% /devtmpfs 879M 708K 878M 1% /dev/shmtmpfs 879M 496K 878M 1% /runtmpfs 879M 0 879M 0% /sys/fs/cgroup/dev/vda1 40G 6.3G 32G 17% /tmpfs 176M 0 176M 0% /run/user/0 # 将系统内的所有特殊文件格式及名称都列出来[root@kuangshen /]# df -aTFilesystem Type 1K-blocks Used Available Use% Mounted onsysfs sysfs 0 0 0 - /sysproc proc 0 0 0 - /procdevtmpfs devtmpfs 889100 0 889100 0% /devsecurityfs securityfs 0 0 0 - /sys/kernel/securitytmpfs tmpfs 899460 708 898752 1% /dev/shmdevpts devpts 0 0 0 - /dev/ptstmpfs tmpfs 899460 496 898964 1% /runtmpfs tmpfs 899460 0 899460 0% /sys/fs/cgroupcgroup cgroup 0 0 0 - /sys/fs/cgroup/systemdpstore pstore 0 0 0 - /sys/fs/pstorecgroup cgroup 0 0 0 - /sys/fs/cgroup/freezercgroup cgroup 0 0 0 - /sys/fs/cgroup/cpusetcgroup cgroup 0 0 0 - /sys/fs/cgroup/hugetlbcgroup cgroup 0 0 0 - /sys/fs/cgroup/blkiocgroup cgroup 0 0 0 - /sys/fs/cgroup/net_cls,net_priocgroup cgroup 0 0 0 - /sys/fs/cgroup/memorycgroup cgroup 0 0 0 - /sys/fs/cgroup/pidscgroup cgroup 0 0 0 - /sys/fs/cgroup/cpu,cpuacctcgroup cgroup 0 0 0 - /sys/fs/cgroup/devicescgroup cgroup 0 0 0 - /sys/fs/cgroup/perf_eventconfigfs configfs 0 0 0 - /sys/kernel/config/dev/vda1 ext4 41152812 6586748 32662356 17% /systemd-1 - - - - - /proc/sys/fs/binfmt_miscmqueue mqueue 0 0 0 - /dev/mqueuedebugfs debugfs 0 0 0 - /sys/kernel/debughugetlbfs hugetlbfs 0 0 0 - /dev/hugepagestmpfs tmpfs 179896 0 179896 0% /run/user/0binfmt_misc binfmt_misc 0 0 0 - /proc/sys/fs/binfmt_misc # 将 /etc 底下的可用的磁盘容量以易读的容量格式显示[root@kuangshen /]# df -h /etcFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 6.3G 32G 17% / du Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。 语法： du [-ahskm] 文件或目录名称 选项与参数： -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； 测试： # 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:# 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。[root@kuangshen home]# du16./redis8./www/.oracle_jre_usage # 包括隐藏文件的目录24./www48. # 这个目录(.)所占用的总量 # 将文件的容量也列出来[root@kuangshen home]# du -a4./redis/.bash_profile4./redis/.bash_logout ....中间省略....4./kuangstudy.txt # 有文件的列表了48. # 检查根目录底下每个目录所占用的容量[root@kuangshen home]# du -sm /*0/bin146/boot.....中间省略....0/proc.....中间省略....1/tmp3026/usr # 系统初期最大就是他了啦！513/var2666/www 通配符 * 来代表每个目录。 与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。 磁盘挂载与卸除 根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载” Linux 的磁盘挂载使用mount命令，卸载使用umount命令。 磁盘挂载语法： mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 测试： # 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！[root@www ~]# mkdir /mnt/hdc6[root@www ~]# mount /dev/hdc6 /mnt/hdc6[root@www ~]# dfFilesystem 1K-blocks Used Available Use% Mounted on/dev/hdc6 1976312 42072 1833836 3% /mnt/hdc6 磁盘卸载命令 umount 语法： umount [-fn] 装置文件名或挂载点 选项与参数： -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -n ：不升级 /etc/mtab 情况下卸除。 卸载/dev/hdc6 [root@www ~]# umount /dev/hdc6 jdk安装（rpm安装）1、rpm下载地址http://www.oracle.com/technetwork/java/javase/downloads/index.html 2、如果有安装openjdk 则卸载 [root@kuangshen ~]# java -versionjava version \"1.8.0_121\"Java(TM) SE Runtime Environment (build 1.8.0_121-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)# 检查[root@kuangshen ~]# rpm -qa|grep jdkjdk1.8.0_121-1.8.0_121-fcs.x86_64# 卸载 -e --nodeps 强制删除[root@kuangshen ~]# rpm -e --nodeps jdk1.8.0_121-1.8.0_121-fcs.x86_64[root@kuangshen ~]# java -version-bash: /usr/bin/java: No such file or directory # OK 3、安装JDK # 安装java rpm[root@kuangshen kuangshen]# rpm -ivh jdk-8u221-linux-x64.rpm# 安装完成后配置环境变量 文件：/etc/profileJAVA_HOME=/usr/java/jdk1.8.0_221-amd64CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/libPATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/binexport PATH CLASSPATH JAVA_HOME# 保存退出# 让新增的环境变量生效！source /etc/profile# 测试 java -version[root@kuangshen java]# java -versionjava version \"1.8.0_221\"Java(TM) SE Runtime Environment (build 1.8.0_221-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) Tomcat安装（解压缩安装）1、安装好了Java环境后我们可以测试下Tomcat！准备好Tomcat的安装包！ 2、将文件移动到/usr/tomcat/下，并解压！ [root@kuangshen kuangshen]# mv apache-tomcat-9.0.22.tar.gz /usr[root@kuangshen kuangshen]# cd /usr[root@kuangshen usr]# lsapache-tomcat-9.0.22.tar.gz[root@kuangshen usr]# tar -zxvf apache-tomcat-9.0.22.tar.gz # 解压 3、运行Tomcat，进入bin目录，和我们以前在Windows下看的都是一样的 # 执行：startup.sh --&gt;启动tomcat# 执行：shutdown.sh --&gt;关闭tomcat./startup.sh./shutdown.sh 4、确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！ # 查看firewall服务状态systemctl status firewalld# 开启、重启、关闭、firewalld.service服务# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all # 查看全部信息firewall-cmd --list-ports # 只看端口信息# 开启端口开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent重启防火墙：systemctl restart firewalld.service命令含义：--zone #作用域--add-port=80/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效 安装Docker（yum安装） 基于 CentOS 7 安装 官网安装参考手册：https://docs.docker.com/install/linux/docker-ce/centos/ 确定你是CentOS7及以上版本 [root@192 Desktop]# cat /etc/redhat-releaseCentOS Linux release 7.2.1511 (Core) yum安装gcc相关（需要确保 虚拟机可以上外网 ） yum -y install gccyum -y install gcc-c++ 卸载旧版本 yum -y remove docker docker-common docker-selinux docker-engine# 官网版本yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装需要的软件包 yum install -y yum-utils device-mapper-persistent-data lvm2 设置stable镜像仓库 # 错误yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo## 报错[Errno 14] curl#35 - TCP connection reset by peer[Errno 12] curl#35 - Timeout# 正确推荐使用国内的yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新yum软件包索引 yum makecache fast 安装Docker CE yum -y install docker-ce docker-ce-cli containerd.io 启动docker systemctl start docker 测试 docker versiondocker run hello-worlddocker images 宝塔面板安装https://www.bilibili.com/video/av91821322","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"JUC","slug":"JUC","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:25:24.553Z","comments":true,"path":"posts/ea4e9788.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9788.html","excerpt":"","text":"1.什么是JUC java.util工具包 业务: 普通的线程代码, 之前都是用的thread或者runnable接口 但是相比于callable来说,thread没有返回值,且效率没有callable高 2.线程和进程 线程,进程 进程 : 一个运行中的程序的集合; 一个进程往往可以包含多个线程,至少包含一个线程 java默认有几个线程? 两个， main线程 和 gc线程 线程 : 线程（thread）是操作系统能够进行运算调度的最小单位。 对于java而言如何创建thread: 继承自thread,实现runnable接口,实现callable接口,线程池创建 Java真的可以开启线程吗? 开不了的,底层是用native关键词修饰.调用本地实现 public synchronized void start() { /** * This method is not invoked for the main method thread or \"system\" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } //本地方法,调用底层c++, java无法操作硬件 private native void start0(); 并发,并行 并发编程: 并发和并行 并发(多线程操作同一个资源,交替执行) CPU一核, 模拟出来多条线程,天下武功,唯快不破,快速交替 并行(多个人一起行走, 同时进行) CPU多核,多个线程同时进行 ; 使用线程池操作 public static void main(String[] args) { //获取CPU核数 //CPU 密集型,IO密集型 System.out.println(Runtime.getRuntime().availableProcessors()); } 并发编程的本质: 充分利用CPU的资源 所有的公司都很看重! 线程有几个状态? public enum State { // 新生 NEW, // 运行 RUNNABLE, // 阻塞 BLOCKED, // 等待 WAITING, //超时等待 TIMED_WAITING, //终止 TERMINATED; } wait/sleep的区别 1.来自不同的类 wait来自object类, sleep来自线程类 2.关于锁的释放 wait会释放锁, sleep不会释放锁 3.使用的范围不同 wait必须在同步代码块中 sleep可以在任何地方睡 4.是否需要捕获异常 wait不需要捕获异常 sleep需要捕获异常 3.Lock锁(重点)在java的锁的实现上就有共享锁和独占锁的区别，而这些实现都是基于AbstractQueuedSynchronizer对于共享同步和独占同步的支持。 独占模式 AbstractQueuedSynchronizer（AQS）使用一个volatile类型的int来作为同步变量，任何想要获得锁的线程都需要来竞争该变量，获得锁的线程可以继续业务流程的执行，而没有获得锁的线程会被放到一个FIFO的队列中去，等待再次竞争同步变量来获得锁。 锁的独占与共享 java并发包提供的加锁模式分为独占锁和共享锁，独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁。共享锁，则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。AQS的内部类Node定义了两个常量SHARED（共享）和EXCLUSIVE（独占），他们分别标识 AQS队列中等待线程的锁获取模式。 很显然，独占锁是一种悲观保守的加锁策略，它避免了读/写冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 java 的并发包中提供了ReadWriteLock，读-写锁。**它允许一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行**。 锁的公平与非公平 锁的公平与非公平，是指线程请求获取锁的过程中，是否允许插队。在公平锁上，线程将按他们发出请求的顺序来获得锁；而非公平锁则允许在线程发出请求后立即尝试获取锁，如果可用则可直接获取锁，尝试失败才进行排队等待。ReentrantLock提供了两种锁获取方式，FairSyn和NofairSync。**结论：ReentrantLock是以独占锁的加锁策略实现的互斥锁，同时它提供了公平和非公平两种锁获取方式**。 AQS提供的模板方法 AQS提供了独占锁和共享锁必须实现的方法，具有独占锁功能的子类，它必须实现tryAcquire、tryRelease、isHeldExclusively等；共享锁功能的子类，必须实现tryAcquireShared和tryReleaseShared等方法，带有Shared后缀的方法都是支持共享锁加锁的语义。Semaphore是一种共享锁，ReentrantLock是一种独占锁。 独占锁获取锁时，设置节点模式为Node.EXCLUSIVE public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 共享锁获取锁，节点模式则为Node.SHARED private void doAcquireShared(int arg) { final Node node = addWaiter(Node.SHARED); boolean failed = true; ..... } 对ConditionObject的认识 ReentrantLock是独占锁，而且AQS的ConditionObject只能与ReentrantLock一起使用，它是为了支持条件队列的锁更方便。ConditionObject的signal和await方法都是基于独占锁的，如果线程非锁的独占线程，则会抛出IllegalMonitorStateException。例如signalAll源码： public final void signalAll() { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignalAll(first); } 我在想，既然Condtion是为了支持Lock的，为什么ConditionObject不作为ReentrantLock的内部类呢？对于实现锁功能的子类，直接扩展它就可以实现对条件队列的支持。但是，对于其它非锁语义的实现类如Semaphore、CountDownLatch等类来说，条件队列是无用的，也会给开发者扩展AQS带来困惑。总之，是各有利弊，大师们的思想，还需要仔细揣摩啊！ 共享模式和独占模式的区别在于，独占模式只允许一个线程获得资源，而共享模式允许多个线程获得资源。 传统synchronized 本质: 队列和锁, synchronized 放在方法上锁的是this,放在代码块中锁的是()里面的对象 package com.kuang.demo01; // 基本的卖票例子 import java.time.OffsetDateTime; /*** 真正的多线程开发，公司中的开发，降低耦合性 * 线程就是一个单独的资源类，没有任何附属的操作！ * 1、 属性、方法 */ public class SaleTicketDemo01 { public static void main(String[] args) { // 并发：多线程操作同一个资源类, 把资源类丢入线程 Ticket ticket = new Ticket(); // @FunctionalInterface 函数式接口，jdk1.8 lambda表达式 (参数)-&gt;{ 代码 } new Thread(()-&gt;{ for (int i = 1; i &lt; 40 ; i++) { ticket.sale(); } },\"A\").start(); new Thread(()-&gt;{ for (int i = 1; i &lt; 40 ; i++) { ticket.sale(); } },\"B\").start(); new Thread(()-&gt;{ for (int i = 1; i &lt; 40 ; i++) { ticket.sale(); } },\"C\").start(); } } // 资源类 OOP class Ticket { // 属性、方法 private int number = 30; // 卖票的方式 // synchronized 本质: 队列，锁 public synchronized void sale(){ if (number&gt;0) { System.out.println(Thread.currentThread().getName()+\"卖出了\"+(number- -)+\"票,剩余：\"+number); } } } Lock 接口 实现类 什么是 “可重入”，可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。 ReentrantLock构造器 public ReentrantLock() { sync = new NonfairSync(); //无参默认非公平锁 } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync();//传参为true为公平锁 } 公平锁: 十分公平: 可以先来后到,一定要排队 非公平锁: 十分不公平,可以插队(默认) public class SaleTicketDemo { public static void main(String[] args) { // 并发：多线程操作同一个资源类, 把资源类丢入线程 Ticket ticket = new Ticket(); // @FunctionalInterface 函数式接口，jdk1.8 lambda表达式 (参数)-&gt;{ 代码 } new Thread(()-&gt;{for(int i = 0; i &lt; 40; i++) {ticket.sale();}}, \"a\").start(); new Thread(()-&gt;{for(int i = 0; i &lt; 40; i++) ticket.sale();}, \"b\").start(); new Thread(()-&gt;{for(int i = 0; i &lt; 40; i++) ticket.sale();}, \"c\").start(); } } class Ticket { // Lock三部曲 // 1、 new ReentrantLock(); // 2、 lock.lock(); // 加锁 // 3、 finally=&gt; lock.unlock(); // 解锁 private int ticketNum = 30; private Lock lock = new ReentrantLock(); public void sale() { lock.lock(); try { if (this.ticketNum &gt; 0) { System.out.println(Thread.currentThread().getName() + \"购得第\" + ticketNum-- + \"张票, 剩余\" + ticketNum + \"张票\"); } } finally { lock.unlock(); } } } synchronized和lock锁的区别 synchronized内置的java关键字,Lock是一个java类 synchronized无法判断获取锁的状态, Lock可以判断是否获取到了锁 synchronized会自动释放锁,Lock必须要手动释放锁!如果不是释放锁,会产生死锁，ReentrantLock 和 synchronized 不一样，需要手动释放锁，所以使用 ReentrantLock的时候一定要手动释放锁，并且加锁次数和释放次数要一样 0synchronized 线程1(获得锁,阻塞),线程2(等待); Lock锁就不一定会等待下去 synchronized 可重入锁,不可以中断的,非公平的; Lock锁,可重入的,可以判断锁,非公平(可自己设置为公平锁); synchronized 适合锁少量的代码同步问题,Lock 适合锁大量的同步代码 4.生产者和消费者问题面试高频: 单例模式, 八大排序,生产者消费者,死锁 Synchronized实现 wait notify package com.xu.PC; public class ProducerAndConsumer { public static void main(String[] args) { Resource resource = new Resource(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"A\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"B\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"C\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"D\").start(); } } class Resource { private int num = 0; public synchronized void increment() throws InterruptedException { // if (num != 0) while (num!=0){//判断是否有值 this.wait(); //有资源，不生产，进入睡眠 } num++; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+num); this.notifyAll();//唤醒其他线程,叫其他线程来消费资源 } public synchronized void decrement() throws InterruptedException { // if (num == 0) while (num == 0) {//判断是否为0 this.wait(); //无资源，不消费，进入睡眠 } num--; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+num); this.notifyAll();//唤醒其他线程，叫其他线程来生产资源 } } 注意：在多个线程通信时，必须使用 while 判断防止虚假唤醒。 if判断改为while判断 因为if只会执行一次，线程醒来会接着向下执行if（）外边的 而while不会，会重新判断条件是否满足，满足才会向下执行while（）外边的 JUC版本生产者和消费者问题 通过Lock 找到 Condition（监视者） 任何一个新的技术,绝对不是仅仅覆盖了原来的技术,一定有优势和补充 package com.xu.PC; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ProducerAndConsumer2 { public static void main(String[] args) { Resource2 resource = new Resource2(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"A\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"C\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"D\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"B\").start(); } } class Resource2 { private int num = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition();//监视器 public void increment() throws InterruptedException { lock.lock(); try { while (num!=0){//判断是否有值 condition.await(); } num++; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+num); condition.signalAll();//唤醒其他线程 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public void decrement() throws InterruptedException { lock.lock(); try { while (num == 0) {//判断是否为0 condition.await(); } num--; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+num); condition.signalAll();//唤醒其他线程 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } condition的精准通知和唤醒线程 package com.xu.PC; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ProducerAndConsumer3 { public static void main(String[] args) { Resource3 resource3 = new Resource3(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { resource3.A(); } }, \"A\").start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { resource3.B(); } }, \"B\").start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { resource3.C(); } }, \"C\").start(); } } class Resource3 { private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); private int number = 1; //A 执行完调用B，B执行完调用C，C执行完调用A 1A 2B 3C public void A() { lock.lock(); try { while (number != 1) { condition1.await(); } number = 2; //这样就可以执行B线程 System.out.println(Thread.currentThread().getName() + \"-&gt;AAAAAA\"); condition2.signal(); //准确唤醒B线程 } catch (Exception exception) { exception.printStackTrace(); } finally { lock.unlock(); } } public void B() { lock.lock(); try { while (number != 2) { condition2.await(); } number = 3; //这样就可以执行C线程 System.out.println(Thread.currentThread().getName() + \"-&gt;BBBBB\"); condition3.signal(); //准确唤醒C线程 } catch (Exception exception) { exception.printStackTrace(); } finally { lock.unlock(); } } public void C() { lock.lock(); try { while (number != 3) { condition3.await(); } number = 1; //这样就可以执行A线程 System.out.println(Thread.currentThread().getName() + \"-&gt;CCCCC\"); condition1.signal(); //准确唤醒A线程 } catch (Exception exception) { exception.printStackTrace(); } finally { lock.unlock(); } } } 5. 8锁现象如何判断锁的是谁！永远的知道什么锁，锁到底锁的是谁！深刻理解我们的锁 package com.xu.LOCK; import java.util.concurrent.TimeUnit; /*** 8锁，就是关于锁的8个问题 * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话 * 1、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话 * synchronized 放在方法上锁的是方法调用者，这里只有一个调用者 phone */ public class Synchronized { public static void main(String[] args) { Phone phone = new Phone(); new Thread(()-&gt;{ try { phone.send(); } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\").start(); // 延迟执行下面t2线程，但是结果无影响，因为他们用的是同把锁。 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(()-&gt;{ phone.call(); },\"t2\").start(); } //两个线程持有的是同一个锁，谁先拿到谁先执行完,另一个才执行 } class Phone { public synchronized void send() throws InterruptedException { System.out.println(Thread.currentThread().getName() + \"sendMessage\"); TimeUnit.SECONDS.sleep(2); call();//与send（）是同一把锁 this，锁的是方法调用者，不是两把锁 } public synchronized void call() { System.out.println(Thread.currentThread().getName() + \"call\"); } } package com.czp.lock; import java.util.concurrent.TimeUnit; /** * 3、 增加了一个普通方法后！先执行发短信还是Hello？ 普通方法 * 4. 两个对象，两个同步方法， 发短信还是 打电话？ // 打电话 */ public class Test2 { public static void main(String[] args) { Phone1 phone = new Phone1(); Phone1 phone2 = new Phone1(); new Thread(() -&gt; { phone.sendMessage(); }, \"A\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { // phone.hello(); phone2.call(); }, \"B\").start(); } } class Phone1 { public synchronized void sendMessage() { try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"sendMessage\"); } public synchronized void call() { System.out.println(Thread.currentThread().getName() + \"call\"); } //这里没有锁,不受锁的影响 public void hello(){ System.out.println(\"hello\"); } } package com.czp.lock; import java.util.concurrent.TimeUnit; /** * 5.增加两个静态的同步方法 * synchronized 锁的是方法调用者 * static 静态方法类一加载就有了 锁的是CLass * * 6. 两个对象,两个静态同步方法,先发短信还是先打电话 //发短信 * */ public class Test3 { public static void main(String[] args) { // 两个对象的Class类模板只有一个，static锁的是Class Phone2 phone2 = new Phone2(); Phone2 phone3 = new Phone2(); new Thread(() -&gt; { phone2.sendMessage(); }, \"A\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone3.call(); }, \"B\").start(); } } class Phone2 { public static synchronized void sendMessage() { try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"sendMessage\"); } public static synchronized void call() { System.out.println(Thread.currentThread().getName() + \"call\"); } } package com.czp.lock; import java.util.concurrent.TimeUnit; /** * 7.一个静态同步方法,一个普通同步方法 ,一个对象,先输出哪一个 //打电话 * * 8. 一个静态同步方法,一个普通同步方法, 两个对象,先打印哪一个 //B打电话 */ public class Test4 { public static void main(String[] args) { Phone3 phone3 = new Phone3(); Phone3 phone4 = new Phone3(); new Thread(() -&gt; { phone3.sendMessage(); }, \"A\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone4.call(); }, \"B\").start(); } } class Phone3 { public static synchronized void sendMessage() { try { TimeUnit.SECONDS.sleep(4); //延迟 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"sendMessage\"); } //普通同步方法 public synchronized void call() { System.out.println(Thread.currentThread().getName() + \"call\"); } } 小结： synchronized 方法锁的是调用者 this 具体的一个手机 static 方法锁的是模板 Class 唯一的一个模板 6.集合类不安全list 不安全//java.util.ConcurrentModificationException 并发修改异常! public class ListTest { public static void main(String[] args) { //并发下 arrayList 是不安全的 /** * 解决方案 * 1. 使用vector解决 * 2. List&lt;String&gt; arrayList = Collections.synchronizedList(new ArrayList&lt;&gt;()); * synchronizedList 方法里面都有 synchronized 同步代码块 * 3. List&lt;String&gt; arrayList = new CopyOnWriteArrayList&lt;&gt;(); * CopyOnWriteArrayList 使用 ReentrantLock 同步，同时使用 Arrays 工具类的 copyOf 接口复制数组 */ //copyOnWrite 写入时复制 COW 计算机程序设计领域的一种优化策略 //多个线程调用的时候, list, 读取的时候固定的,写入的时候,可能会覆盖 //在写入的时候避免覆盖造成数据问题 //读写分离 //CopyOnWriteArrayList 比 vector牛逼在哪里 List&lt;String&gt; arrayList = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) { new Thread(()-&gt;{ arrayList.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(arrayList); },String.valueOf(i)).start(); } } } Set 不安全/** * 同理可证 */ public class SetTest { public static void main(String[] args) { // Set&lt;String&gt; set = new HashSet&lt;&gt;(); //如何解决hashSet线程安全问题 //1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); // 方法里面都有 synchronized 同步代码块 Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); // CopyOnWriteArraySet 实际用的是 CopyOnWriteArrayList 来存储数据，只是在添加数据时会使用 CopyOnWriteArrayList 的 addIfAbsent 方法来检查是否已经存在元素 for (int i = 0; i &lt; 100; i++) { new Thread(() -&gt; { set.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(set); }, String.valueOf(i)).start(); } } } hashSet底层是什么? hashMap public HashSet() { map = new HashMap&lt;&gt;(); } // add 的本质就是 map 的 key key是无法重复的 public boolean add(E e) { return map.put(e, PRESENT)==null; } private static final Object PRESENT = new Object();//这是一个不变的值 HashMap 不安全回顾Map基本操作 package com.kuang.unsafe; import java.util.Collections; import java.util.HashMap; import java.util.Map; import java.util.UUID; import java.util.concurrent.ConcurrentHashMap; // ConcurrentModificationException public class MapTest { public static void main(String[] args) { // map 是这样用的吗？ 不是，工作中不用 HashMap // 默认等价于什么？ new HashMap&lt;&gt;(16,0.75); // Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // 唯一的一个家庭作业：研究ConcurrentHashMap的原理 Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); for (int i = 1; i &lt;=30; i++) { new Thread(()-&gt;{ map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring( 0,5)); System.out.println(map); },String.valueOf(i)).start(); } } } 7. Callable() 可以有返回值 可以抛出异常 方法不同, run() =&gt; call() package com.kuang.callable; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; import java.util.concurrent.locks.ReentrantLock; /** *1、探究原理 *2、觉自己会用 */ public class CallableTest { public static void main(String[] args) throws ExecutionException, InterruptedException { // new Thread(new Runnable()).start(); // new Thread(new FutureTask&lt;V&gt;()).start(); // new Thread(new FutureTask&lt;V&gt;( Callable )).start(); // new Thread().start(); // 怎么启动Callable MyThread thread = new MyThread(); FutureTask futureTask = new FutureTask(thread); // 适配类 new Thread(futureTask,\"A\").start(); new Thread(futureTask,\"B\").start(); // 只输出Acall()，结果会被缓存，效率高 Integer o = (Integer) futureTask.get(); //这个get 方法可能会产生阻塞！把他放到最后 // 或者使用异步通信来处理！ System.out.println(o); } } class MyThread implements Callable&lt;Integer&gt; { @Override public Integer call() { System.out.println(\"call()\"); // 会打印几个call // 耗时的操作 return 1024; } } 细节： 1、有缓存2、结果可能需要等待，会阻塞！ 8. 常用的辅助类CountDownLatch //计数器 public class CountDownLatchDemo { public static void main(String[] args) throws InterruptedException { // 倒计时总数是6, 必须要执行任务的时候,再使用! CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 0; i &lt; 6; i++) { new Thread(()-&gt;{ System.out.println(Thread.currentThread().getName() + \" GO out\"); countDownLatch.countDown(); //数量减1 },String.valueOf(i)).start(); } countDownLatch.await();// 等待计数器归零,唤醒该线程，然后再向下执行 System.out.println(\"close Door\"); } } 原理: countDownLatch.countDown(); //数量减1 countDownLatch.await();// 等待计数器归零,然后再向下执行 每次有线程调用countDown()数量-1,计数器变为0, countDownLatch.await();就会被唤醒,继续执行 CyclicBarrier package com.xu.Others; import java.util.concurrent.BrokenBarrierException; import java.util.concurrent.CyclicBarrier; public class TestCyclicBarrier { public static void main(String[] args) { CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; { System.out.println(\"集齐七颗龙珠召唤神龙\"); }); // CyclicBarrier cyclicBarrier = new CyclicBarrier(7); for (int i = 1; i &lt;= 7; i++) { final int temp = i;//因为该变量会在循环时或者循环完，会消失， //线程延迟还没输出数据，保存在线程里，所以每个线程拥有不同的数据必须final修饰 new Thread(()-&gt;{ System.out.println(Thread.currentThread().getName() + \"集齐了第\" + temp + \"个龙珠\"); try { cyclicBarrier.await();//没有达到7之前会被wait，不会往下执行 //到达7， 才会执行cyclicBarrier的任务 System.out.println(\"ok\"); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }).start(); } } } SemaphoreSemaphore：信号量 package com.xu.Others; import java.util.concurrent.Semaphore; import java.util.concurrent.TimeUnit; public class TestSemaphore { public static void main(String[] args) { //6车---3个停车位置 Semaphore semaphore = new Semaphore(3); for (int i = 1; i &lt;= 6; i++) { new Thread(() -&gt; { try { System.out.println(\"ok\"); semaphore.acquire();//获得资源，如果资源已经被占满就等待资源释放 System.out.println(Thread.currentThread().getName() + \"抢到了车位\"); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName() + \"离开了车位\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release();//释放资源，唤醒等待线程 } },String.valueOf(i)).start(); } } } 原理: semaphore.acquire(); //获取信号量,假设如果已经满了,等待信号量可用时被唤醒 semaphore.release(); //释放信号量 作用: 多个共享资源互斥的使用!并发限流,控制最大的线程数 9.读写锁ReadWriteLock package com.xu.WriteAndRead; import java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class Test { /** * 独占锁(写锁) 一次只能由一个线程占有 * 共享锁(读锁) 一次可以有多个线程占有 * readWriteLock * 读-读 可以共存 * 读-写 不能共存 * 写-写 不能共存 */ public static void main(String[] args) { Mycache2 mycache = new Mycache2(); //创建写线程 for (int i = 1; i &lt;= 10; i++) { final int temp = i; new Thread(() -&gt; { mycache.write(temp + \"\", temp + \"\"); }, String.valueOf(i)).start(); } //创建读线程 for (int i = 1; i &lt;= 10; i++) { final int temp = i; new Thread(() -&gt; { mycache.read(temp + \"\"); }, String.valueOf(i)).start(); } } } //加读写锁 class Mycache2 { private volatile Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //写,只有一个人能写 public void write(String key, String value) { readWriteLock.writeLock().lock(); try { System.out.println(Thread.currentThread().getName() + \"写\"); map.put(key, value); System.out.println(Thread.currentThread().getName() + \"写OK\"); } finally { readWriteLock.writeLock().unlock(); } } //读，可以多个人读 public void read(String key) { readWriteLock.readLock().lock(); try { System.out.println(Thread.currentThread().getName() + \"读\"); map.get(key); System.out.println(Thread.currentThread().getName() + \"读OK\"); } finally { readWriteLock.readLock().unlock(); } } } //没有任何锁 class Mycache { private volatile Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //写 public void write(String key, String value) { System.out.println(Thread.currentThread().getName() + \"写\"); map.put(key, value); System.out.println(Thread.currentThread().getName() + \"写OK\"); } //读 public void read(String key) { System.out.println(Thread.currentThread().getName() + \"读\"); map.get(key); System.out.println(Thread.currentThread().getName() + \"读OK\"); } } 10.阻塞队列 阻塞队列 Blockqueue 什么情况下我们会使用阻塞队列? 多线程并发处理,线程池! 学会使用队列 添加,移除 四组API 方式 抛出异常 不会抛出异常,有返回值 阻塞等待 超时等待 添加操作 add() offer() 供应 put() offer(obj,int,timeunit.status) 移除操作 remove() poll() 获得 take() poll(int,timeunit.status) 判断队列首部 element() peek() 偷看,偷窥 package com.xu.Queue; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.TimeUnit; public class testBlockingQueue { public static void main(String[] args) throws InterruptedException { test4(); } /** * 等待，阻塞（等待超时） */ public static void test4() throws InterruptedException { ArrayBlockingQueue&lt;Object&gt; arrayBlockingQueue4 = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue4.offer(\"a\")); System.out.println(arrayBlockingQueue4.offer(\"b\")); System.out.println(arrayBlockingQueue4.offer(\"c\")); System.out.println(arrayBlockingQueue4.offer(\"d\",2, TimeUnit.SECONDS));//超时等待，false,不会阻塞 System.out.println(\"_____________\"); System.out.println(arrayBlockingQueue4.poll()); System.out.println(arrayBlockingQueue4.poll()); System.out.println(arrayBlockingQueue4.poll()); System.out.println(arrayBlockingQueue4.poll(2,TimeUnit.SECONDS));//超时等待，null，不会抛出异常 } /** * 等待，阻塞（一直阻塞） */ public static void test3() throws InterruptedException { ArrayBlockingQueue&lt;Object&gt; arrayBlockingQueue3 = new ArrayBlockingQueue&lt;&gt;(3); arrayBlockingQueue3.put(\"a\"); arrayBlockingQueue3.put(\"b\"); arrayBlockingQueue3.put(\"c\"); // arrayBlockingQueue3.put(\"d\");// 队列没有位置了，一直阻塞 System.out.println(\"_____________\"); System.out.println(arrayBlockingQueue3.take()); System.out.println(arrayBlockingQueue3.take()); System.out.println(arrayBlockingQueue3.take()); // System.out.println(arrayBlockingQueue3.take());// 没有这个元素，一直阻塞 } /** * 有返回值，不会抛出异常 */ public static void test2() { ArrayBlockingQueue&lt;Object&gt; arrayBlockingQueue2 = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue2.offer(\"a\")); System.out.println(arrayBlockingQueue2.offer(\"b\")); System.out.println(arrayBlockingQueue2.offer(\"c\")); System.out.println(arrayBlockingQueue2.offer(\"d\"));//false,不会阻塞 System.out.println(\"_____________\"); System.out.println(arrayBlockingQueue2.poll()); System.out.println(arrayBlockingQueue2.poll()); System.out.println(arrayBlockingQueue2.poll()); System.out.println(arrayBlockingQueue2.poll());//null，不会抛出异常 } /** * 抛出异常 */ public static void test() { // 队列的大小 ArrayBlockingQueue&lt;Object&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue.add(\"a\")); System.out.println(arrayBlockingQueue.add(\"b\")); System.out.println(arrayBlockingQueue.add(\"c\")); // System.out.println(arrayBlockingQueue.add(\"d\")); //IllegalStateException: Queue full System.out.println(\"_____________\"); System.out.println(arrayBlockingQueue.remove(\"b\")); System.out.println(arrayBlockingQueue.remove()); System.out.println(arrayBlockingQueue.remove()); // System.out.println(arrayBlockingQueue.remove());//NoSuchElementException } } SynchronizedQueue 同步队列 没有容量, 进去一个元素,必须等待取出来之后,才能再往里面放一个元素 put take /** * 同步队列 * 和其他的lockQueue 不一样， SynchronousQueue 不存储元素 * put了一个元素，必须从里面先take取出来，否则不能在put进去值！ */ public class SyncQueue { public static void main(String[] args) { SynchronousQueue&lt;String&gt; synchronousQueue = new SynchronousQueue&lt;&gt;(); //同步队列 new Thread(()-&gt;{ try { System.out.println(Thread.currentThread().getName() + \"put 1\"); synchronousQueue.put(\"1\");//没有被take，会阻塞 System.out.println(Thread.currentThread().getName() + \"put 2\"); synchronousQueue.put(\"2\"); System.out.println(Thread.currentThread().getName() + \"put 3\"); synchronousQueue.put(\"3\"); } catch (InterruptedException e) { e.printStackTrace(); } },\"T1\").start(); new Thread(()-&gt;{ try { TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \"=&gt;\" + synchronousQueue.take()); //没有put，会阻塞 TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \"=&gt;\" + synchronousQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \"=&gt;\" + synchronousQueue.take()); } catch (InterruptedException e) { e.printStackTrace(); } finally { } },\"T2\").start(); } } 11.线程池线程池: 三大方法,七大参数,4种拒绝策略 池化技术 程序的运行，本质：占用系统的资源！ 优化资源的使用！=&gt;池化技术 线程池、连接池、内存池、对象池///. 创建、销毁。十分浪费资源 池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还给我。 线程池的好处: 1、降低资源的消耗 2、提高响应的速度 3、方便管理。 线程复用、可以控制最大并发数、管理线程 线程池: 三大方法 //Executors 工具类 3大方法 //使用了线程池之后要使用线程池创建线程 public class Demo01 { public static void main(String[] args) { // ExecutorService service = Executors.newSingleThreadExecutor();//单个线程 // ExecutorService service = Executors.newFixedThreadPool(5);//创建一个固定的线程池的大小 ExecutorService service = Executors.newCachedThreadPool();//可伸缩的， try { for (int i = 0; i &lt; 10; i++) { service.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + \"ok\"); }); } //线程池用完要关闭线程池 } finally { service.shutdown(); } } } 7大参数newSingleThreadExecutor构造器 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); } newFixedThreadPool构造器 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } newCachedThreadPool构造器 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); } 本质: 所有线程池最终都调用的ThreadPoolExecutor ThreadPoolExecutor底层构造器 public ThreadPoolExecutor(int corePoolSize, //核心线程池大小 int maximumPoolSize, //最大的线程池大小 long keepAliveTime, // 超时了没有人调用就会释放 TimeUnit unit, //时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列 ThreadFactory threadFactory,//线程工厂,创建线程的,一般不动 RejectedExecutionHandler handler) {//拒绝策略 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } 手动创建线程池 package com.xu.Pool; import java.util.concurrent.*; public class testThreadPoolExecutor { public static void main(String[] args) { ExecutorService threadPoolExecutor = new ThreadPoolExecutor( 2,//核心线程数 4,//最大线程数 3,//多久没调用就释放池 TimeUnit.SECONDS,//超时单位 new ArrayBlockingQueue&lt;&gt;(6),//阻塞队列大小 Executors.defaultThreadFactory(), // 线程工厂，创建线程的，默认不用改 //队列满了，线程池满了，还有其他任务过来时拒绝策略 // new ThreadPoolExecutor.AbortPolicy()//满了，不处理，抛出异常 // new ThreadPoolExecutor.CallerRunsPolicy()//由调用线程（提交任务的线程）处理该任务 // new ThreadPoolExecutor.DiscardPolicy()//满了，丢掉任务，不抛出异常 new ThreadPoolExecutor.DiscardOldestPolicy()//抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务 ); try { // 最大承载：Deque + max 等待队列容量和最大线程数之和 // 超过 RejectedExecutionException 抛不抛出异常看拒绝策略 for (int i = 0; i &lt;12; i++) { // 使用了线程池之后，使用线程池来创建线程 threadPoolExecutor.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + \"run\"); }); } } catch (Exception exception) { exception.printStackTrace(); } finally { // 线程池用完，程序结束，关闭线程池 threadPoolExecutor.shutdown(); } } } 四种拒绝策略/** * new ThreadPoolExecutor.AbortPolicy() 超出最大处理线程抛出异常 * new ThreadPoolExecutor.CallerRunsPolicy() 哪个线程创建就由那个线程执行 * new ThreadPoolExecutor.DiscardPolicy() 队列满了，丢弃任务，不会抛出异常 * new ThreadPoolExecutor.DiscardOldestPolicy() 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务 */ 小结和扩展 了解:最大线程到底应该如何定义 CPU密集型 几核,就是几,可以保证CPU的效率最高 IO 密集型 判断程序中十分耗I/O的线程, 大于两倍 //获取电脑处理器数 System.out.println(Runtime.getRuntime().availableProcessors()); 12.四大函数式接口新时代的程序员：lambda表达式、链式编程、函数式接口、Stream流式计算 函数式接口：只有一个方法的接口 @FunctionalInterface public interface Runnable { public abstract void run(); } // 泛型、枚举、反射 // lambda表达式、链式编程、函数式接口、Stream流式计算 // 超级多FunctionalInterface // 简化编程模型，在新版本的框架底层大量应用！ // foreach(消费者类的函数式接口) Function函数式接口 package com.kuang.function; import java.util.function.Function; /** *Function 函数型接口, 有一个输入参数，有一个输出 *只要是 函数型接口 可以 用 lambda表达式简化 */ public class Demo01 { public static void main(String[] args) { // // Function&lt;String,String&gt; function = new Function&lt;String,String&gt;() { // @Override // public String apply(String str) { // return str; // } // }; Function&lt;String,String&gt; function = (str)-&gt;{return str;}; System.out.println(function.apply(\"asd\")); } } Predicate 断定型接口 package com.kuang.function; import java.util.function.Predicate; /** * 断定型接口：有一个输入参数，返回值只能是 布尔值！ */ public class Demo02 { public static void main(String[] args) { // 判断字符串是否为空 // Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;(){ //// @Override //// public boolean test(String str) { //// return str.isEmpty(); //// } //// }; Predicate&lt;String&gt; predicate = (str)-&gt;{return str.isEmpty(); }; System.out.println(predicate.test(\"\")); } } Consumer 消费型接口 package com.kuang.function; import java.util.function.Consumer; /** * Consumer 消费型接口: 只有输入，没有返回值 */ public class Demo03 { public static void main(String[] args) { // Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() { // @Override // public void accept(String str) { // System.out.println(str); // } // }; Consumer&lt;String&gt; consumer = (str)-&gt;{System.out.println(str);}; consumer.accept(\"sdadasd\"); } } Supplier 供给型接口 package com.kuang.function; import java.util.function.Supplier; /** * Supplier 供给型接口 没有参数，只有返回值 */ public class Demo04 { public static void main(String[] args) { // Supplier supplier = new Supplier&lt;Integer&gt;() { // @Override // public Integer get() { // System.out.println(\"get()\"); // return 1024; // } // }; Supplier supplier = ()-&gt;{ return 1024; }; System.out.println(supplier.get()); } } 13.Stream 流式计算 什么是流式计算 大数据：存储 + 计算 集合、MySQL 本质就是存储东西的； 计算都应该交给流来操作！ package com.kuang.stream; import java.util.Arrays; import java.util.List; /** *题目要求：一分钟内完成此题，只能用一行代码实现！ *现在有5个用户！筛选： *1、ID 必须是偶数 *2、年龄必须大于23岁 *3、用户名转为大写字母 *4、用户名字母倒着排序 *5、只输出一个用户！ */ public class Test { public static void main(String[] args) { User u1 = new User(1,\"a\",21); User u2 = new User(2,\"b\",22); User u3 = new User(3,\"c\",23); User u4 = new User(4,\"d\",24); User u5 = new User(6,\"e\",25); // 集合就是存储 List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5); // 计算交给Stream流 // lambda表达式、链式编程、函数式接口、Stream流式计算 list.stream() .filter(u-&gt;{return u.getId()%2==0;}) .filter(u-&gt;{return u.getAge()&gt;23;}) .map(u-&gt;{return u.getName().toUpperCase();}) .sorted((uu1,uu2)-&gt;{return uu2.compareTo(uu1);}) .limit(1) //取前几个元素，数目可以大于元素总个数 .forEach(System.out::println); } } 14. ForkJoin 什么是ForkJoin ForkJoin在JDK1.7,并行执行任务,大数据量! 大数据: Map Reduce( 把大任务拆分成小任务) ForkJoin特点: 工作窃取 这个里面维护的是一个双端队列 ForkJoin package com.kuang.forkjoin; import java.util.concurrent.RecursiveTask; /** *求和计算的任务！ *3000 6000（ForkJoin） 9000（Stream并行流） * 如何使用 forkjoin * 1、forkjoinPool 通过它来执行 * 2、计算任务 forkjoinPool.execute(ForkJoinTask task) * 3. 计算类要继承 ForkJoinTask */ public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; { private Long start; // 1 private Long end; // 1990900000 // 临界值 private Long temp = 10000L; public ForkJoinDemo(Long start, Long end) { this.start = start; this.end = end; } // 计算方法 @Override protected Long compute() { if ((end-start)&lt;temp){ Long sum = 0L; for (Long i = start; i &lt;= end; i++) { sum += i; } return sum; }else { // forkjoin 递归 long middle = (start + end) / 2; // 中间值 ForkJoinDemo task1 = new ForkJoinDemo(start, middle); task1.fork(); // 拆分任务，把任务压入线程队列 ForkJoinDemo task2 = new ForkJoinDemo(middle+1, end); task2.fork(); // 拆分任务，把任务压入线程队列 return task1.join() + task2.join(); } } } 测试 package com.xu.ForkJoin; import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; import java.util.stream.LongStream; public class test { public static void main(String[] args) throws ExecutionException, InterruptedException { // test1();//611 // test2();//617 test3();//618 } public static void test1() { long start = System.currentTimeMillis(); long sum = 0l; for (long i = 0l; i &lt;=10_0000_0000l ; i++) { sum+=i; } long end = System.currentTimeMillis(); System.out.println(\"sum=\"+sum+\"运行时间；\"+(end-start)); } public static void test2() throws ExecutionException, InterruptedException { long start = System.currentTimeMillis(); Long sum; ForkJoinPool forkJoinPool = new ForkJoinPool(); //forkjoinDemo 是自己创建的计算类，参照上面创建 forkjoinDemo forkjoinDemo = new forkjoinDemo(0l, 10_0000_0000l); ForkJoinTask&lt;Long&gt; task = forkJoinPool.submit(forkjoinDemo);// 提交任务 sum = task.get(); long end = System.currentTimeMillis(); System.out.println(\"sum=\"+sum+\"运行时间；\"+(end-start)); } public static void test3() { long start = System.currentTimeMillis(); // Stream并行流 range() 开区间 () ，rangeClosed() 闭区间左开右闭 (] long sum = LongStream.rangeClosed(0l, 10_0000_0000l).parallel().reduce(1, Long::sum); long end = System.currentTimeMillis(); System.out.println(\"sum=\"+sum+\"运行时间；\"+(end-start)); } } 15. 异步回调 Future设计的初衷: 对将来的某个事件的结果进行建模 package com.xu.CompletableFutrue; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; /** *异步调用： CompletableFuture * 异步执行 * 成功回调 * 失败回调 */ public class test { public static void main(String[] args) throws ExecutionException, InterruptedException { //没有返回值的 runAsync 异步回调 // CompletableFuture&lt;Void&gt; completableFuture=CompletableFuture.runAsync(()-&gt;{ // System.out.println(Thread.currentThread().getName() + \"run\"); // try { // TimeUnit.SECONDS.sleep(2); // } catch (InterruptedException e) { // e.printStackTrace(); // } // }); // completableFuture.get();//阻塞，获取执行结果 // System.out.println(\"1111\"); //有返回值的 supplyAsync 异步回调 // ajax，成功和失败的回调 // 返回的是错误信息； CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;{ System.out.println(Thread.currentThread().getName() + \"run\"); int i =10/0; return 1024; }); System.out.println(completableFuture.whenComplete((u, t) -&gt; { //接收什么信息跟参数位置有关，第一个参数接收正确运行结果，第二个接收错误运行的结果 System.out.println(\"u=\" + u); System.out.println(\"t=\" + t); }).exceptionally((e) -&gt; { System.out.println(e.getMessage()); return 111; // 可以获取到错误的返回结果 }).get()); } } /* 运行结果 ForkJoinPool.commonPool-worker-1run u=null t=java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero java.lang.ArithmeticException: / by zero 111 */ 16.JMM 请你谈谈你对Volate的理解 Volate是java虚拟机提供轻量级的同步机制 保证可见性 不保证原子性 禁止指令重排 JMM是什么 JMM: java内存模型,不存在的东西,概念!约定! 关于JMM的一些同步的约定： 线程解锁前,必须把共享变量立刻刷回主存 线程加锁前,必须读取主存中的最新值到工作内存中! 加锁和解锁必须是同一把锁 线程 工作内存 主内存 8种操作：（这里的 write 和 store 交换位置） 操作 说明 lock （锁定） 作用于主内存的变量，把一个变量标识为线程独占状态 unlock （解锁） 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read （读取） 作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用 load （载入） 作用于工作内存的变量，它把read操作从主存中变量放入工作内存中 use （使用） 作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令 assign （赋值） 作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中 store （存储） 作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用 write （写入） 作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中 八种规则: 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 不允许一个线程将没有assign的数据从工作内存同步回主内存 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 对一个变量进行unlock操作之前，必须把此变量同步回主内存 问题: 程序不知道主内存中的值已经被修改过了 17. Volatile保证可见性public class JMMDemo { //不加volatile 程序就会死循环 //加上volatile 可以保证可见性 private volatile static int number = 0; public static void main(String[] args) { new Thread(()-&gt;{ // 线程 1 对主内存的变化不知道的 while(number == 0){ } }).start(); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } finally { } number = 1; System.out.println(number); } } 不保证原子性原子性: 不可分割 线程A在执行任务的时候.不能被打扰,也不能被分割,要么同时成功,要么同时失败 //测试不保证原子性 public class VDemo { // volatile 不保证原子性 private volatile static int num = 0; public static void add(){ num++; } public static void main(String[] args) { //理论上num结果应该为 2 万 for (int i = 0; i &lt; 20; i++) { new Thread(()-&gt;{ for (int j = 0; j &lt; 1000; j++) { add(); } }).start(); } while (Thread.activeCount() &gt; 2){ // main线程 gc垃圾回收线程 Thread.yield(); } System.out.println(num); } } 如果不加lock和synchronized,如何保证原子性 使用原子类,解决原子性问题 //测试不保证原子性 public class VDemo { //原子类的int private volatile static AtomicInteger num = new AtomicInteger(0); // AtomicInteger 调用的是底层的 CAS public static void add(){ // num++; // 不是一个原子性操作 num.getAndIncrement(); // AtomicInteger + 1 方法， CAS } public static void main(String[] args) { for (int i = 0; i &lt; 20; i++) { new Thread(()-&gt;{ for (int j = 0; j &lt; 1000; j++) { add(); } }).start(); } while (Thread.activeCount() &gt; 2){ Thread.yield(); } System.out.println(num); } } 这些类的底层都直接和操作系统挂钩 ! 在内存中修改值! UnSafe类是一个很特殊的存在 指令重排 什么是指令重排: 你写的程序,计算机并不是按照指定的的步骤执行 源代码—&gt;编译器优化源代码–&gt;指令并行也可能会重排—&gt;内存系统也会重排执行 处理器在进行指令重排的时候，考虑：数据之间的依赖性！ int x = 1; // 1 int y = 2; // 2 x = x + 5; // 3 y = x * x; // 4 我们所期望的：1234 但是可能执行的时候回变成 2134 1324 可不可能是 4123！ 可能造成影响的结果： a b x y 这四个值默认都是 0； 线程A 线程B x=a y=b b=1 a=2 正常的结果： x = 0；y = 0；但是可能由于指令重排 线程A 线程B b=1 a=2 x=a y=b 指令重排导致的诡异结果： x = 2；y = 1； volatile 可以避免指令重排： 内存屏障。CPU指令。作用： 1、保证特定的操作的执行顺序！ 2、可以保证某些变量的内存可见性 （利用这些特性volatile实现了可见性） Volatile 是可以保证可见性, 不能保证原子性,由于内存屏障可以避免指令重排的现象产生 ! 18.单例模式饿汉模式package com.kuang.single; // 饿汉式单例 public class Hungry { // 可能会浪费空间 private Hungry(){ } private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance(){ return HUNGRY; } } 懒汉模式package com.czp.single; //单线程安全 public class LazyMan { private static LazyMan lazyMan = null; private LazyMan(){ } public static LazyMan getInstance(){ if(lazyMan == null){ lazyMan = new LazyMan(); } return lazyMan; } } DCL 懒汉式package com.czp.single; import java.lang.reflect.Constructor; public class LazyManThread { private static volatile LazyManThread lazyManThread = null; private static boolean isExist = false; //执行一次构造函数就把标志位反置为true，第二次执行构造函数就抛出异常 private LazyManThread() { synchronized (LazyManThread.class) { if (!isExist) { isExist = true; } else { throw new RuntimeException(\"禁止使用反射创建该对象\"); } } } // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyManThread getInstance() { //if只会判断一次,当两个线程同时判断时一个线程就会在同步代码块中等待 if (lazyManThread == null) { //不直接使用同步的原因,提高执行效率 synchronized (LazyManThread.class) { if (lazyManThread == null) { lazyManThread = new LazyManThread(); // 不是一个原子性操作 } } } /** * 由于对象创建不是原子性操作 * 1. 分配内存空间 * 2. 使用构造器创建对象 * 3. 将对象指向内存空间 */ /** * 可能会发生指令重排 * 123 * 132 * 这是就需使用volatile关键字来防止指令重排 */ return lazyManThread; } // 反射！ public static void main(String[] args) throws Exception { // LazyManThread instance = LazyManThread.getInstance(); Constructor&lt;LazyManThread&gt; declaredConstructor = LazyManThread.class.getDeclaredConstructor(); declaredConstructor.setAccessible(true); LazyManThread lazyManThread = declaredConstructor.newInstance(); LazyManThread instance = declaredConstructor.newInstance(); System.out.println(instance); System.out.println(lazyManThread); } } 静态内部类 public class LazyMan1 { private LazyMan1() {} public static final LazyMan1 getInstance(){ return innerClass.LAZY_MAN_1; } public static class innerClass { private static final LazyMan1 LAZY_MAN_1 = new LazyMan1(); } } 单例不安全,反射package com.xu.SingleInstance; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; public class LazyMan { private volatile static LazyMan lazyMan; //volatile 保证不会指令重排 private LazyMan() { System.out.println(\"new lazyman()\"); } public static LazyMan getLazyMan() { if (lazyMan == null) { synchronized (LazyMan.class) { if (lazyMan == null) { lazyMan = new LazyMan();//不是原子性操作 /** * 1，分配内存空间 * 2，执行构造函数，初始化对象 * 3，把这个对象指向这个空间 * * 正常情况是123 * 但虚拟机会优化编译，指令重排132 */ } } } return lazyMan; } public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { // LazyMan lazyMan = getLazyMan(); Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null); declaredConstructor.setAccessible(true); LazyMan lazyMan1 = declaredConstructor.newInstance(); LazyMan lazyMan2 = declaredConstructor.newInstance(); System.out.println(lazyMan2); System.out.println(lazyMan1); } } /* 没有做特殊处理的单例在反射下可以随便创建实例 输出结果： new lazyman() new lazyman() com.xu.SingleInstance.LazyMan@14ae5a5 com.xu.SingleInstance.LazyMan@7f31245a */ 枚举package com.xu.SingleInstance; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; public class Enum { public static void main(String[] args) throws InterruptedException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { //无参构造函数，枚举默认 Constructor&lt;instance&gt; constructor = Instance.class.getDeclaredConstructor(String.class,int.class); //有参构造函数，最后一个String.class 为参数类型 Constructor&lt;instance&gt; constructor = Instance.class.getDeclaredConstructor(String.class,int.class,String.class); constructor.setAccessible(true); Instance instance = constructor.newInstance(); //Exception in thread \"main\" java.lang.IllegalArgumentException: Cannot reflectively create enum objects 不能通过反射创建实例 } } // enum 是一个什么？ 本身也是一个Class类 public enum Instance { ;//注意这里有分号 private String name; Instance(){ } Instance(String name){ this.name = name; } } 下面是探究枚举类构造函数，以及反编译枚举类的源码 package com.kuang.single; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; // enum 是一个什么？ 本身也是一个Class类 public enum EnumSingle { INSTANCE; public EnumSingle getInstance(){ return INSTANCE; } } class Test{ public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { EnumSingle instance1 = EnumSingle.INSTANCE; Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,int.class); declaredConstructor.setAccessible(true); EnumSingle instance2 = declaredConstructor.newInstance(); // NoSuchMethodException: com.kuang.single.EnumSingle.&lt;init&gt;() System.out.println(instance1); System.out.println(instance2); } 枚举类型的最终反编译源码： // Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov. // Jad home page: http://www.kpdus.com/jad.html // Decompiler options: packimports(3) // Source File Name: EnumSingle.java package com.kuang.single; public final class EnumSingle extends Enum { public static EnumSingle[] values() { return (EnumSingle[])$VALUES.clone(); } public static EnumSingle valueOf(String name) { return (EnumSingle)Enum.valueOf(com/kuang/single/EnumSingle, name); } private EnumSingle(String s, int i) { super(s, i); } public EnumSingle getInstance() { return INSTANCE; } public static final EnumSingle INSTANCE; private static final EnumSingle $VALUES[]; static { INSTANCE = new EnumSingle(\"INSTANCE\", 0); $VALUES = (new EnumSingle[] { INSTANCE }); } } 19.深入理解CASpackage com.kuang.cas; import java.util.concurrent.atomic.AtomicInteger; public class CASDemo { // CAS compareAndSwarp : 比较并交换！ public static void main(String[] args) { // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ AtomicInteger atomicInteger = new AtomicInteger(1); System.out.println(atomicInteger.compareAndSet(1, 2));//true System.out.println(atomicInteger.get()); //2 System.out.println(atomicInteger.getAndIncrement());//其实是3,返回旧值，输出2 System.out.println(atomicInteger.get());//3 System.out.println(atomicInteger.compareAndSet(1, 2));//false System.out.println(atomicInteger.get());//3 } } Unsafe 类 CAS ： 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环！ 缺点： 1、 循环会耗时2、一次性只能保证一个共享变量的原子性3、ABA问题 CAS：ABA问题（狸猫换太子） package com.kuang.cas; import java.util.concurrent.atomic.AtomicInteger; public class CASDemo { // CAS compareAndSwarp : 比较并交换！ public static void main(String[] args) { AtomicInteger atomicInteger = new AtomicInteger(2020); // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ // ============== 捣乱的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2021, 2020)); System.out.println(atomicInteger.get()); // ============== 期望的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 6666)); System.out.println(atomicInteger.get()); } } 20 . 原子引用 解决ABA问题, 引入原子引用 ! 对应的思想: 乐观锁 带版本号的原子操作 ! package com.xu.CASdemo; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicStampedReference; public class AtomicStampedReferenceDemo { public static void main(String[] args) { //AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题 AtomicStampedReference&lt;Long&gt; atomicStampedReference = new AtomicStampedReference(1L, 1); //这里1是版本号 new Thread(()-&gt;{//模拟狸猫换太子 // 获得版本号 System.out.println(\"a1-&gt;\"+atomicStampedReference.getStamp()); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(atomicStampedReference.compareAndSet(1L, 2L, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1)); System.out.println(\"a2-&gt;\" + atomicStampedReference.getStamp()); System.out.println(atomicStampedReference.compareAndSet(2L, 1L, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1)); System.out.println(\"a3-&gt;\" + atomicStampedReference.getStamp()); },\"a\").start(); // 乐观锁的原理相同 new Thread(()-&gt;{//狸猫换太子后，看能不能进行交换操作 int stamp = atomicStampedReference.getStamp();// 获得版本号 System.out.println(\"b1-&gt;\" +stamp); //此时版本还是1 try { TimeUnit.SECONDS.sleep(2); //让前面的线程换完太子 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(atomicStampedReference.compareAndSet(1L, 6L,stamp, stamp+ 1));//此时版本号已经改变不符，所以交换不成功 //经历过狸猫换太子后版本号变为了3 System.out.println(\"b2-&gt;\"+atomicStampedReference.getStamp()); },\"b\").start(); } } 注意：Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂的方法valueOf 获取对象实例，而不是new，因为valueOf 使用缓存，而new一定会创建新的对象分配新的内存空间； 21.各种锁的理解公平锁, 非公平锁公平锁: 非常公平,先来后到,不允许插队 非公平锁: 非常不公平, 允许插队 public ReentrantLock() { sync = new NonfairSync(); //无参默认非公平锁 } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync();//传参为true为公平锁 } 可重入锁 ( 递归锁 )释义: 可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁 synchronized版本的可重入锁 public class TestLock { public static void main(String[] args) { TestPhone phone = new TestPhone(); new Thread(()-&gt;{ //在调用sendMessage的方法时已经为phone加上了一把锁 //而call方法由为其加上了一把锁 phone.sendMessage(); }).start(); } } class TestPhone { public synchronized void sendMessage() { System.out.println(Thread.currentThread().getName() + \"sendMessage\"); call(); } public synchronized void call() { System.out.println(Thread.currentThread().getName() + \"call\"); } } Lock版本的可重入锁 package com.kuang.lock; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class Demo02 { public static void main(String[] args) { Phone2 phone = new Phone2(); new Thread(()-&gt;{ phone.sms(); },\"A\").start(); new Thread(()-&gt;{ phone.sms(); },\"B\").start(); } } class Phone2{ Lock lock = new ReentrantLock(); public void sms(){ lock.lock(); // 细节问题：lock.lock(); lock.unlock(); // lock 锁必须配对，否则就会死在里面 lock.lock(); try { System.out.println(Thread.currentThread().getName() + \"sms\"); call(); // 这里也有锁 } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); lock.unlock(); } } public void call(){ lock.lock(); try { System.out.println(Thread.currentThread().getName() + \"call\"); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } } 自旋锁 package com.xu.LOCK; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicReference; public class Spinlock { public static void main(String[] args) throws InterruptedException { Mylock mylock = new Mylock(); new Thread(()-&gt;{ mylock.lock(); try { System.out.println(\"a\"); TimeUnit.SECONDS.sleep(5); } catch (Exception e) { e.printStackTrace(); } finally { mylock.unlock(); } },\"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;{ mylock.lock(); try { System.out.println(\"b\"); TimeUnit.SECONDS.sleep(6); } catch (Exception e) { e.printStackTrace(); } finally { mylock.unlock(); } },\"B\").start(); } } class Mylock { AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); //对象为null，不带版本号的，AtomicStampedReference才是带版本号的类 public void lock() { Thread thread =Thread.currentThread();//对应的线程 while (!atomicReference.compareAndSet(null, thread)) { //B的线程执行到这里就会自旋，直到等到A线程执行unlock（）解锁 //这个自旋主要是对线程B起作用，对线程A不起作用，因为 // atomicReference.compareAndSet(null, thread)对线程A为真 //因为atomicReference刚开始初始值为null System.out.println(thread.getName()+\"-&gt;b\"); } System.out.println(thread.getName()+\"-&gt;lock\"); } public void unlock() { Thread thread = Thread.currentThread(); System.out.println(thread.getName() + \"-&gt;unlock\"); atomicReference.compareAndSet(thread, null); } } /* 程序执行过程：先输出A-&gt;lock，然后再输出a，此时A就睡5秒，B进来因为 while (!atomicReference.compareAndSet(null, thread)) 一直在自旋，疯狂输出B-&gt;b，过了几秒A醒来，进行A-&gt;unlock，B就因为 while (!atomicReference.compareAndSet(null, thread)) 不满足所以跳出了自旋，输出B-&gt;lock，接着输出b，然后睡6秒醒来后输出B-&gt;unlock，解锁 */ 死锁产生死锁的四大条件：互斥、占有等待、循环等待、不可抢占（破坏其中一个就不会产生死锁） package com.czp.lock; import java.util.concurrent.TimeUnit; public class KillLock implements Runnable { private String stringA; private String stringB; public KillLock(String stringA, String stringB) { this.stringA = stringA; this.stringB = stringB; } @Override public void run() { synchronized (stringA) { System.out.println(Thread.currentThread().getName() + \"lock\" + stringA + \"try to lock stringB\"); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (stringB) { System.out.println(Thread.currentThread().getName() + \"lock\" + stringB + \"try to lock stringA\"); } } } public static void main(String[] args) { String a = \"a\"; String b = \"b\"; new Thread(new KillLock(a, b)).start(); new Thread(new KillLock(b, a)).start(); } } 如何排查死锁 先使用jps -l定位进程号 再使用 jstack 查看进程信息找到死锁问题 面试，工作中！ 排查问题： 1、日志 9 2、堆栈 1","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"MyBatis","slug":"MyBatis笔记","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:27:21.025Z","comments":true,"path":"posts/ea4e978t.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e978t.html","excerpt":"","text":"MyBatis半自动化 ORM 框架: Object Relationship Mapping 对象关系映射 对象指面向对象 关系指关系型数据库 Java 到 MySQL 的映射，开发者可以以面向对象的思想来管理数据库。 什么是MyBatis MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects 普通老式的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目 ibatis, 2010年这个项目由 apache 迁移到了 google code，并且改名为 MyBatis 。 2013年11月迁移到 Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3 持久化 持久化是将程序数据在持久状态和瞬时状态间转换的机制。 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。 为什么需要持久化服务呢？那是由于内存本身的缺陷引起的 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。 持久层 什么是持久层？ 完成持久化工作的代码块 . —-&gt; dao层 【DAO (Data Access Object) 数据访问对象】 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】 核心配置文件 mybatis-config.xml 系统核心配置文件 MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 能配置的内容如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） &lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt; 我们可以阅读 mybatis-config.xml 上面的dtd的头文件查看元素节点顺序！ environments元素&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${driver}\"/&gt; &lt;property name=\"url\" value=\"${url}\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定） 具体的一套环境，通过设置id进行区别，id保证唯一！ 子元素节点：environment dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 数据源是必须配置的。 有三种内建的数据源类型 type=\"[UNPOOLED|POOLED|JNDI]\" UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 JNDI：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等…. 两种事务管理器类型，这两种事务管理器类型都不需要设置任何属性。 子元素节点：transactionManager - [ 事务管理器 ] &lt;!-- 语法 --&gt; &lt;transactionManager type=\"[ JDBC | MANAGED ]\"/&gt; 子元素节点：数据源（dataSource） mappers元素mappers 映射器 : 定义映射SQL语句文件 既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。 引入资源方式 &lt;!-- 使用相对于类路径的资源引用 --&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\"/&gt; &lt;/mappers&gt; &lt;!-- 使用完全限定资源定位符（URL） --&gt; &lt;mappers&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;/mappers&gt; &lt;!-- 使用映射器接口的完全限定类名 需要配置文件名称和接口名称一致，并且位于同一目录下 --&gt; &lt;mappers&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;!-- 不能这样写，用* 会出错--&gt; &lt;mapper class=\"org.mybatis.builder.*\"/&gt; &lt;/mappers&gt; &lt;!-- 将包内的映射器接口全部注册为映射器 但是需要配置文件名称和接口名称一致，并且位于同一目录下 --&gt; &lt;mappers&gt; &lt;package name=\"org.mybatis.builder\"/&gt; &lt;/mappers&gt; Mapper文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.kuang.mapper.UserMapper\"&gt; &lt;select&gt;&lt;/select&gt; &lt;/mapper&gt; namespace中文意思：命名空间，作用如下： namespace的命名必须跟某个接口同名 接口中的方法与映射文件中 sql 语句 id 应该一一对应 namespace 和子元素的 id 联合保证唯一 , 区别不同的 mapper 绑定DAO接口 namespace命名规则 : 包名+类名 MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。 Properties优化数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。 第一步 ; 在资源目录下新建一个db.properties driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis? useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8 username=root password=123456 第二步 : 将文件导入properties 配置文件 &lt;configuration&gt; &lt;!--导入properties文件--&gt; &lt;properties resource=\"db.properties\"&gt; &lt;!-- 优先读取properties文件，properties文件里有的属性，即使property标签下面写 了也只读取properties文件的属性（无论properties文件里属性值是否正确都不会 读取property标签），下面写了相当于没写 --&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/properties&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${driver}\"/&gt; &lt;property name=\"url\" value=\"${url}\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 配置文件优先级问题 如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载： 首先读取在 properties 元素体内指定的属性。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。 最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。可以在 SqlSessionFactoryBuilder.build() 方法中传入属性值，例如： SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props); 通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。 新特性：使用占位符 从 MyBatis 3.4.2 开始，你可以为占位符指定一个默认值。例如： &lt;dataSource type=\"POOLED\"&gt; &lt;!-- ... --&gt; &lt;property name=\"username\" value=\"${username:ut_user}\"/&gt; &lt;!-- 如果属性 'username' 没有被配置，'username' 属性的值将为 'ut_user' --&gt; &lt;/dataSource&gt; 这个特性默认是关闭的。要启用这个特性，需要添加一个特定的属性来开启这个特性。例如： &lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;!-- ... --&gt; &lt;property name=\"org.apache.ibatis.parsing.PropertyParser.enable-default-value\" value=\"true\"/&gt; &lt;!-- 启用默认值特性 --&gt; &lt;/properties&gt; typeAliases优化类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。 &lt;!--配置别名,注意顺序--&gt; &lt;typeAliases&gt; &lt;typeAlias type=\"com.kuang.pojo.User\" alias=\"User\"/&gt; &lt;/typeAliases&gt; 当这样配置时，**User可以用在任何使用com.kuang.pojo.User的地方。** 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如: &lt;typeAliases&gt; &lt;package name=\"com.kuang.pojo\"/&gt; &lt;/typeAliases&gt; 每一个在包 com.kuang.pojo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。（即包下的实体类 类名首字母小写作为别名），例如：user 可以用在任何使用 com.kuang.pojo.User 的地方 若有注解，则别名为其注解值。见下面的例子： @Alias(\"user\") public class User { ... } 其他配置浏览设置 设置（settings）相关 =&gt; 查看帮助文档 懒加载 日志实现 缓存开启关闭 一个配置完整的 settings 元素的示例如下： &lt;settings&gt; &lt;!-- 开启缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 是否允许单个语句返回多结果集（需要数据库驱动支持） --&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;!-- 使用列标签代替列名 --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;!--允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。 --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;!-- 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt; &lt;/settings&gt; 类型处理器 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】 对象工厂 MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】 如何使用1，新建 Maven 工程，pom.xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--解决Maven静态资源过滤问题，寻找配置资源文件--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/resources&gt; &lt;/build&gt; 2，新建数据表 use mybatis; create table t_account( id int primary key auto_increment, username varchar(11), password varchar(11), age int )ENGINE=InnoDB DEFAULT CHARSET=UTF8; 3，新建数据表对应的实体类 Account package com.southwind.entity; import lombok.Data; @Data public class Account { private long id; private String username; private String password; private int age; } 4，在 resources 创建 MyBatis 的配置文件 config.xml，文件名可自定义 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!--下面这两行代码需要自己导入--&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!-- 配置MyBatis运行环境 --&gt; &lt;environments default=\"development\"&gt; &lt;!--这里的environments的default值为要选用的数据库源id--&gt; &lt;environment id=\"development\"&gt;&lt;!--environment标签可用多个，即数据源可以有多个--&gt; &lt;!-- 配置JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- POOLED配置JDBC数据源连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"&gt; &lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis? serverTimezone=GMT&amp;amp;useUnicode=true&amp;amp; characterEncoding=utf-8&amp;amp;useSSL=false\"&gt; &lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 使用原生接口1、MyBatis 框架需要开发者自定义 SQL 语句，写在 Mapper.xml 文件中，实际开发中，会为每个实体类创建对应的 Mapper.xml ，定义管理该对象数据的 SQL。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!--下面这两行代码需要自己导入--&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.mapper.AccoutMapper\"&gt; &lt;insert id=\"save\" parameterType=\"com.southwind.entity.Account\"&gt; insert into t_account(username,password,age) values(#{username}, #{password},#{age}) &lt;!--这里的#{username}，#{password}，#{age}对应Account类的属性， 因为传过来的参数是Account--&gt; &lt;/insert&gt; &lt;/mapper&gt; namespace 通常设置为文件所在包+文件名的形式。 insert 标签表示执行添加操作。 select 标签表示执行查询操作。 update 标签表示执行更新操作。 delete 标签表示执行删除操作。 id 是实际调用实体类接口方法名。 parameterType 是调用对应方法时参数的数据类型。 2、在全局配置文件 config.xml 中注册 AccountMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!--下面这两行代码需要自己导入--&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!-- 配置MyBatis运行环境 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 配置JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- POOLED配置JDBC数据源连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"&gt; &lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis? serverTimezone=GMT&amp;amp;useUnicode=true&amp;amp; characterEncoding=utf-8&amp;amp;useSSL=false\"&gt; &lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 注册AccountMapper.xml --&gt; &lt;mappers&gt; &lt;mapper resource=\"com/southwind/mapper/AccountMapper.xml\"&gt;&lt;/mapper&gt; &lt;/mappers&gt; &lt;/configuration&gt; 3、调用 MyBatis 的原生接口执行添加操作。 public class Test { public static void main(String[] args) { //加载MyBatis配置文件 InputStream inputStream = Test.class.getClassLoader().getResourceAsStream(\"config.xml\"); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); /* String resource = \"org/mybatis/example/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); */ SqlSession sqlSession = sqlSessionFactory.openSession(); String statement = \"com.southwind.mapper.AccoutMapper.save\"; Account account = new Account(1L,\"张三\",\"123123\",22); sqlSession.insert(statement,account); sqlSession.commit();//对数据进行修改添加的操作就需要commit sqlSession.close(); } } SqlSessionFactoryBuilder 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。 SqlSessionFactory SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession 每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式： try (SqlSession session = sqlSessionFactory.openSession()) { // 你的应用逻辑代码 } 在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。 ==sqlSession.commit(); //对数据进行修改添加的操作就需要commit，如果只进行查询就不用== 通过 Mapper 代理实现自定义接口自定义接口，定义相关业务方法。 编写与方法相对应的 Mapper.xml。 1、自定义接口 package com.southwind.repository; import com.southwind.entity.Account; import java.util.List; public interface AccountRepository { public int save(Account account); public int update(Account account); public int deleteById(long id); public List&lt;Account&gt; findAll(); public Account findById(long id); } 2、创建接口对应的 Mapper.xml，定义接口方法对应的 SQL 语句。 statement 标签可根据 SQL 执行的业务选择 insert、delete、update、select。 MyBatis 框架会根据规定自动创建接口实现类的代理对象。 规则： Mapper.xml 中 namespace 为接口的全类名。 Mapper.xml 中 statement 的 id 为接口中对应的方法名。 Mapper.xml 中 statement 的 parameterType 和接口中对应方法的参数类型一致。 Mapper.xml 中 statement 的 resultType 和接口中对应方法的返回值类型一致。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!--下面这两行代码需要自己导入--&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.repository.AccountRepository\"&gt; &lt;insert id=\"save\" parameterType=\"com.southwind.entity.Account\"&gt; &lt;!--增删改操作不用指定resultType，默认是int类型，因为数据库执行成功返回的是行号--&gt; insert into t_account(username,password,age) values(#{username},# {password},#{age}) &lt;/insert&gt; &lt;update id=\"update\" parameterType=\"com.southwind.entity.Account\"&gt; update t_account set username = #{username},password = #{password},age = #{age} where id = #{id} &lt;/update&gt; &lt;delete id=\"deleteById\" parameterType=\"long\"&gt; delete from t_account where id = #{id} &lt;/delete&gt; &lt;select id=\"findAll\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account &lt;/select&gt; &lt;select id=\"findById\" parameterType=\"long\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where id = #{id} &lt;/select&gt; &lt;/mapper&gt; ==增删改操作不用指定resultType，默认是int类型，因为数据库执行成功返回的是行号== 3、在 config.xml 中注册 AccountRepository.xml &lt;!-- 注册AccountMapper.xml --&gt; &lt;mappers&gt; &lt;mapper resource=\"com/southwind/mapper/AccountMapper.xml\"&gt;&lt;/mapper&gt; &lt;mapper resource=\"com/southwind/repository/AccountRepository.xml\"&gt;&lt;/mapper&gt; &lt;/mappers&gt; 4、调用接口的代理对象完成相关的业务操作 package com.southwind.test; import com.southwind.entity.Account; import com.southwind.repository.AccountRepository; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.InputStream; import java.util.List; public class Test2 { public static void main(String[] args) { InputStream inputStream = Test.class.getClassLoader().getResourceAsStream(\"config.xml\"); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获取实现接口的代理对象 AccountRepository accountRepository = sqlSession.getMapper(AccountRepository.class); //添加对象 // Account account = new Account(3L,\"王五\",\"111111\",24); // int result = accountRepository.save(account); // sqlSession.commit(); //查询全部对象 // List&lt;Account&gt; list = accountRepository.findAll(); // for (Account account:list){ // System.out.println(account); // } // sqlSession.close(); //通过id查询对象 // Account account = accountRepository.findById(3L); // System.out.println(account); // sqlSession.close(); //修改对象 // Account account = accountRepository.findById(3L); // account.setUsername(\"小明\"); // account.setPassword(\"000\"); // account.setAge(18); 这样子account的id还是3L，所以修改的是id为3L的数据，如果写上 account.setId(10l);数据库里面没有的id会无法修改 也可以通过new一个Account来修改，但new来的Account的id必须设置成 数据库有的 // int result = accountRepository.update(account); // sqlSession.commit(); // System.out.println(result); // sqlSession.close(); //通过id删除对象 int result = accountRepository.deleteById(3L); System.out.println(result); sqlSession.commit(); sqlSession.close(); } } Mapper.xml statement 标签：select、update、delete、insert 分别对应查询、修改、删除、添加操作。 parameterType：参数数据类型 1、基本数据类型，通过 id 查询 Account &lt;select id=\"findById\" parameterType=\"long\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where id = #{id} &lt;/select&gt; 2、String 类型，通过 name 查询 Account &lt;select id=\"findByName\" parameterType=\"java.lang.String\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where username = #{username} &lt;/select&gt; 3、包装类，通过 id 查询 Account &lt;select id=\"findById2\" parameterType=\"java.lang.Long\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where id = #{id} &lt;/select&gt; 4、多个参数，通过 name 和 age 查询 Account &lt;select id=\"findByNameAndAge\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where username = #{arg0} and age = #{arg1} &lt;!-- 或者 select * from t_account where username = #{param1} and age = #{param2} --&gt; &lt;/select&gt; 5、Java Bean &lt;update id=\"update\" parameterType=\"com.southwind.entity.Account\"&gt; update t_account set username = #{username},password = #{password}, age =#{age} where id = #{id} &lt;/update&gt; resultType：结果类型 1、基本数据类型，统计 Account 总数 &lt;select id=\"count\" resultType=\"int\"&gt; select count(id) from t_account &lt;/select&gt; 2、包装类，统计 Account 总数 &lt;select id=\"count2\" resultType=\"java.lang.Integer\"&gt; select count(id) from t_account &lt;/select&gt; 3、String 类型，通过 id 查询 Account 的 name &lt;select id=\"findNameById\" resultType=\"java.lang.String\"&gt; select username from t_account where id = #{id} &lt;/select&gt; 4、Java Bean &lt;select id=\"findById\" parameterType=\"long\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where id = #{id} &lt;/select&gt; 课堂练习：根据 密码 和 名字 查询用户 思路一：直接在方法中传递参数 1、在接口方法的参数前加 @Param属性 //通过密码和名字查询用户 User selectUserByNP(@Param(\"username\") String username,@Param(\"pwd\") Stringpwd); /* 或者这样 User FindbyNP3( String name, String p); */ 2、Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型 &lt;select id=\"selectUserByNP\" resultType=\"com.kuang.pojo.User\"&gt; select * from user where name = #{username} and pwd = #{pwd} &lt;/select&gt; &lt;!-- 对应上面 User FindbyNP3( String name, String p); &lt;select id=\"FindbyNP3\" resultType=\"com.kuangshen.entity.User\"&gt; select * from user where name=#{param1} and pwd=#{param2}; &lt;/select&gt; --&gt; 3、使用方法 mapper.selectUserByNP(\"李四\", \"111\") 思路二：使用万能的Map 1、在接口方法中，参数直接传递Map； User selectUserByNP2(Map&lt;String,Object&gt; map); 2、编写sql语句的时候，需要传递参数类型，参数类型为map &lt;select id=\"selectUserByNP2\" parameterType=\"map\" resultType=\"com.kuang.pojo.User\"&gt; &lt;!-- parameterType=\"map\" 可写可不写--&gt; select * from user where name = #{username} and pwd = #{pwd} &lt;!-- username 对应 map 的 key ，pwd一样--&gt; &lt;/select&gt; 3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！ Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"username\",\"小明\"); map.put(\"pwd\",\"123456\"); User user = mapper.selectUserByNP2(map); 总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可 模糊查询like语句该怎么写? 第1种：在Java代码中添加sql通配符。 string wildcardname = “%smi%”; list&lt;name&gt; names = mapper.selectlike(wildcardname); &lt;select id=”selectlike” resultType=\"com.kuangshen.entity.User\"&gt; select * from foo where bar like #{value} &lt;/select&gt; 第2种：在sql语句中拼接通配符，会引起sql注入 (不推荐) string wildcardname = “smi”; list&lt;name&gt; names = mapper.selectlike(wildcardname); &lt;select id=”selectlike” resultType=\"com.kuangshen.entity.User\"&gt; select * from foo where bar like \"%\"#{value}\"%\" &lt;/select&gt; ResultMap 查询为null问题 要解决的问题：属性名和字段名不一致 1、查看之前的数据库的字段名 user（id，name，pwd） 2、Java中的实体类设计 public class User { private int id; //id private String name; //姓名 private String password; //密码和数据库的密码字段名不一样！ } 3、接口 //根据id查询用户 User selectUserById(int id); 4、mapper映射文件 &lt;select id=\"selectUserById\" resultType=\"user\"&gt; select * from user where id = #{id} &lt;/select&gt; 5、测试 @Test public void testSelectUserById() { SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接 UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } 结果: User{id=1, name=’狂神’, password=’null’} 查询出来发现 password 为空 . 说明出现了问题！ 分析： select * from user where id = #{id} 可以看做 select id,name,pwd from user where id = #{id} mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的get方法取值 , 由于找不到getPwd() , 所以password返回null ; 【自动映射】 解决方案 方案一：为列名指定别名 , 别名和java实体类的属性名一致 . &lt;select id=\"selectUserById\" resultType=\"User\"&gt; select id , name , pwd as password from user where id = #{id} &lt;/select&gt; 方案二：使用结果集映射-&gt;ResultMap 【推荐】 &lt;resultMap id=\"UserMap\" type=\"User\"&gt; &lt;!-- id为主键 --&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;!-- column 是数据库表的列名 , property 是对应实体类的属性名 --&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;!-- 一般只写不同名字段，同名字段写了也没用，所以上面 id 和 name 都可以不写 --&gt; &lt;result column=\"pwd\" property=\"password\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectUserById\" resultMap=\"UserMap\"&gt; select id , name , pwd from user where id = #{id} &lt;/select&gt; ResultMap 自动映射 resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来。 实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的长达数千行的代码。 ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。 你已经见过简单映射语句的示例了，但并没有显式指定 resultMap。比如： &lt;select id=\"selectUserById\" resultType=\"map\"&gt; select id , name , pwd from user where id = #{id} &lt;/select&gt; 上述语句只是简单地将所有的列映射到 HashMap 的键上，这由 resultType 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。 ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。 手动映射 1、返回值类型为resultMap &lt;select id=\"selectUserById\" resultMap=\"UserMap\"&gt; select id , name , pwd from user where id = #{id} &lt;/select&gt; 2、编写resultMap，实现手动映射！ &lt;resultMap id=\"UserMap\" type=\"User\"&gt; &lt;!-- id为主键 --&gt; &lt;id column=\"id\" property=\"user_id\"/&gt; &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt; &lt;result column=\"name\" property=\"user_name\"/&gt; &lt;result column=\"pwd\" property=\"user_password\"/&gt; &lt;/resultMap&gt; 如果世界总是这么简单就好了。但是肯定不是的，数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些。 日志工厂思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？ 如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。 对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。 Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具： SLF4J Apache Commons Logging Log4j 2 Log4j JDK logging 具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。 标准日志实现 指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。 &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; 测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug Log4j简介： Log4j是Apache的一个开源项目 通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件…. 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 使用步骤： 1、导入log4j的包 &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 2、log4j.properties 配置文件编写 (放在 resources 下) #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/xu.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 3、setting设置日志实现 &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;/settings&gt; 4、在程序中使用Log4j进行输出！ //注意导包：org.apache.log4j.Logger static Logger logger = Logger.getLogger(MyTest.class); @Test public void selectUser() { logger.info(\"info：进入selectUser方法\"); logger.debug(\"debug：进入selectUser方法\"); logger.error(\"error: 进入selectUser方法\"); SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users){ System.out.println(user); } session.close(); } 5、测试，看控制台输出！ 使用Log4j 输出日志 可以看到还生成了一个日志的文件 【需要修改 file 的日志级别】 limit实现分页思考：为什么需要分页？ 在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。 使用Limit实现分页 #语法 SELECT * FROM table LIMIT stratIndex，pageSize SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 #为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： #以前支持，现在已经作为bug被修复 SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. #如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; //检索前 5 个记录行 #换句话说，LIMIT n 等价于 LIMIT 0,n。 步骤： 1、修改Mapper文件 &lt;select id=\"selectUser\" parameterType=\"map\" resultType=\"user\"&gt; select * from user limit #{startIndex},#{pageSize} &lt;/select&gt; 2、Mapper接口，参数为map //选择全部用户实现分页 List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map); 3、在测试类中传入参数测试 推断：起始位置 = （当前页面 - 1 ） * 页面大小 //分页查询 , 两个参数startIndex , pageSize @Test public void testSelectUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int currentPage = 1; //第几页 int pageSize = 2; //每页显示几个 Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(\"startIndex\",(currentPage-1)*pageSize); map.put(\"pageSize\",pageSize); List&lt;User&gt; users = mapper.selectUser(map); for (User user: users){ System.out.println(user); } session.close(); } RowBounds分页 我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！ 步骤： 1、mapper接口 //选择全部用户RowBounds实现分页 List&lt;User&gt; getUserByRowBounds(); 2、mapper文件 &lt;select id=\"getUserByRowBounds\" resultType=\"user\"&gt; select * from user &lt;/select&gt; 3、测试类 在这里，我们需要使用RowBounds类 @Test public void testUserByRowBounds() { SqlSession session = MybatisUtils.getSession(); int currentPage = 2; //第几页 int pageSize = 2; //每页显示几个 RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize); //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了] List&lt;User&gt; users =session.selectList(\"com.kuang.mapper.UserMapper.getUserByRowBounds\", null,rowBounds); for (User user: users){ System.out.println(user); } session.close(); } PageHelper 分页插件，了解即可 使用注解开发 面向接口编程 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了； 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 接口的本身反映了系统设计人员对系统的抽象理解。 接口应有两类： 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）； 一个个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向区别 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 . 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 . 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构 利用注解开发 mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射（级联查询）并不能用注解来构建 sql 类型主要分成 : @select () @update () @Insert () @delete () 注意：利用注解开发就不需要mapper.xml映射文件了 . 1、我们在我们的接口中添加注解 //查询全部用户 @Select(\"select id,name,pwd password from user\") public List&lt;User&gt; getAllUser(); 2、在mybatis的核心配置文件中注入 &lt;!--使用class绑定接口--&gt; &lt;mappers&gt; &lt;mapper class=\"com.kuang.mapper.UserMapper\"/&gt; &lt;/mappers&gt; 3、我们去进行测试 @Test public void testGetAllUser() { SqlSession session = MybatisUtils.getSession(); //本质上利用了jvm的动态代理机制 UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.getAllUser(); for (User user : users){ System.out.println(user); } session.close(); } 4、利用Debug查看本质 5、本质上利用了jvm的动态代理机制 6、Mybatis详细的执行流程 注解增删改 改造MybatisUtils工具类的getSession( ) 方法，重载实现。 //获取SqlSession连接 public static SqlSession getSession(){ return getSession(true); //事务自动提交 } public static SqlSession getSession(boolean flag){ return sqlSessionFactory.openSession(flag); } 【注意】确保实体类和数据库字段对应，不对应的话无法查阅对应字段信息 查询： 1、编写接口方法注解 //根据id查询用户 @Select(\"select * from user where id = #{id}\") User selectUserById(@Param(\"id\") int id); 2、测试 @Test public void testSelectUserById() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } 新增： 1、编写接口方法注解 //添加一个用户 @Insert(\"insert into user (id,name,pwd) values (#{id},#{name},#{pwd})\") int addUser(User user); 2、测试 @Test public void testAddUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, \"秦疆\", \"123456\"); mapper.addUser(user); session.close(); } 修改： 1、编写接口方法注解 //修改一个用户 @Update(\"update user set name=#{name},pwd=#{pwd} where id = #{id}\") int updateUser(User user); 2、测试 @Test public void testUpdateUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, \"秦疆\", \"zxcvbn\"); mapper.updateUser(user); session.close(); } 删除： 1、编写接口方法注解 //根据id删除用 @Delete(\"delete from user where id = #{id}\") int deleteUser(@Param(\"id\")int id); 2、测试 @Test public void testDeleteUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); mapper.deleteUser(6); session.close(); } 【注意点：增删改一定记得对事务的处理】 关于@Param @Param注解用于给方法参数起一个名字。以下是总结的使用原则： 在方法只接受一个参数的情况下，可以不使用@Param。 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 不使用@Param注解时，参数只能有一个，并且是Javabean。 #与$的区别 #{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符?，很大程度上防止 SQL注入 【推荐使用】 INSERT INTO user (name) VALUES (#{name}); INSERT INTO user (name) VALUES (?); ${} 的作用是直接进行字符串替换，无法防止 SQL 注入 INSERT INTO user (name) VALUES ('${name}'); INSERT INTO user (name) VALUES ('kuangshen'); 使用注解和配置文件协同开发，才是MyBatis的最佳实践！ 级联查询一对多Student package com.southwind.entity; import lombok.Data; @Data public class Student { private long id; private String name; private Classes classes; //一个学生对应一个班级 } Classes package com.southwind.entity; import lombok.Data; import java.util.List; @Data public class Classes { private long id; private String name; private List&lt;Student&gt; students; //一个班级对应多个学生 } StudentRepository package com.southwind.repository; import com.southwind.entity.Student; public interface StudentRepository { public Student findById(long id); } StudentRepository.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.repository.StudentRepository\"&gt; &lt;!--将整个studentMap返回--&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"studentMap\"&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes c where s.id = #{id} and s.cid = c.id &lt;!--c.id as cid,c.name as cname这里修改字段名称是为了与前面student的 s.id和s.name做区分，因为查表出来显示的四个字段名称为“id，name，id， name”，方便操作--&gt; &lt;/select&gt; &lt;resultMap id=\"studentMap\" type=\"com.southwind.entity.Student\"&gt; &lt;!--主键使用id标签，其他字段属性用result标签--&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;!-- column 对应数据库字段，property 对应实体类属性--&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;!--这里对应classes类--&gt; &lt;association property=\"classes\" javaType=\"com.southwind.entity.Classes\"&gt; &lt;!--这里因为 c.id as cid ，所以 column 为 cid--&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;/mapper&gt; ==：对象是类就用这个标签，里面的类型定义是javaType属性定义== ==：对象是集合就用这个标签，里面的类型定义是ofType属性定义== 测试 StudentRepository studentRepository = sqlSession.getMapper(StudentRepository.class); System.out.println(studentRepository.findByIdLazy(2)); ClassesRepository package com.southwind.repository; import com.southwind.entity.Classes; public interface ClassesRepository { public Classes findById(long id); } ClassesRepository.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.repository.ClassesRepository\"&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"classesMap\"&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes c where c.id = #{id} and s.cid = c.id &lt;/select&gt; &lt;resultMap id=\"classesMap\" type=\"com.southwind.entity.Classes\"&gt; &lt;!-- column 对应数据库字段，property 对应实体类属性--&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"students\" ofType=\"com.southwind.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;/mapper&gt; 测试 ClassRepository classRepository = sqlSession.getMapper(ClassRepository.class); System.out.println(classRepository.findById(2)); 多对多Customer package com.southwind.entity; import lombok.Data; import java.util.List; @Data public class Customer { private long id; private String name; private List&lt;Goods&gt; goods; //顾客对应多种货物 } Goods package com.southwind.entity; import lombok.Data; import java.util.List; @Data public class Goods { private long id; private String name; private List&lt;Customer&gt; customers; //货物对应多个用户 } CustomerRepository package com.southwind.repository; import com.southwind.entity.Customer; public interface CustomerRepository { public Customer findById(long id); } CustomerRepository.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.repository.CustomerRepository\"&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"customerMap\"&gt; select c.id cid,c.name cname,g.id gid,g.name gname from customer c, goods g,customer_goods cg where c.id = #{id} and cg.cid = c.id and cg.gid = g.id &lt;/select&gt; &lt;resultMap id=\"customerMap\" type=\"com.southwind.entity.Customer\"&gt; &lt;!-- column 对应数据库字段，property 对应实体类属性--&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"goods\" ofType=\"com.southwind.entity.Goods\"&gt; &lt;id column=\"gid\" property=\"id\"/&gt; &lt;result column=\"gname\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;/mapper&gt; 测试 CustomerRepository customerRepository = sqlSession.getMapper(CustomerRepository.class); System.out.println(customerRepository.findById(2l)); GoodsRepository package com.southwind.repository; import com.southwind.entity.Goods; public interface GoodsRepository { public Goods findById(long id); } GoodsRepository.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.repository.GoodsRepository\"&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"goodsMap\"&gt; select c.id cid,c.name cname,g.id gid,g.name gname from customer c, goods g,customer_goods cg where g.id = #{id} and cg.cid = c.id and cg.gid = g.id &lt;/select&gt; &lt;resultMap id=\"goodsMap\" type=\"com.southwind.entity.Goods\"&gt; &lt;!-- column 对应数据库字段，property 对应实体类属性--&gt; &lt;id column=\"gid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"gname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"customers\" ofType=\"com.southwind.entity.Customer\"&gt; &lt;id column=\"cid\" property=\"id\"/&gt; &lt;result column=\"cname\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;/mapper&gt; 测试 GoodsRepository goodsRepository = sqlSession.getMapper(GoodsRepository.class); System.out.println(goodsRepository.findById(2)); 逆向工程MyBatis 框架需要：实体类、自定义 Mapper 接口、Mapper.xml 传统的开发中上述的三个组件需要开发者手动创建，逆向工程可以帮助开发者来自动创建三个组件，减轻开发者的工作量，提高工作效率。 如何使用MyBatis Generator，简称 MBG，是一个专门为 MyBatis 框架开发者定制的代码生成器，可自动生成MyBatis 框架所需的实体类、Mapper 接口、Mapper.xml，支持基本的 CRUD 操作，但是一些相对复杂的 SQL 需要开发者自己来完成。 1，新建 Maven 工程，pom.xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2，在 resources 创建 MBG 配置文件 generatorConfig.xml jdbcConnection 配置数据库连接信息。 javaModelGenerator 配置 JavaBean 的生成策略。 sqlMapGenerator 配置 SQL 映射文件生成策略。 javaClientGenerator 配置 Mapper 接口的生成策略。 table 配置目标数据表（tableName：表名，domainObjectName：JavaBean 类名）。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt; &lt;generatorConfiguration&gt; &lt;context id=\"testTables\" targetRuntime=\"MyBatis3\"&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/mybatis? useUnicode=true&amp;characterEncoding=UTF-8\" userId=\"root\" password=\"root\"&gt; &lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage=\"com.southwind.entity\" targetProject=\"./src/main/java\"&gt; &lt;!--./表示当前文件夹，可省略，resources文件夹就是项目的根目录--&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage=\"com.southwind.repository\" targetProject=\"./src/main/java\"&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.southwind.repository\" targetProject=\"./src/main/java\"&gt; &lt;/javaClientGenerator&gt; &lt;table tableName=\"t_user\" domainObjectName=\"User\"&gt;&lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 3，创建 Generator 执行类。 package com.southwind.test; import org.mybatis.generator.api.MyBatisGenerator; import org.mybatis.generator.config.Configuration; import org.mybatis.generator.config.xml.ConfigurationParser; import org.mybatis.generator.exception.InvalidConfigurationException; import org.mybatis.generator.exception.XMLParserException; import org.mybatis.generator.internal.DefaultShellCallback; import java.io.File; import java.io.IOException; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args) { List&lt;String&gt; warings = new ArrayList&lt;String&gt;(); boolean overwrite = true; String genCig = \"/generatorConfig.xml\"; File configFile = new File(Main.class.getResource(genCig).getFile()); ConfigurationParser configurationParser = new ConfigurationParser(warings); Configuration configuration = null; try { configuration = configurationParser.parseConfiguration(configFile); } catch (IOException e) { e.printStackTrace(); } catch (XMLParserException e) { e.printStackTrace(); } DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = null; try { myBatisGenerator = new MyBatisGenerator(configuration,callback,warings); } catch (InvalidConfigurationException e) { e.printStackTrace(); } try { myBatisGenerator.generate(null); } catch (SQLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } } } MyBatis 延迟加载什么是延迟加载？ 延迟加载也叫懒加载、惰性加载，使用延迟加载可以提高程序的运行效率，针对于数据持久层的操作，在某些特定的情况下去访问特定的数据库，在其他情况下可以不访问某些表，从一定程度上减少了 Java应用与数据库的交互次数。 查询学生和班级时，学生和班级是两张不同的表，如果当前需求只需要获取学生的信息，那么查询学生单表即可，如果需要通过学生获取对应的班级信息，则必须查询两张表。 不同的业务需求，需要查询不同的表，根据具体的业务需求来动态减少数据表查询的动作就是延迟加载。 1,在 config.xml 中开启延迟加载 &lt;settings&gt; &lt;!-- 打印SQL--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;/settings&gt; 2,将多表关联查询拆分成多个单表查询 StudentRepository public Student findByIdLazy(long id); ClassesRepository public Classes findByIdLazy(long id); ClassesRepository.xml &lt;select id=\"findByIdLazy\" parameterType=\"long\" resultType=\"com.southwind.entity.Classes\"&gt; select * from classes where id = #{id} &lt;/select&gt; StudentRepository.xml &lt;resultMap id=\"studentMapLazy\" type=\"com.southwind.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;association property=\"classes\" javaType=\"com.southwind.entity.Classes\" select=\"com.southwind.repository.ClassesRepository.findByIdLazy\" column=\"cid\"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"findByIdLazy\" parameterType=\"long\" resultMap=\"studentMapLazy\"&gt; select * from student where id = #{id} &lt;/select&gt; 3，运行测试 test.java StudentRepository studentRepository = sqlSession.getMapper(StudentRepository.class); Student student = studentRepository.findByIdLazy(2); System.out.println(student.getName()); 日志 ==&gt; Preparing: select * from student where id=? ==&gt; Parameters: 2(Long) &lt;== Columns: id, name, cid &lt;== Row: 2, 张三, 2 &lt;== Total: 1 张三 ==只查询一次，不会去查询班级表== 获取学生班级时，才会查询两次 System.out.println(student.getClasses()); 日志 ==&gt; Preparing: select * from student where id=? ==&gt; Parameters: 2(Long) &lt;== Columns: id, name, cid &lt;== Row: 2, 张三, 2 &lt;== Total: 1 ==&gt; Preparing: select * from class where id=?; ==&gt; Parameters: 2(Long) &lt;== Columns: id, name &lt;== Row: 2, 二年级 &lt;== Total: 1 Classes(id=2, name=二年级, students=null) MyBatis 缓存 缓存简介 1、什么是缓存 [ Cache ]？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 2、为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 3、什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。 什么是 MyBatis 缓存 使用缓存可以减少 Java 应用与数据库的交互次数，从而提升程序的运行效率。比如查询出 id = 1 的对象，第一次查询出之后会自动将该对象保存到缓存中，当下一次查询时，直接从缓存中取出对象即可，无需再次访问数据库。 MyBatis 缓存分类 1、一级缓存：SqlSession 级别，也称为本地缓存，默认开启，并且不能关闭。 操作数据库时需要创建 SqlSession 对象，在对象中有一个 HashMap 用于存储缓存数据，不同的 SqlSession 之间缓存数据区域是互不影响的。 一级缓存的作用域是 SqlSession 范围的，当在同一个 SqlSession 中执行两次相同的 SQL 语句时，第一次执行完毕会将结果保存到缓存中，第二次查询时直接从缓存中获取。 需要注意的是，如果 SqlSession 执行了 DML 操作（insert、update、delete）（即使操作的不是同一条数据），MyBatis 必须将缓存清空以保证数据的准确性。 2、二级缓存：也叫全局缓存，Mapper 级别，默认关闭，可以开启。 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 使二级级缓存时，多个 SqlSession 使用同一个 Mapper 的 SQL 语句操作数据库，得到的数据会存在二级缓存区，同样是使用 HashMap 进行数据存储，相比较于一级缓存，二级缓存的范围更广，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 二级缓存是多个 SqlSession 共享的，其作用域是 Mapper 的同一个 namespace，不同的 SqlSession两次执行相同的 namespace 下的 SQL 语句，参数也相等，则第一次执行成功之后会将数据保存到二级缓存中，第二次可直接从二级缓存中取出数据。 3、自定义二级缓存：为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 缓存原理图 sqlsession 先从二级缓存开始查询有无缓存，如果没有二级缓存再查看有无一级缓存，没有一级缓存的话就只能连接数据库进行查询 代码 一级缓存package com.southwind.test; import com.southwind.entity.Account; import com.southwind.repository.AccountRepository; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream; public class Test4 { public static void main(String[] args) { InputStream inputStream = Test.class.getClassLoader().getResourceAsStream(\"config.xml\"); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); AccountRepository accountRepository = sqlSession.getMapper(AccountRepository.class); Account account = accountRepository.findById(1L); System.out.println(account); // Account account1 = accountRepository.findById(1L); // System.out.println(account1); // 上面这样写就只执行一次SQL查询,sqlSession的一级缓存 sqlSession.close(); // 一级缓存会被清空 sqlSession = sqlSessionFactory.openSession(); accountRepository = sqlSession.getMapper(AccountRepository.class); Account account1 = accountRepository.findById(1L); //执行第二次查询 System.out.println(account1); } } 二级缓存1、MyBatis 自带的二级缓存 config.xml 配置开启二级缓存 &lt;settings&gt; &lt;!-- 打印SQL--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 开启二级缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt; Mapper.xml 中配置二级缓存 &lt;!-- 一般这样写就行，但这样写因为没有缓存处理策略，所以实体类得实现序列化接口--&gt; &lt;cache&gt;&lt;/cache&gt; &lt;!-- 这样写可以进行参数设置 --&gt; &lt;cache eviction=\"FIFO\" #缓存处理方式 flushInterval=\"60000\" #刷新时间 size=\"512\" #缓存数目大小 readOnly=\"true\"/&gt; #只读 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 实体类实现序列化接口 package com.southwind.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;import java.io.Serializable; @Data @AllArgsConstructor @NoArgsConstructor public class Account implements Serializable { private long id; private String username; private String password; private int age; } 测试代码 package com.southwind.test; import com.southwind.entity.Account; import com.southwind.repository.AccountRepository; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream; public class Test4 { public static void main(String[] args) { InputStream inputStream = Test.class.getClassLoader().getResourceAsStream(\"config.xml\"); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); AccountRepository accountRepository = sqlSession.getMapper(AccountRepository.class); Account account = accountRepository.findById(1L); System.out.println(account); sqlSession.close(); // 一级缓存会被清空，二级缓存还在 sqlSession = sqlSessionFactory.openSession(); accountRepository = sqlSession.getMapper(AccountRepository.class); Account account1 = accountRepository.findById(1L); System.out.println(account1); } } 结论 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中 2、第三方 ehcache 二级缓存 pom.xml 添加相关依赖 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt; &lt;/dependency&gt; 在 resources 中添加 ehcache.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\" updateCheck=\"false\"&gt; &lt;!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --&gt; &lt;diskStore path=\"./tmpdir/Tmp_EhCache\"/&gt; &lt;defaultCache eternal=\"false\" maxElementsInMemory=\"10000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"259200\" memoryStoreEvictionPolicy=\"LRU\"/&gt; &lt;cache name=\"cloud_user\" eternal=\"false\" maxElementsInMemory=\"5000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" memoryStoreEvictionPolicy=\"LRU\"/&gt; &lt;!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统崩了时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 --&gt; &lt;/ehcache&gt; config.xml 配置开启二级缓存 &lt;settings&gt; &lt;!-- 打印SQL--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 开启二级缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt; Mapper.xml 中配置二级缓存 &lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt; &lt;!-- 下面这些 property 标签可不写 --&gt; &lt;!-- 缓存创建之后，最后一次访问缓存的时间到缓存失效的时间间隔，以秒为单位 --&gt; &lt;property name=\"timeToIdleSeconds\" value=\"3600\"/&gt; &lt;!-- 缓存自创建时间起到失效的时间间隔 --&gt; &lt;property name=\"timeToLiveSeconds\" value=\"3600\"/&gt; &lt;!-- 缓存回收策略，LRU表示移除近期使用最少的对象 --&gt; &lt;property name=\"memoryStoreEvictionPolicy\" value=\"LRU\"/&gt; &lt;/cache&gt; 实体类不需要实现序列化接口 package com.southwind.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class Account { private long id; private String username; private String password; private int age; } MyBatis 动态 SQL动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句。使用动态 SQL 可简化代码的开发，减少开发者的工作量，程序可以自动根据业务参数来决定 SQL 的组成。 AccountRepository . java public Account findByAccount(Account account); if 标签&lt;select id=\"findByAccount\" parameterType=\"com.southwind.entity.Account\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where &lt;if test=\"id!=0\"&gt; id = #{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username = #{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password = #{password} &lt;/if&gt; &lt;if test=\"age!=0\"&gt; and age = #{age} &lt;/if&gt; &lt;/select&gt; if 标签可以自动根据表达式的结果来决定是否将对应的语句添加到 SQL 中，如果条件不成立则不添加，如果条件成立则添加。==（但是id必须设置，id不设置会查不出或者出异常）== 因为没有设置id，查询语句会变成 ==select * from t_account where and username = #{username}== 测试 Account account = new Account(); account.setId(1l);//必须设置 account.setUsername(\"张三\"); System.out.println(accountRepository.findByAccount(account)); where 标签&lt;select id=\"findByAccount\" parameterType=\"com.southwind.entity.Account\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account &lt;where&gt; &lt;if test=\"id!=0\"&gt; id = #{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username = #{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password = #{password} &lt;/if&gt; &lt;if test=\"age!=0\"&gt; and age = #{age} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; where 标签可以自动判断是否要删除语句块中的 and 或者 or 关键字，如果检测到 where 直接跟 and 或者 or 拼接，则自动删除 and 或者 or，通常情况下 if 和 where 结合起来使用。 测试 Account account = new Account(); // account.setId(1l); 不用必须设置id了 account.setUsername(\"张三\"); // account.setAge(22); account.setPassword(\"123123\"); System.out.println(accountRepository.findByAccount(account)); choose 、when 标签&lt;select id=\"findByAccount\" parameterType=\"com.southwind.entity.Account\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account &lt;where&gt; &lt;if test=\"id!=0\"&gt; id=#{id} &lt;/if&gt; &lt;choose&gt; &lt;when test=\"username!=null\"&gt; and username=#{username} &lt;/when&gt; &lt;when test=\"password!=null\"&gt; and password=#{password} &lt;/when&gt; &lt;when test=\"age!=0\"&gt; and age=#{age} &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; choose相当于switch ， when相当于case ， otherwise相当于default，这样子的话choose标签就只能一个字段判断，多的其他字段不会进行判断，只会选择第一个满足的语句块拼接，即使后面的语句块也满足判断条件 测试 Account account = new Account(); account.setId(5l); account.setUsername(\"王五\"); account.setAge(100); System.out.println(accountRepository.findByAccount(account)); 日志 ==&gt; Preparing: select * from t_account WHERE id=? and username=? ==&gt; Parameters: 5(Long), 王五(String) ==年龄 age 没有进行判断== trim 标签trim 标签中的 prefix 和 suffix 属性会被用于生成实际的 SQL 语句，会和标签内部的语句进行拼接，如果语句前后出现了 prefixOverrides 或者 suffixOverrides 属性中指定的值，MyBatis 框架会自动将其删除。 &lt;select id=\"findByAccount\" parameterType=\"com.southwind.entity.Account\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account &lt;trim prefix=\"where\" prefixOverrides=\"and|or\"&gt; &lt;if test=\"id!=0\"&gt; id = #{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username = #{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password = #{password} &lt;/if&gt; &lt;if test=\"age!=0\"&gt; and age = #{age} &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; set 标签set 标签用于 update 操作，会自动根据参数选择生成 SQL 语句，==生成的SQL只写需要修改的字段==。set 标签会自动去除多余的 “，”。 &lt;update id=\"update\" parameterType=\"com.southwind.entity.Account\"&gt; update t_account &lt;set&gt; &lt;if test=\"username!=null\"&gt; username = #{username}, &lt;/if&gt; &lt;if test=\"password!=null\"&gt; password = #{password}, &lt;/if&gt; &lt;if test=\"age!=0\"&gt; age = #{age} &lt;/if&gt; &lt;/set&gt; where id = #{id} &lt;/update&gt; 测试 Account account = new Account(); account.setId(5l); account.setUsername(\"666\"); account.setAge(100); 日志 ==&gt; Preparing: update t_account SET username=?, age=? where id=?; ==&gt; Parameters: 666(String), 100(Integer), 5(Long) foreach 标签foreach 标签可以迭代生成一系列值，这个标签主要用于 SQL 的 in 语句。 Account .java private List&lt;Long&gt; ids; AccountRepository . java public List&lt;Account&gt; findByIds(Account account); AccountRepositoryMapper .xml &lt;select id=\"findByIds\" parameterType=\"com.southwind.entity.Account\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account &lt;where&gt; &lt;foreach collection=\"ids\" open=\"id in (\" close=\")\" item=\"id\" separator=\",\"&gt; #{id} &lt;!-- 与item相对应 --&gt; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; 测试 Account account = new Account(); List&lt;Long&gt; ids = new ArrayList&lt;Long&gt;(); ids.add(1l); ids.add(2l); ids.add(4l); ids.add(5l); account.setIds(ids); System.out.println(accountRepository.findByIds(account)); 日志 ==&gt; Preparing: select * from t_account WHERE id in ( ? , ? , ? , ? ) ==&gt; Parameters: 1(Long), 2(Long), 4(Long), 5(Long) &lt;== Columns: id, username, password, age &lt;== Row: 1, 张三, 123123, 22 &lt;== Row: 2, 李四, 123123, 25 &lt;== Row: 4, 小明, 12345, 11 &lt;== Row: 5, 王五, 8080, 90 重用SQL片段有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。 提取SQL片段： &lt;sql id=\"if-title-author\"&gt; &lt;if test=\"title != null\"&gt; title = #{title} &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #{author} &lt;/if&gt; &lt;/sql&gt; 引用SQL片段： &lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog &lt;where&gt; &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt; &lt;include refid=\"if-title-author\"&gt;&lt;/include&gt; &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt; &lt;/where&gt; &lt;/select&gt; 注意： ①、最好基于单表操作来定义 sql 片段，提高片段的可重用性 ②、在 sql 片段中不要包括 where","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Redis","slug":"Redis笔记","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:28:18.376Z","comments":true,"path":"posts/ea4e970t.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e970t.html","excerpt":"","text":"RedisNosql概述为什么要用Nosql 1 、单机MySQL的年代！ 90 年代，一个基本的网站访问量一般不会太大，单个数据库完全足够！ 那个时候，更多的去使用静态网页 Html ~ 服务器根本没有太大的压力！ 思考一下，这种情况下：整个网站的瓶颈是什么？ 1 、数据量如果太大、一个机器放不下了！ 2 、数据的索引 （B+ Tree），一个机器内存也放不下 3 、访问量（读写混合），一个服务器承受不了~ 只要你开始出现以上的三种情况之一，那么你就必须要晋级！ 2 、Memcached（缓存） + MySQL + 垂直拆分 （读写分离） 网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据的压 力，我们可以使用缓存来保证效率！ 发展过程： 优化数据结构和索引–&gt; 文件缓存（IO）—&gt; Memcached（当时最热门的技术！） 3 、分库分表 + 水平拆分 + MySQL集群 技术和业务在发展的同时，对人的要求也越来越高！ 本质：数据库（读，写） 早些年 MyISAM： 表锁，十分影响效率！高并发下就会出现严重的锁问题 转战 InnoDB：行锁 慢慢的就开始使用分库分表来解决写的压力！ MySQL 在那个年代推出了表分区！这个并没有多少公司使用！ MySQL 的 集群，很好满足那个年代的所有需求！ 4、如今年代 2010–2020 十年之间，世界已经发生了翻天覆地的变化；（定位，也是一种数据，音乐，热榜！） MySQL 等关系型数据库就不够用了！数据量很多，变化很快~！ MySQL 有的使用它来村粗一些比较大的文件，博客，图片！数据库表很大，效率就低了！如果有一种数据库来专门处理这种数据，MySQL压力就变得十分小（研究如何处理这些问题！）大数据的IO压力下，表几乎没法更大！ 目前一个基本的互联网项目！ 为什么要用NoSQL！ 用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！ 这时候我们就需要使用NoSQL数据库的，Nosql 可以很好的处理以上的情况！ 什么是NoSQL NoSQL NoSQL = Not Only SQL （不仅仅是SQL） 关系型数据库：表格 ，行 ，列 泛指非关系型数据库的，随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区！ 暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的，而且是我们当下必须要掌握的一个技术！ 很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式！不需要多余的操作就可以横向扩展的 ！ Map&lt;String,Object&gt; 使用键值对来控制！ NoSQL 特点 1 、方便扩展（数据之间没有关系，很好扩展！） 2 、大数据量高性能（Redis 一秒写 8 万次，读取 11 万，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！） 3 、数据类型是多样型的！（不需要事先设计数据库！随取随用！如果是数据量十分大的表，很多人就无法设计了！） 4 、高可用 传统的RDBMS 和 NoSQL 传统 RDBMS -结构化组织 -SQL -数据和关系都在单独的表中 -严格的一致性 -操作数据定义语言 -基础的事务 -.... NoSQL -不仅仅是数据 -没有固定的查询语言 -键值对存储，列存储，文档存储，图形数据库（社交关系） -最终一致性， -CAP定理和BASE理论 （异地多活） 初级架构师！ -高性能，高可用，高可扩 -.... 了解：3V+3高 大数据时代的3V：主要是描述问题的 海量Volume 多样Variety 实时Velocity 大数据时代的 3 高：主要是对程序的要求 高并发 高可扩 高性能 真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的，阿里巴巴的架构演进！ 技术没有高低之分，就看你如何去使用！（提升内功，思维的提高！） 阿里巴巴演进分析思考问题：这么多东西难道都是在一个数据库中的吗? 技术急不得，越是慢慢学，才能越扎实！ 开源才是技术的王道！ 任何一家互联网的公司，都不可能只是简简单单让用户能用就好了！ 大量公司做的都是相同的业务；（竞品协议） 随着这样的竞争，业务是越来越完善，然后对于开发者的要求也是越来越高！ 如果你未来相当一个架构师： 没有什么是加一层解决不了的！ # 1、商品的基本信息 名称、价格、商家信息； 关系型数据库就可以解决了！ MySQL / Oracle （淘宝早年就去IOE了！- 王坚：推荐文章：阿里云的这群疯子： 40 分钟重要！） 淘宝内部的 MySQL 不是大家用的 MySQL # 2、商品的描述、评论（文字比较多） 文档型数据库中，MongoDB # 3、图片 分布式文件系统 FastDFS - 淘宝自己的 TFS - Gooale的 GFS - Hadoop HDFS - 阿里云的 oss # 4、商品的关键字 （搜索） - 搜索引擎 solr elasticsearch - ISerach：多隆（多去了解一下这些技术大佬！） 所有牛逼的人都有一段苦逼的岁月！但是你只要像SB一样的去坚持，终将牛逼！ # 5、商品热门的波段信息、 - 内存数据库 - Redis Tair、Memache... # 6、商品的交易，外部的支付接口 - 三方应用 要知道，一个简单地网页背后的技术一定不是大家所想的那么简单！ 大型互联网应用问题： 数据类型太多了！数据源繁多，经常重构！数据要改造，大面积改造？ 解决问题： 这里以上都是NoSQL入门概述，不仅能够提高大家的知识，还可以帮助大家了解大厂的工作内容！ NoSQL的四大分类KV键值对： 新浪： Redis 美团：Redis + Tair 阿里、百度：Redis + memecache 文档型数据库（bson格式 和json一样）： MongoDB （一般必须要掌握） MongoDB 是一个基于分布式文件存储的数据库，C++ 编写，主要用来处理大量的文档！ MongoDB 是一个介于关系型数据库和非关系型数据库中间的产品！MongoDB 是非关系型数据库中功能最丰富，最像关系型数据库的！ ConthDB 列存储数据库 HBase 分布式文件系统 图关系数据库 他不是存图形，放的是关系，比如：朋友圈社交网络，广告推荐！ Neo4j ，InfoGrid； 四者对比 分类 Examples举例 典型应用场景 数据模型 优点 缺点 键值（key-value） Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB 内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。 Key 指向 Value 的键值对，通常用hash table来实现 查找速度快 数据无结构化，通常只被当作字符串或者二进制数据 列存储数据库 Cassandra, HBase, Riak 分布式的文件系统 以列簇式存储，将同一列数据存在一起 查找速度快，可扩展性强，更容易进行分布式扩展 功能相对局限 文档型数据库 CouchDB, MongoDb Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容） Key-Value对应的键值对，Value为结构化数据 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 查询性能不高，而且缺乏统一的查询语法。 图形(Graph)数据库 Neo4J, InfoGrid, Infinite Graph 社交网络，推荐系统等。专注于构建关系图谱 图结构 利用图结构相关算法。比如最短路径寻址，N度关系查找等 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。 Redis入门概述 Redis 是什么？ Redis（Remote Dictionary Server )，即远程字典服务! 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！ Redis 能干嘛？ 内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof） 效率高，可以用于高速缓存 发布订阅系统 地图信息分析 计时器、计数器（浏览量！） …….. 特性 多样的数据类型 持久化 集群 事务 …… 缺点 不适合存储重要的数据（财务类等） 不适合存储经常修改的数据 Windows安装1 、下载安装包：https://github.com/dmajkic/redis/releases 2 、下载完毕得到压缩包： 3 、解压到自己电脑上的环境目录下的就可以的！Redis 十分的小，只有5M 4 、开启Redis，双击运行服务–redis-server.exe即可！ 5 、使用redis客户端–redis-cli.exe来连接redis 记住一句话，Window下使用确实简单，但是Redis 推荐我们使用Linux去开发使用！ Linux安装1 、下载安装包！ redis-5.0.8.tar.gz ，用xftp把安装包放到 /opt下 2 、解压Redis的安装包！ 程序 /opt tar -zxvf redis-5.0.8.tar.gz 3 、进入解压后的文件，可以看到我们redis的配置文件 4 、基本的环境安装 yum install gcc-c++ # 安装gcc，如果使用redis6.0以上的话需要gcc9.0版本以上才 gcc -v # 查看安装版本 make # 自动进行配置，安装后必须执行，需要等待较长时间 make install # 接着执行 5 、redis的默认安装路径 /usr/local/bin cd /usr/local/bin # 进入目录 ls # 查看 6 、将redis配置文件。复制到我们当前目录下 mkdir RedisConfig # 创建目录存放配置文件 cp /opt/redis-5.0.8/redis.conf RedisConfig/ # 将/opt/redis-5.0.8/下的配置文件拷贝过来 7 、redis默认不是后台启动的，修改配置文件！ vi redis.conf # 进行编辑 8 、启动Redis服务！ cd /usr/local/bin # 回到bin目录 redis-server RedisConfig/redis.conf # 启动redis服务 9 、使用redis-cli 进行连接测试！ redis-cli -p 6379 # -h 指定主机 -p指定端口 ping # 测试连接 10 、复制连接，新开一个窗口，查看redis的进程是否开启！ ps -ef|grep redis 11 、如何关闭Redis服务呢？ shutdown # 关闭服务 exit # 退出 12 、再次查看进程是否存在 13 、后面我们会使用单机多Redis启动集群测试！ 测试性能redis-benchmark 是一个压力测试工具！ 官方自带的性能测试工具！ redis-benchmark 命令参数！ redis 性能测试工具可选参数如下所示： 序号 选项 描述 默认值 1 -h 指定服务器主机名 127.0.0.1 2 -p 指定服务器端口 6379 3 -s 指定服务器 socket 4 -c 指定并发连接数 50 5 -n 指定请求数 10000 6 -d 以字节的形式指定 SET/GET 值的数据大小 2 7 -k 1=keep alive 0=reconnect 1 8 -r SET/GET/INCR 使用随机 key, SADD 使用随机值 9 -P 通过管道传输 请求 1 10 -q 强制退出 redis。仅显示 query/sec 值 11 –csv 以 CSV 格式输出 12 -l 生成循环，永久执行测试 13 -t 仅运行以逗号分隔的测试命令列表。 14 -I Idle 模式。仅打开 N 个 idle 连接并等待。 我们来简单测试下： # 测试： 100 个并发连接 每个并发100000 个请求，需要先开启redis redis-benchmark -h localhost -p 6379 -c 100 -n 100000 如何查看这些分析呢？ 基础的知识redis默认有 16 个数据库 默认使用的是第 0 个 # 可以使用 select 进行切换数据库！ 127 .0.0.1:6379&gt; select 3 # 切换数据库 OK 127 .0.0.1:6379[3]&gt; DBSIZE # 查看DB大小！ (integer) 0 127 .0.0.1:6379[3]&gt; set name xu 127 .0.0.1:6379[3]&gt; keys * # 查看数据库所有的key 1 ) \"name\" 127.0.0.1:6379[3]&gt; FLUSHDB # 清除当前数据库 OK 127.0.0.1:6379[3]&gt; FLUSHALL # 清除全部数据库的内容 OK 思考：为什么redis是 6379 ！粉丝效应！（了解一下即可！） Redis 是单线程的！ 明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽来定，既然可以使用单线程来实现，就使用单线程了！所以就使用了单线程了！ Redis 是C 语言写的，官方提供的数据为 100000+ 的QPS，完全不比同样是使用 key-vale的Memecache差！ Redis 为什么单线程还这么快？ 1 、误区 1 ：高性能的服务器一定是多线程的？ 2 、误区 2 ：多线程（CPU上下文会切换！）一定比单线程效率高！ 先去CPU&gt;内存&gt;硬盘的速度要有所了解！ 核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程 （CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！ 五大数据类型Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件MQ。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间 （geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和 自动分区（Cluster）提供高可用性（high availability）。 我们现在讲解的所有命令大家一定要全部记住，后面我们使用SpringBoot。Jedis，所有的方法就是这些命令！——单点登录 Redis-Key127 .0.0.1:6379&gt; keys * # 查看所有的key (empty list or set) 127 .0.0.1:6379&gt; set name kuangshen # set key OK 127 .0.0.1:6379&gt; keys * 1 ) \"name\" 127 .0.0.1:6379&gt; set age 1 OK 127 .0.0.1:6379&gt; keys * 1 ) \"age\" 2 ) \"name\" 127 .0.0.1:6379&gt; EXISTS name # 判断当前的key是否存在 (integer) 1 127 .0.0.1:6379&gt; EXISTS name (integer) 0 127 .0.0.1:6379&gt; move name 1 # 移除当前的key (integer) 1 127 .0.0.1:6379&gt; keys * 1 ) \"age\" 127 .0.0.1:6379&gt; set name qinjiang OK 127 .0.0.1:6379&gt; keys * 1 ) \"age\" 2 ) \"name\" 127 .0.0.1:6379&gt; clear 127 .0.0.1:6379&gt; keys * 1 ) \"age\" 2 ) \"name\" 127 .0.0.1:6379&gt; get name \"qinjiang\" 127 .0.0.1:6379&gt; EXPIRE name 10 # 设置key的过期时间，单位是秒 (integer) 1 127 .0.0.1:6379&gt; ttl name # 查看当前key的剩余时间 (integer) 4 127 .0.0.1:6379&gt; ttl name (integer) 3 127 .0.0.1:6379&gt; ttl name (integer) 2 127 .0.0.1:6379&gt; ttl name (integer) 1 127 .0.0.1:6379&gt; ttl name (integer) -2 127 .0.0.1:6379&gt; get name (nil) 127 .0.0.1:6379&gt; type name # 查看当前key的一个类型！ string 127 .0.0.1:6379&gt; type age string String（字符串）90% 的 java程序员使用 redis 只会使用一个String类型！ ########################################################################## 127 .0.0.1:6379&gt; set key1 v1 # 设置值 OK 127 .0.0.1:6379&gt; get key1 # 获得值 \"v1\" 127 .0.0.1:6379&gt; keys * # 获得所有的key 1 ) \"key1\" 127 .0.0.1:6379&gt; EXISTS key1 # 判断某一个key是否存在 (integer) 1 127 .0.0.1:6379&gt; APPEND key1 \"hello\" # 追加字符串，如果当前key不存在，就相当于setkey (integer) 7 127 .0.0.1:6379&gt; get key1 \"v1hello\" 127 .0.0.1:6379&gt; STRLEN key1 # 获取字符串的长度！ (integer) 7 127 .0.0.1:6379&gt; APPEND key1 \",kaungshen\" (integer) 17 127 .0.0.1:6379&gt; STRLEN key1 (integer) 17 127 .0.0.1:6379&gt; get key1 \"v1hello,kaungshen\" ########################################################################## # i++ # 步长 i+= 127 .0.0.1:6379&gt; set views 0 # 初始浏览量为 0 OK 127 .0.0.1:6379&gt; get views \"0\" 127 .0.0.1:6379&gt; incr views # 自增 1 浏览量变为 1 (integer) 1 127 .0.0.1:6379&gt; incr views (integer) 2 127 .0.0.1:6379&gt; get views \"2\" 127 .0.0.1:6379&gt; decr views # 自减 1 浏览量-1 (integer) 1 127 .0.0.1:6379&gt; decr views (integer) 0 127 .0.0.1:6379&gt; decr views (integer) -1 127 .0.0.1:6379&gt; get views \"-1\" 127 .0.0.1:6379&gt; INCRBY views 10 # 可以设置步长，指定增量！ (integer) 9 127 .0.0.1:6379&gt; INCRBY views 10 (integer) 19 127 .0.0.1:6379&gt; DECRBY views 5 (integer) 14 ########################################################################## # 字符串范围 getrange 127 .0.0.1:6379&gt; set key1 \"hello,kuangshen\" # 设置 key1 的值 OK 127 .0.0.1:6379&gt; get key1 \"hello,kuangshen\" 127 .0.0.1:6379&gt; getrange key1 0 3 # 截取字符串 [0,3] \"hell\" 127 .0.0.1:6379&gt; GETRANGE key1 0 -1 # 获取全部的字符串 和 get key是一样的 \"hello,kuangshen\" ########################################################################## # 替换！ setrange 127 .0.0.1:6379&gt; set key2 abcdefg OK 127 .0.0.1:6379&gt; get key2 \"abcdefg\" 127 .0.0.1:6379&gt; setrange key2 1 xx # 替换指定位置开始的字符串！ (integer) 7 127 .0.0.1:6379&gt; get key2 \"axxdefg\" ########################################################################## setex (set with expire) # 设置值同时设置过期时间 setnx (set if not exist) # 不存在再设置，存在的话保持原值 （在分布式锁中会常常使用！） 127 .0.0.1:6379&gt; setex key3 30 \"hello\" # 设置key3 的值为 hello,30秒后过期 OK 127 .0.0.1:6379&gt; ttl key3 (integer) 26 127 .0.0.1:6379&gt; get key3 \"hello\" 127 .0.0.1:6379&gt; setnx mykey \"redis\" # 如果mykey 不存在，创建mykey (integer) 1 127 .0.0.1:6379&gt; keys * 1 ) \"key2\" 2 ) \"mykey\" 3 ) \"key1\" 127 .0.0.1:6379&gt; ttl key3 (integer) -2 127 .0.0.1:6379&gt; setnx mykey \"MongoDB\" # 如果mykey存在，创建失败！ (integer) 0 127 .0.0.1:6379&gt; get mykey \"redis\" ########################################################################## mset # 同时设置多个值 mget # 同时获取多个值 127 .0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # 同时设置多个值 OK 127 .0.0.1:6379&gt; keys * 1 ) \"k1\" 2 ) \"k2\" 3 ) \"k3\" 127 .0.0.1:6379&gt; mget k1 k2 k3 # 同时获取多个值 1 ) \"v1\" 2 ) \"v2\" 3 ) \"v3\" 127.0.0.1:6379&gt; msetnx k1 v2 k4 v4 #设置失败，k1已经存在，msetnx是原子性操作 (integer) 0 127.0.0.1:6379&gt; get k4 (nil) ########################################################################## # 对象 set user:1 {name:zhangsan,age:3} # 设置一个user:1 对象 值为 json字符来保存一个对象！ 127.0.0.1:6379&gt; set user:1 {name:xu,age:3} OK 127.0.0.1:6379&gt; get user:1 #本质还是键值对，user:1为key，\"{name:xu,age:3}\"为value \"{name:xu,age:3}\" # 这里的key是一个巧妙的设计： user:{id}:{filed} , 如此设计在Redis中是完全OK了！ 127.0.0.1:6379&gt; mset user:1:name xu1 user:1:age 4 # 这里本质也是键值对 OK 127.0.0.1:6379&gt; get user:1 \"{name:xu,age:3}\" 127.0.0.1:6379&gt; mget user:1:name user:1:age 1) \"xu1\" 2) \"4\" ########################################################################## getset # 先get然后再set 127 .0.0.1:6379&gt; getset db redis # 如果不存在值，则返回 nil (nil) 127 .0.0.1:6379&gt; get db \"redis 127 .0.0.1:6379&gt; getset db mongodb # 如果存在值，获取原来的值，并设置新的值 \"redis\" 127 .0.0.1:6379&gt; get db \"mongodb\" 数据结构是相同的！ String类似的使用场景：value除了是我们的字符串还可以是我们的数字！ 计数器 统计多单位的数量 粉丝数 对象缓存存储！ List（列表）基本的数据类型，列表 在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列！ 所有的list命令都是用 L 开头的，Redis不区分大小写命令 ########################################################################## lpush # 从左边头部插入 rpush # 从右边尾部插入 127 .0.0.1:6379&gt; LPUSH list one # 将一个值或者多个值，插入到列表头部 （左） (integer) 1 127 .0.0.1:6379&gt; LPUSH list two (integer) 2 127 .0.0.1:6379&gt; LPUSH list three (integer) 3 127 .0.0.1:6379&gt; LRANGE list 0 -1 # 不能用get命令，获取list中的所有值！ 1 ) \"three\" 2 ) \"two\" 3 ) \"one\" 127 .0.0.1:6379&gt; LRANGE list 0 1 # 通过区间获取具体的值！ 1 ) \"three\" 2 ) \"two\" 127 .0.0.1:6379&gt; Rpush list right # 将一个值或者多个值，插入到列表尾部 （右） (integer) 4 127 .0.0.1:6379&gt; LRANGE list 0 -1 1 ) \"three\" 2 ) \"two\" 3 ) \"one\" 4 ) \"righr\" ########################################################################## lpop # 从左边头部移除 rpop # 从右边尾部移除 127 .0.0.1:6379&gt; LRANGE list 0 -1 1 ) \"three\" 2 ) \"two\" 3 ) \"one\" 4 ) \"righr\" 127 .0.0.1:6379&gt; Lpop list # 移除list的第一个元素 \"three\" 127 .0.0.1:6379&gt; Rpop list # 移除list的最后一个元素 \"righr\" 127 .0.0.1:6379&gt; LRANGE list 0 -1 1 ) \"two\" 2 ) \"one\" ########################################################################## lindex 127 .0.0.1:6379&gt; LRANGE list 0 -1 1 ) \"two\" 2 ) \"one\" 127 .0.0.1:6379&gt; lindex list 1 # 通过下标获得 list 中的某一个值！ \"one\" 127 .0.0.1:6379&gt; lindex list 0 \"two\" ########################################################################## llen # 获取列表长度 127 .0.0.1:6379&gt; Lpush list one (integer) 1 127 .0.0.1:6379&gt; Lpush list two (integer) 2 127 .0.0.1:6379&gt; Lpush list three (integer) 3 127 .0.0.1:6379&gt; Llen list # 返回列表的长度 (integer) 3 ########################################################################## lrem # 移除指定的值！（从头部开始的顺序移除） # 取关 uid 127.0.0.1:6379&gt; lrange list 0 -1 1) \"3\" 2) \"2\" 3) \"1\" 4) \"3\" 5) \"3\" 127.0.0.1:6379&gt; lrem list 1 3 # 移除list集合中指定个数的value，精确匹配 (integer) 1 127.0.0.1:6379&gt; lrange list 0 -1 1) \"2\" 2) \"1\" 3) \"3\" 4) \"3\" 127.0.0.1:6379&gt; lrem list 3 3 # 移除的个数比列表拥有的个数多的话就全部移除 (integer) 2 127.0.0.1:6379&gt; lrange list 0 -1 1) \"2\" 2) \"1\" ########################################################################## ltrim # 修剪 list被截断! 127.0.0.1:6379&gt; lrange list 0 -1 1) \"6\" 2) \"5\" 3) \"4\" 4) \"1\" 5) \"2\" 6) \"1\" 127.0.0.1:6379&gt; ltrim list 2 3 # 截取指定开始下标和结束下标的列表 OK 127.0.0.1:6379&gt; lrange list 0 -1 1) \"4\" 2) \"1\" ########################################################################## rpoplpush # 移除列表的最后一个元素，将他移动到新的列表的头部中！ 127 .0.0.1:6379&gt; rpush mylist \"hello\" (integer) 1 127 .0.0.1:6379&gt; rpush mylist \"hello1\" (integer) 2 127 .0.0.1:6379&gt; rpush mylist \"hello2\" (integer) 3 127 .0.0.1:6379&gt; rpoplpush mylist myotherlist # 移除列表的最后一个元素，将他移动到新的列表头部中！ \"hello2\" 127 .0.0.1:6379&gt; lrange mylist 0 -1 # 查看原来的列表 1 ) \"hello\" 2 ) \"hello1\" 127 .0.0.1:6379&gt; lrange myotherlist 0 -1 # 查看目标列表中，确实存在改值！ 1 ) \"hello2\" ########################################################################## lset # 将列表中指定下标的值替换为另外一个值，更新操作 127 .0.0.1:6379&gt; EXISTS list # 判断这个列表是否存在 (integer) 0 127 .0.0.1:6379&gt; lset list 0 item # 如果不存在列表我们去更新就会报错 (error) ERR no such key 127 .0.0.1:6379&gt; lpush list value1 (integer) 1 127 .0.0.1:6379&gt; LRANGE list 0 0 1 ) \"value1\" 127 .0.0.1:6379&gt; lset list 0 item # 如果存在，更新当前下标的值 OK 127 .0.0.1:6379&gt; LRANGE list 0 0 1 ) \"item\" 127 .0.0.1:6379&gt; lset list 1 other # 如果不存在，则会报错！ (error) ERR index out of range ########################################################################## linsert # 将某个具体的value插入到列把你中某个元素（如果列表有多个符合的元素，从头部开始找到的元素就是指定的元素）的前面或者后面！ 127 .0.0.1:6379&gt; Rpush mylist \"hello\" (integer) 1 127 .0.0.1:6379&gt; Rpush mylist \"world\" (integer) 2 127 .0.0.1:6379&gt; LINSERT mylist before \"world\" \"other\" (integer) 3 127 .0.0.1:6379&gt; LRANGE mylist 0 -1 1 ) \"hello\" 2 ) \"other\" 3 ) \"world\" 127 .0.0.1:6379&gt; LINSERT mylist after world new (integer) 4 127 .0.0.1:6379&gt; LRANGE mylist 0 -1 1 ) \"hello\" 2 ) \"other\" 3 ) \"world\" 4 ) \"new\" 小结 他实际上是一个链表，before Node ，after Node ， left，right 都可以插入值 如果key 不存在，创建新的链表 如果key存在，新增内容 如果移除了所有值，空链表，也代表不存在！ 在两边插入或者改动值，效率最高！ 改变中间元素，相对来说效率会低一点~ 消息排队！消息队列 （Lpush Rpop）， 栈（ Lpush Lpop）！ Set（集合）set中的值是不重复的！ ########################################################################## sadd # set集合中添加多个元素 smembers # 查看指定set的所有值 sismembers # 判断某一个值是不是在set集合中！ 127.0.0.1:6379&gt; sadd myset 1 2 3 4 5 xu # set集合中添加元素 (integer) 6 127.0.0.1:6379&gt; smembers myset # 查看指定set的所有值 1) \"2\" 2) \"4\" 3) \"3\" 4) \"5\" 5) \"xu\" 6) \"1\" 127 .0.0.1:6379&gt; sismembers myset 1 # 判断某一个值是不是在set集合中！ (integer) 1 127 .0.0.1:6379&gt; SISMEMBER myset 6 (integer) 0 ########################################################################## 127.0.0.1:6379&gt; scard myset # 获取set集合中的内容元素个数！ (integer) 6 ########################################################################## srem # 移除set集合中的指定元素(可以多个) 127.0.0.1:6379&gt; srem myset 3 4 # 移除set集合中的指定元素(可以多个) (integer) 2 127.0.0.1:6379&gt; smembers myset 1) \"2\" 2) \"5\" 3) \"xu\" 4) \"1\" ########################################################################## set 无序不重复集合。 srandmember # 抽随机元素！ 127.0.0.1:6379&gt; srandmember myset # 随机抽取一个元素 \"xu\" 127.0.0.1:6379&gt; srandmember myset \"5\" 127.0.0.1:6379&gt; srandmember myset 5 # 抽取随机5个元素 1) \"2\" 2) \"5\" 3) \"1\" 4) \"xu\" 127.0.0.1:6379&gt; srandmember myset 3 1) \"5\" 2) \"1\" 3) \"xu\" ########################################################################## spop # 随机删除key！（可指定个数） 127.0.0.1:6379&gt; spop myset \"1\" 127.0.0.1:6379&gt; spop myset \"5\" 127.0.0.1:6379&gt; smembers myset 1) \"2\" 2) \"xu\" 127.0.0.1:6379&gt; spop myset 2 # 随机删除两个元素 1) \"2\" 2) \"xu\" 127.0.0.1:6379&gt; smembers myset (empty list or set) ########################################################################## 将一个指定的值，移动到另外一个set集合！ 127 .0.0.1:6379&gt; sadd myset \"hello\" (integer) 1 127 .0.0.1:6379&gt; sadd myset \"world\" (integer) 1 127 .0.0.1:6379&gt; sadd myset \"kuangshen\" (integer) 1 127 .0.0.1:6379&gt; sadd myset2 \"set2\" (integer) 1 127 .0.0.1:6379&gt; smove myset myset2 \"kuangshen\" # 将一个指定的值，移动到另外一个set集合！ (integer) 1 127 .0.0.1:6379&gt; SMEMBERS myset 1 ) \"world\" 2 ) \"hello\" 127 .0.0.1:6379&gt; SMEMBERS myset2 1 ) \"kuangshen\" 2 ) \"set2\" ########################################################################## # 微博，B站，共同关注！(并集) # 数字集合类： - 差集 - 交集 - 并集 127.0.0.1:6379&gt; smembers myset 1) \"1\" 2) \"3\" 3) \"4\" 127.0.0.1:6379&gt; smembers myset2 1) \"1\" 2) \"2\" 127.0.0.1:6379&gt; sdiff myset myset2 # 差集，以第一个为主，做比较 1) \"3\" 2) \"4\" 127.0.0.1:6379&gt; sinter myset myset2 # 交集 ，共同好友 1) \"1\" 127.0.0.1:6379&gt; sunion myset myset2 # 并集 1) \"1\" 2) \"2\" 3) \"3\" 4) \"4\" 127.0.0.1:6379&gt; sadd myset3 1 2 3 5 (integer) 4 127.0.0.1:6379&gt; sdiff myset myset2 myset3 # 差集，以第一个为主，做比较 1) \"4\" 127.0.0.1:6379&gt; sinter myset myset2 myset3 1) \"1\" 127.0.0.1:6379&gt; sunion myset myset2 myset3 1) \"1\" 2) \"2\" 3) \"3\" 4) \"4\" 5) \"5\" 微博，A用户将所有关注的人放在一个set集合中！将它的粉丝也放在一个集合中！ 共同关注，共同爱好，二度好友，推荐好友！（六度分割理论） Hash（哈希）Map集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的 key-vlaue！ 127 .0.0.1:6379&gt; hset myhash field1 kuangshen # set一个具体 key-vlaue (integer) 1 127 .0.0.1:6379&gt; hget myhash field1 # 获取一个字段值 \"kuangshen\" 127 .0.0.1:6379&gt; hmset myhash field1 hello field2 world # set多个 key-vlaue OK 127 .0.0.1:6379&gt; hmget myhash field1 field2 # 获取多个字段值 1 ) \"hello\" 2 ) \"world\" 127 .0.0.1:6379&gt; hgetall myhash # 获取全部的数据， 1 ) \"field1\" 2 ) \"hello\" 3 ) \"field2\" 4 ) \"world\" 127 .0.0.1:6379&gt; hdel myhash field1 # 删除hash指定key字段！对应的value值也就消失了！ (integer) 1 127 .0.0.1:6379&gt; hgetall myhash 1 ) \"field2\" 2 ) \"world\" ########################################################################## 127 .0.0.1:6379&gt; hmset myhash field1 hello field2 world OK 127 .0.0.1:6379&gt; HGETALL myhash 1 ) \"field2\" 2 ) \"world\" 3 ) \"field1\" 4 ) \"hello\" 127 .0.0.1:6379&gt; hlen myhash # 获取hash表的字段数量！ (integer) 2 ########################################################################## 127 .0.0.1:6379&gt; hexists myhash field1 # 判断hash中指定字段是否存在！ (integer) 1 127 .0.0.1:6379&gt; HEXISTS myhash field3 (integer) 0 ########################################################################## # 只获得所有field # 只获得所有value 127 .0.0.1:6379&gt; hkeys myhash # 只获得所有field 1 ) \"field2\" 2 ) \"field1\" 127 .0.0.1:6379&gt; hvals myhash # 只获得所有value 1 ) \"world\" 2 ) \"hello\" ########################################################################## # 没有 hdecrb 和 hsetex 指令 127 .0.0.1:6379&gt; hset myhash field3 5 (integer) 1 127 .0.0.1:6379&gt; hincrby myhash field3 2 # 指定增量！ (integer) 7 127 .0.0.1:6379&gt; HINCRBY myhash field3 -2 (integer) 5 127 .0.0.1:6379&gt; hsetnx myhash field4 hello # 如果不存在则可以设置 (integer) 1 127 .0.0.1:6379&gt; hsetnx myhash field4 world # 如果存在则不能设置 (integer) 0 hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！hash 更适合于对象的存储，String更加适合字符串存储！ Zset（有序集合）在set的基础上，增加了一个值，set k1 v1 zset k1 score1 v1 ，根据 score 的大小进行排序 127 .0.0.1:6379&gt; zadd myset 1 one # 添加一个值 (integer) 1 127 .0.0.1:6379&gt; zadd myset 2 two 3 three # 添加多个值 (integer) 2 127 .0.0.1:6379&gt; zrange myset 0 -1 1 ) \"one\" 2 ) \"two\" 3 ) \"three\" 127.0.0.1:6379&gt; zrange myset 0 -1 withscores # 附带成绩（比较排序值）显示 1) \"one\" 2) \"1\" 3) \"two\" 4) \"2\" 5) \"three\" 6) \"3\" ########################################################################## #排序如何实现 127 .0.0.1:6379&gt; zadd salary 2500 xiaohong # 添加三个用户 (integer) 1 127 .0.0.1:6379&gt; zadd salary 5000 zhangsan (integer) 1 127 .0.0.1:6379&gt; zadd salary 500 xu (integer) 1 # ZRANGEBYSCORE key min max 127 .0.0.1:6379&gt; zrangebyscore salary -inf +inf # 显示全部的用户 从小到大！ 这个指令跟 ‘ zrange salary 0 -1 ’一样 1 ) \"xu\" 2 ) \"xiaohong\" 3 ) \"zhangsan\" 127.0.0.1:6379&gt; zrevrange salary 0 -1 # 从大到小排序 1) \"zhangsan\" 2) \"xiaohong\" 3) \"xu\" 127 .0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores # 显示全部的用户并且附带成绩 1 ) \"xu\" 2 ) \"500\" 3 ) \"xiaohong\" 5 ) \"zhangsan\" 6 ) \"5000\" 127 .0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores # 显示工资小于 2500 员工的升序排序！ 1 ) \"kaungshen\" 2 ) \"500\" 3 ) \"xiaohong\" 4 ) \"2500\" ########################################################################## # 移除zset中的元素 127 .0.0.1:6379&gt; zrange salary 0 -1 1 ) \"xu\" 2 ) \"xiaohong\" 3 ) \"zhangsan\" 127 .0.0.1:6379&gt; zrem salary xiaohong # 移除有序集合中的指定元素 (integer) 1 127 .0.0.1:6379&gt; zrange salary 0 -1 1 ) \"kaungshen\" 2 ) \"zhangsan\" 127 .0.0.1:6379&gt; zcard salary # 获取有序集合中的个数 (integer) 2 ########################################################################## 127 .0.0.1:6379&gt; zadd myset 1 hello (integer) 1 127 .0.0.1:6379&gt; zadd myset 2 world 3 kuangshen (integer) 2 127 .0.0.1:6379&gt; zcount myset 1 3 # 获取指定区间的成员数量！ (integer) 3 127 .0.0.1:6379&gt; zcount myset 1 2 (integer) 2 其它的一些API，可以去查看官方文档！ 案例思路：set 排序 存储班级成绩表，工资表排序！ 普通消息， 1 ， 重要消息 2 ，带权重进行判断！ 排行榜应用实现，取Top N 测试！ 三种特殊数据类型Geospatial 地理位置朋友的定位，附近的人，打车距离计算？ Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！ 可以查询一些测试数据：http://www.jsons.cn/lngcodeinfo/0706D99C19A781A3/ 只有 六个命令： Redis 地理位置(geo) 命令 命令 描述 Redis GEOHASH 命令 返回一个或多个位置元素的 Geohash 表示 Redis GEOPOS 命令 从key里返回所有给定位置元素的位置（经度和纬度） Redis GEODIST 命令 返回两个给定位置之间的距离 Redis GEORADIUS 命令 以给定的经纬度为中心， 找出某一半径内的元素 Redis GEOADD 命令 将指定的地理空间位置（纬度、经度、名称）添加到指定的key中 Redis GEORADIUSBYMEMBER 命令 找出位于指定范围内的元素，中心点是由给定的位置元素决定 GEOADD 添加地理位置 # geoadd 添加地理位置 # 规则：两极无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！ # 有效的经度从-180度到 180 度。 # 有效的纬度从-85.05112878度到85.05112878度。 # 当坐标位置超出上述指定范围时，该命令将会返回一个错误。 # 127.0.0.1:6379&gt; geoadd china:city 39.90 116.40 beijin # (error) ERR invalid longitude,latitude pair 39 .900000,116.400000 # 参数 key 值（） 127 .0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing (integer) 1 127 .0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai (integer) 1 127 .0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen (integer) 2 127 .0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian (integer) 2 GEOPOS 获取指定的城市的经度和纬度 获得指定位置定位：一定是一个坐标值！ 127 .0.0.1:6379&gt; geopos china:city beijing # 获取指定的城市的经度和纬度！ 1 ) 1 ) \"116.39999896287918091\" 2 ) \"39.90000009167092543\" 127 .0.0.1:6379&gt; GEOPOS china:city beijing chongqing 1 ) 1 ) \"116.39999896287918091\" 2 ) \"39.90000009167092543\" 2 ) 1 ) \"106.49999767541885376\" 2 ) \"29.52999957900659211\" GEODIST 返回两个位置之间的距离 两人之间的距离！ 单位： m 表示单位为米 (默认单位) km 表示单位为千米 mi 表示单位为英里 ft 表示单位为英尺 127 .0.0.1:6379&gt; geodist china:city beijing shanghai km # 查看上海到北京的直线距离 \"1067.3788\" 127 .0.0.1:6379&gt; GEODIST china:city beijing chongqing km # 查看重庆到北京的直线距离 \"1464.0708\" GEORADIUS 以给定的经纬度为中心， 找出某一半径内的位置元素 我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！ 获得指定数量的人， 200 所有数据应该都录入：china:city ，才会让结果更加请求！ 127 .0.0.1:6379&gt; georadius china:city 110 30 1000 km # 以 110 ， 30 这个经纬度为中心，寻找方圆1000km内的城市 1 ) \"chongqi\" 2 ) \"xian\" 3 ) \"shengzhen\" 4 ) \"hangzhou\" 127 .0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km 1 ) \"chongqi\" 2 ) \"xian\" 127 .0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist # 显示附带位置距离 1 ) 1 ) \"chongqi\" 2 ) \"341.9374\" 2 ) 1 ) \"xian\" 2 ) \"483.8340\" 127 .0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withcoord # 显示他人的定位信息 1 ) 1 ) \"chongqi\" 2 ) 1 ) \"106.49999767541885376\" 2 ) \"29.52999957900659211\" 2 ) 1 ) \"xian\" 2 ) 1 ) \"108.96000176668167114\" 2 ) \"34.25999964418929977\" 127 .0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 1 # 筛选出指定数目的结果！ 1 ) 1 ) \"chongqi\" 2 ) \"341.9374\" 3 ) 1 ) \"106.49999767541885376\" 2 ) \"29.52999957900659211\" 127 .0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 2 1) 1) \"chongqing\" 2) \"341.9374\" 3) 1) \"106.49999767541885376\" 2) \"29.52999957900659211\" 2) 1) \"xian\" 2) \"483.8340\" 3) 1) \"108.96000176668167114\" 2) \"34.25999964418929977\" GEORADIUSBYMEMBER 以指定的key为中心，找出某一半径内的位置元素 # 找出位于指定元素周围的其他元素！ 127 .0.0.1:6379&gt; georadiusbymember china:city beijing 1000 km 1 ) \"beijing\" 2 ) \"xian\" 127 .0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km 1 ) \"hangzhou\" 2 ) \"shanghai\" GEOHASH 返回一个或多个位置元素的 Geohash 表示 该命令将返回 11 个字符的Geohash字符串! # 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！ 127 .0.0.1:6379&gt; geohash china:city beijing chongqing 1 ) \"wx4fbxxfke0\" 2 ) \"wm5xzrybty0\" GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！ 127 .0.0.1:6379&gt; zrange china:city 0 -1 # 查看地图中全部的元素 1 ) \"chongqing\" 2 ) \"xian\" 3 ) \"shengzhen\" 4 ) \"hangzhou\" 5 ) \"shanghai\" 6 ) \"beijing\" 127 .0.0.1:6379&gt; zrem china:city beijing # 移除指定元素！ (integer) 1 127 .0.0.1:6379&gt; ZRANGE china:city 0 -1 1 ) \"chongqing\" 2 ) \"xian\" 3 ) \"shengzhen\" 4 ) \"hangzhou\" 5 ) \"shanghai\" Hyperloglog 基数统计 什么是基数？ A {1,3,5,7,8,7} B{1,3,5,7,8} 基数（不重复的元素） = 5，可以接受误差！ 简介 Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！ Redis Hyperloglog 基数统计的算法！ 优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的话 Hyperloglog 首选！ 网页的 UV （一个人访问一个网站多次，但是还是算作一个人！） 传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断! 这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id； 0.81% 错误率！ 统计UV任务，可以忽略不计的！ 测试使用 127 .0.0.1:6379&gt; pfadd mykey a b c d e f g h i j # 创建第一组元素 mykey (integer) 1 127 .0.0.1:6379&gt; pfcount mykey # 统计 mykey 元素的基数数量 (integer) 10 127 .0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2 (integer) 1 127 .0.0.1:6379&gt; PFCOUNT mykey2 (integer) 9 127 .0.0.1:6379&gt; pfmerge mykey3 mykey mykey2 # 合并两组 mykey mykey2 =&gt; mykey3 并集 OK 127 .0.0.1:6379&gt; PFCOUNT mykey3 # 看并集的数量！ (integer) 15 如果允许容错，那么一定可以使用 Hyperloglog ！ 如果不允许容错，就使用 set 或者自己的数据类型即可！ Bitmap 位图 位存储 统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡， 365 打卡！ 两个状态的，都可以使用Bitmaps！ Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有 0 和 1 两个状态！ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！ # 使用bitmap 来记录 周一到周日的打卡！ # 周一： 1 周二： 0 周三： 1 周四：0 ...... 127.0.0.1:6379&gt; setbit sign 0 1 (integer) 0 127.0.0.1:6379&gt; setbit sign 1 0 (integer) 0 127.0.0.1:6379&gt; setbit sign 2 1 (integer) 0 127.0.0.1:6379&gt; setbit sign 3 0 (integer) 0 127.0.0.1:6379&gt; setbit sign 4 0 (integer) 0 127.0.0.1:6379&gt; setbit sign 5 1 (integer) 0 127.0.0.1:6379&gt; setbit sign 6 0 (integer) 0 # 查看某一天是否有打卡！ 127.0.0.1:6379&gt; getbit sign 5 (integer) 1 127.0.0.1:6379&gt; getbit sign 6 (integer) 0 # 统计操作，统计 打卡的天数！ 127.0.0.1:6379&gt; bitcount sign (integer) 3 事务Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行！ 一次性、顺序性、排他性！执行一些列的命令！ ------ 队列 set set set 执行 ------- Redis事务没有没有隔离级别的概念！ 所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec Redis单条命令是保证原子性的，但是事务不保证原子性！ redis的事务： 开启事务（multi） 命令入队（……） 执行事务（exec） 正常执行事务 # 正常执行事务！ 127 .0.0.1:6379&gt; multi # 开启事务 OK # 命令入队 127 .0.0.1:6379&gt; set k1 v1 QUEUED 127 .0.0.1:6379&gt; set k2 v2 QUEUED 127 .0.0.1:6379&gt; get k2 QUEUED 127 .0.0.1:6379&gt; set k3 v3 QUEUED 127 .0.0.1:6379&gt; exec # 执行事务 1 ) OK 2 ) OK 3 ) \"v2\" 4 ) OK 放弃事务 127 .0.0.1:6379&gt; multi # 开启事务 OK 127 .0.0.1:6379&gt; set k1 v1 QUEUED 127 .0.0.1:6379&gt; set k2 v2 QUEUED 127 .0.0.1:6379&gt; set k4 v4 QUEUED 127 .0.0.1:6379&gt; discard # 取消事务 OK 127 .0.0.1:6379&gt; get k4 # 事务队列中命令都不会被执行！ (nil) 编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！ 127 .0.0.1:6379&gt; multi OK 127 .0.0.1:6379&gt; set k1 v1 QUEUED 127 .0.0.1:6379&gt; set k2 v2 QUEUED 127 .0.0.1:6379&gt; set k3 v3 QUEUED 127 .0.0.1:6379&gt; getset k3 # 错误的命令 (error) ERR wrong number of arguments for 'getset' command 127 .0.0.1:6379&gt; set k4 v4 QUEUED 127 .0.0.1:6379&gt; set k5 v5 QUEUED 127 .0.0.1:6379&gt; exec # 执行事务报错！ (error) EXECABORT Transaction discarded because of previous errors. 127 .0.0.1:6379&gt; get k5 # 所有的命令都不会被执行！ (nil) 运行时异常， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！ 127 .0.0.1:6379&gt; set k1 \"v1\" OK 127 .0.0.1:6379&gt; multi OK 127 .0.0.1:6379&gt; incr k1 # 会执行的时候失败！ QUEUED 127 .0.0.1:6379&gt; set k2 v2 QUEUED 127 .0.0.1:6379&gt; set k3 v3 QUEUED 127 .0.0.1:6379&gt; get k3 QUEUED 127 .0.0.1:6379&gt; exec 1 ) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是依旧正常执行成功了！ 2 ) OK 3 ) OK 4 ) \"v3\" 127 .0.0.1:6379&gt; get k2 \"v2\" 127 .0.0.1:6379&gt; get k3 \"v3\" 监控！ Watch （面试常问！） 悲观锁：很悲观，认为什么时候都会出问题，无论做什么都会加锁！ 乐观锁：很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否有人修改过这个数据 获取version 更新的时候比较 version Redis 监视测试 单线程 正常执行成功！ 127 .0.0.1:6379&gt; set money 100 OK 127 .0.0.1:6379&gt; set out 0 OK 127 .0.0.1:6379&gt; watch money # 监视 money 对象 OK 127 .0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！ OK 127 .0.0.1:6379&gt; DECRBY money 20 QUEUED 127 .0.0.1:6379&gt; INCRBY out 20 QUEUED 127 .0.0.1:6379&gt; exec 1 ) (integer) 80 2 ) (integer) 20 测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！ 127 .0.0.1:6379&gt; watch money # 监视 money OK 127 .0.0.1:6379&gt; multi OK 127 .0.0.1:6379&gt; DECRBY money 10 QUEUED 127 .0.0.1:6379&gt; INCRBY out 10 QUEUED 127 .0.0.1:6379&gt; exec # 执行之前，另外一个线程修改了money的值，这个时候，就会导致事务执行失败！ (nil) 如果修改失败，获取最新的值就好 127.0.0.1:6379&gt; unwatch # 事务执行失败，先解锁 OK 127.0.0.1:6379&gt; get money # 查看被修改后的值 \"900\" 127.0.0.1:6379&gt; watch money # 获取最新的值，再次监视 OK 127.0.0.1:6379&gt; multi # 开启事务 OK 127.0.0.1:6379&gt; decrby money 100 QUEUED 127.0.0.1:6379&gt; incrby out 100 QUEUED 127.0.0.1:6379&gt; exec # 对比监视的值是否发生变化，如果没有，执行成功 1) (integer) 800 2) (integer) 100 Jedis什么是Jedis 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作 Redis 中间件！如果你要使用java 操作 redis，那么一定要对 Jedis 十分的熟悉！ 测试 1 、导入对应的依赖 &lt;!--导入jedis的包--&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--fastjson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2 、编码测试： 连接数据库 操作命令 断开连接！ public class RedisPing { public static void main(String[] args) { Jedis jedis = new Jedis(\"127.0.0.1\",6379); System.out.println(jedis.ping()); jedis.close(); //关闭连接 // jedis.shutdown(); //关闭服务 } } 输出： 常用的API String List Set Hash Zset 所有的api命令，就是我们对应的上面学习的指令，一个都没有变化！ 事务package com.xu; import com.alibaba.fastjson.JSONObject; import redis.clients.jedis.Jedis; import redis.clients.jedis.Transaction; public class RedisPing { public static void main(String[] args) { Jedis jedis = new Jedis(\"127.0.0.1\",6379); jedis.flushDB(); //清除数据 JSONObject jsonObject = new JSONObject(); //json对象 jsonObject.put(\"name\", \"xu\"); jsonObject.put(\"age\", 11); String jsonString = jsonObject.toJSONString(); //转换为json字符串 Transaction multi = jedis.multi();//开启事务 try { multi.set(\"key1\", jsonString); multi.set(\"key2\", jsonString); int i = 1 / 0; // 代码抛出异常事务，执行失败！ multi.exec(); //执行事务 } catch (Exception e) { multi.discard(); //出现异常，停止事务 e.printStackTrace(); } finally { System.out.println(jedis.get(\"key1\")); System.out.println(jedis.get(\"key2\")); jedis.close(); //关闭连接 } } } SpringBoot整合SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！ SpringData 也是和 SpringBoot 齐名的项目！ 说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce? jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接 池！ 更像 BIO 模式 lettuce : 采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据 了，更像 NIO 模式 源码分析： @Bean // 我们可以自己定义一个redisTemplate来替换这个默认的！ @ConditionalOnMissingBean(name = \"redisTemplate\") public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory isConnectionFactory) throws UnknownHostException { // 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！ // 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean // 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！ public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } 整合测试一下 1 、导入依赖 &lt;!-- 操作redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2 、配置连接 # 配置redis spring.redis.host=127.0.0.1 spring.redis.port= 6379 3 、测试！ @SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { // redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // opsForValue 操作字符串 类似String ，位图在这个里面 // opsForList 操作List 类似List // opsForSet // opsForHash // opsForZSet // opsForGeo // opsForHyperLogLog // 除了进本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD // 获取redis的连接对象 // RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); // connection.flushDb(); // connection.flushAll(); redisTemplate.opsForValue().set(\"mykey\",\"关注狂神说公众号\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\")); } } 关于对象的保存： 我们来编写一个自己的 RedisTemplete package com.kuang.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration public class RedisConfig { // 自己定义了一个 RedisTemplate @Bean @SuppressWarnings(\"all\") public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) { // 固定模板，在企业中，拿去就可以直接使用！ // 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); // Json序列化配置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // String 的序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; } } 所有的redis操作，其实对于java开发人员来说，十分的简单，更重要是要去理解redis的思想和每一种数据结构的用处和作用场景！ Redis.conf详解启动的时候，就通过配置文件来启动！ 单位 1 、配置文件 unit单位 对大小写不敏感！ 包含 就好比我们学习的Spring、Improt， include 网络 bind 127 .0.0.1 # 绑定的ip protected-mode yes # 保护模式 port 6379 # 端口设置 通用 GENERAL daemonize yes # 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！ pidfile /var/run/redis_6379.pid # 如果以后台的方式运行，我们就需要指定一个 pid 文件！ # 日志 # Specify the server verbosity level. # This can be one of: # debug (a lot of information, useful for development/testing) # verbose (many rarely useful info, but not a mess like the debug level) # notice (moderately verbose, what you want in production probably) 生产环境 # warning (only very important / critical messages are logged) loglevel notice logfile \"\" # 日志的文件位置名 databases 16 # 数据库的数量，默认是 16 个数据库 always-show-logo yes # 是否总是显示LOGO 快照 持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb 和 .aof redis 是内存数据库，如果没有持久化，那么数据断电即失！ # 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作 save 900 1 # 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作 save 300 10 # 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作 save 60 10000 # 我们之后学习持久化，会自己定义这个测试！ stop-writes-on-bgsave-error yes # 持久化如果出错，是否还需要继续工作！ rdbcompression yes # 是否压缩 rdb 文件，需要消耗一些cpu资源！ rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验！ dir ./ # rdb 文件保存的目录！ REPLICATION 主从复制 SECURITY 安全 可以在这里设置redis的密码，默认是没有密码！ 127 .0.0.1:6379&gt; ping PONG 127 .0.0.1:6379&gt; config get requirepass # 获取redis的密码 1 ) \"requirepass\" 2 ) \"\" 127 .0.0.1:6379&gt; config set requirepass \"123456\" # 设置redis的密码 OK 127 .0.0.1:6379&gt; config get requirepass # 发现所有的命令都没有权限了 (error) NOAUTH Authentication required. 127 .0.0.1:6379&gt; ping (error) NOAUTH Authentication required. 127 .0.0.1:6379&gt; auth 123456 # 使用密码进行登录！ OK 127 .0.0.1:6379&gt; config get requirepass 1 ) \"requirepass\" 2 ) \"123456\" 限制 CLIENTS maxclients 10000 # 设置能连接上redis的最大客户端的数量 maxmemory &lt;bytes&gt; # redis 配置最大的内存容量 maxmemory-policy noeviction # 内存到达上限之后的处理策略 1 、volatile-lru：只对设置了过期时间的key进行LRU（默认值） 2 、allkeys-lru ： 删除lru算法的key 3 、volatile-random：随机删除即将过期key 4 、allkeys-random：随机删除 5 、volatile-ttl ： 删除即将过期的 6 、noeviction ： 永不过期，返回错误 APPEND ONLY 模式 aof配置 appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！ appendfilename \"appendonly.aof\" # 持久化的文件的名字 # appendfsync always # 每次修改都会 sync。消耗性能 appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！ # appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！ 具体的配置，我们在 Redis持久化 中去给大家详细详解！ Redis持久化面试和工作，持久化都是重点！ Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中 的数据库状态也会消失。所以 Redis 提供了持久化功能！ RDB（Redis DataBase） 什么是RDB 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能丢失。我们默认的就是 RDB，一般情况下不需要修改这个配置！ 有时候在生产环境我们会将这个文件进行备份！ rdb保存的文件是dump.rdb 都是在我们的配置文件中快照中进行配置的！ 触发机制 1 、save的规则满足的情况下，会自动触发rdb规则 2 、执行 flushall 命令，也会触发我们的rdb规则！ 3 、退出redis，也会产生 rdb 文件！ 备份就自动生成一个 dump.rdb 如何恢复 rdb 文件 1 、只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中 的数据！ 2 、查看需要存在的位置 127 .0.0.1:6379&gt; config get dir 1 ) \"dir\" 2 ) \"/usr/local/bin\" # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据 几乎就它自己默认的配置就够用了，但是我们还是需要去学习！ 优点： 1 、适合大规模的数据恢复！ 2 、对数据的完整性要不高！ 缺点： 1 、需要一定的时间间隔进行操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！ 2 、fork进程的时候，会占用一定的内容空间！！ AOF（Append Only File）将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！ AOF是什么 以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件，但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 AOF保存的是 appendonly.aof 文件 默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为yes就开启了 aof！ 重启，redis 就可以生效了！ 如果这个 aof 文件有错误，这时候 redis 是启动不起来的，我们需要修复这个aof文件 redis 给我们提供了一个工具 redis-check-aof --fix 如果文件正常，重启就可以直接恢复了！ 重写规则说明 aof 默认就是文件的无限追加，文件会越来越大！ 如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！ 优点： appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下， rdb完全够用！ appendfilename \"appendonly.aof\" # 持久化的文件的名字 # appendfsync always # 每次修改都会 sync。消耗性能 appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！ # appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！ # rewrite 重写， 1 、每一次修改都同步，文件的完整会更加好！ 2 、每秒同步一次，可能会丢失一秒的数据 3 、从不同步，效率最高的！ 缺点： 1 、相对于数据文件来说，aof 远远大于 rdb，修复的速度也比 rdb 慢！ 2 、Aof 运行效率也要比 rdb 慢，所以我们 redis 默认的配置就是rdb持久化！ 扩展 1 、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储 2 、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以 Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。 3 、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化 4 、同时开启两种持久化方式 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。 5 、性能建议 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要 15 分钟备份一次就够了，只保留 save 900 1 这条规则。 如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。 Redis发布订阅Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、 微博、关注系统！ Redis 客户端可以订阅任意数量的频道。 订阅/发布消息图： 第一个：消息发送者， 第二个：频道 ， 第三个：消息订阅者！ 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： 命令 这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。 序号 命令及描述 1 [PSUBSCRIBE pattern pattern …] 订阅一个或多个符合给定模式的频道。 2 PUBSUB subcommand [argument [argument …]] 查看订阅与发布系统状态。 3 PUBLISH channel message 将信息发送到指定的频道。 4 PUNSUBSCRIBE [pattern [pattern …]] 退订所有给定模式的频道。 5 [SUBSCRIBE channel channel …] 订阅给定的一个或多个频道的信息。 6 UNSUBSCRIBE [channel [channel …]] 指退订给定的频道。 测试 订阅端： 127 .0.0.1:6379&gt; subscribe kuangshenshuo # 订阅一个频道 kuangshenshuo Reading messages... (press Ctrl-C to quit) 1 ) \"subscribe\" 2 ) \"kuangshenshuo\" 3 ) (integer) 1 # 等待读取推送的信息 1 ) \"message\" # 消息 2 ) \"kuangshenshuo\" # 那个频道的消息 3 ) \"hello,kuangshen\" # 消息的具体内容 1 ) \"message\" 2 ) \"kuangshenshuo\" 3 ) \"hello,redis\" 发送端： 127 .0.0.1:6379&gt; publish kuangshenshuo \"hello,kuangshen\" # 发布者发布消息到频道！ (integer) 1 127 .0.0.1:6379&gt; PUBLISH kuangshenshuo \"hello,redis\" # 发布者发布消息到频道！ (integer) 1 127 .0.0.1:6379&gt; 原理 Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。 Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。 通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。 通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。 Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。 使用场景： 1 、实时消息系统！ 2 、实时聊天！（频道当做聊天室，将信息回显给所有人即可！） 3 、订阅，关注系统都是可以的！ 稍微复杂的场景我们就会使用 消息中间件 MQ Redis主从复制 概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点 (master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。 Master以写为主，Slave 以读为主。 默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。 主从复制的作用主要包括： 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。 高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。 一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下： 从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较 大； 从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。 电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。 对于这种场景，我们可以使如下这种架构： 主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！ 只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！ 环境配置 127 .0.0.1:6379&gt; info replication # 查看当前库的信息 # Replication role:master # 角色 master connected_slaves:0 # 没有从机 master_replid:b63c90e6c501143759cb0e7f450bd1eb0c70882a master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 只配置从库，不用配置主库！ 复制 3 个配置文件，然后修改对应的信息 1 、端口 2 、pid文件名字 3 、log文件名字 4 、dump.rdb 文件名字 修改完毕之后，启动我们的 3 个redis服务器，可以通过进程信息查看！ps -ef|grep redis 一主二从 默认情况下，每台Redis服务器都是主节点； 我们一般情况下只用配置从机就好了！ 认老大！ 一主 （ 79 ）二从（ 80 ， 81 ） 127.0.0.1:6380&gt; slaveof 127.0.0.1 6379 # SLAVEOF host 6379 找谁当自己的老大！ OK 127.0.0.1:6380&gt; info replication # Replication role:slave # 当前角色是从机 master_host:127.0.0.1 # 可以的看到主机的信息 master_port:6379 master_link_status:up master_last_io_seconds_ago:5 master_sync_in_progress:0 slave_repl_offset:14 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:c63801d05f947eb101e2d46cfd8209a41653d49b master_replid2:0000000000000000000000000000000000000000 master_repl_offset:14 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:14 # 主机信息 127.0.0.1:6379&gt; info replication # Replication role:master connected_slaves:1 slave0:ip=127.0.0.1,port=6380,state=online,offset=112,lag=1 # 可以看到从机信息 master_replid:c63801d05f947eb101e2d46cfd8209a41653d49b master_replid2:0000000000000000000000000000000000000000 master_repl_offset:112 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:112 如果两个都配置完了，就是有两个从机的 真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！ 细节 主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存！ 主机写： 127.0.0.1:6379&gt; set k1 v1 OK 127.0.0.1:6379&gt; get k1 \"v1\" 从机只能读： 127.0.0.1:6380&gt; keys * 1) \"k1\" 127.0.0.1:6380&gt; get k1 \"v1\" 127.0.0.1:6380&gt; set k2 v2 (error) READONLY You can't write against a read only replica. 测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！ 如果是使用命令行来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！ 复制原理 Slave 启动成功连接到 master 后会发送一个sync同步命令 Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步（全量复制）。 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步 但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！ 层层链路 上一个Master链接下一个 Slave！ 这时候也可以完成我们的主从复制！ 如果没有老大了，这个时候能不能选择一个老大出来呢？ 手动！ 谋朝篡位 如果主机断开了连接，我们可以使用 slaveof no one 让自己变成主机！其他的节点就可以手动连接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接老大！ 哨兵模式 概述 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。 哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是 哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。 这里的哨兵有两个作用 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。 当哨兵监测到master宕机，会自动将slave切换成master，然后通过 发布订阅模式 通知其他的从服务器，修改配置文件，让它们切换主机。 然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。 假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为 主观下线 。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线 。 测试 我们目前的状态是 一主二从！ 1 、配置哨兵配置文件 sentinel.conf 后面的这个数字 1 ，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！ # sentinel monitor 被监控的名称 host port 1 sentinel monitor myredis 127.0.0.1 6379 1 2 、启动哨兵！ [root@Linux-xu bin]# redis-sentinel RedisConfig/sentinel.conf 61063:X 27 Jul 2020 17:17:09.768 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 61063:X 27 Jul 2020 17:17:09.768 # Redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=61063, just started 61063:X 27 Jul 2020 17:17:09.768 # Configuration loaded 61063:X 27 Jul 2020 17:17:09.770 * Increased maximum number of open files to 10032 (it was originally set to 1024). _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 5.0.8 (00000000/0) 64 bit .-`` .-```. ```\\/ _.,_ ''-._ ( ' , .-` | `, ) Running in sentinel mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 26379 | `-._ `._ / _.-' | PID: 61063 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-' 61063:X 27 Jul 2020 17:17:09.772 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128. 61063:X 27 Jul 2020 17:17:09.774 # Sentinel ID is 40074a476dbe27d420e78ec7eac1ba0b6d5266cb 61063:X 27 Jul 2020 17:17:09.774 # +monitor master myredis 127.0.0.1 6379 quorum 1 61063:X 27 Jul 2020 17:17:09.783 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379 61063:X 27 Jul 2020 17:17:09.786 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379 如果Master 节点断开了，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！） 如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！ 哨兵模式 优点： 哨兵集群，基于主从复制模式，所有的主从配置优点，它全有 主从可以切换，故障可以转移，系统的可用性就会更好 哨兵模式就是主从模式的升级，手动到自动，更加健壮！ 缺点： Redis 不好在线扩容，集群容量一旦到达上限，在线扩容就十分麻烦！ 实现哨兵模式的配置其实是很麻烦的，里面有很多选择！ 哨兵模式的全部配置 # Example sentinel.conf # 哨兵sentinel实例运行的端口 默认 26379 port 26379 # 多个哨兵集群就得配置端口 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\".-_\"组成。 # quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了 # sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; sentinel monitor mymaster 127 .0.0.1 6379 2 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码 # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass &lt;master-name&gt; &lt;password&gt; sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认 30 秒 # sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt; sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知 相关人员。 #对于脚本的运行结果有以下规则： #若脚本执行后返回 1 ，那么该脚本稍后将会被再次执行，重复次数目前默认为 10 #若脚本执行后返回 2 ，或者比 2 更高的一个返回值，脚本将不会重复执行。 #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为 1 时的行为相同。 #一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。 #通知脚本 # shell编程 # sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt; # 目前&lt;state&gt;总是“failover”, # &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的 # 这个脚本应该是通用的，能被多次调用，不是针对性的。 # sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 一般都是由运维来配置！ Redis缓存穿透和雪崩服务的高可用问题！ 在这里我们不会详细的区分析解决方案的底层！ Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。 另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。 缓存穿透（查不到） 概念 缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。 解决方案 布隆过滤器 布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力； 缓存空对象 当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源； 但是这种方法会存在两个问题： 1 、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键； 2 、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。 缓存击穿（量太大，缓存过期！） 概述 这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。 当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。 解决方案 设置热点数据永不过期 从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。 加互斥锁 分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。 缓存雪崩 概念 缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！ 产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。 解决方案 redis高可用 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！） 限流降级（在SpringCloud讲解过！） 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 数据预热 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"RabbitMQ 实战教程","slug":"RibbitMQ 实战教程","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:29:05.615Z","comments":true,"path":"posts/ea4e978k.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e978k.html","excerpt":"","text":"RabbitMQ 实战教程1.MQ引言1.1 什么是MQMQ(Message Quene) : 翻译为 消息队列,通过典型的 生产者和消费者模型,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入,轻松的实现系统间解耦。别名为 消息中间件 通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。 1.2 MQ有哪些当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发RocketMQ等。 1.3 不同MQ特点# 1.ActiveMQ ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎! # 2.Kafka Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。 # 3.RocketMQ RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。 # 4.RabbitMQ RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。 RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。 2.RabbitMQ 的引言2.1 RabbitMQ 基于AMQP协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。 官网: https://www.rabbitmq.com/ 官方教程: https://www.rabbitmq.com/#getstarted # AMQP 协议 AMQP（advanced message queuing protocol）`在2003年时被提出，最早用于解决金融领域不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型: AMQP 一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。 AMQP是一个二进制协议，拥有一些现代化特点：多信道、协商式，异步，安全，扩平台，中立，高效。 RabbitMQ是AMQP协议的Erlang的实现。 概念 说明 连接Connection 一个网络连接，比如TCP/IP套接字连接。 会话Session 端点之间的命名对话。在一个会话上下文中，保证“恰好传递一次”。 信道Channel 多路复用连接中的一条独立的双向数据流通道。为会话提供物理传输介质。 客户端Client AMQP连接或者会话的发起者。AMQP是非对称的，客户端生产和消费消息，服务器存储和路由这些消息。 服务节点Broker 消息中间件的服务节点；一般情况下可以将一个RabbitMQ Broker看作一台RabbitMQ 服务器。 端点 AMQP对话的任意一方。一个AMQP连接包括两个端点（一个是客户端，一个是服务器）。 消费者Consumer 一个从消息队列里请求消息的客户端程序。 生产者Producer 一个向交换机发布消息的客户端应用程序。 2.2 RabbitMQ 的安装2.2.1 下载官网下载地址: https://www.rabbitmq.com/download.html 2.2.2 下载的安装包 注意:这里的安装包是centos7安装的包 2.2.3 安装步骤# 1.将rabbitmq安装包上传到linux系统中 erlang-22.0.7-1.el7.x86_64.rpm rabbitmq-server-3.7.18-1.el7.noarch.rpm # 2.安装Erlang依赖包 rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm # 3.安装RabbitMQ安装包(需要联网) yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm 注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config # 4.复制配置文件 cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config # 5.查看配置文件位置 ls /etc/rabbitmq/rabbitmq.config # 6.修改配置文件(参见下图:) vim /etc/rabbitmq/rabbitmq.config 将上图中配置文件中红色部分去掉%%,以及最后的,逗号 修改为下图: # 7.执行如下命令,启动rabbitmq中的插件管理 rabbitmq-plugins enable rabbitmq_management 出现如下说明: Enabling plugins on node rabbit@localhost: rabbitmq_management The following plugins have been configured: rabbitmq_management rabbitmq_management_agent rabbitmq_web_dispatch Applying plugin configuration to rabbit@localhost... The following plugins have been enabled: rabbitmq_management rabbitmq_management_agent rabbitmq_web_dispatch set 3 plugins. Offline change; changes will take effect at broker restart. # 8.启动RabbitMQ的服务 systemctl start rabbitmq-server systemctl restart rabbitmq-server systemctl stop rabbitmq-server # 9.查看服务状态(见下图:) systemctl status rabbitmq-server 出现如下说明: ● rabbitmq-server.service - RabbitMQ broker Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled) Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago Main PID: 2904 (beam.smp) Status: \"Initialized\" CGroup: /system.slice/rabbitmq-server.service ├─2904 /usr/lib64/erlang/erts-10.4.4/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf - MBlmbcs... ├─3220 erl_child_setup 32768 ├─3243 inet_gethost 4 └─3244 inet_gethost 4 ......... # 10.关闭防火墙服务 systemctl disable firewalld Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service. Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. systemctl stop firewalld # 11.访问web管理界面 http://10.15.0.8:15672/ # 12.登录管理界面 username: guest password: guest 3. RabiitMQ 配置3.1 RabbitMQ 管理命令行# 1.服务启动相关 systemctl start|restart|stop|status rabbitmq-server # 2.管理命令行 用来在不使用web管理界面情况下命令操作RabbitMQ rabbitmqctl help 可以查看更多命令 # 3.插件管理命令行 rabbitmq-plugins enable|list|disable 3.2 web管理界面介绍3.2.1 overview概览 connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况 channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。 Exchanges：交换机，用来实现消息的路由 Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。 3.2.2 Admin用户和虚拟主机管理1. 添加用户 上面的Tags选项，其实是指定用户的角色，可选的有以下几个： 超级管理员(administrator) 可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。 监控者(monitoring) 可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等) 策略制定者(policymaker) 可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。 普通管理者(management) 仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。 其他 无法登陆管理控制台，通常就是普通的生产者和消费者。 2. 创建虚拟主机# 虚拟主机 为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。 3. 绑定虚拟主机和用户创建好虚拟主机，我们还要给用户添加访问权限： 点击添加好的虚拟主机： 进入虚拟机设置界面: 3.3 RabbitMQ的工作流程介绍1、建立信息。Publisher定义需要发送消息的结构和内容。 2、建立Conection和Channel。由Publisher和Consumer创建连接，连接到Broker的物理节点上，同时建立Channel。Channel是建立在Connection之上的，一个Connection可以建立多个Channel。Publisher连接Virtual Host 建立Channel，Consumer连接到相应的Queue上建立Channel。 3、声明交换机和队列。声明一个消息交换机（Exchange）和队列（Queue），并设置相关属性。 4、发送消息。由Publisher发送消息到Broker中的Exchange中 5、路由转发。RabbitMQ收到消息后，根据消息指定的Exchange(交换机) 来查找Binding(绑定) 然后根据规则（Routing Key）分发到不同的Queue。这里就是说使用Routing Key在消息交换机（Exchange）和消息队列（Queue）中建立好绑定关系，然后将消息发送到绑定的队列中去。 6、消息接收。Consumer监听相应的Queue，一旦Queue中有可以消费的消息，Queue就将消息发送给Consumer端。 7、消息确认。当Consumer完成某一条消息的处理之后，需要发送一条ACK消息给对应的Queue。 Consumer收到消息时需要显式的向RabbitMQ Broker发送basic.ack消息或者Consumer订阅消息时设置auto_ack参数为true。在通信过程中，队列对ACK的处理有以下几种情况： 如果Consumer接收了消息，发送ack，RabbitMQ会删除队列中这个消息，发送另一条消息给Consumer。 如果Consumer接收了消息, 但在发送ack之前断开Channel，RabbitMQ会认为这条消息没有被deliver（递送）,如果有其他的Channel，会该消息将被发送给另外的Channel。如果没有，当在Consumer再次连接的时候，这条消息会被redeliver（重新递送）。 如果consumer接收了消息，但是忘记了ack,RabbitMQ不会重复发送消息。 新版RabbitMQ还支持Consumer reject某条（类）消息，可以通过设置requeue参数中的reject为true达到目的，那么Consumer将会把消息发送给下一个注册的Consumer。 8、关闭消息通道（channel）以及和服务器的连接。 4.RabbitMQ 的第一个程序4.0 AMQP协议的回顾 4.1 RabbitMQ支持的消息模型 4.2 引入依赖&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.7.2&lt;/version&gt; &lt;/dependency&gt; 4.3 第一种模型(直连) 在上图的模型中，有以下概念： P：生产者，也就是要发送消息的程序 C：消费者：消息的接受者，会一直等待消息到来。 queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。 1. 开发生产者//创建连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"10.15.0.9\"); connectionFactory.setPort(5672); connectionFactory.setUsername(\"ems\"); connectionFactory.setPassword(\"123\"); connectionFactory.setVirtualHost(\"/ems\"); Connection connection = connectionFactory.newConnection(); //创建通道 Channel channel = connection.createChannel(); //参数1：队列名称，如果不存在就创建 参数2: 队列是否持久化 参数3:是否独占队列 参数4:队列消费完是否自动删除 参数4:其他属性 channel.queueDeclare(\"hello\",true,false,false,null); //发布消息 //参数1: 交换机名称 参数2:队列名称 参数3:传递消息额外设置 参数4:消息的具体内容 channel.basicPublish(\"\",\"hello\", null,\"hello rabbitmq\".getBytes()); channel.close(); connection.close(); 2. 开发消费者//创建连接工厂 ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(\"10.15.0.9\"); connectionFactory.setPort(5672); connectionFactory.setUsername(\"ems\"); connectionFactory.setPassword(\"123\"); connectionFactory.setVirtualHost(\"/ems\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(\"hello\", true, false, false, null); //消费消息 //参数1: 消费那个队列的消息 队列名称 //参数2: 开始消息的自动确认机制 //参数3: 消费时的回调接口 channel.basicConsume(\"hello\",true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(new String(body)); } }); 3. 参数的说明 //生产者和消费者的这个API的参数要一致，不然使用不是同一个队列 channel.queueDeclare(\"hello\",true,false,false,null); '参数1':用来声明通道对应的队列 '参数2':用来指定是否持久化队列，不开启，如果RabbitMQ重启的话会丢失原有的队列，但不会保存消息，只保存队列，要保存消息得在下面的函数里的'第3个参数'设置 '参数3':用来指定是否独占队列，独占队列只允许一个链接连接 '参数4':用来指定是否自动删除队列，消费者连接断开后才删除 '参数5':对队列的额外配置 channel.basicPublish(\"\",\"hello\", null,\"hello rabbitmq\".getBytes()); '参数1': 交换机名称 '参数2':队列名称 '参数3':传递消息额外设置,使用 MessageProperties 里的常量进行设置 '参数4':消息的具体内容 4.4 第二种模型(work quene)Work queues，也被称为（Task queues），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：让多个消费者绑定到一个队列，共同消费队列中的消息。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。 角色： P：生产者：任务的发布者 C1：消费者-1，领取任务并且完成任务，假设完成速度较慢 C2：消费者-2：领取任务并完成任务，假设完成速度快 1. 开发生产者channel.queueDeclare(\"hello\", true, false, false, null); for (int i = 0; i &lt; 10; i++) { channel.basicPublish(\"\", \"hello\", null, (i+\"====&gt;:我是消息\").getBytes()); } 2.开发消费者-1channel.queueDeclare(\"hello\",true,false,false,null); channel.basicConsume(\"hello\",true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"消费者1: \"+new String(body)); } }); 3.开发消费者-2channel.queueDeclare(\"hello\",true,false,false,null); channel.basicConsume(\"hello\",true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { try { Thread.sleep(1000); //处理消息比较慢 一秒处理一个消息 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"消费者2: \"+new String(body)); } }); 4.测试结果 总结:默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。 5.消息自动确认机制 Doing a task can take a few seconds. You may wonder what happens if one of the consumers starts a long task and dies with it only partly done. With our current code, once RabbitMQ delivers a message to the consumer it immediately marks it for deletion. In this case, if you kill a worker we will lose the message it was just processing. We’ll also lose all the messages that were dispatched to this particular worker but were not yet handled. But we don’t want to lose any tasks. If a worker dies, we’d like the task to be delivered to another worker. 完成一项任务可能需要几秒钟。你可能会想，如果其中一个消费者开始了一项长期任务，但只完成了一部分就结束了，会发生什么。根据我们当前的代码，一旦RabbitMQ向消费者传递了一条消息，它会立即将其标记为删除。在这种情况下，如果你杀了一个工人，我们将丢失它正在处理的消息。我们还将丢失发送给该特定工作人员但尚未处理的所有消息。 但是我们不想失去任何任务。如果一个工人死了，我们希望把任务交给另一个工人。只要关闭消息自动确认机制，只要消息没有被手动确认，即使被消费到一半消费者就挂了，这个消息还是会被另外的消费者消费。 channel.basicQos(1);//一次只接受一条未确认的消息 //参数2:关闭自动确认消息 channel.basicConsume(\"hello\",false,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"消费者1: \"+new String(body)); channel.basicAck(envelope.getDeliveryTag(),false);//手动确认消息 } }); 设置通道一次只能消费一个消息 关闭消息的自动确认,开启手动确认消息 4.5 RabbitMQ的分发机制1、Round-robin dispatch（轮询分发） 这个是RabbitMQ默认的消息分发机制，使用任务队列的优点之一就是可以轻易的并行工作。如果我们有很多要分发的消息，可以通过增加工作者（消费者）来解决这种状况，使得系统的伸缩性更加容易扩展。 在默认情况下，RabbitMQ不会顾虑消息者处理消息的能力，即使其中有的消费者闲置有的消费者高负荷。RabbitMQ会逐个发送消息到在序列中的下一个消费者==(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)==。平均每个消费者获得相同数量的消息，这种方式分发消息机制称为Round-Robin（轮询）。 2、Fair dispatch （公平分发） 而公平分发，则是根据消费者的处理能力来进行分发处理的。这里主要是==通过设置prefetchCount 参数来实现的==。这样RabbitMQ就会使得每个Consumer在同一个时间点最多处理规定的数量级个数的Message。换句话说，在==接收到该Consumer的ack前，它不会将新的Message分发给它==。 比如prefetchCount=1，则在同一时间下，每个Consumer在同一个时间点最多处理1个Message，同时在收到Consumer的ack前，它不会将新的Message分发给它。 ==注意：使用公平分发，必须关闭自动应答，改为手动应答。== 说完了概念，我们再来思考一下，前面我们的实例。在使用Spring Boot结合RabbitMQ时，我们并没有手动去应答，那么这为啥是采用的公平分发机制？ 这个是因为Spring Boot封装的RabbitMQ方法，默认ACK机制是使用手工应答机制，当@RabbitListener修饰的方法被调用且没有抛出异常时, Spring Boot会为我们自动应答。 我们可以在@RabbitListener源码的注解里看到， 如果没有指定containerFactory，将采用默认的containerFactory。然后我们在RabbitListenerContainerFactory中查看到这个接口与MessageListenerContainer有关， 接着查看MessageListenerContainer，这是一个接口，我们查看实现了该接口的类，在源码包了提供了一个SimpleMessageListenerContainer的类，在里面我们找到了DEFAULT_PREFETCH_COUNT，这下就清晰明了了。 默认情况下，Spring Boot中的RabbitMQ采用手动确认机制，只要如果不是程序员编程实现应答，框架就会为我们自动去确认。并且prefetchCount=1，这下就可以解释为啥上面的实例出现的结果了。 4.6 第三种模型(fanout)fanout 扇出 也称为广播 在广播模式下，消息发送流程是这样的： 可以有多个消费者 每个消费者有自己的queue（队列） 每个队列都要绑定到Exchange（交换机） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。 交换机把消息发送给绑定过的所有队列 队列的消费者都能拿到消息。实现一条消息被多个消费者消费 1. 开发生产者//声明交换机 channel.exchangeDeclare(\"logs\",\"fanout\");//广播 一条消息多个消费者同时消费 //发布消息 channel.basicPublish(\"logs\",\"\",null,\"hello\".getBytes()); 2. 开发消费者-1//绑定交换机 channel.exchangeDeclare(\"logs\",\"fanout\"); //创建临时队列 String queue = channel.queueDeclare().getQueue(); //将临时队列绑定exchange channel.queueBind(queue,\"logs\",\"\"); //处理消息 channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"消费者1: \"+new String(body)); } }); 3. 开发消费者-2//绑定交换机 channel.exchangeDeclare(\"logs\",\"fanout\"); //创建临时队列 String queue = channel.queueDeclare().getQueue(); //将临时队列绑定exchange channel.queueBind(queue,\"logs\",\"\"); //处理消息 channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"消费者2: \"+new String(body)); } }); 4.开发消费者-3//绑定交换机 channel.exchangeDeclare(\"logs\",\"fanout\"); //创建临时队列 String queue = channel.queueDeclare().getQueue(); //将临时队列绑定exchange channel.queueBind(queue,\"logs\",\"\"); //处理消息 channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"消费者3: \"+new String(body)); } }); 5. 测试结果 4.7 第四种模型(Routing)4.7.1 Routing 之订阅模型-Direct(直连)在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。 在Direct模型下： 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。 Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息 流程: 图解： P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。 X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列 C1：消费者，其所在队列指定了需要routing key 为 error 的消息 C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息 1. 开发生产者//声明交换机 参数1:交换机名称 参数2:交换机类型 基于指令的Routing key转发 channel.exchangeDeclare(\"logs_direct\",\"direct\"); String key = \"\"; //发布消息 channel.basicPublish(\"logs_direct\",key,null,(\"指定的route key\"+key+\"的消息\").getBytes()); 2.开发消费者-1 //声明交换机 channel.exchangeDeclare(\"logs_direct\",\"direct\"); //创建临时队列 String queue = channel.queueDeclare().getQueue(); //绑定队列和交换机 channel.queueBind(queue,\"logs_direct\",\"error\"); channel.queueBind(queue,\"logs_direct\",\"info\"); channel.queueBind(queue,\"logs_direct\",\"warn\"); //消费消息 channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"消费者1: \"+new String(body)); } }); 3.开发消费者-2//声明交换机 channel.exchangeDeclare(\"logs_direct\",\"direct\"); //创建临时队列 String queue = channel.queueDeclare().getQueue(); //绑定队列和交换机 channel.queueBind(queue,\"logs_direct\",\"error\"); //消费消息 channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"消费者2: \"+new String(body)); } }); 4.测试生产者发送Route key为error的消息时 5.测试生产者发送Route key为info的消息时 4.7.2 Routing 之订阅模型-TopicTopic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！这种模型Routingkey 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert # 统配符 * (star) can substitute for exactly one word. 匹配不多不少恰好1个词 # (hash) can substitute for zero or more words. 匹配一个或多个词 # 如: audit.# 匹配 audit.irs.corporate 或者 audit.irs 或者 audit 等 audit.* 只能匹配 audit.irs 1.开发生产者//生命交换机和交换机类型 topic 使用动态路由(通配符方式) channel.exchangeDeclare(\"topics\",\"topic\"); String routekey = \"user.save\";//动态路由key //发布消息 channel.basicPublish(\"topics\",routekey,null,(\"这是路由中的动态订阅模型,route key: [\"+routekey+\"]\").getBytes()); 2.开发消费者-1Routing Key中使用*通配符方式 //声明交换机 channel.exchangeDeclare(\"topics\",\"topic\"); //创建临时队列 String queue = channel.queueDeclare().getQueue(); //绑定队列与交换机并设置获取交换机中动态路由 channel.queueBind(queue,\"topics\",\"user.*\"); //消费消息 channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"消费者1: \"+new String(body)); } }); 3.开发消费者-2Routing Key中使用#通配符方式 //声明交换机 channel.exchangeDeclare(\"topics\",\"topic\"); //创建临时队列 String queue = channel.queueDeclare().getQueue(); //绑定队列与交换机并设置获取交换机中动态路由 channel.queueBind(queue,\"topics\",\"user.#\"); //消费消息 channel.basicConsume(queue,true,new DefaultConsumer(channel){ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { System.out.println(\"消费者2: \"+new String(body)); } }); 4.测试结果 5. SpringBoot中使用RabbitMQ5.0 搭建初始环境1. 引入依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 2. 配置配置文件spring: application: name: springboot_rabbitmq rabbitmq: host: 10.15.0.9 port: 5672 username: ems password: 123 virtual-host: /ems RabbitTemplate 用来简化操作 使用时候直接在项目中注入即可使用 5.1 第一种hello world模型使用 开发生产者@SpringBootTest(classes = RabbitmqSpringbootApplication.class) @RunWith(SpringRunner.class) public class TestRabbitMQ { @Autowired private RabbitTemplate rabbitTemplate; @Test public void testHello(){ rabbitTemplate.convertAndSend(\"hello\",\"hello world\"); } } 开发消费者@Component @RabbitListener(queuesToDeclare = @Queue(\"hello\")) public class HelloCustomer { @RabbitHandler public void receive1(String message){ System.out.println(\"message = \" + message); } } 5.2 第二种work模型使用 开发生产者@Autowired private RabbitTemplate rabbitTemplate; @Test public void testWork(){ for (int i = 0; i &lt; 10; i++) { rabbitTemplate.convertAndSend(\"work\",\"hello work!\"); } } 开发消费者@Component public class WorkCustomer { @RabbitListener(queuesToDeclare = @Queue(\"work\")) public void receive1(String message){ System.out.println(\"work message1 = \" + message); } @RabbitListener(queuesToDeclare = @Queue(\"work\")) public void receive2(String message){ System.out.println(\"work message2 = \" + message); } } 说明:默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置 5.3 Fanout 广播模型 开发生产者@Autowired private RabbitTemplate rabbitTemplate; @Test public void testFanout() throws InterruptedException { rabbitTemplate.convertAndSend(\"logs\",\"\",\"这是日志广播\"); } 开发消费者@Component public class FanoutCustomer { @RabbitListener(bindings = @QueueBinding( value = @Queue, exchange = @Exchange(name=\"logs\",type = \"fanout\") )) public void receive1(String message){ System.out.println(\"message1 = \" + message); } @RabbitListener(bindings = @QueueBinding( value = @Queue, //创建临时队列 exchange = @Exchange(name=\"logs\",type = \"fanout\") //绑定交换机类型 )) public void receive2(String message){ System.out.println(\"message2 = \" + message); } } 5.4 Route 路由模型 开发生产者@Autowired private RabbitTemplate rabbitTemplate; @Test public void testDirect(){ rabbitTemplate.convertAndSend(\"directs\",\"error\",\"error 的日志信息\"); } 开发消费者@Component public class DirectCustomer { @RabbitListener(bindings ={ @QueueBinding( value = @Queue(), key={\"info\",\"error\"}, exchange = @Exchange(type = \"direct\",name=\"directs\") )}) public void receive1(String message){ System.out.println(\"message1 = \" + message); } @RabbitListener(bindings ={ @QueueBinding( value = @Queue(), key={\"error\"}, exchange = @Exchange(type = \"direct\",name=\"directs\") )}) public void receive2(String message){ System.out.println(\"message2 = \" + message); } } 5.5 Topic 订阅模型(动态路由模型) 开发生产者@Autowired private RabbitTemplate rabbitTemplate; //topic @Test public void testTopic(){ rabbitTemplate.convertAndSend(\"topics\",\"user.save.findAll\",\"user.save.findAll 的消息\"); } 开发消费者@Component public class TopCustomer { @RabbitListener(bindings = { @QueueBinding( value = @Queue, key = {\"user.*\"}, exchange = @Exchange(type = \"topic\",name = \"topics\") ) }) public void receive1(String message){ System.out.println(\"message1 = \" + message); } @RabbitListener(bindings = { @QueueBinding( value = @Queue, key = {\"user.#\"}, exchange = @Exchange(type = \"topic\",name = \"topics\") ) }) public void receive2(String message){ System.out.println(\"message2 = \" + message); } } 5.6 消息确认、消息拒绝与消息回调在resources中把下面的代码注释打开，采用手动确认消息机制。 # 采用手动应答 spring.rabbitmq.listener.acknowledge-mode=manual12 然后我们在接收消息中，即Receiver中如下设置： @RabbitListener(queues = \"hello\") public void process(Message message, Channel channel) throws IOException { System.out.println(\"CheckReceiver: \" + new String(message.getBody())); try { doWork(); } catch (InterruptedException e) { e.printStackTrace(); } // 消息的标识，false只确认当前一个消息收到，true确认所有consumer获得的消息 channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); } 注意：采用了手动确认消息后，所有消费者都需要手动确认消息是否收到完毕。不然RabbitMQ会认为消息投递失败，反复投递。 当然除了消息确认外，还有消息拒绝，当我们拒绝某个消息时，让RabbitMQ会把消息传递给它的下一个消费者接受该消息，直到该消息把确认收到为止，也可以让RabbitMQ把消息给删除掉。 这里的使用和消息确认基本一致，传递不同的参数采用不同的操作。 // true 发送给下一个消费者 // false 谁都不接受，从队列中删除 // 拒绝消息 channel.basicReject(message.getMessageProperties().getDeliveryTag(), true); 除了上面的消息确认、拒绝外，RabbitMQ还带消息的回调确认，用户是否收到消息，发送者的消息是否成功投递，可以通过Callback中的确认来实现。通过在Sender中实现RabbitTemplate.ConfirmCallback接口来实现该操作，如下： @Component public class CallBackSender implements RabbitTemplate.ConfirmCallback { @Autowired private RabbitTemplate rabbitTemplatenew; public void send() { rabbitTemplatenew.setConfirmCallback(this); String msg = \"callbackSender : i am callback sender\"; System.out.println(msg); CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString()); System.out.println(\"callbackSender UUID: \" + correlationData.getId()); this.rabbitTemplatenew.convertAndSend(\"exchange\", \"topic.messages\", msg, correlationData); } public void confirm(CorrelationData correlationData, boolean ack, String cause) { System.out.println(\"callbakck confirm: \" + correlationData.getId() + \" ACK : \" + ack); } } 通过ACK的返回值，我们可以确认用户是否消费掉该消息没有，然后做后续的操作。 6、消息确认机制(AMQP事务)我们知道可以通过持久化（交换机、队列和消息持久化）来保障我们在服务器崩溃时，重启服务器消息数据不会丢失。但是我们无法确认当消息的发布者在将消息发送出去之后，消息到底有没有正确到达Broker代理服务器呢？如果不进行特殊配置的话，默认情况下发布操作是不会返回任何信息给生产者的，也就是默认情况下我们的生产者是不知道消息有没有正确到达Broker的。如果在消息到达Broker之前已经丢失的话，持久化操作也解决不了这个问题，因为消息根本就没到达代理服务器，这个是没有办法进行持久化的，那么当我们遇到这个问题又该如何去解决呢？ 这里就是我们讲解到的RabbitMQ中的消息确认机制，通过消息确认机制我们可以确保我们的消息可靠送达到我们的用户手中，即使消息丢失掉，我们也可以通过进行重复分发确保用户可靠收到消息。 RabbitMQ消息确认机制，主要包括两个方面，因为RabbitMQ为我们提供了两种方式： 通过AMQP事务机制实现，这也是AMQP协议层面提供的解决方案； 通过将channel设置成confirm模式来实现； 6.1 AMQP事务1、使用java原生事务我们知道事务可以保证消息的传递，使得可靠消息最终一致性。接下来我们先来探究一下RabbitMQ的事务机制。 RabbitMQ中与事务有关的主要有三个方法： txSelect() txCommit() txRollback() txSelect主要用于将当前channel设置成transaction模式，txCommit用于提交事务，txRollback用于回滚事务。 当我们使用txSelect提交开始事务之后，我们就可以发布消息给Broke代理服务器，如果txCommit提交成功了，则消息一定到达了Broker了，如果在txCommit执行之前Broker出现异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback方法进行回滚事务了。 所以RabbitMQ事务中的主要代码为： channel.txSelect(); channel.basicPublish(exchange,routingKey,MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes()); channel.txCommit(); 先进行事务提交，然后开始发送消息，最后提交事务。 还是在原来的demo代码（这些代码本笔记没有在前面记载）基础下，在sender和receiver包下分别新建TransactionSender1.java和TransactionReceiver1.java。分别如下所示： TransactionSender1.java package net.anumbrella.rabbitmq.sender; import java.io.IOException; import java.util.concurrent.TimeoutException; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class TransactionSender1 { private final static String QUEUE_NAME = \"transition\"; public static void main(String[] args) throws IOException, TimeoutException { /** * 创建连接连接到MabbitMQ */ ConnectionFactory factory = new ConnectionFactory(); // 设置MabbitMQ所在主机ip或者主机名 factory.setUsername(\"guest\"); factory.setPassword(\"guest\"); factory.setHost(\"127.0.0.1\"); factory.setVirtualHost(\"/\"); factory.setPort(5672); // 创建一个连接 Connection connection = factory.newConnection(); // 创建一个频道 Channel channel = connection.createChannel(); // 指定一个队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 发送的消息 String message = \"This is a transaction message！\"; try { // 开启事务 channel.txSelect(); // 往队列中发出一条消息，使用rabbitmq默认交换机 channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes()); // 提交事务 channel.txCommit(); } catch (Exception e) { e.printStackTrace(); // 事务回滚 channel.txRollback(); } System.out.println(\" TransactionSender1 Sent '\" + message + \"'\"); // 关闭频道和连接 channel.close(); connection.close(); } } 在上面中我们使用try-catch来捕获异常，如果发送失败，就会进行事务回滚。 TransactionReceiver1.java package net.anumbrella.rabbitmq.receiver; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.concurrent.TimeoutException; import com.rabbitmq.client.AMQP; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.Consumer; import com.rabbitmq.client.DefaultConsumer; import com.rabbitmq.client.Envelope; public class TransactionReceiver1 { private final static String QUEUE_NAME = \"transition\"; public static void main(String[] argv) throws IOException, InterruptedException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(\"guest\"); factory.setPassword(\"guest\"); factory.setHost(\"127.0.0.1\"); factory.setVirtualHost(\"/\"); factory.setPort(5672); // 打开连接和创建频道，与发送端一样 Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); // 声明队列，主要为了防止消息接收者先运行此程序，队列还不存在时创建队列。 channel.queueDeclare(QUEUE_NAME, false, false, false, null); System.out.println(\"Receiver1 waiting for messages. To exit press CTRL+C\"); // 创建队列消费者 final Consumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { SimpleDateFormat time = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSSS\"); String message = new String(body, \"UTF-8\"); System.out.println(\" TransactionReceiver1 : \" + message); System.out.println(\" TransactionReceiver1 Done! at \" + time.format(new Date())); } }; channel.basicConsume(QUEUE_NAME, true, consumer); } } 消息的接收者跟原来是一样的，因为事务主要是保证消息要发送到Broker当中。接着我们使用wireshark来监听网络，这里也可以使用Fiddler。由于笔者使用的是MAC系统，没有Fiddler版本。如果读者要使用Fiddler，同时使用windows可以看看这篇文章，后面有对Fiddler的介绍，JMeter搭配Fiddler的简单使用（一）。 启动wireshark，选择好网络，输入amqp过滤我们需要的信息。然后我们分别启动TransactionReceiver1.java 和 TransactionSender1.java。 从上面我们可以清晰的看见消息的分发过程，与我们前面分析的一致。主要执行了四个步骤： Client发送Tx.Select Broker发送Tx.Select-Ok(在它之后，发送消息) Client发送Tx.Commit Broker发送Tx.Commit-Ok 接下来我们通过抛出异常来模拟发送消息错误，进行事务回滚。更改发送信息代码为： try { // 开启事务 channel.txSelect(); // 往队列中发出一条消息，使用rabbitmq默认交换机 channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes()); // 除以0，模拟异常，使用rabbitmq默认交换机 int t = 1/0; // 提交事务 channel.txCommit(); } catch (Exception e) { e.printStackTrace(); // 事务回滚 channel.txRollback(); } 这里我们通过除以0来模拟抛出异常，接着按同样的顺序运行代码。 可以看见事务进行了回滚，同时我们在接收端也没有收到消息。 通过上面我们可以知道事务确实能够解决消息的发送者和Broker之间消息的确认，只有当消息成功被服务端Broker接收，并且接受时，事务才能提交成功，不然我们便可以在捕获异常进行事务回滚操作同时进行消息重发。 在上面的情况中，我们使用java原生代码来模拟事务进行发送，而在实际开发中，我们可能需要结合框架来完成。 2、结合Spring Boot来使用事务我们一般在Spring Boot使用RabbitMQ，主要是通过封装的RabbitTemplate模板来实现消息的发送，这里主要也是分为两种情况，使用RabbitTemplate同步发送，或者异步发送。 注意：发布确认和事务。(两者不可同时使用)在channel为事务时，不可引入确认模式；同样channel为确认模式下，不可使用事务。 所以在使用事务时，在application.properties中，需要将确认模式更改为false。 # 支持发布确认 spring.rabbitmq.publisher-confirms=false A、同步通过设置RabbitTemplate的channelTransacted为true，来设置事务环境，使得可以使用RabbitMQ事务。如下： template.setChannelTransacted(true); 在demo代码里面，主要是在config包下的RabbitConfig.java里的rabbitTemplateNew方法里面配置，如下： @Bean @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public RabbitTemplate rabbitTemplateNew() { RabbitTemplate template = new RabbitTemplate(connectionFactory()); template.setChannelTransacted(true); return template; } 接着在在sender和receiver包，分别建立TransactionSender2.java和TransactionReceiver2.java。分别如下所示： TransactionSender2.java package net.anumbrella.rabbitmq.sender; import java.text.SimpleDateFormat; import java.util.Date; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import org.springframework.transaction.annotation.Transactional; @Component public class TransactionSender2 { @Autowired private AmqpTemplate rabbitTemplate; @Transactional(rollbackFor = Exception.class) public void send(String msg) { SimpleDateFormat time = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String sendMsg = msg + time.format(new Date()) + \" This is a transaction message！ \"; /** * 这里可以执行数据库操作 * **/ System.out.println(\"TransactionSender2 : \" + sendMsg); this.rabbitTemplate.convertAndSend(\"transition\", sendMsg); } } 在上面代码中，我们通过调用者提供外部事务 @Transactional ( rollbackFor = Exception.class)，来现实事务方法。一旦方法中抛出异常，比如执行数据库操作时，就会被捕获到，同时事务将进行回滚，并且向外发送的消息将不会发送出去。 TransactionReceiver2.java package net.anumbrella.rabbitmq.receiver; import java.io.IOException; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; import com.rabbitmq.client.Channel; @Component public class TransactionReceiver2 { @RabbitListener(queues = \"transition\") public void process(Message message, Channel channel) throws IOException { System.out.println(\"TransactionReceiver2 : \" + new String(message.getBody())); } } 添加完消息的发送者和接收者后，还需要在controller包下的RabbitTest.java中添加模拟消息发送的Restful接口方法，添加如下代码： @Autowired private TransactionSender2 transactionSender; /** * 事务消息发送测试 */ @GetMapping(\"/transition\") public void transition() { transactionSender.send(\"Transition: \"); } 启动wireshark，选择好网络，输入amqp过滤我们需要的信息。然后启动Spring Boot项目，访问接口http://localhost:8080/rabbit/transition。 在控制台我们可以得到消息已经发送和收到， TransactionSender2 : Transition: 2018-06-18 23:00:16 This is a transaction message！ TransactionReceiver2 : Transition: 2018-06-18 23:00:16 This is a transaction message！ 查看wireshark如下： 可以看到这里与前面我们讲解的原生事务是一致的，而当发送消息出现异常时，就会响应执行事务回滚。 B、异步刚才我们讲解的是同步的情况，现在我们讲解一下异步的形式。在异步当中，主要使用MessageListener 接口，它是 Spring AMQP 异步消息投递的监听器接口。而MessageListener的实现类SimpleMessageListenerContainer则是作为了整个异步消息投递的核心类存在。 接下来我们开始介绍使用异步的方法，同样表示需要的外部事务，用户需要在容器配置的时候指定PlatformTransactionManager的实现。代码如下： @Bean public ConnectionFactory connectionFactory() { CachingConnectionFactory connectionFactory = new CachingConnectionFactory(); connectionFactory.setAddresses(addresses + \":\" + port); connectionFactory.setUsername(username); connectionFactory.setPassword(password); connectionFactory.setVirtualHost(virtualHost); /** 如果要进行消息回调，则这里必须要设置为true */ connectionFactory.setPublisherConfirms(publisherConfirms); return connectionFactory; } @Bean public SimpleMessageListenerContainer messageListenerContainer() { SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(); container.setConnectionFactory(connectionFactory()); container.setTransactionManager(rabbitTransactionManager());//rabbitTransactionManager()方法在下面代码 container.setChannelTransacted(true); // 开启手动确认 container.setAcknowledgeMode(AcknowledgeMode.MANUAL); container.setQueues(transitionQueue());//transitionQueue()方法在下面代码有 container.setMessageListener(new TransitionConsumer());//TransitionConsumer()也在下面代码有 return container; } /** * 声明transition2队列 * @return */ @Bean public Queue transitionQueue() { return new Queue(\"transition2\"); } /** * 事务管理 * * @return */ @Bean public RabbitTransactionManager rabbitTransactionManager() { return new RabbitTransactionManager(connectionFactory()); } /** * 自定义消费者 */ public class TransitionConsumer implements ChannelAwareMessageListener { @Override public void onMessage(Message message, Channel channel) throws Exception { byte[] body = message.getBody(); System.out.println(\"TransitionConsumer: \" + new String(body)); // 确认消息成功消费 channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); // 除以0，模拟异常，进行事务回滚 // int t = 1 / 0; } } 这段代码我们是添加在config下的RabbitConfig.java下，通过配置事务管理器，将channelTransacted属性被设置为true。 在容器中配置事务时，如果提供了transactionManager，channelTransaction必须为true，使得如果监听器处理失败，并且抛出异常，那么事务将进行回滚，那么消息将返回给消息代理；如果为false，外部的事务仍然可以提供给监听容器，造成的影响是在回滚的业务操作中也会提交消息传输的操作。 通过使用RabbitTransactionManager，这个事务管理器是PlatformTransactionManager接口的实现，它只能在一个RabbitConnectionFactory中使用。 注意：这种策略不能够提供XA事务，例如在消息和数据库之间共享事务。 因为我们在container中设置队列为“transition2”，所以我们在TransactionSender2中更改发送的队列为“transition2”，如下： this.rabbitTemplate.convertAndSend(\"transition2\", sendMsg); 接着我们启动wireshark，选择好网络，输入amqp过滤我们需要的信息。然后启动Spring Boot项目，访问接口http://localhost:8080/rabbit/transition。 我们可以在wireshark中看到有事务的提交，如下： 然后我们在TransitionConsumer中把除以0的模拟异常情况打开，然后再执行上面的操作，可得： 可以看到先进行了事务提交，后面事务又回滚了。意味着消息没有接收成功，我们在RabbitMQ管理界面也可以查看到消息，如果将consumer关掉，则unacked的msg则会又回到了ready状态。（注意：这里我们模拟的是消费者接收事务，前面是消息生成者发送到Broker的事务） 关闭消息者监听后，消息又恢复了ready状态。当重启应用会重新发过它。 但是使用事务虽然可以保证消息的准确达到，但是它极大地牺牲了性能，因此我们为了性能上的要求，可以采用另一种高效的解决方案——通过使用Confirm模式来保证消息的准确性。 6.2 Confirm模式这里的Confirm模式可以分为两个方面来讲解，一是消息的生产者(Producer)的Confirm模式，另一个是消息的消费者(Consumer)的Confirm模式。 1、生产者(Producer)的Confirm模式通过生产者的确认模式我们是要保证消息准确达到Broker端，而与AMQP事务不同的是Confirm是针对一条消息的，而事务是可以针对多条消息的。 发送原理图大致如下： 为了使用Confirm模式，client会发送confirm.select方法帧。通过是否设置了no-wait属性，来决定Broker端是否会以confirm.select-ok来进行应答。一旦在channel上使用confirm.select方法，channel就将处于Confirm模式。处于 transactional模式的channel不能再被设置成Confirm模式，反之亦然。channel一旦设置为Confirm模式就不能为事务模式，为事务模式就不能为Confirm模式。 在生产者将信道设置成Confirm模式，一旦信道进入Confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(以confirm.select为基础从1开始计数)，一旦消息被投递到所有匹配的队列之后，Broker就会发送一个确认给生产者（包含消息的唯一ID）,这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，Broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号，此外Broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。 Confirm模式最大的好处在于它是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条basic.nack来代替basic.ack的消息，在这个情形下，basic.nack中各域值的含义与basic.ack中相应各域含义是相同的，同时requeue域的值应该被忽略。通过nack一条或多条消息， Broker表明自身无法对相应消息完成处理，并拒绝为这些消息的处理负责。在这种情况下，client可以选择将消息re-publish。 在channel 被设置成Confirm模式之后，所有被publish的后续消息都将被Confirm（即 ack）或者被nack一次。但是没有对消息被Confirm的快慢做任何保证，并且同一条消息不会既被Confirm又被nack。 开启confirm模式的方法生产者通过调用channel的confirmSelect方法将channel设置为Confirm模式，如果没有设置no-wait标志的话，Broker会返回confirm.select-ok表示同意发送者将当前channel信道设置为Confirm模式(从目前RabbitMQ最新版本3.6来看，如果调用了channel.confirmSelect方法，默认情况下是直接将no-wait设置成false的，也就是默认情况下broker是必须回传confirm.select-ok的)。 编程模式对于固定消息体大小和线程数，如果消息持久化，生产者Confirm(或者采用事务机制)，消费者ack那么对性能有很大的影响. 消息持久化的优化没有太好方法，用更好的物理存储（SAS, SSD, RAID卡）总会带来改善。生产者confirm这一环节的优化则主要在于客户端程序的优化之上。归纳起来，客户端实现生产者confirm有三种编程方式： 普通Confirm模式：每发送一条消息后，调用waitForConfirms()方法，等待服务器端Confirm。实际上是一种串行Confirm了，每publish一条消息之后就等待服务端Confirm，如果服务端返回false或者超时时间内未返回，客户端进行消息重传； 批量Confirm模式：批量Confirm模式，每发送一批消息之后，调用waitForConfirms()方法，等待服务端Confirm，这种批量确认的模式极大的提高了Confirm效率，但是如果一旦出现Confirm返回false或者超时的情况，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息，如果这种情况频繁发生的话，效率也会不升反降； 异步Confirm模式：提供一个回调方法，服务端Confirm了一条或者多条消息后Client端会回调这个方法。 1、普通Confirm模式主要代码为： channel.basicPublish(\"\", QUEUE_NAME, MessageProperties.PERSISTENT_BASIC, (\" Confirm模式， 第\" + (i + 1) + \"条消息\").getBytes()); if (channel.waitForConfirms()) { System.out.println(\"发送成功\"); }else{ //进行消息重发 } 普通Confirm模式最简单，publish一条消息后，等待服务器端Confirm，如果服务端返回false或者超时时间内未返回，客户端就进行消息重传。 我们还是结合代码来讲解，下载原来的代码 rabbitmq-demo，然后在sender和receiver中分别新建代码ConfirmSender1.java和ConfirmReceiver1.java。 ConfirmSender1.java： package net.anumbrella.rabbitmq.sender; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.MessageProperties; import org.apache.commons.lang.StringUtils; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import java.io.IOException; import java.util.concurrent.TimeoutException; /** * 这是java原生类支持RabbitMQ，直接运行该类 */ public class ConfirmSender1 { private final static String QUEUE_NAME = \"confirm\"; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException { /** * 创建连接连接到RabbitMQ */ ConnectionFactory factory = new ConnectionFactory(); // 设置RabbitMQ所在主机ip或者主机名 factory.setUsername(\"guest\"); factory.setPassword(\"guest\"); factory.setHost(\"127.0.0.1\"); factory.setVirtualHost(\"/\"); factory.setPort(5672); // 创建一个连接 Connection connection = factory.newConnection(); // 创建一个频道 Channel channel = connection.createChannel(); // 指定一个队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 发送的消息 String message = \"This is a confirm message！\"; channel.confirmSelect(); final long start = System.currentTimeMillis(); //发送持久化消息 for (int i = 0; i &lt; 5; i++) { //第一个参数是exchangeName(默认情况下代理服务器端是存在一个\"\"名字的exchange的, //因此如果不创建exchange的话我们可以直接将该参数设置成\"\",如果创建了exchange的话 //我们需要将该参数设置成创建的exchange的名字),第二个参数是路由键 channel.basicPublish(\"\", QUEUE_NAME, MessageProperties.PERSISTENT_BASIC, (\" Confirm模式， 第\" + (i + 1) + \"条消息\").getBytes()); if (channel.waitForConfirms()) { System.out.println(\"发送成功\"); }else{ // 进行消息重发 } } System.out.println(\"执行waitForConfirms耗费时间: \" + (System.currentTimeMillis() - start) + \"ms\"); // 关闭频道和连接 channel.close(); connection.close(); } } 我们在代码中发送了5条消息到Broker端，每条消息发送后都会等待确认。 ConfirmReceiver1.java： package net.anumbrella.rabbitmq.receiver; import com.rabbitmq.client.*; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.concurrent.TimeoutException; /** * 这是java原生类支持RabbitMQ，直接运行该类 */ public class ConfirmReceiver1 { private final static String QUEUE_NAME = \"confirm\"; public static void main(String[] argv) throws IOException, InterruptedException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setUsername(\"guest\"); factory.setPassword(\"guest\"); factory.setHost(\"127.0.0.1\"); factory.setVirtualHost(\"/\"); factory.setPort(5672); // 打开连接和创建频道，与发送端一样 Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); // 声明队列，主要为了防止消息接收者先运行此程序，队列还不存在时创建队列。 channel.queueDeclare(QUEUE_NAME, false, false, false, null); System.out.println(\"ConfirmReceiver1 waiting for messages. To exit press CTRL+C\"); // 创建队列消费者 final Consumer consumer = new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { SimpleDateFormat time = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSSS\"); String message = new String(body, \"UTF-8\"); System.out.println(\" ConfirmReceiver1 : \" + message); System.out.println(\" ConfirmReceiver1 Done! at \" + time.format(new Date())); } }; channel.basicConsume(QUEUE_NAME, true, consumer); } } 我们开启WireShak，监听RabbitMQ消息的发送。然后我们直接运行ConfirmSender1.java类，可以不用运行ConfirmReceiver.java，因为我们主要是测试消息到达Broker端，这主要是涉及到Producer和RabbitMQ的服务端。 在控制台打印出了信息： 发送成功 发送成功 发送成功 发送成功 发送成功 执行waitForConfirms耗费时间: 181ms 在RabbitMQ管理界面confirm队列里，我们可以查看到我们发送的5条消息数据。 在WireShark中也可以发现开启了Confirm模式，以及我们发送的5条消息。接着我们启动ConfirmReceiver.java，可以收到我们发送的具体消息： ConfirmReceiver1 waiting for messages. To exit press CTRL+C ConfirmReceiver1 : Confirm模式， 第1条消息 ConfirmReceiver1 Done! at 2018-08-04 14:58:27:0014 ConfirmReceiver1 : Confirm模式， 第2条消息 ConfirmReceiver1 Done! at 2018-08-04 14:58:27:0016 ConfirmReceiver1 : Confirm模式， 第3条消息 ConfirmReceiver1 Done! at 2018-08-04 14:58:27:0016 ConfirmReceiver1 : Confirm模式， 第4条消息 ConfirmReceiver1 Done! at 2018-08-04 14:58:27:0017 ConfirmReceiver1 : Confirm模式， 第5条消息 ConfirmReceiver1 Done! at 2018-08-04 14:58:27:0017 2、批量Confirm模式主要代码为： channel.confirmSelect(); for(int i=0;i&lt;5;i++){ channel.basicPublish(\"\", QUEUE_NAME, MessageProperties.PERSISTENT_BASIC, (\" Confirm模式， 第\" + (i + 1) + \"条消息\").getBytes()); } if(channel.waitForConfirms()){ System.out.println(\"发送成功\"); }else{ // 进行消息重发 } 这里主要更改代码为发送批量消息后再进行等待服务器确认，还可以调用channel.waitForConfirmsOrDie()方法，该方法会等到最后一条消息得到确认或者得到nack才会结束，也就是说在waitForConfirmsOrDie处会造成当前程序的阻塞。更改代码为批量Confirm模式，运行我们查看控制台： 发送成功 执行waitForConfirms耗费时间: 59ms 在WireShark查看信息如下： 可以发现这里处理的就是在批量发送信息完毕后，再进行ACK确认。同时我们发现这里只有三个Basic.Ack，这是因为Broker对信息进行了批量处理。 我们可以发现multiple的值为true，这与前面我们讲解的一致，true确认所有将比第一个参数指定的 delivery-tag 小的消息都得到确认。 我们也可以发现执行时间比第一种模式缩短了很多，效率极大提高了。 如果我们要对每条消息进行监听处理，可以通过在channel中添加监听器来实现，代码添加在发布者 channel.addConfirmListener(new ConfirmListener() { @Override public void handleNack(long deliveryTag, boolean multiple) throws IOException { System.out.println(\"nack: deliveryTag = \" + deliveryTag + \" multiple: \" + multiple); } @Override public void handleAck(long deliveryTag, boolean multiple) throws IOException { System.out.println(\"ack: deliveryTag = \" + deliveryTag + \" multiple: \" + multiple); } }); 当收到Broker发送过来的ack消息时就会调用handleAck方法，收到nack时就会调用handleNack方法。 我们可以在控制台看到信息，这次调用了两次Basic.Ack方法。 ack: deliveryTag = 4 multiple: true ack: deliveryTag = 5 multiple: false 发送成功 执行waitForConfirms耗费时间: 50ms 3、异步Confirm模式这里使用的异步Confirm模式，也要用到上面提到的监听，但是这里需要我们自己去维护实现一个waitForConfirms()方法或waitForConfirmsOrDie()，而waitForConfirms()是同步的，因此我们需要自己去实现维护delivery-tag。 我们可以在jar中查看到源码，其实waitForConfirmsOrDie()最终调用的也是waitForConfirms()方法，在waitForConfirms()方法内部维护了一个同步块代码，而unconfirmedSet就是存储delivery-tag标识的。 我们要实现自己异步调用，主要就是为了维护delivery-tag，在发送者代码里进行修改，主要实现代码如下： SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(new TreeSet&lt;Long&gt;()); channel.confirmSelect(); channel.addConfirmListener(new ConfirmListener() { public void handleAck(long deliveryTag, boolean multiple) throws IOException { if (multiple) { confirmSet.headSet(deliveryTag + 1L).clear(); } else { confirmSet.remove(deliveryTag); } } public void handleNack(long deliveryTag, boolean multiple) throws IOException { System.out.println(\"Nack, SeqNo: \" + deliveryTag + \", multiple: \" + multiple); /** 消息发送失败，应该进行消息重发 **/ } }); //进行消息发送 for(int i=0;i&lt;5;i++){ long nextSeqNo = channel.getNextPublishSeqNo();//获取消息id channel.basicPublish(\"\", QUEUE_NAME, MessageProperties.PERSISTENT_BASIC, (\" Confirm模式， 第\" + (i + 1) + \"条消息\").getBytes()); confirmSet.add(nextSeqNo); } 维持异步调用要求我们不能断掉连接，不能关掉连接还有通道。 4、关于Spring Boot使用Producer的Confirm模式主要是通过在Sender中实现RabbitTemplate.ConfirmCallback接口来实现该操作。可以参考rabbitmq-demo中的 CallBackSender.java 的实现。 CallBackSender.java package net.anumbrella.rabbitmq.sender; import java.util.UUID; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.amqp.rabbit.support.CorrelationData; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class CallBackSender implements RabbitTemplate.ConfirmCallback { @Autowired private RabbitTemplate rabbitTemplate; public void send() { rabbitTemplate.setConfirmCallback(this); String msg = \"callbackSender : i am callback sender\"; System.out.println(msg); CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString()); System.out.println(\"callbackSender UUID: \" + correlationData.getId()); this.rabbitTemplate.convertAndSend(\"\", \"hello\", msg, correlationData); } public void confirm(CorrelationData correlationData, boolean ack, String cause) { // 这里的ack是Broker对发布者消息达到服务端的确认 System.out.println(\"callbakck confirm: \" + correlationData.getId() + \" ACK : \" + ack + \" cause : \"+ cause); } } 2、消费者(Consumer)的Confirm模式手动确认和自动确认为了保证消息从队列可靠地到达消费者，RabbitMQ提供消息确认机制(message acknowledgment)。消费者在声明队列时，可以指定noAck参数，当noAck=false时，RabbitMQ会等待消费者显式发回ack信号后才从内存(和磁盘，如果是持久化消息的话)中移去消息。否则，RabbitMQ会在队列中消息被消费后立即删除它。 采用消息确认机制后，只要令noAck=false，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直持有消息直到消费者显式调用basicAck为止。 在Consumer中Confirm模式中分为手动确认和自动确认。 手动确认主要并使用以下方法： basic.ack: 用于肯定确认，multiple参数用于多个消息确认。basic.recover：是路由不成功的消息可以使用recovery重新发送到队列中。basic.reject：是接收端告诉服务器这个消息我拒绝接收,不处理,可以设置是否放回到队列中还是丢掉，而且只能一次拒绝一个消息,官网中有明确说明不能批量拒绝消息，为解决批量拒绝消息才有了basicNack。basic.nack：可以一次拒绝N条消息，客户端可以设置basicNack方法的multiple参数为true，服务器会拒绝指定了delivery_tag的所有未确认的消息(tag是一个64位的long值，最大值是9223372036854775807)。 肯定的确认只是指导RabbitMQ将一个消息记录为已投递。basic.reject的否定确认具有相同的效果。 两者的差别在于：肯定的确认假设一个消息已经成功处理，而对立面则表示投递没有被处理，但仍然应该被删除。 同样的Consumer中的Confirm模式也具有同时确认多个投递，通过将确认方法的 multiple “字段设置为true完成的，实现的意义与Producer的一致。 在自动确认模式下，消息在发送后立即被认为是发送成功。 这种模式可以提高吞吐量（只要消费者能够跟上），不过会降低投递和消费者处理的安全性。 这种模式通常被称为“发后即忘”。 与手动确认模式不同，如果消费者的TCP连接或信道在成功投递之前关闭，该消息则会丢失。 使用自动确认模式时需要考虑的另一件事是消费者过载。 手动确认模式通常与有限的信道预取一起使用，限制信道上未完成（“进行中”）传送的数量。 然而，对于自动确认，根据定义没有这样的限制。 因此，消费者可能会被交付速度所压倒，可能积压在内存中，堆积如山，或者被操作系统终止。 某些客户端库将应用TCP反压（直到未处理的交付积压下降超过一定的限制时才停止从套接字读取）。 因此，只建议当消费者可以有效且稳定地处理投递时才使用自动投递方式。 主要实现代码： // 手动确认消息 channel.basicAck(envelope.getDeliveryTag(), false); // 关闭自动确认 boolean autoAck = false; channel.basicConsume(QUEUE_NAME, autoAck, consumer); 关于Spring Boot使用Consumer的Confirm模式CheckReceiver.java package net.anumbrella.rabbitmq.receiver; import java.io.IOException; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; import com.rabbitmq.client.Channel; @Component public class CheckReceiver { @RabbitListener(queues = \"hello\") public void process(Message message, Channel channel) throws IOException { System.out.println(\"CheckReceiver: \" + new String(message.getBody())); try { doWork(); } catch (InterruptedException e) { e.printStackTrace(); } // 使用时需要在application.properties开启手动确认设置 // 消息的标识，false只确认当前一个消息收到，true确认所有将比第一个参数指定的 delivery tag 小的consumer都获得的消息 channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); } private static void doWork() throws InterruptedException { Thread.sleep(1000); } } 7. MQ的应用场景7.1 异步处理场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式 串行方式: 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. 并行方式: 将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 消息队列:假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回. 消息队列: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。 7.2 应用解耦场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. 这种做法有一个缺点: 当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合. 引入消息队列 订单系统:用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。 库存系统:订阅下单的消息,获取下单消息,进行库操作。 就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失. 7.3 流量削峰 场景: 秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。 作用: ​ 1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^) ​ 2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) 1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面. 2.秒杀业务根据消息队列中的请求信息，再做后续处理. 8. RabbitMQ的集群8.1 普通集群(副本集群) All data/state required for the operation of a RabbitMQ broker is replicated across all nodes. An exception to this are message queues, which by default reside on one node, though they are visible and reachable from all nodes. To replicate queues across nodes in a cluster –摘自官网 默认情况下:RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问 架构图 ​ 核心解决问题: 当集群中某一时刻master节点宕机,可以对Quene中元数据信息进行备份，不会同步存储的消息，消息只会存在于创建该队列的master节点上，其它节点只知道这个队列的元数据信息和一个指向队列的owner node的地址 集群搭建 # 0.集群规划 node1: 10.15.0.3 mq1 master 主节点 node2: 10.15.0.4 mq2 repl1 副本节点 node3: 10.15.0.5 mq3 repl2 副本节点 # 1.克隆三台机器主机名和ip映射 vim /etc/hosts加入: 10.15.0.3 mq1 10.15.0.4 mq2 10.15.0.5 mq3 node1: vim /etc/hostname 加入: mq1 node2: vim /etc/hostname 加入: mq2 node3: vim /etc/hostname 加入: mq3 # 2.三个机器安装rabbitmq,并同步cookie文件,在node1上执行: scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/ scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/ # 3.查看cookie是否一致: node1: cat /var/lib/rabbitmq/.erlang.cookie node2: cat /var/lib/rabbitmq/.erlang.cookie node3: cat /var/lib/rabbitmq/.erlang.cookie # 4.后台启动rabbitmq所有节点执行如下命令,启动成功访问管理界面: rabbitmq-server -detached # 5.在node2和node3执行加入集群命令: 1.关闭 rabbitmqctl stop_app 2.加入集群 rabbitmqctl join_cluster rabbit@mq1 3.启动服务 rabbitmqctl start_app # 6.查看集群状态,任意节点执行: rabbitmqctl cluster_status # 7.如果出现如下显示,集群搭建成功: Cluster status of node rabbit@mq3 ... [{nodes,[{disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]}]}, {running_nodes,[rabbit@mq1,rabbit@mq2,rabbit@mq3]}, {cluster_name,&lt;&lt;\"rabbit@mq1\"&gt;&gt;}, {partitions,[]}, {alarms,[{rabbit@mq1,[]},{rabbit@mq2,[]},{rabbit@mq3,[]}]}] # 8.登录管理界面,展示如下状态: # 9.测试集群在node1上,创建队列 # 10.查看node2和node3节点: # 11.关闭node1节点,执行如下命令,查看node2和node3: rabbitmqctl stop_app 8.2 镜像集群 This guide covers mirroring (queue contents replication) of classic queues –摘自官网 By default, contents of a queue within a RabbitMQ cluster are located on a single node (the node on which the queue was declared). This is in contrast to exchanges and bindings, which can always be considered to be on all nodes. Queues can optionally be made mirrored across multiple nodes. –摘自官网 镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。 集群架构图 配置集群架构 # 0.策略说明 rabbitmqctl set_policy [-p &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt; &lt;definition&gt; -p Vhost： 可选参数，针对指定vhost下的queue进行设置 Name: policy的名称 Pattern: queue的匹配模式(正则表达式) Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes all：表示在集群中所有的节点上进行镜像 exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定 nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定 ha-params：ha-mode模式需要用到的参数 ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual priority：可选参数，policy的优先级 # 1.查看当前策略 rabbitmqctl list_policies # 2.添加策略 rabbitmqctl set_policy ha-all '^hello' '{\"ha-mode\":\"all\",\"ha-sync-mode\":\"automatic\"}' 说明:策略正则表达式为 “^” 表示所有匹配所有队列名称 ^hello:匹配hello开头队列 # 3.删除策略 rabbitmqctl clear_policy ha-all # 4.测试集 9. RabbitMQ 应用与面试9.1 消息堆积当消息生产的速度长时间，远远大于消费的速度时。就会造成消息堆积。 消息堆积的影响 可能导致新消息无法进入队列 可能导致旧消息无法丢失 消息等待消费的时间过长，超出了业务容忍范围。 产生堆积的原因 生产者突然大量发布消息 消费者消费失败 消费者出现性能瓶颈。 消费者挂掉 解决办法 排查消费者的消费性能瓶颈 增加消费者的多线程处理 部署增加多个消费者 场景介绍 在用户登录成功之后，会向rabbitmq发送一个登录成功的消息。这个消息可以被多类业务订阅。 登录成功，记录登录日志；登录成功，根据规则送积分。其中登录送积分可以模拟成较为耗时的处理 场景重现：让消息产生堆积 生产者大量发送消息：使用Jmeter开启多线程，循环发送消息大量进入队列。 模拟堆积10万条数据 消费者消费失败：随机抛出异常，模拟消费者消费失败，没有ack（手动ack的时候）。 设置消费者的性能瓶颈：在消费方法中设置休眠时间，模拟性能瓶颈 关闭消费者：停掉消费者，模拟消费者挂掉 消费者端示例核心代码： public class LoginIntegralComsumer implements MessageListener { public void onMessage(Message message) { String jsonString = null; try { jsonString = new String(message.getBody(),\"UTF8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } if(new Random().nextInt(5)==2){ //模拟发生异常 throw new RuntimeException(\"模拟处理异常\"); } try { //模拟耗时的处理过程 TimeUnit.MILLISECONDS.sleep(1000); System.out.println(Thread.currentThread().getName()+\"处理消息:\"+jsonString); } catch (InterruptedException e) { e.printStackTrace(); } } } 如果每1秒钟处理一条消息，1小时处理 60*60=3600条，处理完10万条数据 100000/3600=27.7小时 问题解决：消息已经堆积如何解决 消息队列堆积，想办法把消息转移到一个新的队列，可以增加服务器慢慢来消费这个消息 生产环境的队列可用状态 1、解决消费者消费异常问题 2、解决消费者的性能瓶颈：改短休眠时间 5.4小时。 3、增加消费线程，增加多台服务器部署消费者，快速消费。 增加10个线程，1小时 concurrency=\"10\" prefetch=\"10\" 增加一台服务器，0.5小时 9.2 消息丢失在实际的生产环境中有可能出现一条消息因为一些原因丢失，导致消息没有消费成功，从而造成数据不一致等问题，造成严重的影响，比如：在一个商城的下单业务中，需要生成订单信息和扣减库存两个动作，如果使用RabbitMQ来实现该业务，那么在订单服务下单成功后需要发送一条消息到库存服务进行扣减库存，如果在此过程中，一条消息因为某些原因丢失，那么就会出现下单成功但是库存没有扣减，从而导致超卖的情况，也就是库存已经没有了，但是用户还能下单，这个问题对于商城系统来说是致命的。 消息丢失的场景主要分为：消息在生产者丢失，消息在RabbitMQ丢失，消息在消费者丢失。 9.2.1 消息在生产者丢失 场景介绍 ​ 消息生产者发送消息成功，但是MQ没有收到该消息，消息在从生产者传输到MQ的过程中丢失，一般是由于网络不稳定的原因。 解决方案 ​ 采用RabbitMQ 发送方消息确认机制，当消息成功被MQ接收到时，会给生产者发送一个确认消息，表示接收成功。RabbitMQ 发送方消息确认模式有以下三种：普通确认模式，批量确认模式，异步监听确认模式。spring整合RabbitMQ后只使用了异步监听确认模式。 说明 ​ 异步监听模式，可以实现边发送消息边进行确认，不影响主线程任务执行。 步骤 生产者发送3000条消息 在发送消息前开启开启发送方确认模式 &lt;rabbit:connection-factory id=\"connectionFactory\" host=\"${rabbitmq.host}\" port=\"${rabbitmq.port}\" username=\"${rabbitmq.username}\" password=\"${rabbitmq.password}\" virtual-host=\"${rabbitmq.virtual-host}\" publisher-confirms=\"true\" /&gt; 在发送消息前添加异步确认监听器 //添加异步确认监听器 rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() { public void confirm(CorrelationData correlationData, boolean ack, String cause) { if (ack) { // 处理ack System.out.println(\"已确认消息，标识：\" + correlationData.getId()); } else { // 处理nack, 此时cause包含nack的原因。 System.out.println(\"未确认消息，标识：\" + correlationData.getId()); System.out.println(\"未确认原因：\" + cause); //重发 } } }); 9.2.2 消息在RabbitMQ丢失 场景介绍 ​ 消息成功发送到MQ，消息还没被消费却在MQ中丢失，比如MQ服务器宕机或者重启会出现这种情况 解决方案 ​ 持久化交换机，队列，消息，确保MQ服务器重启时依然能从磁盘恢复对应的交换机，队列和消息。 spring整合后默认开启了交换机，队列，消息的持久化，所以不修改任何设置就可以保证消息不在RabbitMQ丢失。但是为了以防万一，还是可以申明下。 9.2.3 消息在消费者丢失 场景介绍 ​ 消息费者消费消息时，如果设置为自动回复MQ，消息者端收到消息后会自动回复MQ服务器，MQ则会删除该条消息，如果消息已经在MQ被删除但是消费者的业务处理出现异常或者消费者服务宕机，那么就会导致该消息没有处理成功从而导致该条消息丢失。 解决方案 ​ 设置为手动回复MQ服务器，当消费者出现异常或者服务宕机时，MQ服务器不会删除该消息，而是会把消息重发给绑定该队列的消费者，如果该队列只绑定了一个消费者，那么该消息会一直保存在MQ服务器，直到消息者能正常消费为止。本解决方案以一个队列绑定多个消费者为例来说明，一般在生产环境上也会让一个队列绑定多个消费者也就是工作队列模式来减轻压力，提高消息处理效率 ​ MQ重发消息场景： ​ 1.消费者未响应ACK，主动关闭频道或者连接 ​ 2.消费者未响应ACK，消费者服务挂掉 9.3 有序消费消息 场景介绍 场景1 当RabbitMQ采用work Queue模式，此时只会有一个Queue但是会有多个Consumer,同时多个Consumer直接是竞争关系，此时就会出现MQ消息乱序的问题。 解决方案 场景2 当RabbitMQ采用简单队列模式的时候,如果消费者采用多线程的方式来加速消息的处理,此时也会出现消息乱序的问题。 解决方案 9.4 重复消费 场景介绍 ​ 为了防止消息在消费者端丢失，会采用手动回复MQ的方式来解决，同时也引出了一个问题，消费者处理消息成功，手动回复MQ时由于网络不稳定，连接断开，导致MQ没有收到消费者回复的消息，那么该条消息还会保存在MQ的消息队列，由于MQ的消息重发机制，会重新把该条消息发给和该队列绑定的消息者处理，这样就会导致消息重复消费。而有些操作是不允许重复消费的，比如下单，减库存，扣款等操作。 ​ MQ重发消息场景： ​ 1.消费者未响应ACK，主动关闭频道或者连接 ​ 2.消费者未响应ACK，消费者服务挂掉 解决方案 ​ 如果消费消息的业务是幂等性操作（同一个操作执行多次，结果不变）就算重复消费也没问题，可以不做处理，如果不支持幂等性操作，如：下单，减库存，扣款等，那么可以在消费者端每次消费成功后将该条消息id保存到数据库，每次消费前查询该消息id，如果该条消息id已经存在那么表示已经消费过就不再消费否则就消费。本方案采用redis存储消息id，因为redis是单线程的，并且性能也非常好，提供了很多原子性的命令，本方案使用setnx命令存储消息id。 setnx(key,value):如果key不存在则插入成功且返回1,如果key存在,则不进行任何操作,返回0","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Spring","slug":"Spring笔记","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:30:58.229Z","comments":true,"path":"posts/ea4e955k.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e955k.html","excerpt":"","text":"Spring 简介 Spring : 春天 —&gt;给软件行业带来了春天 2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。 2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。 很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。 Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术 优点 Spring是一个开源免费的框架（容器） Spring是一个轻量级的、非入侵式的框架 控制反转 IoC，面向切面 AOP 对事物的支持，对框架的支持 一句话概括：Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。 组成 Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 . 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 拓展 Spring Boot与Spring Cloud Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; Spring Cloud是基于Spring Boot实现的； Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。 Spring 框架两大核心机制（IoC、AOP） IoC（控制反转）/ DI（依赖注入） AOP（面向切面编程） Spring 是一个企业级开发框架，是软件设计层面的框架，优势在于可以将应用程序进行分层，开发者可以自主选择组件。 MVC：Struts2、Spring MVC ORMapping：Hibernate、MyBatis、Spring Data Spring配置 别名 alias 设置别名 , 为bean设置别名 , 可以设置多个别名 &lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt; &lt;alias name=\"user\" alias=\"userNew\"/&gt; Bean的配置 &lt;!--bean就是java对象,由Spring创建和管理--&gt; &lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; class是bean的全限定名=包名+类名 --&gt; &lt;bean id=\"hello\" name=\"hello2 h2,h3;h4\" class=\"com.kuang.pojo.Hello\"&gt; &lt;property name=\"name\" value=\"Spring\"/&gt; &lt;/bean&gt; import 团队的合作通过import来实现 . &lt;import resource=\"{path}/beans.xml\"/&gt; IoC基础新建一个空白的maven项目 分析实现 我们先用我们原来的方式写一段代码 . 1、先写一个UserDao接口 public interface UserDao { public void getUser(); } 2、再去写Dao的实现类 public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\"获取用户数据\"); } } 3、然后去写UserService的接口 public interface UserService { public void getUser(); } 4、最后写Service的实现类 public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } } 5、测试一下 @Test public void test(){ UserService service = new UserServiceImpl(); service.getUser(); } 这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 . 把Userdao的实现类增加一个 . public class UserDaoMySqlImpl implements UserDao { @Override public void getUser() { System.out.println(\"MySql获取用户数据\"); } } 紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现 public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() { userDao.getUser(); } } 在假设, 我们再增加一个Userdao的实现类 . public class UserDaoOracleImpl implements UserDao { @Override public void getUser() { System.out.println(\"Oracle获取用户数据\"); } } 那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 . 那我们如何去解决呢 ? 我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 . public class UserServiceImpl implements UserService { private UserDao userDao; // 利用set实现 public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } } 现在去我们的测试类里 , 进行测试 ; @Test public void test(){ UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢 service.setUserDao( new UserDaoOracleImpl() ); service.getUser(); } 大家发现了区别没有 ? 可能很多人说没啥区别 ,但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 . 这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 ! IOC本质 控制反转 IoC (Inversion of Control)，是一种设计思想，DI (依赖注入)是实现 IoC 的一种方法，也有人认为 DI 只是 IoC 的另一种说法。没有 IoC 的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。 Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI），依赖注入 : 就是利用set方法来进行注入的。 IoC 底层原理 读取配置文件，解析 XML。 通过反射机制实例化配置文件中所配置所有的 bean。 package com.southwind.ioc; import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Iterator; import java.util.Map; public class ClassPathXmlApplicationContext implements ApplicationContext { private Map&lt;String,Object&gt; ioc = new HashMap&lt;String, Object&gt;(); public ClassPathXmlApplicationContext(String path){ try { SAXReader reader = new SAXReader(); Document document = reader.read(\"./src/main/resources/\"+path); Element root = document.getRootElement(); Iterator&lt;Element&gt; iterator = root.elementIterator(); while(iterator.hasNext()){ Element element = iterator.next(); String id = element.attributeValue(\"id\"); String className = element.attributeValue(\"class\"); //通过反射机制创建对象 Class clazz = Class.forName(className); //获取无参构造函数，创建目标对象 Constructor constructor = clazz.getConstructor(); Object object = constructor.newInstance(); //给目标对象赋值 Iterator&lt;Element&gt; beanIter = element.elementIterator(); while(beanIter.hasNext()){ Element property = beanIter.next(); String name = property.attributeValue(\"name\"); String valueStr = property.attributeValue(\"value\"); String ref = property.attributeValue(\"ref\"); if(ref == null){ String methodName = \"set\"+name.substring(0,1).toUpperCase()+name.substring(1); Field field = clazz.getDeclaredField(name); Method method = clazz.getDeclaredMethod(methodName,field.getType()); //根据成员变量的数据类型将 value 进行转换 Object value = null; if(field.getType().getName() == \"long\"){ value = Long.parseLong(valueStr); } if(field.getType().getName() == \"java.lang.String\"){ value = valueStr; } if(field.getType().getName() == \"int\"){ value = Integer.parseInt(valueStr); } method.invoke(object,value); } ioc.put(id,object); } } } catch (DocumentException e) { e.printStackTrace(); } catch (ClassNotFoundException e){ e.printStackTrace(); } catch (NoSuchMethodException e){ e.printStackTrace(); } catch (InstantiationException e){ e.printStackTrace(); } catch (IllegalAccessException e){ e.printStackTrace(); } catch (InvocationTargetException e){ e.printStackTrace(); } catch (NoSuchFieldException e){ e.printStackTrace(); } } public Object getBean(String id) { return ioc.get(id); } } 如何使用 IoC 创建 Maven 工程，pom.xml 添加依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.southwind&lt;/groupId&gt; &lt;artifactId&gt;aispringioc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 创建实体类 Student package com.southwind.entity; import lombok.Data; @Data public class Student { private long id; private String name; private int age; } 传统的开发方式，手动 new Student Student student = new Student(); student.setId(1L); student.setName(\"张三\"); student.setAge(22); System.out.println(student); 通过 IoC 创建对象，在配置文件中添加需要管理的对象，XML 格式的配置文件，文件名可以自定义。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd \"&gt; &lt;bean id=\"student\" class=\"com.southwind.entity.Student\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 从 IoC 中获取对象，通过 id 获取。 //加载配置文件 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); Student student = (Student) applicationContext.getBean(\"student\"); System.out.println(student); 通过运行时类获取 bean ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); Student student = (Student) applicationContext.getBean(Student.class); System.out.println(student); 这种方式存在一个问题，配置文件中一个数据类型的对象==只能有一个实例==，否则会抛出异常，因为没有唯一的 bean。 依赖注入（Dependency Injection,DI） 概念 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 . 构造器注入 通过无参构造方法来创建 1、User.java public class User { private String name; public User() { System.out.println(\"user无参构造方法\"); } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\"name=\"+ name ); } } 2、beans.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\"&gt; &lt;property name=\"name\" value=\"kuangshen\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 3、测试类 @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //在执行getBean之前, user已经创建好了 , 通过无参构造 User user = (User) context.getBean(\"user\"); //调用对象的方法 . user.show(); } 结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！ 通过有参构造方法来创建 1、UserT . java public class UserT { private String name; public UserT(String name) { this.name = name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\"name=\"+ name ); } } 2、beans.xml 有三种方式编写 &lt;!-- 第一种根据index参数下标设置 --&gt; &lt;bean id=\"userT\" class=\"com.kuang.pojo.UserT\"&gt; &lt;!-- index指构造方法参数下标 , 下标从0开始 --&gt; &lt;constructor-arg index=\"0\" value=\"kuangshen2\"/&gt; &lt;/bean&gt; &lt;!-- 第二种根据参数名字设置 --&gt; &lt;bean id=\"userT\" class=\"com.kuang.pojo.UserT\"&gt; &lt;!-- name指参数名 --&gt; &lt;constructor-arg name=\"name\" value=\"kuangshen2\"/&gt; &lt;/bean&gt; &lt;!-- 第三种根据参数类型设置 --&gt; &lt;bean id=\"userT\" class=\"com.kuang.pojo.UserT\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"kuangshen2\"/&gt; &lt;/bean&gt; 3、测试 @Test public void testT(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserT user = (UserT) context.getBean(\"userT\"); user.show(); } 结论：在配置文件加载的时候，其中管理的对象都已经初始化了！ Set 注入要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 测试pojo类 : Address.java public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } Student.java package com.kuang.pojo; import java.util.List; import java.util.Map; import java.util.Properties; import java.util.Set; public class Student { private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; public void setName(String name) { this.name = name; } public void setAddress(Address address) { this.address = address; } public void setBooks(String[] books) { this.books = books; } public void setHobbys(List&lt;String&gt; hobbys) { this.hobbys = hobbys; } public void setCard(Map&lt;String, String&gt; card) { this.card = card; } public void setGames(Set&lt;String&gt; games) { this.games = games; } public void setWife(String wife) { this.wife = wife; } public void setInfo(Properties info) { this.info = info; } public void show(){ System.out.println(\"name=\"+ name + \",address=\"+ address.getAddress() + \",books=\" ); for (String book:books){ System.out.print(\"&lt;&lt;\"+book+\"&gt;&gt;\\t\"); } System.out.println(\"\\n爱好:\"+hobbys); System.out.println(\"card:\"+card); System.out.println(\"games:\"+games); System.out.println(\"wife:\"+wife); System.out.println(\"info:\"+info); } } 1、常量注入 &lt;bean id=\"student\" class=\"com.kuang.pojo.Student\"&gt; &lt;property name=\"name\" value=\"小明\"/&gt; &lt;/bean&gt; 测试： @Test public void test01(){ ApplicationContext context = newClassPathXmlApplicationContext(\"applicationContext.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student.getName()); } 2、Bean注入 注意点：这里的值是一个引用，ref，引用另一个bean &lt;bean id=\"addr\" class=\"com.kuang.pojo.Address\"&gt; &lt;property name=\"address\" value=\"重庆\"/&gt; &lt;/bean&gt; &lt;bean id=\"student\" class=\"com.kuang.pojo.Student\"&gt; &lt;property name=\"name\" value=\"小明\"/&gt; &lt;property name=\"address\" ref=\"addr\"/&gt; &lt;/bean&gt; 3、数组注入 &lt;bean id=\"student\" class=\"com.kuang.pojo.Student\"&gt; &lt;property name=\"name\" value=\"小明\"/&gt; &lt;property name=\"address\" ref=\"addr\"/&gt; &lt;property name=\"books\"&gt; &lt;array&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 4、List注入 &lt;property name=\"hobbys\"&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;value&gt;爬山&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 给 bean 注入类集合 &lt;bean id=\"student\" class=\"com.southwind.entity.Student\"&gt; &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"33\"&gt;&lt;/property&gt; &lt;property name=\"addresses\"&gt; &lt;list&gt; &lt;ref bean=\"address\"&gt;&lt;/ref&gt; &lt;ref bean=\"address2\"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"address\" class=\"com.southwind.entity.Address\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"科技路\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"address2\" class=\"com.southwind.entity.Address\"&gt; &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"高新区\"&gt;&lt;/property&gt; &lt;/bean&gt; 5、Map注入 &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"中国邮政\" value=\"456456456465456\"/&gt; &lt;entry key=\"建设\" value=\"1456682255511\"/&gt; &lt;/map&gt; &lt;/property&gt; 6、Set (集合)注入 &lt;property name=\"games\"&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; 7、Null注入 &lt;property name=\"wife\"&gt; &lt;null/&gt; &lt;/property&gt; 8、Properties注入 &lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"学号\"&gt;20190604&lt;/prop&gt; &lt;prop key=\"性别\"&gt;男&lt;/prop&gt; &lt;prop key=\"姓名\"&gt;小明&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; p命名和c命名注入User.java ：【注意：这里没有有参构造器！】 public class User { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 1、P命名空间注入 : 需要在头文件中加入约束文件 导入约束 : xmlns:p=\"http://www.springframework.org/schema/p\" &lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\" p:name=\"狂神\" p:age=\"18\"/&gt; 2、C命名空间注入 : 需要在头文件中加入约束文件 导入约束 : xmlns:c=\"http://www.springframework.org/schema/c\" &lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\" c:name=\"狂神\" c:age=\"18\"/&gt; ==c命名空间注入需要把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！== 测试代码： @Test public void test02(){ ApplicationContext context = newClassPathXmlApplicationContext(\"applicationContext.xml\"); User user = (User) context.getBean(\"user\"); System.out.println(user); } scope 作用域Spring 管理的 bean 是根据 scope 来生成的，表示 bean 的作用域，共4种，默认值是 singleton。 范围 描述 singleton (默认)为每个 Spring IoC 容器的单个 object 实例定义单个 bean 定义。 prototype 为任意数量的 object 实例定义单个 bean 定义。 request 将单个 bean 定义范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有自己的 bean 实例，该实例是在单个 bean 定义的后面创建的。仅在 web-aware Spring ApplicationContext的 context 中有效。 session 将单个 bean 定义范围限定为 HTTP Session的生命周期。仅在 web-aware Spring ApplicationContext的 context 中有效。 Application 将单个 bean 定义范围限定为ServletContext的生命周期。仅在 web-aware Spring ApplicationContext的 context 中有效。 WebSocket 将单个 bean 定义范围限定为WebSocket的生命周期。仅在 web-aware Spring ApplicationContext的 context 中有效。 singleton：单例，表示通过 IoC 容器获取的 bean 是唯一的。 prototype：原型，表示通过 IoC 容器获取的 bean 是不同的。 request：请求，表示在一次 HTTP 请求内有效。 session：回话，表示在一个用户会话内有效。 request 和 session 只适用于 Web 项目，大多数情况下，使用单例和原型较多。 prototype 模式当业务代码获取 IoC 容器中的 bean 时，Spring 才去调用无参构造创建对应的 bean。 &lt;bean id=\"ServiceImpl\" class=\"cn.csdn.service.ServiceImpl\" scope=\"singleton\"&gt; singleton 模式无论业务代码是否获取 IoC 容器中的 bean，Spring 在加载 spring.xml 时就会创建 bean。 &lt;bean id=\"account\" class=\"com.foo.DefaultAccount\" scope=\"prototype\"/&gt; 或者 &lt;bean id=\"account\" class=\"com.foo.DefaultAccount\" singleton=\"false\"/&gt; Spring 的继承与 Java 的继承不同，Java 是类层面的继承，子类可以继承父类的内部结构信息；Spring 是对象层面的继承，子对象可以继承父对象的属性值。 &lt;bean id=\"student2\" class=\"com.southwind.entity.Student\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt; &lt;property name=\"addresses\"&gt; &lt;list&gt; &lt;ref bean=\"address\"&gt;&lt;/ref&gt; &lt;ref bean=\"address2\"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"address\" class=\"com.southwind.entity.Address\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"科技路\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"address2\" class=\"com.southwind.entity.Address\"&gt; &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"高新区\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"stu\" class=\"com.southwind.entity.Student\" parent=\"student2\"&gt; &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt; &lt;/bean&gt; Spring 的继承关注点在于==具体的对象==，而不在于类，即==不同的两个类的实例化对象可以完成继承==，前提是==子对象必须包含父对象的所有属性==，同时可以在此基础上添加其他的属性。 Spring 的依赖与继承类似，依赖也是描述 bean 和 bean 之间的一种关系，配置依赖之后，被依赖的 bean 一定先创建，再创建依赖的 bean，A 依赖于 B，先创建 B，再创建 A。==没有依赖关系的话 bean 会根据写的先后顺序创建== &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \"&gt; &lt;bean id=\"student\" class=\"com.southwind.entity.Student\" depends-on=\"user\"&gt;&lt;/bean&gt; &lt;bean id=\"user\" class=\"com.southwind.entity.User\"&gt;&lt;/bean&gt; &lt;/beans&gt; Spring 的工厂方法IoC 通过工厂模式创建 bean 的方式有两种： 静态工厂方法 实例工厂方法 静态工厂方法 package com.southwind.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class Car { private long id; private String name; } package com.southwind.factory; import com.southwind.entity.Car; import java.util.HashMap; import java.util.Map; public class StaticCarFactory { private static Map&lt;Long, Car&gt; carMap; static{ carMap = new HashMap&lt;Long, Car&gt;(); carMap.put(1L,new Car(1L,\"宝马\")); carMap.put(2L,new Car(2L,\"奔驰\")); } public static Car getCar(long id){ return carMap.get(id); } } &lt;!-- 配置静态工厂创建 Car --&gt; &lt;bean id=\"car\" class=\"com.southwind.factory.StaticCarFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg value=\"2\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 实例工厂方法 package com.southwind.factory; import com.southwind.entity.Car; import java.util.HashMap; import java.util.Map; public class InstanceCarFactory { private Map&lt;Long, Car&gt; carMap; public InstanceCarFactory(){ carMap = new HashMap&lt;Long, Car&gt;(); carMap.put(1L,new Car(1L,\"宝马\")); carMap.put(2L,new Car(2L,\"奔驰\")); } public Car getCar(long id){ return carMap.get(id); } } &lt;!-- 配置实例工厂 bean --&gt; &lt;bean id=\"carFactory\" class=\"com.southwind.factory.InstanceCarFactory\"&gt;&lt;/bean&gt; &lt;!-- 配置实例工厂创建 Car --&gt; &lt;bean id=\"car2\" factory-bean=\"carFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg value=\"1\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; IoC 自动装载（Autowire）Bean的自动装配 自动装配说明 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配机制，分别是： 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的 IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。 推荐不使用自动装配xml配置 , 而使用注解 . 测试环境搭建 1、新建一个项目 2、新建两个实体类，Cat Dog 都有一个叫的方法 public class Cat { public void shout() { System.out.println(\"miao~\"); } } public class Dog { public void shout() { System.out.println(\"wang~\"); } } 3、新建一个用户类 User public class User { private Cat cat; private Dog dog; private String str; } 4、编写Spring配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\"&gt; &lt;property name=\"cat\" ref=\"cat\"/&gt; &lt;property name=\"dog\" ref=\"dog\"/&gt; &lt;property name=\"str\" value=\"qinjiang\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 5、测试 public class MyTest { @Test public void testMethodAutowire() { ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"user\"); user.getCat().shout(); user.getDog().shout(); } } 结果正常输出，环境OK 自动装配的两种方式：1、byName (按名称自动装配) 2、byType (按类型自动装配) byName autowire byName (按名称自动装配) 由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。 采用自动装配将避免这些错误，并且使配置简单化。 测试： 1、修改bean配置，增加一个属性 autowire=”byName” &lt;bean id=\"user\" class=\"com.kuang.pojo.User\" autowire=\"byName\"&gt; &lt;property name=\"str\" value=\"qinjiang\"/&gt; &lt;/bean&gt; 2、再次测试，结果依旧成功输出！ 3、我们将 cat 的bean id修改为 catXXX 4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat方法就没执行，对象就没有初始化，所以调用时就会报空指针错误。 小结： 当一个bean节点带有 autowire byName的属性时。 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称 id 的bean。 如果有，就取出注入；如果没有，就报空指针异常。 byType autowire byType (按类型自动装配) 使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。 NoUniqueBeanDefinitionException 测试： 1、将user的bean配置修改一下 ： autowire=”byType” 2、测试，正常输出 3、在注册一个cat 的bean对象！ &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"cat2\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\" autowire=\"byType\"&gt; &lt;property name=\"str\" value=\"qinjiang\"/&gt; &lt;/bean&gt; 4、测试，报错：NoUniqueBeanDefinitionException 5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。 使用注解 jdk1.5开始支持注解，spring2.5开始全面支持注解。 准备工作：利用注解的方式注入属性。 1、在spring配置文件中引入context文件头 xmlns:context=\"http://www.springframework.org/schema/context\" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd 2、开启属性注解支持！ &lt;context:annotation-config/&gt; @Autowired @Autowired是按类型自动转配的，不支持 id 匹配。 需要导入 spring-aop 的 jar包！ 测试： 1、将User类中的set方法去掉，使用@Autowired注解 public class User { @Autowired private Cat cat; @Autowired private Dog dog; private String str; public Cat getCat() { return cat; } public Dog getDog() { return dog; } public String getStr() { return str; } } 2、此时配置文件内容 &lt;context:annotation-config/&gt; &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\"/&gt; 3、测试，成功输出结果！ 【小狂神科普时间】 @Autowired(required=false) 说明：false，对象可以为null；true，对象必须存在，不能为null。 //如果允许对象为null，设置required = false,默认为true @Autowired(required = false) private Cat cat; @Qualifier @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用。 测试实验步骤： 1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ &lt;bean id=\"dog1\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"dog2\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat1\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"cat2\" class=\"com.kuang.pojo.Cat\"/&gt; 2、没有加Qualifier测试，直接报错 3、在属性上添加Qualifier注解 @Autowired @Qualifier(value = \"cat2\") private Cat cat; @Autowired @Qualifier(value = \"dog2\") private Dog dog; 测试，成功输出！ @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 实体类： public class User { @Resource(name = \"cat2\") private Cat cat; @Resource private Dog dog; private String str; } beans.xml &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat1\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"cat2\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\"/&gt; 测试：结果OK 配置文件2：beans.xml ， 删掉cat2 &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat1\" class=\"com.kuang.pojo.Cat\"/&gt; 实体类上只保留注解 @Resource private Cat cat; @Resource private Dog dog; 结果：OK 结论：先进行byName查找，失败；再进行byType查找，成功。 小结 @Autowired与@Resource异同： 1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用 3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。 使用注解开发 说明 在spring4之后，想要使用注解形式，必须得要引入 spring-aop 的 jar 包 在配置文件当中，还得要引入一个context约束 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解支持 --&gt; &lt;context:annotation-config/&gt; &lt;/beans&gt; Bean的实现 我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！ 1、配置扫描哪些包下的注解 &lt;!--指定注解扫描包，有 @Component 注解会自动装配 bean --&gt; &lt;context:component-scan base-package=\"com.kuang.pojo\"/&gt; 2、在指定包下编写类，增加注解 @Component(\"user\") // 相当于配置文件中 &lt;bean id=\"user\" class=\"当前注解的类\"/&gt; public class User { public String name = \"秦疆\"; } 3、测试 @Test public void test(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) applicationContext.getBean(\"user\"); System.out.println(user.name); } 属性注入 使用注解注入属性 1、可以不用提供set方法，直接在直接名上添加 @value(“值”) @Component(\"user\") // 相当于配置文件中 &lt;bean id=\"user\" class=\"当前注解的类\"/&gt; // @Component 默认是 @Component(\"类名首字母小写\") public class User { @Value(\"秦疆\") // 相当于配置文件中 &lt;property name=\"name\" value=\"秦疆\"/&gt; public String name; } 2、如果提供了set方法，在set方法上添加**@value(“值”)**; @Component(\"user\") public class User { public String name; @Value(\"秦疆\") public void setName(String name) { this.name = name; } } 衍生注解 我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！ @Component三个衍生注解 为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。 @Controller：web层 @Service：service层 @Repository：dao层 写上这些注解，就相当于将这个类交给Spring管理装配了！ 自动装配注解 @Autowired是按类型自动转配的，不支持 id 匹配。 @Qualifier：@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配，**@Qualifier不能单独使用。** @Resource：@Resource如有指定的name属性，先按该属性进行byName方式查找装配；其次再进行默认的byName方式进行装配；如果以上都不成功，则按byType的方式自动装配。 作用域 @scope singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 @Controller(\"user\") @Scope(\"prototype\") public class User { @Value(\"秦疆\") public String name; } 小结 XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践 xml 管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 开启注解支持 ： &lt;context:annotation-config/&gt; 作用： 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显式的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！ 基于Java类进行配置JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。 测试： 1、编写一个实体类，Dog @Component //将这个类标注为Spring的一个组件，放到容器中！ 在这里可不写，没有作用，因为 bean 已经在 MyConfig 类中注册 与@ComponentScan 搭配使用 public class Dog { public String name = \"dog\"; } 2、新建一个config配置包，编写一个MyConfig配置类 @Configuration //代表这是一个配置类 @ComponentScan(\"com.xu.bean\") //自动扫描包，有 @Component 注解的会自动装配 bean public class MyConfig { @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！ public Dog getdog(){ return new Dog(); } } 3、测试 @Test public void test2(){ ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class); //注意这里是 AnnotationConfigApplicationContext 类 Dog dog = (Dog) applicationContext.getBean(\"getdog\"); // 这样写用的是 @Component 和 @ComponentScan 注解 // Dog dog = (Dog) applicationContext.getBean(\"dog\"); System.out.println(dog.name); } 4、成功输出结果！ 导入其他配置如何做呢？ 1、我们再编写一个配置类！ @Configuration //代表这是一个配置类 public class MyConfig2 { } 2、在之前的配置类中我们来选择导入这个配置类 @Configuration @Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签 public class MyConfig { @Bean public Dog dog(){ return new Dog(); } } 关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！ 代理模式为什么要学习代理模式，因为AOP的底层机制就是动态代理！ 代理模式： 静态代理 动态代理 学习aop之前 , 我们要先了解一下代理模式！ 静态代理 静态代理角色分析 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 代码实现 Rent . java 即抽象角色 //抽象角色：租房 public interface Rent { public void rent(); } Host . java 即真实角色 //真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\"房屋出租\"); } } Proxy . java 即代理角色 //代理角色：中介 public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房 public void rent(){ seeHouse(); host.rent(); fare(); } //看房 public void seeHouse(){ System.out.println(\"带房客看房\"); } //收中介费 public void fare(){ System.out.println(\"收中介费\"); } } Client . java 即客户 //客户类，一般客户都会去找代理！ public class Client { public static void main(String[] args) { //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); } } 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。 静态代理的好处: 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 缺点 : 类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 . 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 ! 静态代理再理解 同学们练习完毕后，我们再来举一个例子，巩固大家的学习！ 练习步骤： 1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！ //抽象角色：增删改查业务 public interface UserService { void add(); void delete(); void update(); void query(); } 2、我们需要一个真实对象来完成这些增删改查操作 //真实对象，完成增删改查操作的人 public class UserServiceImpl implements UserService { public void add() { System.out.println(\"增加了一个用户\"); } public void delete() { System.out.println(\"删除了一个用户\"); } public void update() { System.out.println(\"更新了一个用户\"); } public void query() { System.out.println(\"查询了一个用户\"); } } 3、需求来了，现在我们需要增加一个日志功能，怎么实现！ 思路1 ：在实现类上增加代码 【麻烦！】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！ 4、设置一个代理类来处理日志！代理角色 //代理角色，在这里面增加日志的实现 public class UserServiceProxy implements UserService { private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) { this.userService = userService; } public void add() { log(\"add\"); userService.add(); } public void delete() { log(\"delete\"); userService.delete(); } public void update() { log(\"update\"); userService.update(); } public void query() { log(\"query\"); userService.query(); } public void log(String msg){ System.out.println(\"执行了\"+msg+\"方法\"); } } 5、测试访问类： public class Client { public static void main(String[] args) { //真实业务 UserServiceImpl userService = new UserServiceImpl(); //代理类 UserServiceProxy proxy = new UserServiceProxy(); //使用代理类实现日志功能！ proxy.setUserService(userService); proxy.add(); } } OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想； 我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想 聊聊AOP：纵向开发，横向开发 动态代理 动态代理的角色和静态代理的一样 . 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理—-JDK动态代理 基于类的动态代理–cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下 javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、 JDK的动态代理需要了解两个类 核心 : InvocationHandler 和 Proxy ， 打开JDK帮助文档看看 【InvocationHandler：调用处理程序】 Object invoke(Object proxy, 方法 method, Object[] args)； //参数 //proxy - 调用该方法的代理实例 //method -对应代理业务接口的方法对象。方法对象的声明类型将是该方法所属的接口类型，它可以是代理类继承该方法的代理接口的超级接口。 //args -method 的参数列，即业务方法的参数列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 【Proxy : 代理】 //生成代理类 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } 代码实现 抽象角色和真实角色和之前的一样！ Rent . java 即抽象角色 //抽象角色：租房 public interface Rent { public void rent(); } Host . java 即真实角色 //真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\"房屋出租\"); } } ProxyInvocationHandler. java 即代理角色 public class ProxyInvocationHandler implements InvocationHandler { private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } // proxy : 代理类 method : 代理类的调用处理程序的方法对象. // 处理代理实例上的方法调用并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable { seeHouse(); //核心：本质利用反射实现！ Object result = method.invoke(rent, args); fare(); return result; } //看房 public void seeHouse(){ System.out.println(\"带房客看房\"); } //收中介费 public void fare(){ System.out.println(\"收中介费\"); } } Client . java //租客 public class Client { public static void main(String[] args) { //真实角色 Host host = new Host(); //代理实例的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //隐式向上转型 pih.setRent(host); //将真实角色放置进去！ Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！ proxy.rent(); } } 核心：一个静态态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口! 深化理解 我们来使用动态代理实现代理我们后面写的 UserService！ 我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为 Object 即可！ public class ProxyInvocationHandler implements InvocationHandler { private Object target; public void setTarget(Object target) { this.target = target; } //生成代理类 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); } // proxy : 代理类 // method : 代理类的调用处理程序的方法对象. public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String methodName){ System.out.println(\"执行了\"+methodName+\"方法\"); } } 测试！ public class Test { public static void main(String[] args) { //真实对象 UserServiceImpl userService = new UserServiceImpl(); //代理对象的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //隐式向上转型 pih.setTarget(userService); //设置要代理的对象 UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！ proxy.delete(); } } 测试，增删改查，查看结果！ 动态代理的好处 静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ AOPAOP：Aspect Oriented Programming 面向切面编程。 AOP 的优点： 降低模块之间的耦合度。 使系统更容易扩展。 更好的代码复用。 非业务代码更加集中，不分散，便于统一管理。 业务代码更加简洁存粹，不参杂其他代码的影响。 AOP 是对面向对象编程的一个补充，在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。将不同方法的同一个位置抽象成一个切面对象，对该切面对象进行编程就是 AOP。 Aop在Spring中的作用 提供声明式事务；允许用户自定义切面 以下名词需要了解下： 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 . 使用Spring实现Aop【重点】使用AOP织入，需要导入一个依赖包！ &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; 第一种方式 通过 Spring API 实现首先编写我们的业务接口和实现类 public interface UserService { public void add(); public void delete(); public void update(); public void search(); } public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\"增加用户\"); } @Override public void delete() { System.out.println(\"删除用户\"); } @Override public void update() { System.out.println(\"更新用户\"); } @Override public void search() { System.out.println(\"查询用户\"); } } 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强 public class Log implements MethodBeforeAdvice { //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //Object : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println( o.getClass().getName() + \"的\" + method.getName() + \"方法被执行了\"); } } public class AfterLog implements AfterReturningAdvice { //returnValue 返回值 //method被调用的方法 //args 被调用的方法的对象的参数 //target 被调用的目标对象 @Override public void afterReturning(Object returnValue, Method method, Object[] args,Object target) throws Throwable { System.out.println(\"执行了\" + target.getClass().getName() +\"的\"+method.getName()+\"方法,\" +\"返回值：\"+returnValue); } } 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 . &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--注册bean--&gt; &lt;bean id=\"userService\" class=\"com.kuang.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"com.kuang.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"com.kuang.log.AfterLog\"/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--切入点 expression:表达式匹配要执行的方法--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/&gt; &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 测试 public class MyTest { @Test public void test(){ ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\"); UserService userService = (UserService) context.getBean(\"userService\"); userService.search(); } } Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 . Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . 第二种方式 自定义类来实现Aop目标业务类不变依旧是userServiceImpl 第一步 : 写我们自己的一个切入类 public class DiyPointcut { public void before(){ System.out.println(\"---------方法执行前---------\"); } public void after(){ System.out.println(\"---------方法执行后---------\"); } } 去spring中配置 &lt;!--第二种方式自定义实现--&gt; &lt;!--注册bean--&gt; &lt;bean id=\"diy\" class=\"com.kuang.config.DiyPointcut\"/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--第二种方式：使用AOP的标签实现--&gt; &lt;aop:aspect ref=\"diy\"&gt; &lt;aop:pointcut id=\"diyPonitcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/&gt; &lt;aop:before pointcut-ref=\"diyPonitcut\" method=\"before\"/&gt; &lt;aop:after pointcut-ref=\"diyPonitcut\" method=\"after\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试： public class MyTest { @Test public void test(){ ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\"); UserService userService = (UserService) context.getBean(\"userService\"); userService.add(); } } 第三种方式 使用注解实现第一步：编写一个注解实现的增强类 package com.kuang.config; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; @Aspect public class AnnotationPointcut { @Before(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void before(){ System.out.println(\"---------方法执行前---------\"); } @After(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void after(){ System.out.println(\"---------方法执行后---------\"); } @Around(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(\"环绕前\"); //获取方法名 System.out.println(\"签名:\"+jp.getSignature()); //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(\"环绕后\"); System.out.println(proceed); } @AfterThrowing(value = \"execution(* com.xu.Service.*.*(..))\", throwing = \"exception\") public void afterThrowing(JoinPoint joinPoint, Exception exception){ //获取方法名 String name = joinPoint.getSignature().getName(); System.out.println(name+\"方法抛出异常：\"+exception); } @AfterReturning(value = \"execution(* com.xu.Service.*.*(..))\",returning = \"result\") public void afterReturning(JoinPoint joinPoint,Object result) { //获取方法名 String name = joinPoint.getSignature().getName(); System.out.println(name+\"方法的结果是\"+result); } } 第二步：在Spring配置文件中，注册bean，并增加支持注解的配置 &lt;!--第三种方式:注解实现--&gt; &lt;bean id=\"annotationPointcut\" class=\"com.kuang.config.AnnotationPointcut\"/&gt; &lt;!-- 开启注解支持，自动代理 --&gt; &lt;aop:aspectj-autoproxy/&gt; aop:aspectj-autoproxy：说明 通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 &lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy poxy-target-class=\"true\"/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 整合MyBatis步骤1、导入相关jar包 junit &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; mybatis &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; mysql-connector-java &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; spring相关 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; aspectJ AOP 织入器 &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; mybatis-spring整合包 【重点】 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; 配置Maven静态资源过滤问题！ &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 2、编写配置文件 3、代码实现 回忆MyBatis编写pojo实体类 package com.kuang.pojo; public class User { private int id; //id private String name; //姓名 private String pwd; //密码 } 实现mybatis的配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.kuang.pojo\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=\"com.kuang.dao\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; UserDao接口编写 public interface UserMapper { public List&lt;User&gt; selectUser(); } 接口对应的Mapper映射文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.kuang.dao.UserMapper\"&gt; &lt;select id=\"selectUser\" resultType=\"User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 测试类 @Test public void selectUser() throws IOException { String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.selectUser(); for (User user: userList){ System.out.println(user); } sqlSession.close(); } MyBatis-Spring学习什么是 MyBatis-Spring？ MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。 知识基础 在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要 MyBatis-Spring 需要以下版本： MyBatis-Spring MyBatis Spring 框架 Spring Batch Java 2.0 3.5+ 5.0+ 4.0+ Java 8+ 1.3 3.4+ 3.2.2+ 2.1+ Java 6+ 如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可： &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; 要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。 DataSource 的 bean 配置 &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"admin\"/&gt; &lt;/bean&gt; 在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中： &lt;!--配置 sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!-- 绑定Mybatis配置文件--&gt; &lt;property name=\"configLocation\" value=\"Mybatis.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/xu/Mapper/UserMapper.xml\"/&gt; &lt;!-- mybatis的配置文件可以全部在这里配置，mybatis的配置文件可以不写，但是一般留着mybatis配置文件来配置别名和设置（&lt; settings&gt; 和 &lt; typeAliases&gt;元素）--&gt; &lt;/bean&gt; 注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。 在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。 在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。 SqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。 一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt; settings&gt; 或 &lt; typeAliases&gt;元素。 需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（），数据源（）和 MyBatis 的事务管理器（）都会被忽略，Spring 的配置文件里会用 bean 配好。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。 SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。 模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。 可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。 &lt;!-- sqlSession 的 bean--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; 现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样： public class UserDaoImpl implements UserDao { private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) { this.sqlSession = sqlSession; } public User getUser(String userId) { return sqlSession.getMapper...; } } 按下面这样，注入 SqlSessionTemplate： &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\" /&gt; &lt;/bean&gt; 整合实现一1、引入Spring配置文件beans.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; 2、配置数据源替换mybaits的数据源 &lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt; &lt;bean id=\"dataSource\"class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/bean&gt; 3、配置SqlSessionFactory，关联MyBatis &lt;!--配置SqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--关联Mybatis--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/kuang/dao/*.xml\"/&gt; &lt;/bean&gt; 4、注册sqlSessionTemplate，关联sqlSessionFactory； &lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!--利用构造器注入--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; 5、增加Dao接口的实现类；私有化sqlSessionTemplate public class UserDaoImpl implements UserMapper { //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } public List&lt;User&gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); } } 6、注册bean实现 &lt;bean id=\"userDao\" class=\"com.kuang.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt; &lt;/bean&gt; 7、测试 @Test public void test2(){ ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\"); UserMapper mapper = (UserMapper) context.getBean(\"userDao\"); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user); } 结果成功输出！现在我们的Mybatis配置文件的内容一般就剩下 和！ &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.kuang.pojo\"/&gt; &lt;/typeAliases&gt; &lt;!-- 还有settings 设置--&gt; &lt;/configuration&gt; 整合实现二**mybatis-spring1.2.3版以上的才有这个 ** dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看 测试： 1、将我们上面写的UserDaoImpl修改一下 public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper { public List&lt;User&gt; selectUser() { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.selectUser(); } } 2、修改bean的配置 &lt;bean id=\"userDao\" class=\"com.kuang.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; 3、测试 @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); // 这里注意不是bean的类型，而是mapper接口的类型 UserMapper mapper = (UserMapper) context.getBean(\"userDao\"); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user); } ==注意：上面获取的bean的类型是mapper接口的类型== 总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！ 声明式事务 回顾事务 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。 事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。 事务四个属性ACID 原子性（atomicity） 事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（consistency） 一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 隔离性（isolation） 可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏 持久性（durability） 事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中 测试 将上面的代码拷贝到一个新项目中 在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户； //添加一个用户 int addUser(User user); //根据id删除用户 int deleteUser(int id); mapper文件，我们故意把 deletes 写错，测试！ &lt;insert id=\"addUser\" parameterType=\"com.kuang.pojo.User\"&gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) &lt;/insert&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; deletes from user where id = #{id} &lt;/delete&gt; 编写接口的实现类，在实现类中，我们去操作一波 public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper { //一个函数包含多个事务 public List&lt;User&gt; selectUser() { User user = new User(4,\"小明\",\"123456\"); UserMapper mapper = getSqlSession().getMapper(UserMapper.class); //增加一些操作 mapper.addUser(user); mapper.deleteUser(4); return mapper.selectUser(); } //新增 public int addUser(User user) { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.addUser(user); } //删除 public int deleteUser(int id) { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.deleteUser(id); } } 测试 @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserMapper mapper = (UserMapper) context.getBean(\"userDao\"); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user); } 报错：sql异常，delete写错了 结果 ：插入成功！ 没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要事务！ 以前我们都需要自己手动管理事务，十分麻烦！但是Spring给我们提供了事务管理，我们只需要配置即可； Spring中的事务管理 Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。 编程式事务管理 将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 声明式事务管理 一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。 使用Spring管理事务，注意头文件的约束导入 : tx xmlns:tx=\"http://www.springframework.org/schema/tx\" http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; 事务管理器 无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。 JDBC事务 &lt;bean id=\"transactionManager\"class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; 配置好事务管理器后我们需要去配置事务的通知 &lt;!--配置事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"search*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"get\" read-only=\"true\"/&gt; &lt;!--配置所有方法--&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; spring事务传播特性： 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为： propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。 假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。 就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！ 配置AOP 导入aop的头文件！ &lt;!--配置aop织入事务--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.kuang.dao.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/&gt; &lt;/aop:config&gt; 进行测试 删掉刚才插入的数据，再次测试！ @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserMapper mapper = (UserMapper) context.getBean(\"userDao\"); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user); } 思考问题？ 为什么需要配置事务？ 如果不配置，就需要我们手动提交控制事务； 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Vue:概述","slug":"Vue","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:31:53.400Z","comments":true,"path":"posts/ea4e982k.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e982k.html","excerpt":"","text":"1、Vue:概述Vue 是一套用于构建用户界面的渐进式JavaScript框架，开发商：尤雨溪，发布于 2014 年 2 月。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库（如：vue-router：跳转，vue-resource：通信，vuex：管理）或既有项目整合。 官网：https://cn.vuejs.org/v2/guide/ 2、前端知识体系2.1、前端三要素 HTML（结构）：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容 CSS（表现）：层叠样式表（Cascading Style Sheets），设定网页的表现样式 JavaScript（行为）：是一种弱类型脚本语言，其源代码不需要经过编译，而是由浏览器解释运行，用于控制网页的行为 2.2、结构层(HTML)2.3、表现层(CSS)CSS层叠样式表是一门标记语言，并不是编程语言，因此不可以自定义变量，不可以引用等，换句话说就是不具备任何语法支持，它主要缺陷如下: 语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器; 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护; 这就导致了我们在工作中无端增加了许多工作量。为了解决这个问题，前端开发人员会使用一种称之为 [ CSS 预处理器] 的工具，提供CSS缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了前端在样式.上的开发效率。 什么是CSS预处理器CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编码工作。转化成通俗易懂的话来说就是“用一种专门的编程语言，进行Web页面样式设计，再通过编译器转化为正常的CSS文件,以供项目使用”。 常用的 CSS 预处理器有 SASS：基于Ruby，通过服务端处理，功能强大。解析效率稿。需要学习 Ruby 语言，上手难度高于LESS。 LESS：基于 Node.JS，通过客户端处理，使用简单。功能比 SASS 简单，解析效率也低于 SASS，但在实际开发中足够了，所以后台人员如果需要的话，建议使用 LESS。 2.4、行为层（JavaScript）JavaScript一门弱类型脚本语言，其源代码在发往客户端运行之前不需经过编译，而是将文本格 式的字符代码发送给浏览器由浏览器解释运行。 Native原生JS开发 原生JS开发，也就是让我们按照【ECMAScript】标准的开发方式，简称是ES,特点是所有浏览器都支持。截止到当前博客发布时间，ES标准已发布如下版本: ES3 ES4 (内部,未正式发布) ES5 (全浏览器支持) ES6 (常用，当前主流版本: webpack打包成为ES5支持! ) ES7 ES8 ES9 (草案阶段) 区别就是逐步增加新特性。 TypeScript微软的标准 TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。由安德斯海尔斯伯格（C#、Delphi、TypeScript 之父； .NET 创立者）主导。 该语言的特点就是除了具备 ES 的特性之外还纳入了许多不在标准范围内的新特性，所以会导致很多浏览器不能直接支持 TypeScript 语法，需要编译后（编译成 JS ）才能被浏览器正确执行。 JavaScript 框架 jQuery：大家熟知的 JavaScript 框架，优点是简化了DOM操作，缺点是DOM操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容 IE6、7、8; Angular：Google 收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念，与微软合作，采用 TypeScript 语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如: 1代 -&gt; 2代，除了名字，基本就是两个东西) React：Facebook 出品，一款高性能的 JS 前端框架；特点是提出了新概念【虚拟DOM】用于减少真实 DOM 操作，在内存中模拟 DOM 操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一门【JSX】 语言； Vue：一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了 Angular（模块化）和 React（虚拟DOM）的优点; Axios：前端通信框架；因为 Vue 的边界很明确，就是为了处理 DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用 jQuery 提供的 AJAX 通信功能; UI框架 Ant-Design：阿里巴巴出品，基于 React 的 UI 框架 ElementUI、iview、 ice：饿了么出品，基于 Vue 的 UI 框架 Bootstrap：Twitter 推出的一个用于前端开发的开源工具包 AmazeUI：又叫“妹子 UI”，一款HTML5跨屏前端框架 JavaScript 构建工具 Babel：JS 编译工具，主要用于浏览器不支持的ES新特性，比如用于编译 TypeScript WebPack：模块打包器，主要作用是打包、压缩、合并及按序加载 注:以上知识点已将WebApp开发所需技能全部梳理完毕 2.5、三端统一2.5.1、混合开发（Hybrid App）主要目的是实现一套代码三端统一（PC、Android：.apk、iOS：.ipa）并能够调用到设备底层硬件（如：传感器、GPS、摄像头等），打包方式主要有以下两种： 云打包：HBuild -&gt; HBuildX，DCloud 出品；API Cloud 本地打包：Cordova（前身是 PhoneGap） 2.5.2、微信小程序详见微信官网，这里介绍一个方便微信小程序 UI 开发的框架：WeUI 2.6、后端技术前端人员为了方便开发也需要掌握一定的后端技术，但我们 Java 后台人员知道后台知识体系极其庞大复杂,所以为了方便前端人员开发后台应用，就出现了 NodeJS 这样的技术。 NodeJS的作者已经声称放弃 NodeJS （说是架构做的不好再加上笨重的 node_ modules，可能让作者不爽了吧） , 开始开发全新架构的 Deno 既然是后台技术，那肯定也需要框架和项目管理工具，NodeJS 框架及项目管理工具如下： Express：NodeJS 框架 Koa：Express 简化版 NPM：项目综合管理工具，类似于 Maven YARM：NPM 的替代方案，类似于 Maven 和 Gradle 的关系 2.7、主流前端框架Vue.js 2.7.1、iViewiview 是一个强大的基于 Vue 的 UI 库，有很多实用的基础组件比 elementui 的组件更丰富，主要服务于 PC 界面的中后台产品。使用单文件的 Vue 组件化开发模式基于 npm + webpack + babel 开发，支持 ES2015 高质量、功能丰富友好的 API，自由灵活地使用空间。 官网地址 Github iview-admin 备注：属于前端主流框架，选型时可以考虑使用，主要特点是移动端支持较多 2.7.2、 ElementUIElement 是饿了么前端开源维护的 Vue UI 组件库，组件齐全，基本涵盖后台所需的所有组件，文档讲解详细，例子也很丰富。主要用于开发 PC 端的页面，是一个质量比较高的 Vue UI 组件库。 官网地址 Github vue-element-admin 备注：属于前端主流框架，选型时可以考虑使用，主要特点是桌面端支持较多 2.7.3、 ICE飞冰 是阿里巴巴团队基于 React/Angular/Vue 的中后台应用解决方案，在阿里巴巴内部，已经有270多个来自几乎所有 BU 的项目在使用。飞冰包含了一条从设计端到开发端的完整链路，帮助用户快速搭建属于自己的中后台应用。 官网地址 Github 备注:主要组件还是以 React 为主，截止 2019 年 02 月 17 日更新博客前对 Vue 的支持还不太完善，目前尚处于观望阶段 2.7.4、VantUIVant UI 是有赞前端团队基于有赞统一的规范实现的 Vue 组件库,提供了一整套 UI 基础组件和业务组件。通过 Vant，可以快速搭建出风格统一的页面， 提升开发效率。 官网地址 Github 2.7.5、 AtUIat-ui是一款基于 Vue 2.x 的前端UI组件库,主要用于快速开发PC网站产品。它提供了一套 npm + webpack + babel 前端开发工作流程，CSS 样式独立，即使采用不同的框架实现都能保持统一的UI风格。 官网地址 Github 2.7.6、 CubeUIcube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库。支持按需引入和后编译，轻量灵活；扩展性强，可以方便地基于现有组件实现二次开发。 官网地址 Github 混合开发Flutter Flutter是谷歌的移动端UI框架，可在极短的时间内构建Android 和iOs.上高质量的原生级应用。Flutter 可与现有代码一起工作,它被世界各地的开发者和组织使用,并且Flutter是免费和开源的。 官网地址 Github 备注: Google出品，主要特点是快速构建原生APP应用程序，如做混合应用该框架为必选框架 lonic lonic 既是一个 CSS 框架也是一个 Javascript UI 库，lonic 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它提供了很多 UI 组件来帮助开发者开发强大的应用。它使用 JavaScript MVVM框架和 AngularJS/Vue 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。 官网地址 官网文档 Github 微信小程序mpvue mpvue 是美团开发的一个使用 Vue.js 开发小程序的前端框架，目前支持微信小程序、百度智能小程序，头条小程序和支付宝小程序。框架基于 Vue.js ，修改了的运行时框架 runt ime 和代码编译器 compiler 实现，使其可运行在小程序环境中，从而为小程序开发引入了 Vue.js 开发体验。 官网地址 Github 备注:完备的Vue开发体验，并且支持多平台的小程序开发，推荐使用 WeUl WeUI 是一套同微信原生视觉体验一致的基础样式库， 由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含 button、cell、 dialog、toast、article、 icon 等各式元素。 官网地址 Github 3、了解前后端分离的演变史3.1、后端为主的 MVC 时代为了降低开发的复杂度，以后端为出发点,比如：Struts、 SpringMVC 等框架的使用，就是后端的MVC时代； 以 Spring MVC 的流程为例： 发起请求到前端控制器( DispatcherServlet ) 前端控制器请求 HandlerMapping 查找 Handler, 可以根据 xml 配置、注解进行查找 处理器映射器 HandlerMapping 向前端控制器返回 Handler 前端控制器调用处理器适配器去执行Handler 处理器适配器去执行 Handler Handler 执行完成给适配器返回 ModelAndView 处理器适配器向前端控制器返回 ModelAndView ，Mode lAndView 是 SpringMVC 框架的一个底层对象，包括 Model 和 View 前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图( JSP ) 视图解析器向前端控制器返回 View 前端控制器进行视图渲染，视图渲染将模型数据（在 ModelAndView 对象中）填充到 request 域 前端控制器向用户响应结果 优点： MVC是一个非常好的协作模式，能够有效降低代码的耦合度,从架构上能够让开发者明白代码应该写在哪里。为了让View更纯粹,还可以使用Thymeleaf、Freemarker 等模板引擎，使模板里无法写入Java代码,让前后端分工更加清晰。 缺点： 前端开发重度依赖开发环境，开发效率低，这种架构下，前后端协作有两种模式： 第一种是前端写 DEMO，写好后，让后端去套模板。好处是 DEMO 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大； 另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。 前后端职责纠缠不清：模板弓|擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 Controller ，页面路由等功能本应该是前端最关注的，但却是由后端来实现。Controller 本身与 Model 往往也会纠缠不清，看了让人咬牙的业务代码经常会出现在 Controller 层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。 对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作，但由于后端框架限制，我们很难使用【Comet】 、【BigPipe】 等技术方案来优化性能。 注：在这期间（2005 年以前），包括早期的 JSP、PHP 可以称之为 Web 1.0 时代。因为时代在变、技术在变、什么都在变（引用扎克伯格的一句话：唯一不变的是变化本身）；一些陈旧的技术对于市场来说早就过时了，比如 JSP。 3.2、基于 AJAX 带来的 SPA 时代时间回到 2005 年 AJAX （Asynchronous JavaScript And XM，异步JavaScript和XML,老技术新用法）被正式提出并开始使用 CDN 作为静态资源存储，于是出现了JavaScript王者归来（在这之前 JS 都是用来在网页上贴狗皮膏药广告的）的 SPA （Single Page Application）单页面应用时代。 优点 这种模式下，前后端的分工非常清晰，前后端的关键协作点是AJAX接口。看起来是如此美妙,但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，这个时代开始出现浏览器端的分层架构： 缺点 前后端接口的约定：如果后端的接口一塌糊涂,如果后端的业务模型不够稳定,那么前端开发会很痛苦；不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。 前端开发的复杂度控制：SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。 3.3、前端为主的 MV* 时代此处的 MV* 模式如下： MVC （同步通信为主）：Model、View、Controller MVP （异步通信为主）： Model、 View、 Presenter MVVM （异步通信为主）：Model、 View、 ViewModel 为了降低前端开发复杂度，涌现了大量的前端框架，比如：AngularJS、 React、 Vue.js 、EmberJS等，这些框架总的原则是先按类型分层,比如 Templates、Controllers、 Models, 然后再在层内做切分，如下图： 优点 前后端职责很清晰：前端工作在浏览器端，后端工作在服务器端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。 前端开发的复杂度可控：前端代码很重，但合理分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计都有很大学问，得花一本书的厚度去说明。 部署相对独立：可以快速改进产品的体验。 缺点 代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。 全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。 性能并非最佳，特别是移动互联网环境下。 SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌握。 3.4、Node.JS 代理的全栈时代前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 Node.JS 的兴起， JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式： 在这种研发模式下，前后端的职责很清晰。对前端来说，两个UI层各司其职： Front-End UI Layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层,具体看应用场景。 Back-End UI Layer 处理路由、模板、数据获取、Cookie 等。通过路由,前端终于可以自主把控URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。 通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要SEO的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。 与JSP模式相比,全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归,不过是一种螺旋上升式的回归。 基于NodeJS的全栈模式，依旧面临很多挑战: 需要前端对服务端编程有更进一步的认识。比如 TCP/IP 等网络知识的掌握。 NodeJS 层与 Java 层的高效通信。NodeJS 模式下，都在服务器端，RESTful HTTP 通信未必高效,通过 SOAP 等方式通信更高效。一切需要在验证中前行。 对部署、运维层面的熟练了解，需要更多知识点和实操经验。 大量历史遗留问题如何过渡。这可能是最大最大的阻力。 注：为什么说:” 前端想学后台很难，而我们后端程序员学任何东西都很简单“；就是因为后端程序员具备相对完善的知识体系。 3.5、总结综上所述，模式也好，技术也罢，没有好坏优劣之分，只有适合不适合；前后分离的开发思想主要是基于 SoC（关注度分离原则），上面种种模式，都是让前后端的职责更清晰，分工更合理高效。 4、Vue：MVVM模式和第一个Vue程序 什么是 MVVM MVVM（Model-View-ViewModel）是一种软件架构设计模式，由微软 WPF（用于替代 WinForm，以前就是用这个技术开发桌面应用程序的）和 Silverlight（类似于 Java Applet，简单点说就是在浏览器上运行的 WPF） 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于 2005 年在他的博客上发表。 MVVM 源自于经典的 MVC（Model-View-Controller）模式。MVVM 的核心是 ViewModel 层，负责转换 Model 中的数据对象来让数据变得更容易管理和使用，其作用如下： 该层向上与视图层进行双向数据绑定 向下与 Model 层通过接口请求进行数据交互 MVVM 已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。当下流行的 MVVM 框架有 Vue.js，AngularJS 等。 为什么要使用 MVVMMVVM 模式和 MVC 模式一样，主要目的是分离视图（View）和模型（Model），有几大好处 低耦合： 视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。 可复用： 你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。 独立开发： 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试： 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。 MVVM 的组成部分 ViewView 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建，为了更方便地展现 ViewModel 或者 Model 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Thymeleaf 等等，各大 MVVM 框架如 Vue.js，AngularJS，EJS 等也都有自己用来构建用户界面的内置模板语言。 ModelModel 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的接口规则 ViewModelViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。 需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的 比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示） 页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互） 视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图。 MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现事件驱动编程。 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。 VueVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架，发布于 2014 年 2 月。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库（如：vue-router，vue-resource，vuex）或既有项目整合。 MVVM 模式的实现者 Model：模型层，在这里表示 JavaScript 对象 View：视图层，在这里表示 DOM（HTML 操作的元素） ViewModel：连接视图和数据的中间件，Vue.js 就是 MVVM 中的 ViewModel 层的实现者 在 MVVM 架构中，是不允许 数据 和 视图 直接通信的，只能通过 ViewModel 来通信，而 ViewModel 就是定义了一个 Observer 观察者 ViewModel 能够观察到数据的变化，并对视图对应的内容进行更新 ViewModel 能够监听到视图的变化，并能够通知数据发生改变 至此，我们就明白了，Vue.js 就是一个 MVVM 的实现者，他的核心就是实现了 DOM 监听 与 数据绑定 为什么要使用 Vue.js 轻量级，体积小是一个重要指标。Vue.js 压缩后有只有 20多kb （Angular 压缩后 56kb+，React 压缩后 44kb+） 移动优先。更适合移动端，比如移动端的 Touch 事件 易上手，学习曲线平稳，文档齐全 吸取了 Angular（模块化）和 React（虚拟 DOM）的长处，并拥有自己独特的功能，如：计算属性 开源，社区活跃度高 …… 第一个Vue程序【说明】IDEA 可以安装 Vue 的插件！ 注意：Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。 下载地址 开发版本 包含完整的警告和调试模式：https://vuejs.org/js/vue.js 删除了警告，30.96KB min + gzip：https://vuejs.org/js/vue.min.js CDN 代码编写 Vue.js 的核心是实现了 MVVM 模式，她扮演的角色就是 ViewModel 层，那么所谓的第一个应用程序就是展示她的 数据绑定 功能，操作流程如下： 1、创建一个 HTML 文件 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 2、引入 Vue.js &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt; 3、创建一个 Vue 的实例 &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { message: 'Hello Vue!' } }); &lt;/script&gt; 说明: el:'#vue'：绑定元素的 ID data:{message:'Hello Vue!'}：数据对象中有一个名为 message 的属性，并设置了初始值 Hello Vue! 4、将数据绑定到页面元素 &lt;div id=\"vue\"&gt; {{message}} &lt;/div&gt; 说明：只需要在绑定的元素中使用 双花括号 将 Vue 创建的名为 message 属性包裹起来，即可实现数据绑定功能，也就实现了 ViewModel 层所需的效果，是不是和 EL 表达式非常像？ 完整的 HTML &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;第一个 Vue 应用程序&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--View--&gt; &lt;div id=\"vue\"&gt; {{message}} &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; // var vm = new Vue({}); //ViewModel var vm = new Vue({ el: '#vue', data: { //Model message: 'Hello Vue!' } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 测试 为了能够更直观的体验 Vue 带来的数据绑定功能，我们需要在浏览器测试一番，操作流程如下： 1、在浏览器上运行第一个 Vue 应用程序，进入 开发者工具 2、在控制台输入 vm.message = ‘Hello World’ ，然后 回车，你会发现浏览器中显示的内容会直接变成 Hello World 此时就可以在控制台直接输入 vm.message 来修改值，中间是可以省略 data 的，在这个操作中，我并没有主动操作 DOM，就让页面的内容发生了变化，这就是借助了 Vue 的 数据绑定 功能实现的；MVVM 模式中要求 ViewModel 层就是使用 观察者模式 来实现数据的监听与绑定，以做到数据与视图的快速响应。 5、Vue：基础语法v-bind我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们在控制台操作对象属性，界面可以实时更新！ 我们还可以使用v-bind来绑定元素特性! 上代码： &lt;!DOCTYPE html&gt; &lt;html xmlns:v-bind=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说Java&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;span v-bind:title=\"message\"&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#app', data: { message: '页面加载于 ' + new Date().toLocaleString() } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 你看到的 v-bind 等被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊特性。可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致”。 如果你再次打开浏览器的 JavaScript 控制台，输入 vm.message = ‘新消息’，就会再一次看到这个绑定了 title 特性的 HTML 已经进行了更新。 v-if,v-else什么是条件判断语句，就不需要我说明了吧（￣▽￣）,以下两个属性！ v-if v-else 上代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说Java&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"vue\"&gt; &lt;h1 v-if=\"ok\"&gt;YES&lt;/h1&gt; &lt;h1 v-else&gt;NO&lt;/h1&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { ok: true } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 测试： 在浏览器上运行，打开控制台！ 在控制台输入 vm.ok = false ，然后 回车，你会发现浏览器中显示的内容会直接变成 NO 注：使用 v-* 属性绑定数据是不需要 双花括号 包裹的 v-else-if v-if v-else-if v-else 注：=== 三个等号在 JS 中表示绝对等于（就是数据与类型都要相等） 上代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说Java&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"vue\"&gt; &lt;h1 v-if=\"type === 'A'\"&gt;A&lt;/h1&gt; &lt;h1 v-else-if=\"type === 'B'\"&gt;B&lt;/h1&gt; &lt;h1 v-else-if=\"type === 'C'\"&gt;C&lt;/h1&gt; &lt;h1 v-else&gt;who&lt;/h1&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { type: 'A' } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 测试：观察在控制台输入 vm.type = ‘B’、’C’、’D’ 的变化 v-for格式说明： &lt;div id=\"vue\"&gt; &lt;li v-for=\"item in items\"&gt; {{ item.message }} &lt;/li&gt; &lt;/div&gt; 注：items 是数组，item是数组元素迭代的别名。我们之后学习的Thymeleaf模板引擎的语法和这个十分的相似！ 上代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说Java&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"vue\"&gt; &lt;li v-for=\"item in items\"&gt; {{ item.message }} &lt;/li&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { //items数组，items在这里只是代号作用，可以改为其他代名词 items: [ {message: '狂神说Java'}, {message: '狂神说前端'} ] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 测试 ：在控制台输入 vm.items.push({message: '狂神说运维'}) ，尝试追加一条数据，你会发现浏览器中显示的内容会增加一条 狂神说运维. v-onv-on 监听事件 事件有Vue的事件、和前端页面本身的一些事件！我们这里的click是vue的事件，可以绑定到Vue中的methods中的方法事件！ 上代码： &lt;!DOCTYPE html&gt; &lt;html xmlns:v-on=\"\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说Java&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"vue\"&gt; &lt;!--在这里我们使用了 v-on 绑定了 click 事件，并指定了名为 sayHi 的方法--&gt; &lt;button v-on:click=\"sayHi\"&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { message: 'Hello World' }, // 方法必须定义在 Vue 实例的 methods 对象中 methods: { sayHi: function (event) { // `this` 在方法里指向当前 Vue 实例 alert(this.message); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 6、Vue：表单双绑、组件 什么是双向数据绑定 Vue.js 是一个 MVVM 框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是 Vue.js 的精髓之处了。 值得注意的是，我们所说的数据双向绑定，一定是对于 UI 控件来说的，非 UI 控件不会涉及到数据双向绑定。单向数据绑定是使用状态管理工具的前提。如果我们使用 vuex，那么数据流也是单项的，这时就会和双向数据绑定有冲突。 为什么要实现数据的双向绑定 在 Vue.js 中，如果使用 vuex，实际上数据还是单向的，之所以说是数据双向绑定，这是用的 UI 控件来说，对于我们处理表单，Vue.js 的双向数据绑定用起来就特别舒服了。即两者并不互斥，在全局性数据流使用单项，方便跟踪；局部性数据流使用双向，简单易操作。 在表单中使用双向数据绑定你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 注意：v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值! 单行文本&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说Java&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--我们这里希望，输入框的值和{}取值动态绑定，实时相同，我们就使用v-model绑定message--&gt; &lt;div id=\"vue\"&gt; 单行文本：&lt;input type=\"text\" v-model=\"message\" value=\"hello\" /&gt;&amp;nbsp;&amp;nbsp;单行文本是：{{message}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { message: \"Hello Vue\" } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 多行文本&lt;div id=\"vue\"&gt; 多行文本：&lt;textarea v-model=\"message\"&gt;&lt;/textarea&gt;&amp;nbsp;&amp;nbsp;多行文本是：{{message}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { message: \"Hello Textarea\" } }); &lt;/script&gt; 单复选框&lt;div id=\"vue\"&gt; 单复选框： &lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt; &amp;nbsp;&amp;nbsp; &lt;label for=\"checkbox\"&gt;{{ checked }}&lt;/label&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { checked: false } }); &lt;/script&gt; 多复选框&lt;div id=\"vue\"&gt; 多复选框： &lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt; &lt;label for=\"jack\"&gt;Jack&lt;/label&gt; &lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt; &lt;label for=\"john\"&gt;John&lt;/label&gt; &lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt; &lt;label for=\"mike\"&gt;Mike&lt;/label&gt; &lt;span&gt;选中的值: {{ checkedNames }}&lt;/span&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { checkedNames: [] } }); &lt;/script&gt; 单选按钮&lt;div id=\"vue\"&gt; 单选按钮： &lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt; &lt;label for=\"one\"&gt;One&lt;/label&gt; &lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt; &lt;label for=\"two\"&gt;Two&lt;/label&gt; &lt;span&gt;选中的值: {{ picked }}&lt;/span&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { picked: '' } }); &lt;/script&gt; 下拉框&lt;div id=\"vue\"&gt; 下拉框： &lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;!-- &lt;option selected &gt;B&lt;/option&gt; 如果要生效，就得将date里的selected数据改为‘B’ --&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;选中的值: {{ selected }}&lt;/span&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { selected: '' } }); &lt;/script&gt; 注意：如果 v-model 表达式的初始值未能匹配任何选项， 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。 什么是组件组件是可复用的 Vue 实例，说白了就是一组可以重复使用的模板，跟 JSTL 的自定义标签、Thymeleaf 的 th:fragment 等框架有着异曲同工之妙。通常一个应用会以一棵嵌套的组件树的形式来组织： 例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。 第一个 Vue 组件注意：在实际开发中，我们并不会用以下方式开发组件，而是采用 vue-cli 创建 .vue 模板文件的方式开发，以下方法只是为了让大家理解什么是组件。 使用 Vue.component() 方法注册组件,格式如下： &lt;script type=\"text/javascript\"&gt; // 先注册组件，组件名不能有大写 Vue.component('my-component-li', { template: '&lt;li&gt;Hello li&lt;/li&gt;' }); // 再实例化 Vue var vm = new Vue({ el: '#vue' }); &lt;/script&gt; &lt;div id=\"vue\"&gt; &lt;ul&gt; &lt;my-component-li&gt;&lt;/my-component-li&gt; &lt;/ul&gt; &lt;/div&gt; 说明： Vue.component()：注册组件 my-component-li：自定义组件的名字 template：组件的模板 使用 props 属性传递参数像上面那样用组件没有任何意义，所以我们是需要传递参数到组件的，此时就需要使用 props 属性了！ 注意：默认规则下组件名 和 props 属性里的值不能为大写； &lt;script type=\"text/javascript\"&gt; // 先注册组件 Vue.component('my-component-li', { props: ['list'], template: '&lt;li&gt;Hello {{list}}&lt;/li&gt;' }); // 再实例化 Vue var vm = new Vue({ el: '#vue', data: { items: [\"张三\", \"李四\", \"王五\"] } }); &lt;/script&gt; &lt;div id=\"vue\"&gt; &lt;ul&gt; &lt;my-component-li v-for=\"item in items\" v-bind:list=\"item\"&gt;&lt;/my-component-li&gt; &lt;/ul&gt; &lt;/div&gt; 说明： v-for=\"item in items\"：遍历 Vue 实例中定义的名为 items 的数组，并创建同等数量的组件 v-bind:list=“item“：将遍历的 item 项绑定到组件中 props 定义的名为 list 属性上；= 号左边的 list 为 props 定义的属性名，右边的为 item in items 中遍历的 item 项的值 7、什么是Axios Axios是一个开源的可以用在浏览器端和Node JS的异步通信框架， 她的主要作用就是实现AJAX异步通信，其功能特点如下： 从浏览器中创建XMLHttpRequests 从node.js创建http请求 支持Promise API[JS中链式编程] 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF(跨站请求伪造) GitHub：https://github.com/axios/axios 中文文档：http://www.axios-js.com/ 为什么要使用Axios 由于Vue.js是一个视图层框架并且作者(尤雨溪) 严格准守SoC(关注度分离原则)所以Vue.js并不包含AJAX的通信功能， 为了解决通信问题， 作者单独开发了一个名为vue-resource的插件， 不过在进入2.0版本以后停止了对该插件的维护并推荐了Axios框架。少用jQuery， 因为它操作Dom太频繁! 第一个Axios应用程序 咱们开发的接口大部分都是采用JSON格式， 可以先在项目里模拟一段JSON数据， 数据内容如下：创建一个名为data.json的文件并填入上面的内容， 放在项目的根目录下 { \"name\": \"狂神说Java\", \"url\": \"https://blog.kuangstudy.com\", \"page\": 1, \"isNonProfit\": true, \"address\": { \"street\": \"含光门\", \"city\": \"陕西西安\", \"country\": \"中国\" }, \"links\": [ { \"name\": \"bilibili\", \"url\": \"https://space.bilibili.com/95256449\" }, { \"name\": \"狂神说Java\", \"url\": \"https://blog.kuangstudy.com\" }, { \"name\": \"百度\", \"url\": \"https://www.baidu.com/\" } ] } 测试代码 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:v-binf=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--v-cloak 解决闪烁问题--&gt; &lt;style&gt; [v-cloak]{ display: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"vue\"&gt; &lt;div&gt;地名：{{info.name}}&lt;/div&gt; &lt;div&gt;地址：{{info.address.country}}--{{info.address.city}}--{{info.address.street}}&lt;/div&gt; &lt;div&gt;链接：&lt;a v-bind:href=\"info.url\" target=\"_blank\"&gt;{{info.url}}&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--引入js文件--&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el:\"#vue\", //data：属性，下面这个是函数 data(){ return{ //这里info可以写为其他，这里只是一个引用变量的作用 info:{ name:null, address:{ country:null, city:null, street:null }, url:null } } }, mounted(){//钩子函数 axios .get('data.json')//这里是链接，看json文件位置 //这里response可以写为其他，这里只是一个引用变量的作用 .then(response=&gt;(this.info=response.data)); } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 说明： 在这里使用了v-bind将a:href的属性值与Vue实例中的数据进行绑定 使用axios框架的get方法请求AJAX并自动将数据封装进了Vue实例的数据对象中 我们在data中的数据结构必须和Ajax响应回来的数据格式匹配！ 8、Vue的生命周期 官方文档：https://cn.vuejs.org/v2/guide/instance.html #生命周期图示 Vue实例有一个完整的生命周期，也就是从开始创建初始化数据、编译模板、挂载DOM、渲染一更新一渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 在Vue的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册JS方法，可以让我们用自己注册的JS方法控制整个大局，在这些事件响应方法中的this直接指向的是Vue的实例。 9、Vue：计算属性、内容分发、自定义事件计算属性计算属性的重点突出在 属性 两个字上（属性是名词），首先它是个 属性 其次这个属性有 计算 的能力（计算是动词），这里的 计算 就是个函数；简单点说，它就是一个能够将计算结果缓存起来的属性（将行为转化成了静态的属性），仅此而已；可以想象为缓存！ 上代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说Java&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"vue\"&gt; &lt;!--注意，一个是方法，一个是属性--&gt; &lt;p&gt;调用当前时间的方法：{{currentTime1()}}&lt;/p&gt; &lt;p&gt;当前时间的计算属性：{{currentTime2}}&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue({ el: '#vue', data: { message: 'Hello Vue' }, methods: { currentTime1: function () { return Date.now(); } }, computed: { //currentTime2 ，这是一个属性！不是方法 currentTime2: function () { this.message; return Date.now(); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意：methods 和 computed 里的东西不能重名 说明： methods：定义方法，调用方法使用 currentTime1()，需要带括号 computed：定义计算属性，调用属性使用 currentTime2，不需要带括号；this.message 是为了能够让 currentTime2 观察到数据变化而变化 如果在方法中的值发生了变化，则缓存就会刷新！如果在控制台使用 vm.message=\"qinjiang\",改变下数据的值，则缓存会被刷新，也就是 currentTime2 的值会刷新！ 结论： 调用方法时，每次都需要进行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢？此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这一点,计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销; 内容分发在 Vue.js 中我们使用 &lt;slot&gt; 元素作为承载分发内容的出口，作者称其为 插槽，可以应用在组合组件的场景中; 测试 比如准备制作一个待办事项组件（todo），该组件由待办标题（todo-title）和待办内容（todo-items）组成，但这三个组件又是相互独立的，该如何操作呢？ 第一步: 定义一个待办事项的组件 &lt;div id=\"vue\"&gt; &lt;todo&gt;&lt;/todo&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.component('todo', { template: '&lt;div&gt;\\ &lt;div&gt;待办事项&lt;/div&gt;\\ &lt;ul&gt;\\ &lt;li&gt;学习狂神说Java&lt;/li&gt;\\ &lt;/ul&gt;\\ &lt;/div&gt;' //这里得外加一个&lt;div&gt;包围，不然&lt;ul&gt;列表会显示不出来 }); &lt;/script&gt; 第二步: 我们需要让,待办事项的标题和值实现动态绑定,怎么做呢? 我们可以留出一个插槽! 1-将上面的代码留出一个插槽,即 slot Vue.component('todo', { template: '&lt;div&gt;\\ &lt;slot name=\"todo-title\"&gt;&lt;/slot&gt;\\ &lt;ul&gt;\\ &lt;slot name=\"todo-items\"&gt;&lt;/slot&gt;\\ &lt;/ul&gt;\\ &lt;/div&gt;' }); 2-定义一个名为 todo-title 的待办标题组件 和 todo-items 的待办内容组件 Vue.component('todo-title', { props: ['title'], template: '&lt;div&gt;{{title}}&lt;/div&gt;' }); //这里的index,就是数组的下标,使用for循环遍历的时候,可以循环出来! Vue.component('todo-items', { props: ['item', 'index'], template: '&lt;li&gt;{{index + 1}}. {{item}}&lt;/li&gt;' }); 3-实例化 Vue 并初始化数据 var vm = new Vue({ el: '#vue', data: { todoItems: ['狂神说Java', '狂神说运维', '狂神说前端'] } }); 4-将这些值,通过插槽插入 &lt;div id=\"vue\"&gt; &lt;todo&gt; &lt;todo-title slot=\"todo-title\" title=\"秦老师系列课程\"&gt;&lt;/todo-title&gt; &lt;todo-items slot=\"todo-items\" v-for=\"(item, index) in todoItems\" v-bind:item=\"item\" v-bind:index=\"index\" &gt;&lt;/todo-items&gt; &lt;/todo&gt; &lt;/div&gt; 说明:我们的 todo-title 和 todo-items 组件分别被分发到了 todo 组件的 todo-title 和 todo-items 插槽中 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:v-bind=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"../lib/vue.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"vue\"&gt; &lt;todo&gt; &lt;todo-title slot=\"title\" v-bind:header=\"head\"&gt;&lt;/todo-title&gt; &lt;todo-list slot=\"list\" v-for=\"(item, index) in items\" v-bind:list=\"item\" v-bind:ini=\"index\"&gt;&lt;/todo-list&gt; &lt;/todo&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.component(\"todo\",{ template: '&lt;div&gt;\\ &lt;slot name=\"title\"&gt;&lt;/slot&gt;\\ &lt;ul&gt;\\ &lt;slot name=\"list\"&gt;&lt;/slot&gt;\\ &lt;/ul&gt;\\ &lt;/div&gt;' //这里得外加一个&lt;div&gt;包围，不然&lt;ul&gt;列表会显示不出来 }); Vue.component(\"todo-title\",{ props:['header'], template: '&lt;p&gt;{{header}}&lt;/p&gt;' }); Vue.component('todo-list',{ props: ['list','ini'], template:'&lt;li&gt;{{list}}---{{ini+1}}&lt;/li&gt;' }); var vm = new Vue({ el: '#vue', data: { head:'秦老师教程', items:['java','linux','mysql'] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;/body&gt; &lt;/html&gt; 自定义事件通过以上代码不难发现，数据项在 Vue 的实例中，但删除操作要在组件中完成，那么组件如何才能删除 Vue 实例中的数据呢？此时就涉及到参数传递与事件分发了，Vue 为我们提供了自定义事件的功能很好的帮助我们解决了这个问题；使用 this.$emit(‘自定义事件名’, 参数)，操作过程如下: 1-在vue的实例中,增加了 methods 对象并定义了一个名为 removeTodoItems 的方法 var vm = new Vue({ el: '#vue', data: { title: \"秦老师系列课程1\", todoItems: ['狂神说Java', '狂神说运维', '狂神说前端'] }, methods: { // 该方法可以被模板中自定义事件触发 removeTodoItems: function (index) { console.log(\"删除 \" + this.todoItems[index] + \" 成功\"); // splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目，其中 index 为添加/删除项目的位置，1 表示删除的数量 this.todoItems.splice(index, 1); } } }); 2-修改 todo-items 待办内容组件的代码,增加一个删除按钮,并且绑定事件! Vue.component('todo-items', { props: ['item', 'index'], //v-on:click 缩写 @click template: '&lt;li&gt;{{index + 1}}. {{item}} &lt;button @click=\"remove_component\"&gt;删除&lt;/button&gt;&lt;/li&gt;', methods: { remove_component: function (index) { // 这里的 remove 是自定义事件的名称，需要在 HTML 中使用 v-on:remove 的方式指派 this.$emit('remove', index); } } }); 3-修改 todo-items 待办内容组件的 HTML 代码,增加一个自定义事件,比如叫 remove,可以和组件的方法绑定,然后绑定到vue的方法中! &lt;!--增加了 v-on:remove=\"removeTodoItems(index)\" 自定义事件，该事件会调用 Vue 实例中定义的名为 removeTodoItems 的方法 增加了 :key=\"index\" 不然无法传递 index 参数，v-bind:key=\"index\" 缩写:key=\"index\" 新版本 :key=\"index\"可不写 --&gt; &lt;todo-items slot=\"todo-items\" v-for=\"(item, index) in todoItems\" v-bind:item=\"item\" v-bind:index=\"index\" :key=\"index\" v-on:remove=\"removeTodoItems(index)\"&gt;&lt;/todo-items&gt; &lt;!-- 这里remove相当于点击事件函数名 --&gt; 逻辑理解 10、Vue 入门小结核心 : 数据驱动 , 组件化优点 : 借鉴了 AngulaJS 的模块化开发 和 React 的虚拟Dom , 虚拟Dom就是把Dom操作放到内存中执行; 常用的属性: v-if v-else-if v-else v-for v-on 绑定事件 , 简写@ v-model 数据双向绑定 v-bind 给组件绑定参数,简写 : 组件化: 组合组件 slot 插槽 组件内部绑定事件需要使用到 this.$emit(\"事件名\",参数); 计算属性的特色,缓存计算数据 遵循SoC 关注度分离原则,Vue是纯粹的视图框架,并不包含,比如Ajax之类的通信功能,为了解决通信问题,我们需要使用Axios 框架做异步通信; 说明 Vue的开发都是要基于NodeJS, 实际开发采用 vue-cli 脚手架开发,vue-router 路由,vuex 做状态管理; Vue UI界面我们一般使用 ElementUI(饿了么出品),或者ICE(阿里巴巴出品!)来快速搭建前端项目~ 官网: https://element.eleme.cn/#/zh-CN https://ice.work/ 11、第一个vue-cli项目 什么是vue-cli vue-cli 官方提供的一个脚手架，用于快速生成一个vue的项目模板；预先定义好的目录结构及基础代码，就好比咱们在创建Maven项目时可以选择创建一个骨架项目，这个估计项目就是脚手架，我们的开发更加的快速； 项目的功能 统一的目录结构 本地调试 热部署 单元测试 集成打包上线 需要的环境 Node.js：http://nodejs.cn/download/ 安装就是无脑的下一步就好，安装在自己的环境目录下 Git：https://git-scm.com/doenloads镜像：https://npm.taobao.org/mirrors/git-for-windows/ 确认nodejs安装成功： cmd下输入node -v，查看是否能够正确打印出版本号即可！ cmd下输入npm -v，查看是否能够正确打印出版本号即可！ 这个npm，就是一个软件包管理工具，就和linux下的apt软件安装差不多！安装Node.js淘宝镜像加速器（cnpm）这样的话，下载会快很多~ # -g 就是全局安装 npm install cnpm -g # 或使用如下语句解决npm速度慢的问题 npm install --registry=https://registry.npm.taobao.org 安装的过程可能有点慢~，耐心等待！虽然安装了cnpm，但是尽量少用！ 安装的位置：C:\\Users\\administrator\\AppData\\Roaming\\npm 安装vue-cli cnpm install vue-cli -g #测试是否安装成功#查看可以基于哪些模板创建vue应用程序，通常我们选择webpack vue list 第一个vue-cli应用程序1.创建一个Vue项目，我们随便建立一个空的文件夹在电脑上，我这里在D盘下新建一个目录 D:\\Project\\vue-study; 2.创建一个基于webpack模板的vue应用程序 #1、首先需要进入到对应的目录 cd D:\\Project\\vue-study #2、这里的myvue是顶日名称，可以根据自己的需求起名 vue init webpack myvue 一路都选择no即可； 说明： Project name：项目名称，默认回车即可 Project description：项目描述，默认回车即可 Author：项目作者，默认回车即可 Install vue-router：是否安装vue-router，选择n不安装（后期需要再手动添加） Use ESLint to lint your code:是否使用ESLint做代码检查，选择n不安装（后期需要再手动添加) Set up unit tests:单元测试相关，选择n不安装（后期需要再手动添加） Setupe2etests with Nightwatch：单元测试相关，选择n不安装（后期需要再手动添加） Should we run npm install for you after the,project has been created:创建完成后直接初始化，选择n，我们手动执行；运行结果！ 初始化并运行cd myvue #进入项目目录 npm install #安装依赖包 npm run dev #启动，相当于启动tomcat 执行完成后，目录多了很多依赖 当出现问题时，可以查看提示进行处理如下 Vue-cli目录结构 build 和 config：WebPack 配置文件 node_modules：用于存放 npm install 安装的依赖文件 src： 项目源码目录 static：静态资源文件 .babelrc：Babel 配置文件，主要作用是将 ES6 转换为 ES5 .editorconfig：编辑器配置 eslintignore：需要忽略的语法检查配置文件 .gitignore：git 忽略的配置文件 .postcssrc.js：css 相关配置文件，其中内部的 module.exports 是 NodeJS 模块化语法 index.html：首页，仅作为模板页，实际开发时不使用 package.json：项目的配置文件 name：项目名称 version：项目版本 description：项目描述 author：项目作者 scripts：封装常用命令 dependencies：生产环境依赖 devDependencies：开发环境依赖 12、webpack使用 什么是Webpack 本质上， webpack是一个现代JavaScript应用程序的静态模块打包器(module bundler) 。当webpack处理应用程序时， 它会递归地构建一个依赖关系图(dependency graph) ， 其中包含应用程序需要的每个模块， 然后将所有这些模块打包成一个或多个bundle. Webpack是当下最热门的前端资源模块化管理和打包工具， 它可以将许多松散耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分离，等到实际需要时再异步加载。通过loader转换， 任何形式的资源都可以当做模块， 比如Commons JS、AMD、ES 6、CSS、JSON、Coffee Script、LESS等； 伴随着移动互联网的大潮， 当今越来越多的网站已经从网页模式进化到了WebApp模式。它们运行在现代浏览器里， 使用HTML 5、CSS 3、ES 6等新的技术来开发丰富的功能， 网页已经不仅仅是完成浏览器的基本需求； WebApp通常是一个SPA(单页面应用) ， 每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的JS代码，这给前端的开发流程和资源组织带来了巨大挑战。 前端开发和其他开发工作的主要区别，首先是前端基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器的，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。 模块化的演进Script标签 &lt;script src = \"module1.js\"&gt;&lt;/script&gt; &lt;script src = \"module2.js\"&gt;&lt;/script&gt; &lt;script src = \"module3.js\"&gt;&lt;/script&gt; 这是最原始的JavaScript文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在window对象中，不同模块的调用都是一个作用域。 这种原始的加载方式暴露了一些显而易见的弊端： 全局作用域下容易造成变量冲突 文件只能按照``的书写顺序进行加载 开发人员必须主观解决模块和代码库的依赖关系 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 CommonsJS 服务器端的NodeJS遵循CommonsJS规范，该规范核心思想是允许模块通过require方法来同步加载所需依赖的其它模块，然后通过exports或module.exports来导出需要暴露的接口。 require(\"module\"); require(\"../module.js\"); export.doStuff = function(){}; module.exports = someValue; 优点： 服务器端模块便于重用 NPM中已经有超过45万个可以使用的模块包 简单易用 缺点： 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 实现： 服务端的NodeJS Browserify：浏览器端的CommonsJS实现，可以使用NPM的模块，但是编译打包后的文件体积较大 modules-webmake：类似Browserify，但不如Browserify灵活 wreq：Browserify的前身 AMD Asynchronous Module Definition规范其实主要一个主要接口define(id?,dependencies?,factory);它要在声明模块的时候指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行。 define(\"module\",[\"dep1\",\"dep2\"],functian(d1,d2){ return someExportedValue; }); require（[\"module\",\"../file.js\"],function(module，file){}); 优点 适合在浏览器环境中异步加载模块 可以并行加载多个模块 缺点 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不畅 不符合通用的模块化思维方式，是一种妥协的实现 实现 RequireJS curl CMD Commons Module Definition规范和AMD很相似，尽保持简单，并与CommonsJS和NodeJS的Modules规范保持了很大的兼容性。 define(function(require,exports,module){ var $=require(\"jquery\"); var Spinning = require(\"./spinning\"); exports.doSomething = ...; module.exports=...; }); 优点： 依赖就近，延迟执行 可以很容易在NodeJS中运行缺点 依赖SPM打包，模块的加载逻辑偏重 实现 Sea.js coolie ES6模块 EcmaScript 6标准增加了JavaScript语言层面的模块体系定义。ES 6模块的设计思想， 是尽量静态化， 使编译时就能确定模块的依赖关系， 以及输入和输出的变量。Commons JS和AMD模块，都只能在运行时确定这些东西。 import \"jquery\" export function doStuff(){} module \"localModule\"{} 优点 容易进行静态分析 面向未来的Ecma Script标准 缺点 原生浏览器端还没有实现该标准 全新的命令，新版的Node JS才支持 实现 Babel 一、简介 Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行执行。 这意味着，你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持。 二、安装 安装命令行转码工具 Babel提供babel-cli工具，用于命令行转码。它的安装命令如下： npm install --global babel-cli #查看是否安装成功 babel --version 三、Babel的使用 1、初始化项目 npm init -y 2、创建文件 src/example.js 下面是一段ES6代码： // 转码前 // 定义数据 let input = [1, 2, 3] // 将数组的每个元素 +1 input = input.map(item =&gt; item + 1) console.log(input) 2、配置.babelrc Babel的配置文件是.babelrc，存放在项目的根目录下，该文件用来设置转码规则和插件，基本格式如下。 { \"presets\": [], \"plugins\": [] } presets字段设定转码规则，将es2015规则加入 .babelrc： { \"presets\": [\"es2015\"], \"plugins\": [] } 3、安装转码器 在项目中安装 npm install --save-dev babel-preset-es2015 4、转码 # 转码结果写入一个文件 mkdir dist1 # --out-file 或 -o 参数指定输出文件 babel src/example.js --out-file dist1/compiled.js # 或者 babel src/example.js -o dist1/compiled.js # 整个目录转码 mkdir dist2 # --out-dir 或 -d 参数指定输出目录 babel src --out-dir dist2 # 或者 babel src -d dist2 5、自定义脚本 改写package.json： { // ... \"scripts\": { // ... \"build\": \"babel src\\\\example.js -o dist\\\\compiled.js\" }, } 转码的时候，执行下面的命令： mkdir dist npm run build 大家期望的模块 系统可以兼容多种模块风格， 尽量可以利用已有的代码， 不仅仅只是JavaScript模块化， 还有CSS、图片、字体等资源也需要模块化。 安装Webpack WebPack是一款模块加载器兼打包工具， 它能把各种资源， 如JS、JSX、ES 6、SASS、LESS、图片等都作为模块来处理和使用。 安装： npm install webpack -g npm install webpack-cli -g 测试安装成功 webpack -v webpack-cli -v 配置 创建 webpack.config.js配置文件 entry：入口文件， 指定Web Pack用哪个文件作为项目的入口，也就是引用了很多 js 文件的文件 output：输出， 指定WebPack把处理完成的文件放置到指定路径 module：模块， 用于处理各种类型的文件 plugins：插件， 如：热更新、代码重用等 resolve：设置路径指向 watch：监听， 用于设置文件改动后直接打包 module.exports = { entry: './src/main.js', //配置入口文件 output:{ path:path.resolve(__dirname, './dist'), //输出路径，__dirname：当前文件所在路径 filename: 'bundle.js' //输出文件 }, module:{ loaders:[ {test:/\\.js$/,;\\loade:\"\"} ] }, plugins:{}, resolve:{}, watch:true } 直接运行webpack命令打包 CSS打包 1、安装style-loader和 css-loader Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。Loader 可以理解为是模块和资源的转换器。 首先我们需要安装相关Loader插件，css-loader 是将 css 装载到 javascript；style-loader 是让 javascript 认识css npm install --save-dev style-loader css-loader 2、修改webpack.config.js const path = require(\"path\"); //Node.js内置模块 module.exports = { entry: './src/main.js', //配置入口文件 output:{ path:path.resolve(__dirname, './dist'), //输出路径，__dirname：当前文件所在路径 filename: 'bundle.js' //输出文件 }, module: { rules: [ { test: /\\.css$/, //打包规则应用到以css结尾的文件上 use: ['style-loader', 'css-loader'] } ] } } 3、在src文件夹创建style.css body{ background:pink; } 4、修改main.js 在第一行引入style.css require('./style.css'); 5、运行编译命令 webpack #有黄色警告 webpack --mode=development #没有警告 #执行后查看bundle.js 里面包含了上面两个js文件的内容并惊醒了代码压缩 使用webpack 创建项目(普通文件夹可以容纳 js 文件和 html 文件就行) 创建一个名为modules的目录，用于放置JS模块等资源文件 在modules下创建模块文件，如hello.js，用于编写JS模块相关代码 //暴露一个方法：sayHi exports.sayHi = function(){ document.write(\"&lt;div&gt;Hello Webpack&lt;/div&gt;\"); } 4.在modules下创建一个名为main.js的入口文件，用于打包时设置entry属性 //require 导入一个模块，就可以调用这个模块中的方法了 var hello = require(\"./hello\"); hello.sayHi(); 5.在项目目录下创建webpack.config.js配置文件，使用webpack命令打包 module.exports = { entry:\"./modules/main.js\", output:{ filename:\"./js/bundle.js\" } } 6.在项目目录下创建HTML页面，如index.html，导入webpack打包后的JS文件 &lt;!doctype html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说Java&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"dist/js/bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在IDEA控制台中直接执行webpack；如果失败的话，就使用管理员权限运行即可！ 运行HTML看效果 说明 # 参数--watch 用于监听变化，实时更新打包出来的js，实现热部署 webpack --watch 13、vue-router路由 说明 学习的时候，尽量的打开官方的文档 Vue Router是Vue.js官方的路由管理器。它和Vue.js的核心深度集成， 让构建单页面应用变得易如反掌。包含的功能有： 嵌套的路由/视图表 模块化的、基于组件的路由配置 路由参数、查询、通配符 基于Vue js过渡系统的视图过渡效果 细粒度的导航控制 带有自动激活的CSS class的链接 HTML5 历史模式或hash模式， 在IE 9中自动降级 自定义的滚动行为 安装 基于第一个vue-cli进行测试学习； 先查看node modules中是否存在vue-router vue-router是一个插件包， 所以我们还是需要用npm/cnpm来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。 npm install vue-router --save-dev 如果在一个模块化工程中使用它，必须要通过Vue.use()显式声明使用，明确地安装路由功能： import Vue from 'vue' import VueRouter from 'vue-router' Vue.use(VueRouter); 测试1、先删除没有用的东西2、components 目录下存放我们自己编写的组件3、定义一个Content.vue 的组件 &lt;template&gt; &lt;div&gt; &lt;h1&gt;内容页&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:\"Content\" } &lt;/script&gt; 定义一个Main.vue组件 &lt;template&gt; &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:\"Main\" } &lt;/script&gt; 4、安装路由，在src目录下，新建一个文件夹：router，专门存放路由，配置路由index.js，如下 import Vue from'vue' //导入路由插件 import Router from 'vue-router' //导入上面定义的组件 import Content from '../components/Content' import Main from '../components/Main' //安装路由 Vue.use(Router) ; //配置路由 export default new Router({ routes:[ { //路由路径 path:'/content', //路由名称 name:'content', //跳转到组件 component:Content },{ //路由路径 path:'/main', //路由名称 name:'main', //跳转到组件 component:Mian } ] }); 5、在main.js中配置路由 import Vue from 'vue' import App from './App' //导入上面创建的路由配置目录，这里router不能有大写 import router from './router'//自动扫描里面的路由配置 //来关闭生产模式下给出的提示 Vue.config.productionTip = false; new Vue({ el:\"#app\", //配置路由 router, components:{App}, template:'&lt;App/&gt;' }); 注意：这里router不能有大写，且不能换别的单词，不然会报错 6、在App.vue中使用路由 &lt;template&gt; &lt;div id=\"app\"&gt; &lt;!-- router-link：默认会被渲染成一个&lt;a&gt;标签，to属性为指定链接 router-view：用于渲染路由匹配到的组件 --&gt; &lt;router-link to=\"/main\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/content\"&gt;内容&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default{ name:'App' } &lt;/script&gt; &lt;style&gt;&lt;/style&gt; 14、实战快速上手我们采用实战教学模式并结合ElementUI组件库，将所需知识点应用到实际中，以最快速度带领大家掌握Vue的使用； 创建工程 注意：命令行都要使用管理员模式运行1、创建一个名为hello-vue的工程 #1、首先需要进入到对应的目录 cd D:\\Project\\vue-study #2、这里的hello-vue是顶日名称，可以根据自己的需求起名 vue init webpack hello-vue 2、安装依赖， 我们需要安装vue-router、element-ui、sass-loader和node-sass四个插件 #进入工程目录 cd hello-vue #安装vue-routern npm install vue-router --save-dev #安装element-ui npm i element-ui -S #安装依赖 npm install # 安装SASS加载器 cnpm install sass-loader node-sass --save-dev #启功测试 npm run dev 3、Npm命令解释： npm install moduleName：安装模块到项目目录下 npm install -g moduleName：-g的意思是将模块安装到全局，具体安装到磁盘哪个位置要看npm config prefix的位置 npm install -save moduleName：–save的意思是将模块安装到项目目录下，安装的是发布环境中需要用到的module， 并在package文件的dependencies节点写入依赖，-S为该命令的缩写 npm install -save-dev moduleName:–save-dev的意思是将模块安装到项目目录下， 安装的是只有在开发环境下需要用到的module，并在package文件的devDependencies节点写入依赖，-D为该命令的缩写 创建登录页面 把没有用的初始化东西删掉！ 在源码目录中创建如下结构： assets：用于存放资源文件 components：用于存放Vue功能组件 views：用于存放Vue视图组件 router：用于存放vue-router配置 创建首页视图，在views目录下创建一个名为Main.vue的视图组件： &lt;template&gt; &lt;div&gt;首页&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:\"Main\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 创建登录页视图在views目录下创建名为Login.vue的视图组件，其中el-*的元素为ElementUI组件； &lt;template&gt; &lt;div&gt; &lt;el-form ref=\"loginForm\" :model=\"form\" :rules=\"rules\" label-width=\"80px\" class=\"login-box\"&gt; &lt;h3 class=\"login-title\"&gt;欢迎登录&lt;/h3&gt; &lt;el-form-item label=\"账号\" prop=\"username\"&gt; &lt;el-input type=\"text\" placeholder=\"请输入账号\" v-model=\"form.username\"/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"密码\" prop=\"password\"&gt; &lt;el-input type=\"password\" placeholder=\"请输入密码\" v-model=\"form.password\"/&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=\"primary\" v-on:click=\"onSubmit('loginForm')\"&gt;登录&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-dialog title=\"温馨提示\" :visible.sync=\"dialogVisible\" width=\"30%\" :before-close=\"handleClose\"&gt; &lt;span&gt;请输入账号和密码&lt;/span&gt; &lt;span slot=\"footer\" class=\"dialog-footer\"&gt; &lt;el-button type=\"primary\" @click=\"dialogVisible = false\"&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"Login\", data() { return { form: { username: '', password: '' }, // 表单验证，需要在 el-form-item 元素中增加 prop 属性 rules: { username: [ {required: true, message: '账号不可为空', trigger: 'blur'} ], password: [ {required: true, message: '密码不可为空', trigger: 'blur'} ] }, // 对话框显示和隐藏 dialogVisible: false } }, methods: { onSubmit(formName) { // 为表单绑定验证功能 this.$refs[formName].validate((valid) =&gt; { if (valid) { // 使用 vue-router 路由到指定页面，该方式称之为编程式导航 this.$router.push(\"/main\"); } else { this.dialogVisible = true; return false; } }); } } } &lt;/script&gt; &lt;style lang=\"scss\" scoped&gt; .login-box { border: 1px solid #DCDFE6; width: 350px; margin: 180px auto; padding: 35px 35px 15px 35px; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; box-shadow: 0 0 25px #909399; } .login-title { text-align: center; margin: 0 auto 40px auto; color: #303133; } &lt;/style&gt; elementUI 的 el 标签解释 标签 解释 el-col 整体，默认占24栅格 el-container 主题区域 el-tooltip 提示框信息 el-header 内容头部区域 el-aside 左侧内容区域 el-main 主要内容区域 el-menu 整个导航栏 el-submenu 单独一个导航栏 el-menu-item 单独一个导航栏里面的单独一个栏目 el-menu-item-group 一组导航栏 el-date-picker 组件事件格式化方式 el-dialog 弹出对话框 el-table 表格 el-table-column 表格列 el-pagination 新增分页 el-select 选择框 el-button 按钮 el-form 表单提交 el-form-item lable = “活动区域” 表单域 el-input-number : (@change = handlechange – change 事件) 数字输入框，可以实现加减 el-tab-pane 是 el-table 的分页 创建路由，在router目录下创建一个名为index.js的vue-router路由配置文件 import Vue from 'vue' import VueRouter from 'vue-router' import Main from '../views/Main' import Login from '../views/Login' Vue.use(VueRouter); export default new VueRouter({ routes:[ { path:'/login', name:'login', component: Login },{ path: '/main', name:'main', component: Main } ] }); APP.vue &lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'App', } &lt;/script&gt; &lt;style&gt; #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } &lt;/style&gt; main.js // The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from 'vue' import App from './App' import router from \"./router\" //导入element-ui和其css import ElementUI from 'element-ui' import 'element-ui/lib/theme-chalk/index.css' Vue.use(router) //可不写，router不能改，且不能大写 Vue.use(ElementUI) /* eslint-disable no-new */ new Vue({ el: '#app', router, /* element-ui官方规定用法 */ render:h=&gt;h(App) }) 如果出现错误: 可能是因为sass-loader的版本过高导致的编译错误，当前最高版本是8.x，需要退回到7.3.1 ；去package.json文件里面的 “sass-loader”的版本更换成7.3.1，然后重新cnpm install就可以了； 15、路由嵌套嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如： /user/foo/profile /user/foo/posts +------------------+ +-----------------+ | User | | User | | +--------------+ | | +-------------+ | | | Profile | | +------------&gt; | | Posts | | | | | | | | | | | +--------------+ | | +-------------+ | +------------------+ +-----------------+ 1、用户信息组件，在上面项目基础上，在 views/user 目录下创建一个名为 Profile.vue 的视图组件； &lt;template&gt; &lt;div&gt; 个人信息 &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"UserProfile\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 2、用户列表组件在 views/user 目录下创建一个名为 List.vue 的视图组件； &lt;template&gt; &lt;div&gt; 用户列表 &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"UserList\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 3、配置嵌套路由修改 router 目录下的 index.js 路由配置文件，代码如下 import Vue from 'vue' import Router from 'vue-router' import Login from \"../views/Login\" import Main from '../views/Main' // 用于嵌套的路由组件 import UserProfile from '../views/user/Profile' import UserList from '../views/user/List' Vue.use(Router); export default new Router({ routes: [ { // 登录页 path: '/login', name: 'Login', component: Login }, { // 首页 path: '/main', name: 'Main', component: Main, // 配置嵌套路由 children: [ {path: '/user/profile', component: UserProfile}, {path: '/user/list', component: UserList}, ] } ] }); 说明：主要在路由配置中增加了 children 数组配置，用于在该组件下设置嵌套路由 4、修改首页视图，我们修改 Main.vue 视图组件，此处使用了 ElementUI 布局容器组件，代码如下： &lt;template&gt; &lt;div&gt; &lt;el-container&gt; &lt;el-aside width=\"200px\"&gt; &lt;el-menu :default-openeds=\"['1']\"&gt; &lt;el-submenu index=\"1\"&gt; &lt;template slot=\"title\"&gt;&lt;i class=\"el-icon-caret-right\"&gt;&lt;/i&gt;用户管理&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=\"1-1\"&gt; &lt;router-link to=\"/user/profile\"&gt;个人信息&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=\"1-2\"&gt; &lt;router-link to=\"/user/list\"&gt;用户列表&lt;/router-link&gt; &lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index=\"2\"&gt; &lt;template slot=\"title\"&gt;&lt;i class=\"el-icon-caret-right\"&gt;&lt;/i&gt;内容管理&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=\"2-1\"&gt;分类管理&lt;/el-menu-item&gt; &lt;el-menu-item index=\"2-2\"&gt;内容列表&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header style=\"text-align: right; font-size: 12px\"&gt; &lt;el-dropdown&gt; &lt;i class=\"el-icon-setting\" style=\"margin-right: 15px\"&gt;&lt;/i&gt; &lt;el-dropdown-menu slot=\"dropdown\"&gt; &lt;el-dropdown-item&gt;个人信息&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;退出登录&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;router-view /&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"Main\" } &lt;/script&gt; &lt;style scoped lang=\"scss\"&gt; .el-header { background-color: #B3C0D1; color: #333; line-height: 60px; } .el-aside { color: #333; } &lt;/style&gt; 说明：在元素中配置了用于展示嵌套路由,主要使用个人信息展示嵌套路由内容 参数传递我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。此时我们就需要传递参数了； 1、修改路由配置, 主要是在 path 属性中增加了 :id 这样的占位符，以及name属性 { path: '/user/profile/:id', name:'UserProfile', component: UserProfile } 2、传递参数 此时我们将 to 改为了 :to，是为了将这一属性当成对象使用，注意 router-link 中的 name 属性名称 一定要和路由中的 name 属性名称匹配，因为这样 Vue 才能找到对应的路由路径； &lt;router-link to=\"/user/profile\"&gt;个人信息&lt;/router-link&gt;&lt;!--原来样式--&gt; &lt;router-link :to=\"{name: 'UserProfile', params: {id: 1}}\"&gt;个人信息&lt;/router-link&gt; 3、接收参数, 在参数所要接送的组件中 (需要一个标签包围，不然会报错) &lt;div&gt;{{ $route.params.id }}&lt;/div&gt; 使用 props 的方式1、修改路由配置 , 主要增加了 props: true 属性 {path: '/user/profile/:id', name:'UserProfile', component: UserProfile, props: true} 2、传递参数和之前一样 &lt;router-link :to=\"{name: 'UserProfile', params: {id: 1}}\"&gt;个人信息&lt;/router-link&gt; 3、接收参数为目标组件增加 props 属性 &lt;template&gt; &lt;div&gt; 个人信息 {{ id }} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: ['id'], name: \"UserProfile\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 组件重定向重定向的意思大家都明白，但 Vue 中的重定向是作用在路径不同但组件相同的情况下，比如： { path: '/main', name: 'Main', component: Main }, { path: '/goHome', redirect: '/main' } 说明：这里定义了两个路径，一个是 /main ，一个是 /goHome，其中 /goHome 重定向到了 /main 路径，由此可以看出重定向不需要定义组件； 使用的话，只需要设置对应路径即可； &lt;el-menu-item index=\"1-3\"&gt; &lt;router-link to=\"/goHome\"&gt;回到首页&lt;/router-link&gt; &lt;/el-menu-item&gt; 16、路由模式与 404路由模式有两种 hash：路径带 # 符号，如 http://localhost/#/login history：路径不带 # 符号，如 http://localhost/login 修改路由配置，代码如下： export default new Router({ mode: 'history', routes: [ ] }); 处理 404 创建一个名为 NotFound.vue 的视图组件，代码如下： &lt;template&gt; &lt;div&gt; 页面不存在，请重试！ &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"NotFount\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 修改路由配置，代码如下： import NotFound from '../views/NotFound' { path: '*', component: NotFound } 路由钩子与异步请求beforeRouteEnter：在进入路由前执行beforeRouteLeave：在离开路由前执行 在 Profile.vue 上代码： export default { props: ['id'], name: \"UserProfile\", beforeRouteEnter: (to, from, next) =&gt; { console.log(\"准备进入个人信息页\"); next(); }, beforeRouteLeave: (to, from, next) =&gt; { console.log(\"准备离开个人信息页\"); next(); } } 参数说明： to：路由将要跳转的路径信息 from：路径跳转前的路径信息 next：路由的控制参数 next() 跳入下一个页面 next(’/path’) 改变路由的跳转方向，使其跳到另一个路由 next(false) 返回原来的页面 next( (vm)=&gt;{ } ) 仅在 beforeRouteEnter 中可用，vm 是组件实例 在钩子函数中使用异步请求1、安装 Axios cnpm install --save vue-axios npm install --save axios 2、main.js引用 Axios import axios from 'axios' import VueAxios from 'vue-axios' //这里两个参数位置不能颠倒 Vue.use(VueAxios, axios) 3、准备数据 ： 只有我们的 static 目录下的文件是可以被访问到的，所以我们就把静态文件放入该目录下。 // 静态数据存放的位置 static/mock/data.json 4、在 beforeRouteEnter 中进行异步请求 export default { props: ['id'], name: \"UserProfile\", beforeRouteEnter: (to, from, next) =&gt; { console.log(\"准备进入个人信息页\"); // 注意，一定要在 next 中请求，因为该方法调用时 Vue 实例还没有创建，此时无法获取到 this 对象，在这里使用官方提供的回调函数拿到当前实例 next(vm =&gt; { vm.getData(); }); }, beforeRouteLeave: (to, from, next) =&gt; { console.log(\"准备离开个人信息页\"); next(); }, methods: { getData: function () { this.axios({ method: 'get', url: 'http://localhost:8080/static/mock/data.json' }).then(function (repos) { console.log(repos); }).catch(function (error) { console.log(error); }); } } }","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Docker概述","slug":"Docker","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:20:53.918Z","comments":true,"path":"posts/ea4e9756.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9756.html","excerpt":"","text":"Docker概述Docker为什么出现？ 一款产品： 开发–上线 两套环境！应用环境，应用配置！ 开发 — 运维。 问题：我在我的电脑上可以运行！版本更新，导致服务不可用！对于运维来说考验十分大！环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。 发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！ 之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。开发环境Windows，最后发布到Linux！ 传统：开发jar，运维来做！ 现在：开发打包部署上线，一套流程做完！ 安卓流程：java — apk —发布（应用商店）一 张三使用apk一安装即可用！ docker流程： java-jar（环境） — 打包项目帯上环境（镜像） — ( Docker仓库：商店）— 安装即可用 Docker给以上的问题，提出了解决方案！Docker的思想就来自于集装箱！ JRE – 多个应用(端口冲突) – 原来都是交叉的！隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。 Docker 通过隔离机制，可以将服务器利用到极致！ 本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！ Docker历史2010年，几个的年轻人，就在美国成立了一家公司 dotcloud 做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！ Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。 他们将自己的技术（容器化技术）命名为 DockerDocker 刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！ 开源 2013年，Docker开源！越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！ 2014年4月9日，Docker1.0发布！docker为什么这么火？十分的轻巧！ 在容器技术出来之前，我们都是使用虚拟机技术！ 虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！ 虚拟机也属于虚拟化技术，Docker 容器技术，也是一种虚拟化技术！ VMware : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟 docker: 隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！ 聊聊Docker Docker基于Go语言开发的！开源项目！ docker官网：https://www.docker.com/ 文档：https://docs.docker.com/ Docker的文档是超级详细的！ 仓库：https://hub.docker.com/ Docker能干嘛 之前的虚拟机技术 虚拟机技术缺点： 资源占用十分多 冗余步骤多 启动很慢！ 容器化技术 容器化技术不是模拟一个完整的操作系统 比较Docker和虚拟机技术的不同： 传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件 容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了 每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响 DevOps（开发、运维） 应用更快速的交付和部署 传统：一对帮助文档，安装程序。 Docker：打包镜像发布测试一键运行。 更便捷的升级和扩缩容 使用了 Docker之后，我们部署应用就和搭积木一样项目打包为一个镜像，扩展服务器A！服务器B 更简单的系统运维 在容器化之后，我们的开发，测试环境都是高度一致的 更高效的计算资源利用 Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。 Docker安装Docker的基本组成 镜像（image)： docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像=&gt;run=&gt;容器（提供服务），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。 容器(container)： Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.启动，停止，删除，基本命令目前就可以把这个容器理解为就是一个简易的 Linux系统。 仓库(repository)： 仓库就是存放镜像的地方！仓库分为公有仓库和私有仓库。(很类似git)Docker Hub是国外的。阿里云…都有容器服务器(配置镜像加速!) 安装Docker 环境准备 1.Linux要求内核3.0以上 2.CentOS 7 #查看Linux版本号 [root@iz2zeak7sgj6i7hrb2g862z ~]# uname -r 3.10.0-514.26.2.el7.x86_64 # 要求3.0以上 #查看系统信息 [root@iz2zeak7sgj6i7hrb2g862z ~]# cat /etc/os-release NAME=\"CentOS Linux\" VERSION=\"7 (Core)\" ID=\"centos\" ID_LIKE=\"rhel fedora\" VERSION_ID=\"7\" PRETTY_NAME=\"CentOS Linux 7 (Core)\" ANSI_COLOR=\"0;31\" CPE_NAME=\"cpe:/o:centos:centos:7\" HOME_URL=\"https://www.centos.org/\" BUG_REPORT_URL=\"https://bugs.centos.org/\" CENTOS_MANTISBT_PROJECT=\"CentOS-7\" CENTOS_MANTISBT_PROJECT_VERSION=\"7\" REDHAT_SUPPORT_PRODUCT=\"centos\" REDHAT_SUPPORT_PRODUCT_VERSION=\"7\" 安装 帮助文档：https://docs.docker.com/engine/install/卸载与安装 #1.卸载旧版本 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine #2.需要的安装包 yum install -y yum-utils #3.设置镜像的仓库 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #上述方法默认是从国外的，不推荐 #推荐使用国内的 yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #更新yum软件包索引 yum makecache fast #4.安装docker相关的 docker-ce 社区版 而ee是企业版 yum install docker-ce docker-ce-cli containerd.io # 这里我们使用社区版即可 #5.启动docker systemctl start docker #6. 使用docker version查看是否按照成功 docker version #7. 测试 docker run hello-world #8.查看已经下载的镜像(从这里可以查看已有镜像的id) [root@iz2zeak7sgj6i7hrb2g862z ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 4 months ago 13.3kB 卸载docker #1. 卸载依赖 yum remove docker-ce docker-ce-cli containerd.io #2. 删除资源 rm -rf /var/lib/docker # /var/lib/docker 是docker的默认工作路径！ 阿里云镜像加速1、登录阿里云找到容器服务,找到镜像加速器 2、配置使用#1.创建一个目录 sudo mkdir -p /etc/docker #2.编写配置文件 sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' { \"registry-mirrors\": [\"https://t2wwyxhb.mirror.aliyuncs.com\"] } EOF #3.重启服务 sudo systemctl daemon-reload sudo systemctl restart docker 回顾HelloWorld流程docker run 流程图 底层原理Docker是怎么工作的？ Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！ Docker-Server接收到Docker-Client的指令，就会执行这个命令！ 为什么Docker比Vm快1、docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。2、docker利用的是宿主机的内核,而不需要Guest OS。 GuestOS： VM（虚拟机）里的的系统（OS） HostOS：物理机里的系统（OS） 因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。因而避免引导、加载操作系统内核整个比较费时费资源的过程，当新建一个虚拟机时,虚拟机软件需要加载GuestOS，整个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统，则省略了这个复杂的过程,因此新建一个docker容器只需要几秒钟。 Docker的常用命令1.帮助命令docker version #显示docker的版本信息。 docker info #显示docker的系统信息，包括镜像和容器的数量 docker 命令 --help #帮助命令 帮助文档的地址：https://docs.docker.com/engine/reference/commandline/build/ 2.镜像命令docker images #查看所有本地主机上的镜像 可以使用docker image ls代替 docker search #搜索镜像 docker pull #下载镜像 docker image pull docker rmi #删除镜像 docker image rm 查看镜像[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest bf756fb1ae65 4 months ago 13.3kB mysql 5.7 b84d68d0a7db 6 days ago 448MB # 解释 #REPOSITORY # 镜像的仓库源 #TAG # 镜像的标签(版本) ---lastest 表示最新版本 #IMAGE ID # 镜像的id #CREATED # 镜像的创建时间 #SIZE # 镜像的大小 # 可选项 Options: -a, --all Show all images (default hides intermediate images) #列出所有镜像 -q, --quiet Only show numeric IDs # 只显示镜像的id [root@iz2zeak7sgj6i7hrb2g862z ~]# docker images -a #列出所有镜像详细信息 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker images -aq #列出所有镜像的id d5f28a0bb0d0 f19c56ce92a8 1b6b1fe7261e 搜索镜像 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker search mysql # --filter=STARS=3000 #过滤，搜索出来的镜像收藏STARS数量大于3000的 Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output [root@iz2zeak7sgj6i7hrb2g862z ~]# docker search mysql --filter=STARS=3000 NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL IS ... 9520 [OK] mariadb MariaDB IS ... 3456 [OK] 下载镜像# 下载镜像 docker pull 镜像名[:tag] [root@iZwz97ikj14iruzlnq4vr3Z ~]# docker pull mysql Using default tag: latest latest: Pulling from library/mysql #如果不写tag，默认就是latest，最新版本 bb79b6b2107f: Pull complete #分层下载 docker image 的核心 联合文件系统 49e22f6fb9f7: Pull complete 842b1255668c: Pull complete 9f48d1f43000: Pull complete c693f0615bce: Pull complete 8a621b9dbed2: Pull complete 0807d32aef13: Pull complete a56aca0feb17: Pull complete de9d45fd0f07: Pull complete 1d68a49161cc: Pull complete d16d318b774e: Pull complete 49e112c55976: Pull complete Digest: sha256:8c17271df53ee3b843d6e16d46cff13f22c9c04d6982eb15a9a47bd5c9ac7e2d #防伪签名 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest #真实的地址 #等价于 docker pull mysql docker pull docker.io/library/mysql:latest #下载mysql 5.7 [root@iZwz97ikj14iruzlnq4vr3Z ~]# docker pull mysql:5.7 5.7: Pulling from library/mysql bb79b6b2107f: Already exists #因为有些底层文件跟mysql最新版本一样，所以就共用了不用下载 49e22f6fb9f7: Already exists 842b1255668c: Already exists 9f48d1f43000: Already exists c693f0615bce: Already exists 8a621b9dbed2: Already exists 0807d32aef13: Already exists f15d42f48bd9: Pull complete 098ceecc0c8d: Pull complete b6fead9737bc: Pull complete 351d223d3d76: Pull complete Digest: sha256:4d2b34e99c14edb99cdd95ddad4d9aa7ea3f2c4405ff0c3509a29dc40bcb10ef Status: Downloaded newer image for mysql:5.7 docker.io/library/mysql:5.7 删除镜像docker rmi -f 镜像id #删除指定id的镜像 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker rmi -f f19c56ce92a8 docker rmi -f 镜像id 镜像id 镜像id #删除多个指定id的镜像 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker rmi -f f19c56ce92a8 a20c56ce92a6 docker rmi -f $(docker images -aq) #删除全部的镜像 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker rmi -f $(docker images -aq) 3.容器命令说明：我们有了镜像才可以创建容器，Linux，下载centos镜像来学习 镜像下载#docker中下载centos docker pull centos 新建容器并启动docker run [可选参数] image | docker container run [可选参数] image #参书说明 --name=\"Name\" #起容器名字 tomcat01 tomcat02 用来区分容器 -d #后台方式运行 -it #使用交互方式运行，进入容器查看内容 -p #指定容器的端口 -p 8080(宿主机):8080(容器) -p ip:主机端口:容器端口 -p 主机端口:容器端口(常用) -p 容器端口 容器端口 -P(大写) 随机指定端口 # 测试、启动并进入容器 [root@iz2zeak7sgj6i7hrb2g [root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -it centos /bin/bash [root@241b5abce65e /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var [root@241b5abce65e /]# exit #停止容器运行退回主机 exit 列出运行的容器docker ps 命令 #列出当前正在运行的容器 -a, --all #列出当前正在运行的容器 + 带出历史运行过的容器 -n=?, --last int #列出最近创建的?个容器 ?为1则只列出最近创建的一个容器,为2则列出2个 -q, --quiet #只列出容器的编号 退出容器exit #容器直接退出 ctrl +P +Q #容器不停止退出 ---注意：这个很有用的操作 删除容器docker rm 容器id #删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -rf docker rm -f $(docker ps -aq) #删除所有的容器 docker ps -a -q|xargs docker rm #删除所有的容器 启动和停止容器docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止当前正在运行的容器 docker kill 容器id #强制停止当前容器 4.常用其他命令后台启动命令# 命令 docker run -d 镜像名 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d centos a8f922c255859622ac45ce3a535b7a0e8253329be4756ed6e32265d2dd2fac6c [root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES # 问题docker ps. 发现centos 停止了 # 常见的坑，docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止 # nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了 查看日志docker logs --help Options: --details Show extra details provided to logs * -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) * --tail string Number of lines to show from the end of the logs (default \"all\") * -t, --timestamps Show timestamps --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) #写一个脚本 模拟日志打印 -c 表示运行脚本 [root@iZwz97ikj14iruzlnq4vr3Z /]# docker run -d centos /bin/sh -c \"while true;do echo xu;sleep 1;done\" 559341c73531fcc6608c2ff0438516afd0a52e2131e80238b478f77789ab7440 [root@iZwz97ikj14iruzlnq4vr3Z /]# docker ps CONTAINER ID IMAGE COMMAND CREATED 559341c73531 centos \"/bin/sh -c 'while t…\" 2 seconds ago [root@iZwz97ikj14iruzlnq4vr3Z /]# docker logs -tf --tail 10 559341c73531 2020-11-10T11:32:19.175389018Z xu 2020-11-10T11:32:20.177734043Z xu 2020-11-10T11:32:21.179991429Z xu 2020-11-10T11:32:22.182378671Z xu 2020-11-10T11:32:23.185062917Z xu 2020-11-10T11:32:24.187506010Z xu 2020-11-10T11:32:25.190021447Z xu 2020-11-10T11:32:26.192300226Z xu 2020-11-10T11:32:27.194908898Z xu 2020-11-10T11:32:28.197536665Z xu 2020-11-10T11:32:29.199825363Z xu 2020-11-10T11:32:30.202154866Z xu ^C [root@iZwz97ikj14iruzlnq4vr3Z /]# #显示日志 -tf #显示日志信息（一直更新） --tail number #需要显示日志条数（不带日期时间） docker logs -t --tail n 容器id #查看n行日志（带日期时间） docker logs -ft 容器id #跟着日志 查看容器中进程信息ps# 命令 docker top 容器id [root@iZwz97ikj14iruzlnq4vr3Z /]# docker top 559341c73531 查看镜像的元数据# 命令 docker inspect 容器id #测试 [root@iZwz97ikj14iruzlnq4vr3Z /]# docker inspect 559341c73531 [ { \"Id\": \"559341c73531fcc6608c2ff0438516afd0a52e2131e80238b478f77789ab7440\", \"Created\": \"2020-11-10T11:31:59.812311196Z\", \"Path\": \"/bin/sh\", \"Args\": [ \"-c\", \"while true;do echo xu;sleep 1;done\" ], \"State\": { \"Status\": \"running\", \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 12248, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2020-11-10T11:32:00.132022147Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, \"Image\": \"sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566\", \"ResolvConfPath\": \"/var/lib/docker/containers/559341c73531fcc6608c2ff0438516afd0a52e2131e80238b478f77789ab7440/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/559341c73531fcc6608c2ff0438516afd0a52e2131e80238b478f77789ab7440/hostname\", \"HostsPath\": \"/var/lib/docker/containers/559341c73531fcc6608c2ff0438516afd0a52e2131e80238b478f77789ab7440/hosts\", \"LogPath\": \"/var/lib/docker/containers/559341c73531fcc6608c2ff0438516afd0a52e2131e80238b478f77789ab7440/559341c73531fcc6608c2ff0438516afd0a52e2131e80238b478f77789ab7440-json.log\", \"Name\": \"/pedantic_bhaskara\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"MountLabel\": \"\", \"ProcessLabel\": \"\", \"AppArmorProfile\": \"\", \"ExecIDs\": null, \"HostConfig\": { \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": { \"Type\": \"json-file\", \"Config\": {} }, \"NetworkMode\": \"default\", \"PortBindings\": {}, \"RestartPolicy\": { \"Name\": \"no\", \"MaximumRetryCount\": 0 }, \"AutoRemove\": false, \"VolumeDriver\": \"\", \"VolumesFrom\": null, \"CapAdd\": null, \"CapDrop\": null, \"Capabilities\": null, \"Dns\": [], \"DnsOptions\": [], \"DnsSearch\": [], \"ExtraHosts\": null, \"GroupAdd\": null, \"IpcMode\": \"private\", \"Cgroup\": \"\", \"Links\": null, \"OomScoreAdj\": 0, \"PidMode\": \"\", \"Privileged\": false, \"PublishAllPorts\": false, \"ReadonlyRootfs\": false, \"SecurityOpt\": null, \"UTSMode\": \"\", \"UsernsMode\": \"\", \"ShmSize\": 67108864, \"Runtime\": \"runc\", \"ConsoleSize\": [ 0, 0 ], \"Isolation\": \"\", \"CpuShares\": 0, \"Memory\": 0, \"NanoCpus\": 0, \"CgroupParent\": \"\", \"BlkioWeight\": 0, \"BlkioWeightDevice\": [], \"BlkioDeviceReadBps\": null, \"BlkioDeviceWriteBps\": null, \"BlkioDeviceReadIOps\": null, \"BlkioDeviceWriteIOps\": null, \"CpuPeriod\": 0, \"CpuQuota\": 0, \"CpuRealtimePeriod\": 0, \"CpuRealtimeRuntime\": 0, \"CpusetCpus\": \"\", \"CpusetMems\": \"\", \"Devices\": [], \"DeviceCgroupRules\": null, \"DeviceRequests\": null, \"KernelMemory\": 0, \"KernelMemoryTCP\": 0, \"MemoryReservation\": 0, \"MemorySwap\": 0, \"MemorySwappiness\": null, \"OomKillDisable\": false, \"PidsLimit\": null, \"Ulimits\": null, \"CpuCount\": 0, \"CpuPercent\": 0, \"IOMaximumIOps\": 0, \"IOMaximumBandwidth\": 0, \"MaskedPaths\": [ \"/proc/asound\", \"/proc/acpi\", \"/proc/kcore\", \"/proc/keys\", \"/proc/latency_stats\", \"/proc/timer_list\", \"/proc/timer_stats\", \"/proc/sched_debug\", \"/proc/scsi\", \"/sys/firmware\" ], \"ReadonlyPaths\": [ \"/proc/bus\", \"/proc/fs\", \"/proc/irq\", \"/proc/sys\", \"/proc/sysrq-trigger\" ] }, \"GraphDriver\": { \"Data\": { \"LowerDir\": \"/var/lib/docker/overlay2/29a9053abbfd5e11ac8cc35f5f0e6973d419fc6998277b2e2b325a3118dbd3d0-init/diff:/var/lib/docker/overlay2/268dd219c7917e92d851d24339219959f593fd43a8a855d9ebeb1ffb81a5e360/diff\", \"MergedDir\": \"/var/lib/docker/overlay2/29a9053abbfd5e11ac8cc35f5f0e6973d419fc6998277b2e2b325a3118dbd3d0/merged\", \"UpperDir\": \"/var/lib/docker/overlay2/29a9053abbfd5e11ac8cc35f5f0e6973d419fc6998277b2e2b325a3118dbd3d0/diff\", \"WorkDir\": \"/var/lib/docker/overlay2/29a9053abbfd5e11ac8cc35f5f0e6973d419fc6998277b2e2b325a3118dbd3d0/work\" }, \"Name\": \"overlay2\" }, \"Mounts\": [], \"Config\": { \"Hostname\": \"559341c73531\", \"Domainname\": \"\", \"User\": \"\", \"AttachStdin\": false, \"AttachStdout\": false, \"AttachStderr\": false, \"Tty\": false, \"OpenStdin\": false, \"StdinOnce\": false, \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ], \"Cmd\": [ \"/bin/sh\", \"-c\", \"while true;do echo xu;sleep 1;done\" ], \"Image\": \"centos\", \"Volumes\": null, \"WorkingDir\": \"\", \"Entrypoint\": null, \"OnBuild\": null, \"Labels\": { \"org.label-schema.build-date\": \"20200809\", \"org.label-schema.license\": \"GPLv2\", \"org.label-schema.name\": \"CentOS Base Image\", \"org.label-schema.schema-version\": \"1.0\", \"org.label-schema.vendor\": \"CentOS\" } }, \"NetworkSettings\": { \"Bridge\": \"\", \"SandboxID\": \"7dfa71c6c37841502acb4ab7b08f048cdb504aacbb2ec23295ff7a091e3f25db\", \"HairpinMode\": false, \"LinkLocalIPv6Address\": \"\", \"LinkLocalIPv6PrefixLen\": 0, \"Ports\": {}, \"SandboxKey\": \"/var/run/docker/netns/7dfa71c6c378\", \"SecondaryIPAddresses\": null, \"SecondaryIPv6Addresses\": null, \"EndpointID\": \"1aadcb05d0e9b5e2e106a3383b51374bfe9fd31042a441f5b8d769b7f024b86e\", \"Gateway\": \"172.17.0.1\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"IPAddress\": \"172.17.0.2\", \"IPPrefixLen\": 16, \"IPv6Gateway\": \"\", \"MacAddress\": \"02:42:ac:11:00:02\", \"Networks\": { \"bridge\": { \"IPAMConfig\": null, \"Links\": null, \"Aliases\": null, \"NetworkID\": \"80c4ffaf3459890ad888d3b9dbf32e375640d35c3b118f698f3c82eae4f2d8b0\", \"EndpointID\": \"1aadcb05d0e9b5e2e106a3383b51374bfe9fd31042a441f5b8d769b7f024b86e\", \"Gateway\": \"172.17.0.1\", \"IPAddress\": \"172.17.0.2\", \"IPPrefixLen\": 16, \"IPv6Gateway\": \"\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"MacAddress\": \"02:42:ac:11:00:02\", \"DriverOpts\": null } } } } ] 进入当前正在运行的容器docker exec -it 容器id #测试 [root@iZwz97ikj14iruzlnq4vr3Z ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED 559341c73531 centos \"/bin/sh -c 'while t…\" 12 minutes ago [root@iZwz97ikj14iruzlnq4vr3Z ~]# docker exec -it 559341c73531 /bin/bash #注意，下面已经进入容器 [root@559341c73531 /]# # 方式二 docker attach 容器id #测试 docker attach 55321bcae33d #进入正在执行当前的代码... #区别 #docker exec #进入当前容器后开启一个新的终端，可以在里面操作。（常用） #docker attach # 进入容器正在执行的终端 从容器内拷贝到主机上 docker cp 容器id:容器内路径 主机目的路径 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 56a5583b25b4 centos \"/bin/bash\" 7seconds ago Up 6 seconds #1. 进入docker容器内部 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 56a5583b25b4 /bin/bash [root@55321bcae33d /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var #新建一个文件 [root@55321bcae33d /]# echo \"hello\" &gt; java.java [root@55321bcae33d /]# cat hello.java hello [root@55321bcae33d /]# exit exit #hello.java拷贝到home文件加下 [root@iz2zeak7sgj6i7hrb2g862z /]# docker cp 56a5583b25b4:/hello.java /home [root@iz2zeak7sgj6i7hrb2g862z /]# cd /home [root@iz2zeak7sgj6i7hrb2g862z home]# ls -l #可以看见java.java存在 total 8 -rw-r--r-- 1 root root 0 May 19 22:09 haust.java -rw-r--r-- 1 root root 6 May 22 11:12 java.java drwx------ 3 www www 4096 May 8 12:14 www 小结：命令大全 attach Attach local standard input, output, and error streams to a running container #当前shell下 attach连接指定运行的镜像 build Build an image from a Dockerfile # 通过Dockerfile定制镜像 commit Create a new image from a container's changes #提交当前容器为新的镜像 cp Copy files/folders between a container and the local filesystem #拷贝文件 create Create a new container #创建一个新的容器 diff Inspect changes to files or directories on a container's filesystem #查看docker容器的变化 events Get real time events from the server # 从服务获取容器实时时间 exec Run a command in a running container # 在运行中的容器上运行命令 export Export a container's filesystem as a tar archive #导出容器文件系统作为一个tar归档文件[对应import] history Show the history of an image # 展示一个镜像形成历史 images List images #列出系统当前的镜像 import Import the contents from a tarball to create a filesystem image #从tar包中导入内容创建一个文件系统镜像 info Display system-wide information # 显示全系统信息 inspect Return low-level information on Docker objects #查看容器详细信息 kill Kill one or more running containers # kill指定docker容器 load Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载一个镜像[对应save] login Log in to a Docker registry # logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes 作业练习 作业一：Docker 安装Nginx #1. 搜索镜像 search 建议大家去docker搜索，可以看到帮助文档 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker search nginx #2. 拉取下载镜像 pull [root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull nginx #3. 查看是否下载成功镜像 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker images #3. 运行测试 # -d 后台运行 # --name 给容器命名 # -p 宿主机端口：容器内部端口 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name nginx01 -p 3344:80 nginx aa664b0c8ed98f532453ce1c599be823bcc1f3c9209e5078615af416ccb454c2 #4. 查看正在启动的镜像 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED 75943663c116 nginx \"nginx -g 'daemon of…\" 41 seconds ago #5. 进入容器 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it nginx01 /bin/bash #进入 root@aa664b0c8ed9:/# whereis nginx #找到nginx位置 nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx root@aa664b0c8ed9:/# cd /etc/nginx/ root@aa664b0c8ed9:/etc/nginx# ls conf.d fastcgi_params koi-utf koi-win mime.types modules nginx.conf scgi_params uwsgi_params win-utf #6. 退出容器 root@aa664b0c8ed9:/etc/nginx# exit exit #7. 停止容器 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED aa664b0c8ed9 nginx \"nginx -g 'daemon of…\" 10 minutes ago [root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop aa664b0c8ed9 宿主机端口 和 容器内部端口 以及端口暴露： 问题：我们每次改动nginx配置文件，都需要进入容器内部？十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器外部修改文件名，容器内部就可以自动修改？-v 数据卷 技术！ 作业二：用docker 来装一个tomcat # 下载 tomcat9.0 # 之前的启动都是后台，停止了容器，容器还是可以查到， docker run -it --rm 镜像名 一般是用来测试，用完就删除 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -it --rm tomcat:9.0 --rm Automatically remove the container when it exits 用完即删 #下载 最新版 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull tomcat #查看下载的镜像 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker images #以后台方式，暴露端口方式，启动运行 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 --name tomcat01 tomcat #测试访问有没有问题 curl localhost:8080 #根据容器id进入tomcat容器 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 645596565d3f /bin/bash root@645596565d3f:/usr/local/tomcat# #查看tomcat容器内部内容： root@645596565d3f:/usr/local/tomcat# ls -l total 152 -rw-r--r-- 1 root root 18982 May 5 20:40 BUILDING.txt -rw-r--r-- 1 root root 5409 May 5 20:40 CONTRIBUTING.md -rw-r--r-- 1 root root 57092 May 5 20:40 LICENSE -rw-r--r-- 1 root root 2333 May 5 20:40 NOTICE -rw-r--r-- 1 root root 3255 May 5 20:40 README.md -rw-r--r-- 1 root root 6898 May 5 20:40 RELEASE-NOTES -rw-r--r-- 1 root root 16262 May 5 20:40 RUNNING.txt drwxr-xr-x 2 root root 4096 May 16 12:05 bin drwxr-xr-x 1 root root 4096 May 21 11:04 conf drwxr-xr-x 2 root root 4096 May 16 12:05 lib drwxrwxrwx 1 root root 4096 May 21 11:04 logs drwxr-xr-x 2 root root 4096 May 16 12:05 native-jni-lib drwxrwxrwx 2 root root 4096 May 16 12:05 temp drwxr-xr-x 2 root root 4096 May 16 12:05 webapps drwxr-xr-x 7 root root 4096 May 5 20:37 webapps.dist drwxrwxrwx 2 root root 4096 May 5 20:36 work root@645596565d3f:/usr/local/tomcat# #进入webapps目录 root@645596565d3f:/usr/local/tomcat# cd webapps root@645596565d3f:/usr/local/tomcat/webapps# ls root@645596565d3f:/usr/local/tomcat/webapps# # 发现问题：1、linux命令少了。 2.webapps目录为空 # 原因：阿里云镜像的原因，阿里云默认是最小的镜像，所以不必要的都剔除掉 # 保证最小可运行的环境！ # 解决方案： # 将webapps.dist下的文件都拷贝到webapps下即可 root@645596565d3f:/usr/local/tomcat# ls 找到webapps.dist BUILDING.txt LICENSE README.md RUNNING.txt conf logs temp webapps.dist CONTRIBUTING.md NOTICE RELEASE-NOTES bin lib native-jni-lib webapps work root@645596565d3f:/usr/local/tomcat# cd webapps.dist/ # 进入webapps.dist root@645596565d3f:/usr/local/tomcat/webapps.dist# ls # 查看内容 ROOT docs examples host-manager manager root@645596565d3f:/usr/local/tomcat/webapps.dist# cd .. root@645596565d3f:/usr/local/tomcat# cp -r webapps.dist/* webapps # 拷贝webapps.dist 内容给webapps root@645596565d3f:/usr/local/tomcat# cd webapps #进入webapps root@645596565d3f:/usr/local/tomcat/webapps# ls #查看拷贝结果 ROOT docs examples host-manager manager 这样docker部署tomcat就可以访问了问题:我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？要是可以在容器外部提供一个映射路径，比如webapps，我们在外部放置项目，就自动同步内部就好了！ 作业三：部署elasticsearch+kibana # es 暴露的端口很多！ # es 十分耗内存 # es 的数据一般需要放置到安全目录！挂载 # --net somenetwork ? 网络配置 # 启动elasticsearch [root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.6.2 # 测试一下es是否成功启动 [root@iZwz97ikj14iruzlnq4vr3Z home]# curl localhost:9200 { \"name\" : \"2a071dce5e61\", \"cluster_name\" : \"docker-cluster\", \"cluster_uuid\" : \"ivWRQ4SPSPSIyFRks3D-dw\", \"version\" : { \"number\" : \"7.6.2\", \"build_flavor\" : \"default\", \"build_type\" : \"docker\", \"build_hash\" : \"ef48eb35cf30adf4db14086e8aabd07ef6fb113f\", \"build_date\" : \"2020-03-26T06:34:37.794943Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.4.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } #测试成功就关掉elasticSearch，防止耗内存 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop d834ce2bd306 d834ce2bd306 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker stats # 查看docker容器使用内存情况 #测试成功就关掉elasticSearch，可以添加内存的限制，修改配置文件 -e 环境配置修改 [root@iZwz97ikj14iruzlnq4vr3Z home]# docker rm -f d73ad2f22dd3 # stop命令也行 [root@iZwz97ikj14iruzlnq4vr3Z home]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" elasticsearch:7.6.2 作业三：使用kibana连接es (elasticSearch)？思考网络如何才能连接 Portainer 可视化面板安装 portainer(先用这个) docker run -d -p 3344:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer Rancher(CI/CD再用) 什么是portainer？ Docker图形化界面管理工具！提供一个后台面板供我们操作！ # 安装命令 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 3344:9000 \\ &gt; --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer Unable to find image 'portainer/portainer:latest' locally latest: Pulling from portainer/portainer d1e017099d17: Pull complete a7dca5b5a9e8: Pull complete Digest: sha256:4ae7f14330b56ffc8728e63d355bc4bc7381417fa45ba0597e5dd32682901080 Status: Downloaded newer image for portainer/portainer:latest 81753869c4fd438cec0e31659cbed0d112ad22bbcfcb9605483b126ee8ff306d 测试访问： 外网：8080 ：http://ip:3344/进入之后的面板 Docker镜像讲解镜像原理之联合文件系统镜像是什么镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。 所有应用，直接打包docker镜像，就可以直接跑起来！ 如何得到镜像 从远程仓库下载 别人拷贝给你 自己制作一个镜像 DockerFile Docker镜像加载原理 UnionFs （联合文件系统） UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。 Docker镜像加载原理 docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。boots(boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加載器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。 平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？ 对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs. 虚拟机是分钟级别，容器是秒级！ 分层理解 分层的镜像 我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载 思考：为什么Docker镜像要采用这种分层的结构呢？ 最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。 查看镜像分层的方式可以通过docker image inspect 命令 [root@iZwz97ikj14iruzlnq4vr3Z ~]# docker image inspect redis [ { \"Id\": \"sha256:f9b9909726890b00d2098081642edf32e5211b7ab53563929a47f250bcdc1d7c\", \"RepoTags\": [ \"redis:latest\" ], \"RepoDigests\": [ \"redis@sha256:399a9b17b8522e24fbe2fd3b42474d4bb668d3994153c4b5d38c3dafd5903e32\" ], \"Parent\": \"\", \"Comment\": \"\", \"Created\": \"2020-05-02T01:40:19.112130797Z\", \"Container\": \"d30c0bcea88561bc5139821227d2199bb027eeba9083f90c701891b4affce3bc\", \"ContainerConfig\": { \"Hostname\": \"d30c0bcea885\", \"Domainname\": \"\", \"User\": \"\", \"AttachStdin\": false, \"AttachStdout\": false, \"AttachStderr\": false, \"ExposedPorts\": { \"6379/tcp\": {} }, \"Tty\": false, \"OpenStdin\": false, \"StdinOnce\": false, \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"GOSU_VERSION=1.12\", \"REDIS_VERSION=6.0.1\", \"REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz\", \"REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273\" ], \"Cmd\": [ \"/bin/sh\", \"-c\", \"#(nop) \", \"CMD [\\\"redis-server\\\"]\" ], \"ArgsEscaped\": true, \"Image\": \"sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0\", \"Volumes\": { \"/data\": {} }, \"WorkingDir\": \"/data\", \"Entrypoint\": [ \"docker-entrypoint.sh\" ], \"OnBuild\": null, \"Labels\": {} }, \"DockerVersion\": \"18.09.7\", \"Author\": \"\", \"Config\": { \"Hostname\": \"\", \"Domainname\": \"\", \"User\": \"\", \"AttachStdin\": false, \"AttachStdout\": false, \"AttachStderr\": false, \"ExposedPorts\": { \"6379/tcp\": {} }, \"Tty\": false, \"OpenStdin\": false, \"StdinOnce\": false, \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"GOSU_VERSION=1.12\", \"REDIS_VERSION=6.0.1\", \"REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz\", \"REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273\" ], \"Cmd\": [ \"redis-server\" ], \"ArgsEscaped\": true, \"Image\": \"sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0\", \"Volumes\": { \"/data\": {} }, \"WorkingDir\": \"/data\", \"Entrypoint\": [ \"docker-entrypoint.sh\" ], \"OnBuild\": null, \"Labels\": null }, \"Architecture\": \"amd64\", \"Os\": \"linux\", \"Size\": 104101893, \"VirtualSize\": 104101893, \"GraphDriver\": { \"Data\": { \"LowerDir\": \"/var/lib/docker/overlay2/adea96bbe6518657dc2d4c6331a807eea70567144abda686588ef6c3bb0d778a/diff:/var/lib/docker/overlay2/66abd822d34dc6446e6bebe73721dfd1dc497c2c8063c43ffb8cf8140e2caeb6/diff:/var/lib/docker/overlay2/d19d24fb6a24801c5fa639c1d979d19f3f17196b3c6dde96d3b69cd2ad07ba8a/diff:/var/lib/docker/overlay2/a1e95aae5e09ca6df4f71b542c86c677b884f5280c1d3e3a1111b13644b221f9/diff:/var/lib/docker/overlay2/cd90f7a9cd0227c1db29ea992e889e4e6af057d9ab2835dd18a67a019c18bab4/diff\", \"MergedDir\": \"/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/merged\", \"UpperDir\": \"/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/diff\", \"WorkDir\": \"/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/work\" }, \"Name\": \"overlay2\" }, \"RootFS\": { \"Type\": \"layers\", \"Layers\": [ \"sha256:c2adabaecedbda0af72b153c6499a0555f3a769d52370469d8f6bd6328af9b13\", \"sha256:744315296a49be711c312dfa1b3a80516116f78c437367ff0bc678da1123e990\", \"sha256:379ef5d5cb402a5538413d7285b21aa58a560882d15f1f553f7868dc4b66afa8\", \"sha256:d00fd460effb7b066760f97447c071492d471c5176d05b8af1751806a1f905f8\", \"sha256:4d0c196331523cfed7bf5bafd616ecb3855256838d850b6f3d5fba911f6c4123\", \"sha256:98b4a6242af2536383425ba2d6de033a510e049d9ca07ff501b95052da76e894\" ] }, \"Metadata\": { \"LastTagTime\": \"0001-01-01T00:00:00Z\" } } ] 理解： 所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。 举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。 在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点. 在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。 上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版。 这种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中，Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统 Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的文件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。 Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW 。 下图展示了与系统显示相同的三层镜像。所有镜像层堆并合井，对外提供统一的视图。 特点 Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！ 这一层就是我们通常说的容器层，容器之下的都叫镜像层！ commit镜像docker commit 提交容器成为一个新的副本 # 命令和git原理类似 docker commit -m=\"描述信息\" -a=\"作者\" 容器id 目标镜像名:[版本TAG] 实战测试 # 1、启动一个默认的tomcat [root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 tomcat de57d0ace5716d27d0e3a7341503d07ed4695ffc266aef78e0a855b270c4064e # 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！ #docker exec -it 容器id /bin/bash [root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it de57d0ace571 /bin/bash root@de57d0ace571:/usr/local/tomcat# # 3、从webapps.dist拷贝文件进去webapp root@de57d0ace571:/usr/local/tomcat# cp -r webapps.dist/* webapps root@de57d0ace571:/usr/local/tomcat# cd webapps root@de57d0ace571:/usr/local/tomcat/webapps# ls ROOT docs examples host-manager manager # 4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，而不需要每次都重新拷贝webapps.dist下的文件到webapps了，这就是我们自己的一个修改的镜像。 docker commit -m=\"描述信息\" -a=\"作者\" 容器id 目标镜像名:[TAG] docker commit -a=\"kuangshen\" -m=\"add webapps app\" 容器id tomcat02:1.0 [root@iz2zeak7sgj6i7hrb2g862z ~]# docker commit -a=\"csp提交的\" -m=\"add webapps app\" de57d0ace571 tomcat02:1.0 sha256:d5f28a0bb0d0b6522fdcb56f100d11298377b2b7c51b9a9e621379b01cf1487e [root@iz2zeak7sgj6i7hrb2g862z ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE tomcat02 1.0 d5f28a0bb0d0 14 seconds ago 652MB tomcat latest 1b6b1fe7261e 5 days ago 647MB nginx latest 9beeba249f3e 5 days ago 127MB mysql 5.7 b84d68d0a7db 5 days ago 448MB elasticsearch 7.6.2 f29a1ee41030 8 weeks ago 791MB portainer/portainer latest 2869fc110bf7 2 months ago 78.6MB centos latest 470671670cac 4 months ago 237MB hello-world latest bf756fb1ae65 4 months ago 13.3kB 如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比我们我们使用虚拟机的快照。 容器数据卷什么是容器数据卷将应用和环境打包成一个镜像！ 数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化 MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！ 容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！ 这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！ 总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！ 使用数据卷 方式一 ：直接使用命令挂载 -v -v, --volume list Bind mount a volume docker run -it -v 主机目录:容器内目录 -p 主机端口:容器内端口 # /home/ceshi：主机home目录下的ceshi文件夹 映射：centos容器中的/home [root@iz2zeak7 home]# docker run -it -v /home/ceshi:/home centos /bin/bash #这时候主机的/home/ceshi文件夹就和容器的/home文件夹关联了,二者可以实现文件或数据同步了 #通过 docker inspect 容器id 查看 [root@iz2zeak7sgj6i7hrb2g862z home]# docker inspect 6064c490c371 测试文件的同步 再来测试！ 1、停止容器 2、宿主机修改文件 3、启动容器 4、容器内的数据依旧是同步的 好处：我们以后修改只需要在本地修改即可，容器内会自动同步！ 实战：安装MySQL思考：MySQL的数据持久化的问题 # 获取mysql镜像 [root@iz2zeak7sgj6i7hrb2g862z home]# docker pull mysql:5.7 # 运行容器,需要做数据挂载 #安装启动mysql，需要配置密码的，这是要注意点！ # 参考官网hub docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag #启动我们得 -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 -- name 容器名字 $ docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql03 mysql:5.7 # 启动成功之后，我们在本地使用sqlyog来测试一下 # sqlyog-连接到服务器的3306--和容器内的3306映射 # 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！ 测试连接：注意3310端口要在阿里云服务器的安全组中打开，否则无法连接。 当我们在本地用SQLyog新建名称为test的数据库时候，容器容器也会创建 假设我们将包含mysql的容器删除时， 发现，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能。 具名和匿名挂载# 匿名挂载 -v 容器内路径! $ docker run -d -P --name nginx01 -v /etc/nginx nginx # 查看所有的volume(卷)的情况 $ docker volume ls DRIVER VOLUME NAME # 容器内的卷名(匿名卷挂载) local 21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0 local b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c # 这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路径！ # 具名挂载 -P:表示随机映射端口 $ docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx 9663cfcb1e5a9a1548867481bfddab9fd7824a6dc4c778bf438a040fe891f0ee # 查看所有的volume(卷)的情况 $ docker volume ls DRIVER VOLUME NAME local 21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0 local b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c local juming-nginx #多了一个名字 # 通过 -v 卷名：查看容器内路径 # 查看一下这个卷 $ docker volume inspect juming-nginx [ { \"CreatedAt\": \"2020-05-23T13:55:34+08:00\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/juming-nginx/_data\", #默认目录 \"Name\": \"juming-nginx\", \"Options\": null, \"Scope\": \"local\" } ] 所有的docker容器内的卷，没有指定目录的情况下都是在**/var/lib/docker/volumes/自定义的卷名/_data下，**如果指定了目录，docker volume ls 是查看不到的。 区分三种挂载方式 # 三种挂载： 匿名挂载、具名挂载、指定路径挂载 -v 容器内路径 #匿名挂载 -v 卷名：容器内路径 #具名挂载 -v /宿主机路径：容器内路径 #指定路径挂载 docker volume ls 是查看不到的 拓展： # 通过 -v 容器内路径： ro rw 改变读写权限 ro #readonly 只读 rw #readwrite 可读可写 $ docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx $ docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx # ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！ 初始DockerfileDockerfile 就是用来构建docker镜像的构建文件！命令脚本！先体验一下！ 通过这个脚本可以生成镜像，镜像是一层一层的，脚本是一个个的命令，每个命令都是一层！ # 创建一个dockerfile文件，名字可以随便 建议Dockerfile # 文件中的内容： 指令(大写) + 参数 $ vim dockerfile1 FROM centos # 当前这个镜像是以centos为基础的 VOLUME [\"volume01\",\"volume02\"] # 挂载卷的卷目录列表(多个目录) CMD echo \"-----end-----\" # 输出一下用于测试 CMD /bin/bash # 默认走bash控制台 # 这里的每个命令，就是镜像的一层！ # 构建出这个镜像 -f dockerfile1 # f代表file，指这个当前文件的地址(这里是当前目录下的dockerfile1) -t caoshipeng/centos # t就代表target，指目标目录(注意caoshipeng镜像名前不能加斜杠‘/’，后面可以加版本号 镜像名:版本号 ) . # 表示生成在当前目录下 $ docker build -f dockerfile1 -t caoshipeng/centos . Sending build context to Docker daemon 2.56kB Step 1/4 : FROM centos latest: Pulling from library/centos 8a29a15cefae: Already exists Digest: sha256:fe8d824220415eed5477b63addf40fb06c3b049404242b31982106ac204f6700 Status: Downloaded newer image for centos:latest ---&gt; 470671670cac Step 2/4 : VOLUME [\"volume01\",\"volume02\"] # 卷名列表 ---&gt; Running in c18eefc2c233 Removing intermediate container c18eefc2c233 ---&gt; 623ae1d40fb8 Step 3/4 : CMD echo \"-----end-----\" # 输出 脚本命令 ---&gt; Running in 70e403669f3c Removing intermediate container 70e403669f3c ---&gt; 0eba1989c4e6 Step 4/4 : CMD /bin/bash ---&gt; Running in 4342feb3a05b Removing intermediate container 4342feb3a05b ---&gt; f4a6b0d4d948 Successfully built f4a6b0d4d948 Successfully tagged caoshipeng/centos:latest # 查看自己构建的镜像 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE caoshipeng/centos latest f4a6b0d4d948 About a minute ago 237MB 启动自己写的容器镜像 $ docker run -it f4a6b0d4d948 /bin/bash # 运行自己写的镜像 $ ls -l # 查看目录 这个卷和外部一定有一个同步的目录 查看一下卷挂载 # docker inspect 容器id $ docker inspect ca3b45913df5 测试一下刚才的文件是否同步出去了！ 这种方式使用的十分多，因为我们通常会构建自己的镜像！ 假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名：容器内路径！ 数据卷容器多个MySQL同步数据！ 命名的容器挂载数据卷！ # 测试 启动3个容器，通过刚才自己写的镜像启动 # 创建docker01：因为我本机是最新版，故这里用latest，狂神老师用的是1.0如下图 $ docker run -it --name docker01 caoshipeng/centos:latest # 查看容器docekr01内容 $ ls bin home lost+found opt run sys var dev lib media proc sbin tmp volume01 etc lib64 mnt root srv usr volume02 # 不关闭该容器退出 CTRL + Q + P # 创建docker02: 并且让docker02 继承 docker01 $ docker run -it --name docker02 --volumes-from docker01 caoshipeng/centos:latest # 查看容器docker02内容 $ ls bin home lost+found opt run sys var dev lib media proc sbin tmp volume01 etc lib64 mnt root srv usr volume02 # 再新建一个docker03同样继承docker01 $ docker run -it --name docker03 --volumes-from docker01 caoshipeng/centos:latest $ cd volume01 #进入volume01 查看是否也同步docker01的数据 $ ls docker01.txt # 测试：可以删除docker01，查看一下docker02和docker03是否可以访问这个文件 # 测试发现：数据依旧保留在docker02和docker03中没有被删除 多个mysql实现数据共享 $ docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 $ docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7 # 这个时候，可以实现两个容器数据同步！ 结论： 容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。 但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！ DockerFileDockerFile介绍dockerfile是用来构建docker镜像的文件！命令参数脚本！ 构建步骤： 1、 编写一个dockerfile文件 2、 docker build 构建称为一个镜像 3、 docker run运行镜像 4、 docker push发布镜像（DockerHub 、阿里云仓库) 点击后跳到一个Dockerfile 很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！ DockerFile构建过程基础知识： 1、每个保留关键字(指令）都是必须是大写字母 2、执行从上到下顺序 3、#表示注释 4、每一个指令都会创建提交一个新的镜像层，并提交！ Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！ Docker镜像逐渐成企业交付的标准，必须要掌握！ DockerFile：构建文件，定义了一切的步骤，源代码 DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。 Docker容器：容器就是镜像运行起来提供服务。 DockerFile的指令FROM # 基础镜像，一切从这里开始构建 MAINTAINER # 镜像是谁写的， 姓名+邮箱 RUN # 镜像构建的时候需要运行的命令 ADD # 步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录 WORKDIR # 镜像的工作目录 VOLUME # 挂载的目录 EXPOSE # 保留端口配置 CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代 ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD # 当构建一个被继承 DockerFile 这个时候就会运行onbuild的指令，触发指令 COPY # 类似ADD，将我们文件拷贝到镜像中 ENV # 构建的时候设置环境变量！ 实战测试scratch 镜像 FROM scratch ADD centos-7-x86_64-docker.tar.xz / LABEL \\ org.label-schema.schema-version=\"1.0\" \\ org.label-schema.name=\"CentOS Base Image\" \\ org.label-schema.vendor=\"CentOS\" \\ org.label-schema.license=\"GPLv2\" \\ org.label-schema.build-date=\"20200504\" \\ org.opencontainers.image.title=\"CentOS Base Image\" \\ org.opencontainers.image.vendor=\"CentOS\" \\ org.opencontainers.image.licenses=\"GPL-2.0-only\" \\ org.opencontainers.image.created=\"2020-05-04 00:00:00+01:00\" CMD [\"/bin/bash\"] Docker Hub 中 99%的镜像都是从这个基础镜像过来的 FROM scratch，然后配置需要的软件和配置来进行构建。 创建一个自己的centos # 1./home下新建dockerfile目录 $ mkdir dockerfile # 2. dockerfile目录下新建mydockerfile-centos文件 $ vim mydockerfile-centos # 3.编写Dockerfile配置文件 FROM centos # 基础镜像是官方原生的centos MAINTAINER cao&lt;1165680007@qq.com&gt; # 作者 ENV MYPATH /usr/local # 配置环境变量的目录 WORKDIR $MYPATH # 将工作目录设置为 MYPATH RUN yum -y install vim # 给官方原生的centos 增加 vim指令 RUN yum -y install net-tools # 给官方原生的centos 增加 ifconfig命令 EXPOSE 80 # 暴露端口号为80 CMD echo $MYPATH # 输出下 MYPATH 路径 CMD echo \"-----end----\" CMD /bin/bash # 启动后进入 /bin/bash # 4.通过这个文件构建镜像 # 命令： docker build -f 文件路径 -t 镜像名:[tag] . $ docker build -f mydockerfile-centos -t mycentos:0.1 . # 5.出现下图后则构建成功 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mycentos 0.1 cbf5110a646d 2 minutes ago 311MB # 6.测试运行 $ docker run -it mycentos:0.1 # 注意带上版本号，否则每次都回去找最新版latest $ pwd /usr/local # 与Dockerfile文件中 WORKDIR 设置的 MYPATH 一致 $ vim # vim 指令可以使用 $ ifconfig # ifconfig 指令可以使用 # docker history 镜像id 查看镜像构建历史步骤 $ docker history 镜像id 我们可以列出本地进行的变更历史 我们平时拿到一个镜像，可以用 “docker history 镜像id” 研究一下是什么做的 CMD 和 ENTRYPOINT区别 CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。 ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令 测试cmd # 编写dockerfile文件 $ vim dockerfile-test-cmd FROM centos CMD [\"ls\",\"-a\"] # 启动后执行 ls -a 命令 # 构建镜像 $ docker build -f dockerfile-test-cmd -t cmd-test:0.1 . # 运行镜像 $ docker run cmd-test:0.1 # 由结果可得，运行后就执行了 ls -a 命令 . .. .dockerenv bin dev etc home # 想追加一个命令 -l 成为ls -al：展示列表详细数据 $ docker run cmd-test:0.1 -l docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused \"exec: \\\"-l\\\": executable file not found in $PATH\": unknown. ERRO[0000] error waiting for container: context canceled # cmd的情况下 -l 替换了CMD[\"ls\",\"-l\"] 而 -l 不是命令所以报错 测试ENTRYPOINT # 编写dockerfile文件 $ vim dockerfile-test-entrypoint FROM centos ENTRYPOINT [\"ls\",\"-a\"] # 构建镜像 $ docker build -f dockerfile-test-entrypoint -t cmd-test:0.1 . # 运行镜像 $ docker run entrypoint-test:0.1 . .. .dockerenv bin dev etc home lib lib64 lost+found ... # 我们的命令，是直接拼接在我们得ENTRYPOINT命令后面的 $ docker run entrypoint-test:0.1 -l total 56 drwxr-xr-x 1 root root 4096 May 16 06:32 . drwxr-xr-x 1 root root 4096 May 16 06:32 .. -rwxr-xr-x 1 root root 0 May 16 06:32 .dockerenv lrwxrwxrwx 1 root root 7 May 11 2019 bin -&gt; usr/bin drwxr-xr-x 5 root root 340 May 16 06:32 dev drwxr-xr-x 1 root root 4096 May 16 06:32 etc drwxr-xr-x 2 root root 4096 May 11 2019 home lrwxrwxrwx 1 root root 7 May 11 2019 lib -&gt; usr/lib lrwxrwxrwx 1 root root 9 May 11 2019 lib64 -&gt; usr/lib64 .... Dockerfile中很多命令都十分的相似，我们需要了解它们的区别，我们最好的学习就是对比他们然后测试效果！ 实战：Tomcat镜像1、准备镜像文件准备tomcat 和 jdk 到当前目录，编写好README 2、编写dokerfile$ vim Dockerfile FROM centos # 基础镜像centos MAINTAINER cao&lt;1165680007@qq.com&gt; # 作者 COPY README /usr/local/README # 复制README文件 ADD jdk-8u231-linux-x64.tar.gz /usr/local/ # 添加jdk，ADD 命令会自动解压 ADD apache-tomcat-9.0.35.tar.gz /usr/local/ # 添加tomcat，ADD 命令会自动解压 RUN yum -y install vim # 安装 vim 命令 ENV MYPATH /usr/local # 环境变量设置 工作目录 WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_231 # 环境变量： JAVA_HOME环境变量 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.35 # 环境变量： tomcat环境变量 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.35 # 设置环境变量 分隔符是： ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 # 设置暴露的端口 CMD /usr/local/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.35/logs/catalina.out # 设置默认命令 3、构建镜像# 因为dockerfile命名使用默认命名 因此不用使用-f 指定文件 $ docker build -t mytomcat:0.1 . 4、run镜像# -d:后台运行 -p:暴露端口 --name:别名 -v:绑定路径 $ docker run -d -p 8080:8080 --name tomcat01 -v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test -v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.35/logs mytomcat:0.1 5、访问测试$ docker exec -it 自定义容器的id /bin/bash $ curl localhost:8080 6、发布项目(由于做了卷挂载，我们直接在本地编写项目就可以发布了！) 发现：项目部署成功，可以直接访问！ 我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！ 发布自己的镜像 发布到 Docker Hub 1、地址 https://hub.docker.com/ 2、确定这个账号可以登录 3、登录 $ docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username $ docker login -u 你的用户名 -p 你的密码 4、提交 push镜像 # 会发现push不上去，因为如果没有前缀的话默认是push到 官方的library # 解决方法： # 第一种 build的时候添加你的dockerhub用户名，然后再push就可以放到自己的仓库了 $ docker build -t kuangshen/mytomcat:0.1 . # 第二种 使用docker tag 然后再次push $ docker tag 容器id kuangshen/mytomcat:1.0 #然后再次push $ docker push kuangshen/mytomcat:1.0 发布到 阿里云镜像服务上 看官网 很详细https://cr.console.aliyun.com/repository/ 1.创建命名空间 2.创建镜像仓库 3.点击镜像仓库，查看基本信息和镜像操作步骤 $ sudo docker login --username=起名字是个问题阿 registry.cn-shenzhen.aliyuncs.com #登录 $ sudo docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/xudongyin/test:[镜像版本号] #镜像版本号自己定义 $ sudo docker push registry.cn-shenzhen.aliyuncs.com/xudongyin/test:[镜像版本号] # 根据id 修改镜像命名 $sudo docker tag a5ef1f32aaae registry.cn-shenzhen.aliyuncs.com/xudongyin/test:1.0 # 上传镜像 $ sudo docker push registry.cn-shenzhen.aliyuncs.com/xudongyin/test:1.0 小结 Docker 网络理解Docker 0学习之前清空下前面的docker 镜像、容器 # 删除全部容器 $ docker rm -f $(docker ps -aq) # 删除全部镜像 $ docker rmi -f $(docker images -aq) 测试 三个网络 问题： docker 是如果处理容器网络访问的？ # 测试 运行一个tomcat $ docker run -d -P --name tomcat01 tomcat # 查看容器内部网络地址 $ docker exec -it 容器id ip addr # 发现容器启动的时候会得到一个 eth0@if91 ip地址，docker分配！ 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 261: eth0@if91: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0 valid_lft forever preferred_lft forever # 思考？ linux能不能ping通容器内部！ 可以 容器内部可以ping通外界吗？ 可以！ $ ping 172.18.0.2 PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data. 64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.069 ms 64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.074 ms 原理 1、我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个docker0桥接模式，使用的技术是veth-pair技术！ 讲解veth-pair 技术的博客 https://www.cnblogs.com/bakari/p/10613710.html 再次测试 ip addr 2 、再启动一个容器测试，发现又多了一对网络 # 我们发现这个容器带来网卡，都是一对对的 # veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连 # 正因为有这个特性 veth-pair 充当一个桥梁，连接各种虚拟网络设备的 # OpenStac,Docker容器之间的连接，OVS的连接，都是使用evth-pair技术 3、我们来测试下tomcat01和tomcat02是否可以ping通 # 获取tomcat01的ip 172.17.0.2 $ docker-tomcat docker exec -it tomcat01 ip addr 550: eth0@if551: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 让tomcat02 ping tomcat01 $ docker-tomcat docker exec -it tomcat02 ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data. 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.098 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.071 ms # 结论：容器和容器之间是可以互相ping通 网络模型图 结论：tomcat01和tomcat02共用一个路由器，docker0。 所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip。 小结 Docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥 docker0 Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件） 只要容器删除，对应的网桥一对就没了！ 思考一个场景：我们编写了一个微服务，database url=ip: 项目不重启，数据ip换了，我们希望可以处理这个问题，可以通过名字来进行访问容器？ –-link$ docker exec -it tomcat02 ping tomca01 # ping不通 ping: tomca01: Name or service not known # 运行一个tomcat03 --link tomcat02 $ docker run -d -P --name tomcat03 --link tomcat02 tomcat 5f9331566980a9e92bc54681caaac14e9fc993f14ad13d98534026c08c0a9aef # 3连接2 # 用tomcat03 ping tomcat02 可以ping通 $ docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.115 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.080 ms # 2连接3 $ docker exec -it tomcat02 ping tomca03 # ping不通 ping: tomcat03: Name or service not known 探究： #查看所有网络指令 [root@iZwz97ikj14iruzlnq4vr3Z /]# docker network --help #查看所有网段 [root@iZwz97ikj14iruzlnq4vr3Z /]# docker network ls NETWORK ID NAME DRIVER SCOPE 80c4ffaf3459 bridge bridge local 8fcb7145beb0 host host local 853163a1e0db none null local #查看指定网络的信息 [root@iZwz97ikj14iruzlnq4vr3Z /]# docker network inspect 80c4ffaf3459 [root@iZwz97ikj14iruzlnq4vr3Z /]# docker inspect tomcat03 [root@iZwz97ikj14iruzlnq4vr3Z /]# docker inspect tomcat02 查看tomcat03里面的/etc/hosts发现有tomcat02的配置 –link 本质就是在hosts配置中添加映射 现在使用Docker已经不建议使用–link了！ 自定义网络，不适用docker0！ docker0问题：不支持容器名连接访问！ 自定义网络docker network connect -- Connect a container to a network create -- Creates a new network with a name specified by the disconnect -- Disconnects a container from a network inspect -- Displays detailed information on a network ls -- Lists all the networks created by the user prune -- Remove all unused networks rm -- Deletes one or more networks 查看所有的docker网络 网络模式 bridge ：桥接 docker（默认，自己创建也是用bridge模式） none ：不配置网络，一般不用 host ：和宿主机共享网络 container ：容器网络连通（用得少！局限很大） 测试 # 我们直接启动的命令 --net bridge,而这个就是我们得docker0 # bridge就是docker0 $ docker run -d -P --name tomcat01 tomcat 等价于 =&gt; docker run -d -P --name tomcat01 --net bridge tomcat # docker0，特点：默认，域名不能访问。 --link可以打通连接，但是很麻烦！ # 我们可以 自定义一个网络 $ docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet $ docker network inspect mynet; 启动两个tomcat,再次查看网络情况 在自定义的网络下，服务可以互相ping通，不用使用–link 我们自定义的网络docker当我们维护好了对应的关系，推荐我们平时这样使用网络！ 好处： redis -不同的集群使用不同的网络，保证集群是安全和健康的 mysql-不同的集群使用不同的网络，保证集群是安全和健康的 网络连通 # 测试两个不同的网络连通 再启动两个tomcat 使用默认网络，即docker0 $ docker run -d -P --name tomcat01 tomcat $ docker run -d -P --name tomcat02 tomcat # 此时ping不通 # 要将tomcat01 连通 tomcat—net-01 ，连通就是将 tomcat01加到 mynet网络 # 一个容器两个ip（tomcat01） [root@iZwz97ikj14iruzlnq4vr3Z /]# docker network connect mynet tomcat01 [root@iZwz97ikj14iruzlnq4vr3Z /]# docker exec -it tomcat01 ping tomcat-mynet01 PING tomcat-mynet01 (192.168.0.2) 56(84) bytes of data. 64 bytes from tomcat-mynet01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.122 ms 64 bytes from tomcat-mynet01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.107 ms ^C --- tomcat-mynet01 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1ms rtt min/avg/max/mdev = 0.107/0.114/0.122/0.013 ms # 01连通 ，加入后此时，已经可以tomcat01 和 tomcat-01-net ping通了 # 02是依旧不通的 结论：假设要跨网络操作别人，就需要使用docker network connect 连通！ 实战：部署Redis集群 # 创建网卡 docker network create redis --subnet 172.38.0.0/16 # 通过脚本创建六个redis配置 for port in $(seq 1 6);\\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat &lt;&lt; EOF &gt;&gt; /mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done # 通过脚本运行六个redis for port in $(seq 1 6);\\ do docker run -p 637${port}:6379 -p 1667${port}:16379 --name redis-${port} \\ -v /mydata/redis/node-${port}/data:/data \\ -v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf done #进入redis docker exec -it redis-1 /bin/sh #redis默认没有bash #进行集群开启配置 redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1 docker搭建redis集群完成！ /data # redis-cli -c #进入 redis 客户端 127.0.0.1:6379&gt; cluster nodes 789f0f51aa46656d9754e9785ab4aa2c5962fd0b 172.38.0.11:6379@16379 myself,master - 0 1605607079000 1 connected 0-5460 60c6c6ce439d8aa19e6485c5fc6df80e074037f5 172.38.0.12:6379@16379 master - 0 1605607079408 2 connected 5461-10922 71d85b690af2c616fc95a9d664dbe6d025d50936 172.38.0.16:6379@16379 slave 60c6c6ce439d8aa19e6485c5fc6df80e074037f5 0 1605607079507 6 connected 650e4b3d95035fa72295ab3a36d2b3783f3b6864 172.38.0.13:6379@16379 master - 0 1605607079000 3 connected 10923-16383 087c5c3db81521d01ebe004e075e318e89f417fe 172.38.0.14:6379@16379 slave 650e4b3d95035fa72295ab3a36d2b3783f3b6864 0 1605607078405 4 connected 11ab2149e88c3a99a8d6937b789c705436ac1e32 172.38.0.15:6379@16379 slave 789f0f51aa46656d9754e9785ab4aa2c5962fd0b 0 1605607078000 5 connected 127.0.0.1:6379&gt; set a b -&gt; Redirected to slot [15495] located at 172.38.0.13:6379 OK #此时关闭 redis-1 ，进入 redis-2 172.38.0.13:6379&gt; [root@iZwz97ikj14iruzlnq4vr3Z xu]# docker exec -it redis-2 /bin/sh /data # redis-cli -c 127.0.0.1:6379&gt; get a -&gt; Redirected to slot [15495] located at 172.38.0.13:6379 \"b\" #退出 redis-2 172.38.0.13:6379&gt; exit /data # exit #进入 redis-5 [root@iZwz97ikj14iruzlnq4vr3Z xu]# docker exec -it redis-5 /bin/sh /data # redis-cli -c 127.0.0.1:6379&gt; get a -&gt; Redirected to slot [15495] located at 172.38.0.13:6379 \"b\" #此时集群状态 172.38.0.13:6379&gt; cluster nodes 087c5c3db81521d01ebe004e075e318e89f417fe 172.38.0.14:6379@16379 slave 650e4b3d95035fa72295ab3a36d2b3783f3b6864 0 1605607380897 4 connected 71d85b690af2c616fc95a9d664dbe6d025d50936 172.38.0.16:6379@16379 slave 60c6c6ce439d8aa19e6485c5fc6df80e074037f5 0 1605607379391 6 connected 789f0f51aa46656d9754e9785ab4aa2c5962fd0b 172.38.0.11:6379@16379 master,fail - 1605607149672 1605607148000 1 connected # redis-1 失效 60c6c6ce439d8aa19e6485c5fc6df80e074037f5 172.38.0.12:6379@16379 master - 0 1605607380000 2 connected 5461-10922 11ab2149e88c3a99a8d6937b789c705436ac1e32 172.38.0.15:6379@16379 master - 0 1605607380395 7 connected 0-5460 650e4b3d95035fa72295ab3a36d2b3783f3b6864 172.38.0.13:6379@16379 myself,master - 0 1605607380000 3 connected 10923-16383 我们使用docker之后，所有的技术都会慢慢变得简单起来！ SpringBoot微服务打包Docker镜像1、构建SpringBoot项目 2、打包运行 mvn package 3、编写dockerfile FROM java:8 COPY *.jar /app.jar CMD [\"--server.port=8080\"] EXPOSE 8080 ENTRYPOINT [\"java\",\"-jar\",\"app.jar\"] 4、构建镜像 # 1.复制jar和DockerFIle到服务器 # 2.构建镜像 $ docker build -t xxxxx:xx . 5、发布运行 以后我们使用了Docker之后，给别人交付就是一个镜像即可！ Docker Compose简介原来Docker根据Dockerfile来创建运行镜像都是手动操作，并且操作的是单个容器，如果要运行多个容器做微服务的话这样是很不方便的。 Docker Compose 可以定义运行多个容器，轻松高效的管理容器。 官方介绍 定义、运行多个容器。YAML file配置文件。single command。命令 有哪些? Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see the list of features. 所有的环境都可以使用 Compose Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in Common Use Cases. 三步骤： Using Compose is basically a three-step process: Define your app’s environment withal Dockerfile so it can be reproduced anywhere. Dockerfile保证我们的项目在任何地方都可以运行 Define the services that make up your app in docker-compose. yml so they can be run together in an isolated environment. services 什么是服务 docker-compose.yml 这个文件怎么写 Run docker-compose up and Compose starts and runs your entire app. 启动项目 作用：批量容器编排 Compose 理解 Compose是Docker官方的开源项目。需要安装!Dockerfile 让程序在任何地方运行。 web服务。 redis、 mysql、nginx… 多个容器。runCompose version: \"3.8\" services: web: build: . ports: - \"5000:5000\" volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis volumes: logvolume01: {} docker-compose up 100 个服务。 Compose :重要的概念。 服务services， 容器。 应用。比如 web、 redis、 mysl…. 项目project。 一组关联的容器。比如博客系统，由 web、mysql、wp组成 安装1、下载 sudo curl -L \"https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose #这个可能快点! curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 2、授权 sudo chmod +x /usr/local/bin/docker-compose 体验地址: https://docs.docker.com/compose/gettingstarted/ 一个python应用。计数器。使用了redis! 准备工作 $ mkdir composetest #创建项目目录 $ cd composetest #进入目录 2. 创建应用 app.py ~~~shell import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) if __name__ == \"__main__\": app.run(host=\"0.0.0.0\",debug=True) 创建 requirements.txt flask redis 创建 Dockerfile ，应用打包为镜像 #用官方这个 Dockerfile 会使用到 flask 框架，下载极慢 FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP=app.py ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers COPY requirements.txt requirements.txt RUN pip install -r requirements.txt EXPOSE 5000 COPY . . CMD [\"flask\", \"run\"] #将官方的 Dockerfile 修改为下面 FROM python:3.6-alpine ADD . /code WORKDIR /code RUN pip install -r requirements.txt CMD [\"python\", \"app.py\"] #这告诉 Docker: #从 Python3.6 映像开始构建映像。 #将当前目录添加 . 到 /code 映像中的路径中。 #将工作目录设置为 /code. #安装 Python 依赖项。 #将容器的默认命令设置为 python app.py。 创建 docker-compose.yml 文件 (定义整个服务, 需要的环境。web、 redis) 完整的上线服务! version: \"3.8\" services: web: build: . ports: - \"5000:5000\" volumes: - .:/code redis: image: \"redis:alpine\" 运行项目 docker-compose up 项目运行成功 如果项目运行不起来，就先执行 docker-compose build ,然后再执行 docker-compose up 流程:1、创建网络2、执行Docker-compose yaml3、启动服务。Starting composetest_web_1 … doneStarting composetest_redis_1 … done 只执行一句 docker-compose up 就自动把需要的镜像都下载了 [root@iZwz97ikj14iruzlnq4vr3Z ~]# docker service ls Error response from daemon: This node is not a swarm manager. Use \"docker swarm init\" or \"docker swarm join\" to connect this node to swarm and try again. 默认的服务名 文件名_ 服务名 _ num多个服务器。集群A 、 B。 num就是副本数量服务redis服务=&gt; 4个副本。集群状态。服务都不可能只有一个运行实例。弹性、10 HA 高并发。kubectl service 负载均衡。 网络规则 启动项目，会自动创建一个网络，项目里面的所有服务容器都是在同一个网络下，并且支持域名访问 Ctrl+c 停止运行 docker-compose以前都是单个docker run启动容器。Docker Compose 通过docker-compose编写yaml配置文件、可以通过 compose 一键启动所有服务以及停止。 yaml 规则文档 https://docs.docker.com/compose/compose-file/ # 3层 version: \"\" # 版本 services: # 服务 redis: # 服务配置 image: redis:alpine ports: - \"6379\" networks: - frontend deploy: replicas: 2 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure # 其他配置：网络、数据卷、全局规则 networks: volumes: configs: 一个开源博客项目 文档 https://docs.docker.com/compose/wordpress/ 1、创建项目目录，进入目录 mkdir my_wordpress cd my_wordpress/ 2、编写 docker-compose.yml 文件 version: '3.3' services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - \"8000:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: {} 3、运行项目 docker-compose up -d 后台运行 用 docker-compose down 关闭 docker-compose up 前台运行 用 Ctrl+c 关闭 实战1、编写项目微服务 2、编写 Dockerfile FROM java:8 COPY *.jar /app.jar CMD [\"--server.port=8080\"] EXPOSE 8080 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] 3、编写 docker-compose.yml version: \"3.8\" services: xuapp: build: . image: xuapp depends_on: - redis ports: - \"3344:8080\" redis: image: redis 4、丢到服务器， docker-compose up运行 如果项目想重新部署构建，执行docker-compose up --bulid docker-compose up --bulid # 项目重新部署构建 小结 项目根据 docker-compose.yml 文件进行启动编排容器，未来项目只要 docker-compose up 直接运行。 工程、服务、容器 项目compose：三层 工程Porject 服务服务 容器运行实例！ docker k8s 容器 . . Docker Swarm准备工作购买服务器购买4台服务器 到此，服务器购买完毕，1主 3从！ 4台服务器都安装Docker 工作模式 搭建集群 这里 docker swarm init --advertise-addr 172.24.82.149 添加的 ip 是服务器私网，用私网不用流量也就是不用钱，用公网就要流量也就是要花钱，使用 ip addr 就可以查看服务器的 私网 ip 初始化主节点 docker swarm init docker swarm join 加入到一个节点！ # 获取令牌 docker swarm join-token manager #会生成一段命令字符串，别的服务器上运行这个命令就成为了当前主机的 manager 节点 docker swarm join-token worker #会生成一段命令字符串，别的服务器上运行这个命令就成为了当前主机的 worker 节点 1、生成主节点 init 2、加入（管理者，worker） 目标：双主双从，Leader 和 manager 节点都是主节点 Raft协议双主双从：假设一个节点挂了，其他节点是否可用？ Raft 协议：保证主节点存活过半（大于总结点数/2的整数值）才可以用。 实验： 1、将docker1机器停止，宕机！双主下，另一个主节点也不能使用了！因为 1 不大于 2/2，只是等于 2、再重新启动 docker1，此时 docker1 已不再是 Leader，而是 manager 节点 3、如果节点离开集群，STATUS 字段会变成 Down docker swarm leave # 节点离开集群 4、worker节点是工作的，manager节点是来操作管理节点的 体会弹性、扩缩容 ! 集群 !以后告别 docker run !docker-compose up ! 启动一个项目 。单机 !集群: swarmdocker serivce容器=&gt;服务! =&gt;副本!redis服务=&gt; 10个副本! (同时开启10个redis容器)体验：创建服务、动态扩展服务、动态更新服务 灰度发布：金丝雀发布！ docker run 容器启动，不具有扩缩容器 docker service 服务启动，具有扩缩容器，滚动更新！ 动态扩缩容 服务,集群中任意的节点都可以访问。服务可以有多个副本动态扩缩容实现高可用! worker 节点不能进行任何管理操作 docker service create -p 8888:80 --name my-nginx nginx # 集群创建服务，并启动一个随机分布在任何节点的 nginx 服务 docker service ls # 列出集群上所有服务 docker service ps my-nginx # 通过自定义服务名查询服务进程 docker service inspect my-nginx # 通过自定义服务名查看服务信息 docker service update --replicas 3 my-nginx # 启动3个随机节点分布的 my-nginx 服务，集群里的任何一个节点的ip都可以访问这3个服务 # 注意 docker service update --replicas 10 my-nginx 即使数量超过了服务器数量还是可以启动运行，因为使用的是 docker 容器虚拟化技术，可以一个大的容器开启多个小的容器，可以重复使用这个命令来更改服务启动数 docker service scale my-nginx=5 # 跟 update --replicas 作用一样 docker service rm my-nginx # 集群移除服务 概念总结swarm集群的管理和编号。docker可以初始化一 个swarm集群，其他节点可以加入。(管理、 工作者) Node就是一个docker节点。多个节点就组成了一个网络集群。(管理、 工作者) Service任务,可以在管理节点或者工作节点来运行。核心。用户访问! Task容器内的命令,细节任务! Service 命令 -&gt; 管理 -&gt; api -&gt; 调度 -&gt; 工作节点 ( 创建Task容器维护创建! ) 服务副本与全局服务 黄色的是全局服务，灰色的是副本服务只在工作节点跑 调整 service 以什么方式运行 docker service create --mode replicated --name mytom tomcat # 以副本服务启动 docker service create --mode global --name mytom tomcat # 以全局服务启动 拓展 : 网络模式: “PublishMode”: “ingress”Swarm:Overlay : 几台不同的机器通过连接到一个 overlay 网络可以进行通信ingress : 特殊的Overlay网络 ! 具有负载均衡的功能 !虽然docker在4台机器上，实际网络是同一个 ingress 网络，是一个特殊的 overlay 网络 Docker Stackdocker-compose 单机部署项目！ Docker Stack 部署，集群部署！ # 单机 docker-compose up -d wordpress.yml # 集群 docker stack deploy wordpress.yml # docker-compose yml 文件 version: \"3\" services: nginx: image: nginx:alpine ports: - 80:80 deploy: # 集群下载 mode: replicated replicas: 4 # 副本数量 visualizer: image: dockersamples/visualizer ports: - \"9001:8080\" volumes: - \"/var/run/docker.sock:/var/run/docker.sock\" deploy: replicas: 1 placement: constraints: [node.role == manager] portainer: image: portainer/portainer ports: - \"9000:9000\" volumes: - \"/var/run/docker.sock:/var/run/docker.sock\" deploy: replicas: 1 placement: constraints: [node.role == manager] Docker Secret安全，配置密码，证书！ Docker Config配置","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"SpringCloud","slug":"Spring Cloud笔记","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:30:04.728Z","comments":true,"path":"posts/ea4e975k.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e975k.html","excerpt":"","text":"Spring Cloud 这个阶段如何学习? 三层架构 + MVC 框架： Spring(轻量级的Java开源框架)：解决企业开发的复杂性 IOC、AOP SpringBoot(Spring的升级版)：新一代的JavaEE开发标准 自动装配 模块化~ all in one 模块化的开发===all in one 代码没发生变 微服务架构4个核心问题: 1. 服务很多,客户端怎么访问? 2. 这么多服务,服务之间如何通信? 3. 这么多服务,如何治理? 4. 服务挂了怎么办? 解决方案选型: SpringCloud 是一种生态！ 学习前提已经会使用Springboot,有分布式基础,了解Dubbo+ZooKeeper 1. Spring Cloud NetFlix(已经停止维护)：一站式解决方案！可解决上述4个核心问题 API网关：zuul组件 通信：Feign ---- HttpClient ---- Http通信方式,同步,阻塞 服务注册和发现：Eureka 熔断机制：Hystrix ...... 2. Apache Dubbo Zookeeper：半自动！需要整合别人的 API网关：没有,找第三方组件(比如整合zull组件),或者自己实现 通信：Dubbo 是一个基于Java的高性能的RPC通信框架(性能比Feign强大) 服务注册和发现：Zookeeper 熔断机制：没有,需要借助Hystrix 3. Spring Cloud Alibaba：目前最新的一站式解决方案！可解决上述4个核心问题,更简单 API网关： 通信： 服务注册和发现： 熔断机制： 新概念：服务网格~ Server Mesh istio 万变不离其宗4个问题： 1. API网关 2. HTTP,RPC通信 3. 注册和发现 4. 熔断机制 1. 常见面试题1.1 什么是微服务？ 1.2 微服务之间是如何独立通讯的？ 1.3 SpringCloud 和 Dubbo有那些区别？ 1.4 SpringBoot 和 SpringCloud，请谈谈你对他们的理解 1.5 什么是服务熔断？什么是服务降级？ 1.6 微服务的优缺点分别是什么？说下你在项目开发中遇到的坑 1.7 你所知道的微服务技术栈有哪些？列举一二 1.8 Eureka和Zookeeper都可以提供服务注册与发现的功能，请说说两者的区别 … 2. 微服务概述2.1 什么是微服务？什么是微服务？微服务(Microservice Architecture) 是近几年流行的一种架构思想，关于它的概念很难一言以蔽之。 究竟什么是微服务呢？我们在此引用ThoughtWorks 公司的首席科学家 Martin Fowler 于2014年提出的一段话： 原文：https://martinfowler.com/articles/microservices.html 汉化：https://www.cnblogs.com/liuning8023/p/4493156.html 就目前而言，对于微服务，业界并没有一个统一的，标准的定义。 但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，它体长将单一的应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(HTTP)互相沟通，每个服务都围绕着具体的业务进行构建，并且能狗被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(Maven)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。 再来从技术维度角度理解下： 微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。 2.2 微服务与微服务架构微服务 强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。 IDEA 工具里面使用Maven开发的一个个独立的小Moudel，它具体是使用SpringBoot开发的一个小模块，专业的事情交给专业的模块来做，一个模块就做着一件事情。 强调的是一个个的个体，每个个体完成一个具体的任务或者功能。 微服务架构 一种新的架构形式，Martin Fowler 于2014年提出。 微服务架构是一种架构模式，它体长将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制**(如HTTP)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如Maven)**对其进行构建。 2.3 微服务优缺点优点 单一职责原则； 每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求； 开发简单，开发效率高，一个服务可能就是专一的只干一件事； 微服务能够被小团队单独开发，这个团队只需2-5个开发人员组成； 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的； 微服务能使用不同的语言开发； 易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins，Hudson，bamboo； 微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值； 微服务允许利用和融合最新技术； 微服务只是业务逻辑的代码，不会和HTML，CSS，或其他的界面混合; 每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库； 缺点 开发人员要处理分布式系统的复杂性； 多服务运维难度，随着服务的增加，运维的压力也在增大； 系统部署依赖问题； 服务间通信成本问题； 数据一致性问题； 系统集成测试问题； 性能和监控问题； 2.4 微服务技术栈有那些？ 微服务技术条目 落地技术 服务开发 SpringBoot、Spring、SpringMVC等 服务配置与管理 Netfix公司的Archaius、阿里的Diamond等 服务注册与发现 Eureka、Consul、Zookeeper等 服务调用 Rest、PRC、gRPC 服务熔断器 Hystrix、Envoy等 负载均衡 Ribbon、Nginx等 服务接口调用(客户端调用服务的简化工具) Fegin等 消息队列 Kafka、RabbitMQ、ActiveMQ等 服务配置中心管理 SpringCloudConfig、Chef等 服务路由(API网关) Zuul等 服务监控 Zabbix、Nagios、Metrics、Specatator等 全链路追踪 Zipkin、Brave、Dapper等 数据流操作开发包 SpringCloud Stream(封装与Redis，Rabbit，Kafka等发送接收消息) 时间消息总栈 SpringCloud Bus 服务部署 Docker、OpenStack、Kubernetes等 2.5 为什么选择SpringCloud作为微服务架构 选型依据 整体解决方案和框架成熟度 社区热度 可维护性 学习曲线 当前各大IT公司用的微服务架构有那些？ 阿里：dubbo+HFS 京东：JFS 新浪：Motan 当当网：DubboX … 各微服务框架对比 功能点/服务框架 Netflix/SpringCloud Motan gRPC Thrift Dubbo/DubboX 功能定位 完整的微服务框架 RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册发现 RPC框架 RPC框架 服务框架 支持Rest 是，Ribbon支持多种可拔插的序列号选择 否 否 否 否 支持RPC 否 是(Hession2) 是 是 是 支持多语言 是(Rest形式) 否 是 是 否 负载均衡 是(服务端zuul+客户端Ribbon)，zuul-服务，动态路由，云端负载均衡Eureka（针对中间层服务器） 是(客户端) 否 否 是(客户端) 配置服务 Netfix Archaius，Spring Cloud Config Server 集中配置 是(Zookeeper提供) 否 否 否 服务调用链监控 是(zuul)，zuul提供边缘服务，API网关 否 否 否 否 高可用/容错 是(服务端Hystrix+客户端Ribbon) 是(客户端) 否 否 是(客户端) 典型应用案例 Netflix Sina Google Facebook 社区活跃程度 高 一般 高 一般 2017年后重新开始维护，之前中断了5年 学习难度 中等 低 高 高 低 文档丰富程度 高 一般 一般 一般 高 其他 Spring Cloud Bus为我们的应用程序带来了更多管理端点 支持降级 Netflix内部在开发集成gRPC IDL定义 实践的公司比较多 3. SpringCloud入门概述3.1 SpringCloud是什么？Spring官网：https://spring.io/ Spring Cloud为开发人员提供了快速构建分布式系统中的一些常见模式的工具(例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导人选举、分布式会话、集群状态)。分布式系统的协调导致了锅炉板模式，而使用Spring Cloud开发人员可以快速建立实现这些模式的服务和应用程序。它们在任何分布式环境中都能很好地工作，包括开发人员自己的笔记本电脑、裸金属数据中心和云计算等托管平台。 3.2 SpringCloud和SpringBoot的关系 SpringBoot专注于开苏方便的开发单个个体微服务； SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、为代理、事件总栈、全局锁、决策竞选、分布式会话等等集成服务； SpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系； SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架； 3.3 Dubbo 和 SpringCloud技术选型1. 分布式+服务治理Dubbo目前成熟的互联网架构，应用服务化拆分+消息中间件 2. Dubbo 和 SpringCloud对比可以看一下社区活跃度： https://github.com/dubbo https://github.com/spring-cloud 对比结果： Dubbo SpringCloud 服务注册中心 Zookeeper Spring Cloud Netfilx Eureka 服务调用方式 RPC REST API 服务监控 Dubbo-monitor Spring Boot Admin 断路器 不完善 Spring Cloud Netfilx Hystrix 服务网关 无 Spring Cloud Netfilx Zuul 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总栈 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task 最大区别: SpringCloud抛弃 了Dubbo的RPC通信，采用的是基于HTTP的REST方式。严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约, 不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。 品牌机与组装机的区别很明显，Spring Cloud的功能比DUBBO更加强大，涵盖面更广,而且作为Spring的拳头项目，它也能够与SpringFramework、Spring Boot、Spring Data、Spring Batch等其他Spring项目完美融合,这些对于微服务而言是至关重要的。使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手， 那这些都不是问题;而SpringCloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性,但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。 社区支持与更新力度最为重要的是，DUBBO停止了5年左右的更新，虽然2017.7重启了。对于技术发展的新需求，需要由开发者自行拓展升级(比如当当网弄出了DubboX)，这对于很多想要采用微服务架构的中小软件组织，显然是不太合适的,中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案,并不是每-一个公司都有阿里的大牛+真实的线上生产环境测试过。 总结:二者解决的问题域不一样：Dubbo的定位是一款RPC框架，而SpringCloud的目标是微服务架构下的一站式解决方案。 3.4 SpringCloud能干嘛？ Distributed/versioned configuration 分布式/版本控制配置 Service registration and discovery 服务注册与发现 Routing 路由 Service-to-service calls 服务到服务的调用 Load balancing 负载均衡配置 Circuit Breakers 断路器 Distributed messaging 分布式消息管理 … 3.5 SpringCloud下载官网：http://projects.spring.io/spring-cloud/ 版本号有点特别： SpringCloud没有采用数字编号的方式命名版本号，而是采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如最早的Realse版本：Angel，第二个Realse版本：Brixton，然后是Camden、Dalston、Edgware，目前最新的是Hoxton SR4 CURRENT GA通用稳定版。 自学参考书： SpringCloud Netflix 中文文档：https://springcloud.cc/spring-cloud-netflix.html SpringCloud 中文API文档(官方文档翻译版)：https://springcloud.cc/spring-cloud-dalston.html SpringCloud中国社区：http://springcloud.cn/ SpringCloud中文网：https://springcloud.cc 4. SpringCloud Rest学习环境搭建：服务提供者4.1 介绍 我们会使用一个Dept部门模块做一个微服务通用案例Consumer消费者(Client)通过REST调用Provider提供者(Server)提供的服务。 回顾Spring，SpringMVC，Mybatis等以往学习的知识。 Maven的分包分模块架构复习。 一个简单的Maven模块结构是这样的： -- app-parent: 一个父项目(app-parent)聚合了很多子项目(app-util\\app-dao\\app-web...) |-- pom.xml | |-- app-core ||---- pom.xml | |-- app-web ||---- pom.xml ...... 一个父工程带着多个Moudule子模块 MicroServiceCloud父工程(Project)下初次带着3个子模块(Module) microservicecloud-api 【封装的整体entity/接口/公共配置等】 microservicecloud-consumer-dept-80 【服务提供者】 microservicecloud-provider-dept-8001 【服务消费者】 4.2 SpringCloud版本选择大版本说明 SpringBoot SpringCloud 关系 1.2.x Angel版本(天使) 兼容SpringBoot1.2x 1.3.x Brixton版本(布里克斯顿) 兼容SpringBoot1.3x，也兼容SpringBoot1.4x 1.4.x Camden版本(卡姆登) 兼容SpringBoot1.4x，也兼容SpringBoot1.5x 1.5.x Dalston版本(多尔斯顿) 兼容SpringBoot1.5x，不兼容SpringBoot2.0x 1.5.x Edgware版本(埃奇韦尔) 兼容SpringBoot1.5x，不兼容SpringBoot2.0x 2.0.x Finchley版本(芬奇利) 兼容SpringBoot2.0x，不兼容SpringBoot1.5x 2.1.x Greenwich版本(格林威治) 实际开发版本关系 spring-boot-starter-parent spring-cloud-dependencles 版本号 发布日期 版本号 发布日期 1.5.2.RELEASE 2017-03 Dalston.RC1 2017-x 1.5.9.RELEASE 2017-11 Edgware.RELEASE 2017-11 1.5.16.RELEASE 2018-04 Edgware.SR5 2018-10 1.5.20.RELEASE 2018-09 Edgware.SR5 2018-10 2.0.2.RELEASE 2018-05 Fomchiey.BULD-SNAPSHOT 2018-x 2.0.6.RELEASE 2018-10 Fomchiey-SR2 2018-10 2.1.4.RELEASE 2019-04 Greenwich.SR1 2019-03 使用后两个 4.3 创建父工程 新建父工程项目springcloud，切记Packageing是pom模式 主要是定义POM文件，将后续各个子模块公用的jar包等统一提取出来，类似一个抽象父类 pom.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;springcloud-api&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;springcloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;springcloud-eureka-7001&lt;/module&gt; &lt;module&gt;springcloud-eureka-7002&lt;/module&gt; &lt;module&gt;springcloud-eureka-7003&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8003&lt;/module&gt; &lt;module&gt;springcloud-consumer-dept-feign&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-hystrix-8001&lt;/module&gt; &lt;module&gt;springcloud-consumer-hystrix-dashboard&lt;/module&gt; &lt;module&gt;springcloud-zuul-9527&lt;/module&gt; &lt;module&gt;springcloud-config-server-3344&lt;/module&gt; &lt;module&gt;springcloud-config-client-3355&lt;/module&gt; &lt;module&gt;springcloud-config-eureka-7001&lt;/module&gt; &lt;module&gt;springcloud-config-dept-8001&lt;/module&gt; &lt;/modules&gt; &lt;!--打包方式 pom--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;0.2.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--springCloud的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--SpringBoot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringBoot 启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志测试~--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${lombok.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; 父工程为springcloud，其下有多个子mudule，详情参考完整代码了解 springcloud-consumer-dept-80访问springcloud-provider-dept-8001下的controller使用REST方式 如DeptConsumerController.java @RestController public class DeptConsumerController { // 理解：消费者，不应该有service层~ // RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中 // (url, 实体：Map ,Class&lt;T&gt; responseType) @Autowired private RestTemplate restTemplate; //提供多种便捷访问远程http服务的方法，简单的Restful服务模板~ //Ribbon。我们这里的地址，应该是一个变量，通过服务名来访问 private static final String REST_URL_PREFIX = \"http://localhost:8001\"; //private static final String REST_URL_PREFIX = \"http://SPRINGCLOUD-PROVIDER-DEPT\"; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept){ return restTemplate.postForObject(REST_URL_PREFIX+\"/dept/add\",dept,Boolean.class); } @RequestMapping(\"/consumer/dept/get/{id}\") public Dept get(@PathVariable(\"id\") Long id){ return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/get/\"+id,Dept.class); } @RequestMapping(\"/consumer/dept/list\") public List&lt;Dept&gt; list(){ return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/list\",List.class); } } 使用RestTemplete先需要放入Spring容器中 ConfigBean.java @Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml //配置负载均衡实现RestTemplate // IRule // RoundRobinRule 轮询 // RandomRule 随机 // AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~ // RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试 @Bean public RestTemplate getRestTemplate(){ return new RestTemplate(); } } springcloud-provider-dept-8001的dao接口调用springcloud-api模块下的pojo，可使用在springcloud-provider-dept-8001的pom文件导入springcloud-api模块依赖的方式： &lt;!--我们需要拿到实体类，所以要配置api module--&gt; &lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; springcloud-consumer-dept-80和springcloud-provider-dept-8001的pom.xml和父工程下的依赖基本一样，直接看完整代码即可，不再添加重复笔记。 5. Eureka服务注册与发现5.1 什么是Eureka Netflix在涉及Eureka时，遵循的就是API原则. Eureka是Netflix的有个子模块，也是核心模块之一。Eureka是基于REST的服务，用于定位服务，以实现云端中间件层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心，比如Zookeeper. 5.2 原理理解 Eureka基本的架构 Springcloud 封装了Netflix公司开发的Eureka模块来实现服务注册与发现 (对比Zookeeper). Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心. 而系统中的其他微服务，使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，Springcloud 的一些其他模块 (比如Zuul) 就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑. 和Dubbo架构对比. Eureka 包含两个组件：Eureka Server 和 Eureka Client. Eureka Server 提供服务注册，各个节点启动后，回在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会储存所有课用服务节点的信息，服务节点的信息可以在界面中直观的看到. Eureka Client 是一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳 (默认周期为30秒) 。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除掉 (默认周期为90s). 三大角色 Eureka Server：提供服务的注册与发现 Service Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能狗找到 Service Consumer：服务消费方，从Eureka中获取注册服务列表，从而找到消费服务 目前工程状况 5.3 构建步骤1. eureka-server springcloud-eureka-7001 模块建立 pom.xml 配置 &lt;!--导包~--&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;!--导入Eureka Server依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; application.yml server: port: 7001 #Eureka配置 eureka: instance: hostname: localhost #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 源码中Eureka的默认端口以及访问路径: 主启动类 //启动之后，访问 http://localhost:7001/ @SpringBootApplication @EnableEurekaServer //EnableEurekaServer 表示是 Eureka服务端的启动类，可以接受别人注册进来~ public class EurekaServer_7001 { public static void main(String[] args) { SpringApplication.run(EurekaServer_7001.class,args); } } 启动成功后访问 http://localhost:7001/ 得到以下页面 2. eureka-client调整之前创建的springlouc-provider-dept-8001 导入Eureca依赖 &lt;!--Eureka依赖--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; application中新增Eureca配置 # Eureka配置：配置服务注册中心地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ 为主启动类添加@EnableEurekaClient注解 @SpringBootApplication @EnableEurekaClient //EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务 public class DeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(DeptProvider_8001.class,args); } } 先启动7001服务端后启动8001客户端进行测试，然后访问监控页http://localhost:7001/ 产看结果如图，成功 修改Eureka上的默认描述信息 # Eureka配置：配置服务注册中心地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ instance: instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息 结果如图： 如果此时停掉springcloud-provider-dept-8001 等30s后 监控会开启保护机制 配置关于服务加载的监控信息 pom.xml中添加依赖 &lt;!--actuator完善监控信息--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; application.yml中添加配置 #info配置 info: app.name: haust-springcloud #项目的名称 company.name: com.haust #公司的名称 此时刷新监控页，点击进入跳转新页面显示如下内容： 3. EureKa自我保护机制：好死不如赖活着一句话总结就是：某时刻某一个微服务不可用，eureka不会立即清理，依旧会对该微服务的信息进行保存！ 默认情况下，当eureka server在一定时间内没有收到实例的心跳，便会把该实例从注册表中删除（默认是90秒），但是，如果短时间内丢失大量的实例心跳，便会触发eureka server的自我保护机制，比如在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启（因为在开发过程中不会修改eureka注册中心），当一分钟内收到的心跳数大量减少时，会触发该保护机制。可以在eureka管理界面看到Renews threshold和Renews(last min)，当后者（最后一分钟收到的心跳数）小于前者（心跳阈值）的时候，触发保护机制，会出现红色的警告：**EMERGENCY!EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT.RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEGING EXPIRED JUST TO BE SAFE.**从警告中可以看到，eureka认为虽然收不到实例的心跳，但它认为实例还是健康的，eureka会保护这些实例，不会把它们从注册表中删掉。 该保护机制的目的是避免网络连接故障，在发生网络故障时，微服务和注册中心之间无法正常通信，但服务本身是健康的，不应该注销该服务，如果eureka因网络故障而把微服务误删了，那即使网络恢复了，该微服务也不会重新注册到eureka server了，因为只有在微服务启动的时候才会发起注册请求，后面只会发送心跳和服务列表请求，这样的话，该实例虽然是运行着，但永远不会被其它服务所感知。所以，eureka server在短时间内丢失过多的客户端心跳时，会进入自我保护模式，该模式下，eureka会保护注册表中的信息，不在注销任何微服务，当网络故障恢复后，eureka会自动退出保护模式。自我保护模式可以让集群更加健壮。 但是我们在开发测试阶段，需要频繁地重启发布，如果触发了保护机制，则旧的服务实例没有被删除，这时请求有可能跑到旧的实例中，而该实例已经关闭了，这就导致请求错误，影响开发测试。所以，在开发测试阶段，我们可以把自我保护模式关闭，只需在eureka server配置文件中加上如下配置即可：eureka.server.enable-self-preservation=false 详细内容可以参考下这篇博客内容：https://blog.csdn.net/wudiyong22/article/details/80827594 4. 注册进来的微服务，获取一些消息（团队开发会用到）DeptController.java新增方法 //获取一些配置的信息，得到具体的微服务！ @Autowired private DiscoveryClient client; //注册进来的微服务~，获取一些消息~ @GetMapping(\"/dept/discovery\") public Object discovery() { //获取微服务列表的清单 List&lt;String&gt; services = client.getServices(); System.out.println(\"discovery=&gt;services:\" + services); //得到一个具体的微服务信息,通过具体的微服务id，applicaioinName； List&lt;ServiceInstance&gt; instances = client.getInstances(\"SPRINGCLOUD-PROVIDER-DEPT\"); for (ServiceInstance instance : instances) { System.out.println( instance.getHost() + \"\\t\" + // 主机名称 instance.getPort() + \"\\t\" + // 端口号 instance.getUri() + \"\\t\" + // uri instance.getServiceId() // 服务id ); } return this.client; } 主启动类中加入@EnableDiscoveryClient 注解 @SpringBootApplication @EnableEurekaClient //在服务启动后自动注册到Eureka中！ @EnableDiscoveryClient //服务发现~ public class DeptProvider_8001 { ... } 结果如图： 5.4 Eureka：集群环境配置1.初始化新建springcloud-eureka-7002、springcloud-eureka-7003 模块 1.为pom.xml添加依赖 (与springcloud-eureka-7001相同) &lt;!--导包~--&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;!--导入Eureka Server依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.application.yml配置(与springcloud-eureka-7001相同) server: port: 7003 #Eureka配置 eureka: instance: hostname: localhost #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 3.主启动类(与springcloud-eureka-7001相同) //启动之后，访问 http://localhost:7001/ @SpringBootApplication @EnableEurekaServer //EnableEurekaServer 服务端的启动类，可以接受别人注册进来~ public class EurekaServer_7003 { public static void main(String[] args) { SpringApplication.run(EurekaServer_7003.class,args); } } 2.集群成员相互关联配置一些自定义本机名字，找到本机hosts文件并打开 在hosts文件最后加上，要访问的本机名称，默认是localhost 修改application.yml的配置，如图为springcloud-eureka-7001配置，springcloud-eureka-7002/springcloud-eureka-7003同样分别修改为其对应的名称即可 在集群中使springcloud-eureka-7001关联springcloud-eureka-7002、springcloud-eureka-7003 完整的springcloud-eureka-7001下的application.yml如下 server: port: 7001 #Eureka配置 eureka: instance: hostname: eureka7001.com #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ # 单机： defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ # 集群（关联）：7001关联7002、7003 defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 同时在集群中使springcloud-eureka-7002关联springcloud-eureka-7001、springcloud-eureka-7003 完整的springcloud-eureka-7002下的application.yml如下 server: port: 7002 #Eureka配置 eureka: instance: hostname: eureka7002.com #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ # 单机： defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ # 集群（关联）：7002关联7001、7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7003.com:7003/eureka/ springcloud-eureka-7003配置方式同理可得. 通过springcloud-provider-dept-8001下的yml配置文件，修改Eureka配置：配置服务注册中心地址 # Eureka配置：配置服务注册中心地址 eureka: client: service-url: # 注册中心地址7001-7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息 这样模拟集群就搭建号了，就可以把一个项目挂载到三个服务器上了 5.5 对比和Zookeeper区别1. 回顾CAP原则RDBMS (MySQL\\Oracle\\sqlServer) ===&gt; ACID NoSQL (Redis\\MongoDB) ===&gt; CAP 2. ACID是什么？ A (Atomicity) 原子性 C (Consistency) 一致性 I (Isolation) 隔离性 D (Durability) 持久性 3. CAP是什么? C (Consistency) 强一致性 A (Availability) 可用性 P (Partition tolerance) 分区容错性 CAP的三进二：CA、AP、CP 4. CAP理论的核心 一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求 根据CAP原理，将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类 CA：单点集群，满足一致性，可用性的系统，通常可扩展性较差 CP：满足一致性，分区容错的系统，通常性能不是特别高 AP：满足可用性，分区容错的系统，通常可能对一致性要求低一些 5. 作为分布式服务注册中心，Eureka比Zookeeper好在哪里？著名的CAP理论指出，一个分布式系统不可能同时满足C (一致性) 、A (可用性) 、P (容错性)，由于分区容错性P再分布式系统中是必须要保证的，因此我们只能再A和C之间进行权衡。 Zookeeper 保证的是CP Eureka 保证的是AP Zookeeper保证的是CP ​ 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接收服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30-120s，且选举期间整个zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题使得zookeeper集群失去master节点是较大概率发生的事件，虽然服务最终能够恢复，但是，漫长的选举时间导致注册长期不可用，是不可容忍的。 Eureka保证的是AP ​ Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的信息可能不是最新的，除此之外，Eureka还有之中自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： Eureka不在从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上 (即保证当前节点依然可用) 当网络稳定时，当前实例新的注册信息会被同步到其他节点中 因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪 6. Ribbon：负载均衡(基于客户端)6.1 负载均衡以及RibbonRibbon是什么？ Spring Cloud Ribbon 是基于Netflix Ribbon 实现的一套客户端负载均衡的工具。 简单的说，Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 的客户端组件提供一系列完整的配置项，如：连接超时、重试等。简单的说，就是在配置文件中列出 LoadBalancer (简称LB：负载均衡) 后面所有的及其，Ribbon 会自动的帮助你基于某种规则 (如简单轮询，随机连接等等) 去连接这些机器。我们也容易使用 Ribbon 实现自定义的负载均衡算法！ Ribbon能干嘛？ LB，即负载均衡 (LoadBalancer) ，在微服务或分布式集群中经常用的一种应用。 负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高用)。 常见的负载均衡软件有 Nginx、Lvs 等等。 Dubbo、SpringCloud 中均给我们提供了负载均衡，SpringCloud 的负载均衡算法可以自定义。 负载均衡简单分类： 集中式LB 即在服务的提供方和消费方之间使用独立的LB设施，如Nginx，由该设施负责把访问请求通过某种策略转发至服务的提供方！ 进程式LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。 Ribbon 就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址！ 6.2 集成Ribbonspringcloud-consumer-dept-80向pom.xml中添加Ribbon和Eureka依赖 &lt;!--Ribbon--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka: Ribbon需要从Eureka服务中心获取要拿什么--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 在application.yml文件中配置Eureka # Eureka配置 eureka: client: register-with-eureka: false # 不向 Eureka注册自己 service-url: # 从三个注册中心中随机取一个去访问 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 主启动类加上@EnableEurekaClient注解，开启Eureka //Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号 @SpringBootApplication @EnableEurekaClient //开启Eureka 客户端 public class DeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_80.class, args); } } 自定义Spring配置类：ConfigBean.java 配置负载均衡实现RestTemplate @Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml @LoadBalanced //配置负载均衡实现RestTemplate @Bean public RestTemplate getRestTemplate() { return new RestTemplate(); } } 修改conroller：DeptConsumerController.java //Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 //private static final String REST_URL_PREFIX = \"http://localhost:8001\"; private static final String REST_URL_PREFIX = \"http://SPRINGCLOUD-PROVIDER-DEPT\"; 6.3 使用Ribbon实现负载均衡流程图： 1.新建两个服务提供者Moudle：springcloud-provider-dept-8003、springcloud-provider-dept-8002 2.参照springcloud-provider-dept-8001 依次为另外两个Moudle添加pom.xml依赖 、resourece下的mybatis和application.yml配置，Java代码 3.启动所有服务测试(根据自身电脑配置决定启动服务的个数)，访问http://eureka7001.com:7002/查看结果 测试访问http://localhost/consumer/dept/list 这时候随机访问的是服务提供者8003 再次访问http://localhost/consumer/dept/list这时候随机的是服务提供者8001 以上这种每次访问http://localhost/consumer/dept/list随机访问集群中某个服务提供者，这种情况叫做轮询，轮询算法在SpringCloud中可以自定义。 如何切换或者自定义规则呢？ 在springcloud-provider-dept-80模块下的ConfigBean中进行配置，切换使用不同的规则 @Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml /** * IRule: * RoundRobinRule 轮询 * RandomRule 随机 * AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~ * RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试 */ @LoadBalanced //配置负载均衡实现RestTemplate @Bean public RestTemplate getRestTemplate() { return new RestTemplate(); } @Bean public IRule myRule(){ return new RandomRule();//使用随机规则 } } 也可以自定义规则，在myRule包下自定义一个配置类MyRule.java，注意：该包不要和主启动类所在的包同级(不能被扫描)，要跟启动类所在包同级： MyRule.java /** * @Auther: csp1999 * @Date: 2020/05/19/11:58 * @Description: 自定义规则 */ @Configuration public class MyRule { @Bean public IRule myRule(){ return new MyRandomRule();//默认是轮询RandomRule,现在自定义为自己的 } } 主启动类开启负载均衡并指定自定义的MyRule配置类 //Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号 @SpringBootApplication @EnableEurekaClient //在微服务启动的时候就能加载自定义的Ribbon类(自定义的规则会覆盖原有默认的规则) @RibbonClient(name = \"SPRINGCLOUD-PROVIDER-DEPT\",configuration = MyRule.class)//开启负载均衡,并指定自定义的规则 public class DeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_80.class, args); } } 自定义的规则(这里我们参考Ribbon中默认的规则代码自己稍微改动)：MyRandomRule.java public class MyRandomRule extends AbstractLoadBalancerRule { /** * 每个服务访问5次则换下一个服务(总共3个服务) * &lt;p&gt; * total=0,默认=0,如果=5,指向下一个服务节点 * index=0,默认=0,如果total=5,index+1 */ private int total = 0;//被调用的次数 private int currentIndex = 0;//当前是谁在提供服务 //@edu.umd.cs.findbugs.annotations.SuppressWarnings(value = \"RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE\") public Server choose(ILoadBalancer lb, Object key) { if (lb == null) { return null; } Server server = null; while (server == null) { if (Thread.interrupted()) { return null; } List&lt;Server&gt; upList = lb.getReachableServers();//获得当前活着的服务 List&lt;Server&gt; allList = lb.getAllServers();//获取所有的服务 int serverCount = allList.size(); if (serverCount == 0) { /* * No servers. End regardless of pass, because subsequent passes * only get more restrictive. */ return null; } //int index = chooseRandomInt(serverCount);//生成区间随机数 //server = upList.get(index);//从或活着的服务中,随机获取一个 //=====================自定义代码========================= if (total &lt; 5) { server = upList.get(currentIndex); total++; } else { total = 0; currentIndex++; if (currentIndex &gt; upList.size()) { currentIndex = 0; } server = upList.get(currentIndex);//从活着的服务中,获取指定的服务来进行操作 } //====================================================== if (server == null) { /* * The only time this should happen is if the server list were * somehow trimmed. This is a transient condition. Retry after * yielding. */ Thread.yield(); continue; } if (server.isAlive()) { return (server); } // Shouldn't actually happen.. but must be transient or a bug. server = null; Thread.yield(); } return server; } protected int chooseRandomInt(int serverCount) { return ThreadLocalRandom.current().nextInt(serverCount); } @Override public Server choose(Object key) { return choose(getLoadBalancer(), key); } @Override public void initWithNiwsConfig(IClientConfig clientConfig) { // TODO Auto-generated method stub } } 7.Feign：负载均衡(基于服务端)7.1 Feign简介Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Ribbon和Eureka，可以使用Feigin提供负载均衡的http客户端 只需要创建一个接口，然后添加注解即可~ Feign，主要是社区版，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法 微服务名字 【ribbon】 接口和注解 【feign】 Feign能干什么？ Feign旨在使编写Java Http客户端变得更容易 前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一个客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解)，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon 时，自动封装服务调用客户端的开发量。 Feign默认集成了Ribbon 利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。 7.2 Feign的使用步骤 创建springcloud-consumer-fdept-feign模块 拷贝springcloud-consumer-dept-80模块下的pom.xml，resource，以及java代码到springcloud-consumer-feign模块，并添加feign依赖。 &lt;!--Feign的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 通过Ribbon实现：—原来的controller：DeptConsumerController.java package com.haust.springcloud.controller; import com.haust.springcloud.pojo.Dept; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import java.util.List; /** * @Auther: csp1999 * @Date: 2020/05/17/22:44 * @Description: */ @RestController public class DeptConsumerController { // 理解：消费者，不应该有service层~ // RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中 // (url, 实体：Map ,Class&lt;T&gt; responseType) @Autowired private RestTemplate restTemplate; //提供多种便捷访问远程http服务的方法，简单的Restful服务模板~ //Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 //private static final String REST_URL_PREFIX = \"http://localhost:8001\"; private static final String REST_URL_PREFIX = \"http://SPRINGCLOUD-PROVIDER-DEPT\"; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept) { return restTemplate.postForObject(REST_URL_PREFIX + \"/dept/add\", dept, Boolean.class); } @RequestMapping(\"/consumer/dept/get/{id}\") public Dept get(@PathVariable(\"id\") Long id) { return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/get/\" + id, Dept.class); } @RequestMapping(\"/consumer/dept/list\") public List&lt;Dept&gt; list() { return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/list\", List.class); } } 通过Feign实现：—改造后controller：DeptConsumerController.java @RestController public class DeptConsumerController { @Autowired private DeptClientService deptClientService = null; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept) { return this.deptClientService.addDept(dept); } @RequestMapping(\"/consumer/dept/get/{id}\") public Dept get(@PathVariable(\"id\") Long id) { return this.deptClientService.queryById(id); } @RequestMapping(\"/consumer/dept/list\") public List&lt;Dept&gt; list() { return this.deptClientService.queryAll(); } } Feign和Ribbon二者对比，前者显现出面向接口编程特点，代码看起来更清爽 主配置类 @SpringBootApplication @EnableEurekaClient //feign客户端注解,并指定要扫描的包以及配置接口DeptClientService @EnableFeignClients(basePackages = {\"com.haust.springcloud\"}) //扫描所有自己的包,让所有注解也能生效 @ComponentScan(\"com.haust.springcloud\") public class FeignDeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(FeignDeptConsumer_80.class, args); } } 改造springcloud-api模块 pom.xml添加feign依赖 &lt;!--Feign的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 新建service包，并新建DeptClientService.java接口， //@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务 @FeignClient(value = \"SPRINGCLOUD-PROVIDER-DEPT\") public interface DeptClientService { @GetMapping(\"/dept/get/{id}\") public Dept queryById(@PathVariable(\"id\") Long id); @GetMapping(\"/dept/list\") public Dept queryAll(); @GetMapping(\"/dept/add\") public Dept addDept(Dept dept); } 7.3 Feign和Ribbon如何选择？根据个人习惯而定，如果喜欢REST风格使用Ribbon；如果喜欢社区版的面向接口风格使用Feign. 8. Hystrix：服务熔断分布式系统面临的问题 复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免失败！ 8.1 服务雪崩​ 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”，如果扇出的链路上某个微服务的调用响应时间过长，或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。 ​ 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几十秒内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障，这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。 ​ 我们需要，弃车保帅 8.2 什么是Hystrix？​ Hystrix是一个应用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整个体系服务失败，避免级联故障，以提高分布式系统的弹性。 ​ “断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控 (类似熔断保险丝) ，向调用方方茴一个服务预期的，可处理的备选响应 (FallBack) ，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证了服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。 8.3 Hystrix能干嘛？ 服务降级 服务熔断 服务限流 接近实时的监控 … 当一切正常时，请求流可以如下所示： 当许多后端系统中有一个潜在时，它可以阻止整个用户请求： 随着大容量通信量的增加，单个后端依赖项的潜在性会导致所有服务器上的所有资源在几秒钟内饱和。 应用程序中通过网络或客户端库可能导致网络请求的每个点都是潜在故障的来源。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，从而备份队列、线程和其他系统资源，从而导致更多跨系统的级联故障。 当使用hystrix包装每个基础依赖项时，上面的图表中所示的体系结构会发生类似于以下关系图的变化。每个依赖项是相互隔离的，限制在延迟发生时它可以填充的资源中，并包含在回退逻辑中，该逻辑决定在依赖项中发生任何类型的故障时要做出什么样的响应： 官网资料：https://github.com/Netflix/Hystrix/wiki 8.4 服务熔断什么是服务熔断​ 熔断机制是赌赢雪崩效应的一种微服务链路保护机制。 ​ 在微服务架构中，微服务之间的数据交互通过远程调用完成，微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，此时如果链路上某个微服务的调用响应时间过长或者不可用，那么对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，导致“雪崩效应”。 服务熔断是应对雪崩效应的一种微服务链路保护机制。例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。同样，在微服务架构中，熔断机制也是起着类似的作用。当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。 ​ 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阀值缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是：**@HystrixCommand** 。 ​ 服务熔断解决如下问题： 1. 当所依赖的对象不稳定时，能够起到快速失败的目的；2. 快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复。 入门案例新建springcloud-provider-dept-hystrix-8001模块并拷贝springcloud-provider-dept–8001内的pom.xml、resource和Java代码进行初始化并调整。 导入hystrix依赖 &lt;!--导入Hystrix依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 调整yml配置文件 server: port: 8001 # mybatis配置 mybatis: # springcloud-api 模块下的pojo包 type-aliases-package: com.haust.springcloud.pojo # 本模块下的mybatis-config.xml核心配置文件类路径 config-location: classpath:mybatis/mybatis-config.xml # 本模块下的mapper配置文件类路径 mapper-locations: classpath:mybatis/mapper/*.xml # spring配置 spring: application: #项目名 name: springcloud-provider-dept datasource: # 德鲁伊数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db01?useUnicode=true&amp;characterEncoding=utf-8 username: root password: root # Eureka配置：配置服务注册中心地址 eureka: client: service-url: # 注册中心地址7001-7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: springcloud-provider-dept-hystrix-8001 #修改Eureka上的默认描述信息 prefer-ip-address: true #改为true后默认显示的是ip地址而不再是localhost #info配置 info: app.name: haust-springcloud #项目的名称 company.name: com.haust #公司的名称 prefer-ip-address: false: prefer-ip-address: true： 修改controller //提供Restful服务 @RestController public class DeptController { @Autowired private DeptService deptService; @HystrixCommand(fallbackMethod = \"hystrixGet\")//如果根据id查询出现异常,走这段代码 @GetMapping(\"/dept/get/{id}\")//根据id查询 public Dept get(@PathVariable(\"id\") Long id){ Dept dept = deptService.queryById(id); if (dept==null){ throw new RuntimeException(\"这个id=&gt;\"+id+\",不存在该用户，或信息无法找到~\"); } return dept; } //根据id查询备选方案(熔断) public Dept hystrixGet(@PathVariable(\"id\") Long id){ return new Dept().setDeptno(id) .setDname(\"这个id=&gt;\"+id+\",没有对应的信息,null---@Hystrix~\") .setDb_source(\"在MySQL中没有这个数据库\"); } } 为主启动类添加对熔断的支持注解@EnableCircuitBreaker @SpringBootApplication @EnableEurekaClient //EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务 @EnableCircuitBreaker//添加对熔断的支持注解 public class HystrixDeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(HystrixDeptProvider_8001.class,args); } } 测试： 使用熔断后，当访问一个不存在的id时，前台页展示数据如下 而不适用熔断的springcloud-provider-dept–8001模块访问相同地址会出现下面状况 因此，为了避免因某个微服务后台出现异常或错误而导致整个应用或网页报错，使用熔断是必要的 8.5 服务降级什么是服务降级​ 服务降级是指 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。说白了，就是尽可能的把系统资源让给优先级高的服务。 资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证核心功能服务的可用性，都要对某些服务降级处理。比如当双11活动时，把交易无关的服务统统降级，如查看蚂蚁深林，查看历史订单等等。 服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，可以将一些 不重要 或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用。 降级的方式可以根据业务来，可以延迟服务，比如延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行 ；或者在粒度范围内关闭服务，比如关闭相关文章的推荐。 由上图可得，当某一时间内服务A的访问量暴增，而B和C的访问量较少，为了缓解A服务的压力，这时候需要B和C暂时关闭一些服务功能，去承担A的部分服务，从而为A分担压力，叫做服务降级。 服务降级需要考虑的问题 1）那些服务是核心服务，哪些服务是非核心服务 2）那些服务可以支持降级，那些服务不能支持降级，降级策略是什么 3）除服务降级之外是否存在更复杂的业务放通场景，策略是什么？ 自动降级分类1）超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况 2）失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况 3）故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据） 4）限流降级：秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。 入门案例在springcloud-api模块下的service包中新建降级配置类DeptClientServiceFallBackFactory.java //降级 ~ @Component public class DeptClientServiceFallBackFactory implements FallbackFactory { @Override public DeptClientService create(Throwable cause) { return new DeptClientService() { @Override public Dept queryById(Long id) { return new Dept() .setDeptno(id) .setDname(\"id=&gt;\" + id + \"没有对应的信息，客户端提供了降级的信息，这个服务现在已经被关闭\") .setDb_source(\"没有数据~\"); } @Override public List&lt;Dept&gt; queryAll() { return null; } @Override public Boolean addDept(Dept dept) { return false; } }; } } 在DeptClientService中指定降级配置类DeptClientServiceFallBackFactory @Component //注册到spring容器中 //@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务 @FeignClient(value = \"SPRINGCLOUD-PROVIDER-DEPT\",fallbackFactory = DeptClientServiceFallBackFactory.class)//fallbackFactory指定降级配置类 public interface DeptClientService { @GetMapping(\"/dept/get/{id}\") public Dept queryById(@PathVariable(\"id\") Long id); @GetMapping(\"/dept/list\") public List&lt;Dept&gt; queryAll(); @GetMapping(\"/dept/add\") public Boolean addDept(Dept dept); } 在springcloud-consumer-dept-feign模块中开启降级 server: port: 80 # Eureka配置 eureka: client: register-with-eureka: false # 不向 Eureka注册自己 service-url: # 从三个注册中心中随机取一个去访问 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ # 开启降级feign.hystrix feign: hystrix: enabled: true 8.6 服务熔断和降级的区别 服务熔断—&gt;服务端：某个服务超时或异常，引起熔断~，类似于保险丝(自我熔断) 服务降级—&gt;客户端：从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再被调用，此时在客户端，我们可以准备一个 FallBackFactory ，返回一个默认的值(缺省值)。会导致整体的服务下降，但是好歹能用，比直接挂掉强。 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始） 实现方式不太一样，服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为自我熔断。 限流：限制并发的请求访问量，超过阈值则拒绝；降级：服务分优先级，牺牲非核心服务（不可用），保证核心服务稳定；从整体负荷考虑；熔断：依赖的下游服务故障触发熔断，避免引发本系统崩溃；系统自动执行和恢复 8.7 Dashboard 流监控新建springcloud-consumer-hystrix-dashboard模块 添加依赖 &lt;!--Hystrix依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifact &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--dashboard依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Ribbon--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactI &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactI &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--实体类+web--&gt; &lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 消费者端application.yml配一个端口 server: port: 9001 主启动类 @SpringBootApplication //开启Dashboard @EnableHystrixDashboard public class DeptConsumerDashboard_9001 { public static void main(String[] args) { SpringApplication.run(DeptConsumerDashboard_9001.class,args); } } 给springcloud-provider-dept-8001模块下的主启动类添加如下代码,添加监控 @SpringBootApplication @EnableEurekaClient //EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务 public class DeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(DeptProvider_8001.class,args); } //增加一个 Servlet @Bean public ServletRegistrationBean hystrixMetricsStreamServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet()); //访问该页面就是监控页面 registrationBean.addUrlMappings(\"/actuator/hystrix.stream\"); return registrationBean; } } Hystirx-dashboard 效果图(先打开http://localhost:9001/hystrix，然后在输入栏里输入http://消费端口+/actuator/hystrix.stream，会打开消费端口的监控页面) 9. Zull路由网关概述什么是zuul? ​ Zull包含了对请求的路由(用来跳转的)和过滤两个最主要功能： ​ 其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础，而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础。Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。 ​ 注意：Zuul服务最终还是会注册进Eureka ​ 提供：代理+路由+过滤 三大功能！ Zuul能干嘛？ 路由 过滤 官方文档：https://github.com/Netflix/zuul/ 入门案例新建springcloud-zuul模块，并导入依赖 &lt;dependencies&gt; &lt;!--导入zuul依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Hystrix依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifac &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--dashboard依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboar &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Ribbon--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifact &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifact &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--实体类+web--&gt; &lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; application.yml server: port: 9527 spring: application: name: springcloud-zuul #微服务名称 eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: #实例的id instance-id: zuul9527.com prefer-ip-address: true # 显示ip info: app.name: haust.springcloud #项目名称 company.name: haust #公司名称 zuul: routes: mydept.serviceId: springcloud-provider-dept mydept.path: /mydept/** ignored-services: \"*\" # 不能再使用某个(*：全部)路径访问了，ignored ： 忽略,隐藏全部的~ prefix: /kuagn # 设置公共的前缀,实现隐藏原有路由 主启动类 @SpringBootApplication @EnableZuulProxy //开启Zuul public class ZuulApplication_9527 { public static void main(String[] args) { SpringApplication.run(ZuulApplication_9527.class,args); } } 详情参考springcloud中文社区zuul组件 :https://www.springcloud.cc/spring-cloud-greenwich.html#_router_and_filter_zuul 10. Spring Cloud Config 分布式配置Dalston.RELEASE Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持。使用Config Server，您可以在所有环境中管理应用程序的外部属性。客户端和服务器上的概念映射与Spring Environment和PropertySource抽象相同，因此它们与Spring应用程序非常契合，但可以与任何以任何语言运行的应用程序一起使用。随着应用程序通过从开发人员到测试和生产的部署流程，您可以管理这些环境之间的配置，并确定应用程序具有迁移时需要运行的一切。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。很容易添加替代实现，并使用Spring配置将其插入。 概述分布式系统面临的–配置文件问题 微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的，动态的配置管理设施是必不可少的。spring cloud提供了configServer来解决这个问题，我们每一个微服务自己带着一个application.yml，那上百个的配置文件修改起来，令人头疼！ 什么是SpringCloud config分布式配置中心？ ​ spring cloud config 为微服务架构中的微服务提供集中化的外部支持，配置服务器为各个不同微服务应用的所有环节提供了一个中心化的外部配置。 ​ spring cloud config 分为服务端和客户端两部分。 ​ 服务端也称为 分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密，解密信息等访问接口。 ​ 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可用通过git客户端工具来方便的管理和访问配置内容。 spring cloud config 分布式配置中心能干嘛？ 集中式管理配置文件 不同环境，不同配置，动态化的配置更新，分环境部署，比如 /dev /test /prod /beta /release 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息 当配置发生变动时，服务不需要重启，即可感知到配置的变化，并应用新的配置 将配置信息以REST接口的形式暴露 spring cloud config 分布式配置中心与GitHub整合 ​ 由于spring cloud config 默认使用git来存储配置文件 (也有其他方式，比如自持SVN 和本地文件)，但是最推荐的还是git ，而且使用的是 http / https 访问的形式。 入门案例服务端新建springcloud-config-server-3344模块导入pom.xml依赖 &lt;dependencies&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--config--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--eureka--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; resource下创建application.yml配置文件，Spring Cloud Config服务器从git存储库（必须提供）为远程客户端提供配置： server: port: 3344 spring: application: name: springcloud-config-server # 连接码云远程仓库 cloud: config: server: git: #注意是https的而不是ssh uri: https://gitee.com/cao_shi_peng/springcloud-config.git # 通过 config-server可以连接到git，访问其中的资源以及配置~ # 不加这个配置会报Cannot execute request on any known server 这个错：连接Eureka服务端地址不对 # 或者直接注释掉eureka依赖 这里暂时用不到eureka eureka: client: register-with-eureka: false fetch-registry: false 主启动类 @EnableConfigServer //开启spring cloud config server服务 @SpringBootApplication public class Config_server_3344 { public static void main(String[] args) { SpringApplication.run(Config_server_3344.class,args); } } 将本地git仓库springcloud-config文件夹下新建的application.yml提交到码云仓库： 定位资源的默认策略是克隆一个git仓库（在spring.cloud.config.server.git.uri），并使用它来初始化一个迷你SpringApplication。小应用程序的Environment用于枚举属性源并通过JSON端点发布。 HTTP服务具有以下格式的资源： /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 其中“应用程序”作为SpringApplication中的spring.config.name注入（即常规的Spring Boot应用程序中通常是“应用程序”），“配置文件”是活动配置文件（或逗号分隔列表的属性），“label”是可选的git标签（默认为“master”）。 测试访问http://localhost:3344/application-dev.yml 测试访问 http://localhost:3344/application/test/master 测试访问 http://localhost:3344/master/application-dev.yml 如果测试访问不存在的配置则不显示 如：http://localhost:3344/master/application-aaa.yml 客户端将本地git仓库springcloud-config文件夹下新建的config-client.yml提交到码云仓库： 新建一个springcloud-config-client-3355模块，并导入依赖 &lt;!--config--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; resources下创建application.yml和bootstrap.yml配置文件 bootstrap.yml是系统级别的配置 # 系统级别的配置 spring: cloud: config: name: config-client # 需要从git上读取的资源名称，不要后缀 profile: dev label: master uri: http://localhost:3344 application.yml是用户级别的配置 # 用户级别的配置 spring: application: name: springcloud-config-client 创建controller包下的ConfigClientController.java用于测试 @RestController public class ConfigClientController { @Value(\"${spring.application.name}\") private String applicationName; //获取微服务名称 @Value(\"${eureka.client.service-url.defaultZone}\") private String eurekaServer; //获取Eureka服务 @Value(\"${server.port}\") private String port; //获取服务端的端口号 @RequestMapping(\"/config\") public String getConfig(){ return \"applicationName:\"+applicationName + \"eurekaServer:\"+eurekaServer + \"port:\"+port; } } 主启动类 @SpringBootApplication public class ConfigClient { public static void main(String[] args) { SpringApplication.run(ConfigClient.class,args); } } 测试： 启动服务端Config_server_3344 再启动客户端ConfigClient 访问：http://localhost:8201/config/ 小案例 本地新建config-dept.yml和config-eureka.yml并提交到码云仓库 这里配置文件内容不再列举直接到代码中看把。 新建springcloud-config-eureka-7001模块，并将原来的springcloud-eureka-7001模块下的内容拷贝的该模块。 1.清空该模块的application.yml配置，并新建bootstrap.yml连接远程配置 spring: cloud: config: name: config-eureka # 仓库中的配置文件名称 label: master profile: dev uri: http://localhost:3344 2.在pom.xml中添加spring cloud config依赖 &lt;!--config--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-config --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; 3.主启动类 @SpringBootApplication @EnableEurekaServer //EnableEurekaServer 服务端的启动类，可以接受别人注册进来~ public class ConfigEurekaServer_7001 { public static void main(String[] args) { SpringApplication.run(ConfigEurekaServer_7001.class,args); } } 4.测试 第一步：启动 Config_Server_3344，并访问 http://localhost:3344/master/config-eureka-dev.yml 测试 第二部：启动ConfigEurekaServer_7001，访问 http://localhost:7001/ 测试 显示上图则成功 新建springcloud-config-dept-8001模块并拷贝springcloud-provider-dept-8001的内容 同理导入spring cloud config依赖、清空application.yml 、新建bootstrap.yml配置文件并配置 spring: cloud: config: name: config-dept label: master profile: dev uri: http://localhost:3344 主启动类 @SpringBootApplication @EnableEurekaClient //在服务启动后自动注册到Eureka中！ @EnableDiscoveryClient //服务发现~ @EnableCircuitBreaker // public class ConfigDeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(ConfigDeptProvider_8001.class,args); } //增加一个 Servlet @Bean public ServletRegistrationBean hystrixMetricsStreamServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet()); registrationBean.addUrlMappings(\"/actuator/hystrix.stream\"); return registrationBean; } } 测试 (略) 服务跟踪Spring Cloud Zipkin Zipkin 是一个可以采集并且跟踪分布式系统中请求数据的组件，让开发者可以更加直观的监控到请求在各个微服务所耗费的时间等，Zipkin：Zipkin Server、Zipkin Client。 ####创建 Zipkin Server 创建 Maven 工程，pom.xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;version&gt;2.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;version&gt;2.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建配置文件 application.yml server: port: 9090 创建启动类 package com.southwind; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import zipkin.server.internal.EnableZipkinServer; @SpringBootApplication @EnableZipkinServer public class ZipkinApplication { public static void main(String[] args) { SpringApplication.run(ZipkinApplication.class,args); } } 注解说明 @EnableZipkinServer：声明启动 Zipkin Server 创建 Zipkin Client 创建 Maven 工程，pom.xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建配置文件 application.yml server: port: 8090 spring: application: name: zipkinclient sleuth: web: client: enabled: true sampler: probability: 1.0 zipkin: base-url: http://localhost:9090/ eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 属性说明 spring.sleuth.web.client.enabled：设置开启请求跟踪 spring.sleuth.sampler.probability：设置采样比例，默认是 1.0 srping.zipkin.base-url：Zipkin Server 地址 创建启动类 package com.southwind; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ZipkinClientApplication { public static void main(String[] args) { SpringApplication.run(ZipkinClientApplication.class,args); } } Handler package com.southwind.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/zipkin\") public class ZipkinHandler { @Value(\"${server.port}\") private String port; @GetMapping(\"/index\") public String index(){ return this.port; } }","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"23种设计模式","slug":"23种设计模式","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:18:16.367Z","comments":true,"path":"posts/ea4e979e.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e979e.html","excerpt":"","text":"设计模式的目的编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好 代码重用性 (即：相同功能的代码，不用多次编写) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响) 使程序呈现高内聚，低耦合的特性分享金句： 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要” Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是前者手背上有很多伤疤 设计模式的七大原则单一职责原则 单一职责的特点 对于这个原则书上是这样说的：对于一个类而言，应该仅有一个引起它变化的原因。换个通俗的语言来说，就是一个类只做自己的分内之事。就拿mvc分成来说的，view就是负责显示数据，model层负责封装数据，control层负责跟视图层跟model层交互。这也是在软件设计中为什么提倡mvc模式。如果不分层把所有代码写在一个类中，到时维护起来会有多么麻烦。这就是单一职责模型的最好的诠释了。其实在软件设计中，大部分都在做一件事就是划分职责。最重要的也最难的就是划分职责。 开放封闭原则 开放封闭的特点 这个原则其实有两个特征，对扩展开放，对修改封闭的。所以在程序中对于程序的设计要思考清楚，如果每次增加新功能都需要去修改原有的代码，那么便不符合，开放封闭原则。在程序中有新功能就新增代码，而不是修改原有的代码。这就是开放封闭的灵魂。 开放封闭原则的优点: 可维护 可扩展 可复用 灵活性好 当然要拒绝不成熟的抽象，并不是每个都去抽象它。 依赖倒置原则 依赖倒置的特点 官方是这样解释的：抽象不应该依赖细节，细节依赖于抽象。换做通俗的话来说就是面向接口编程。 依赖倒置原则： 1.高层模块不应该依赖于低层模块。两个都要依赖于抽象。 2.抽象不应该依赖于细节，细节依赖于抽象。 ​ 简单来说，就是你高层的代码，不应该依赖于底层的代码。应该依赖抽象接口或者类。不管需求怎么改。我们只需要修改具体的实现细节就行了。这就好比修电脑，内存条坏了换内存条就行，不应该说是把主板也换了。 里氏代换原则 里式代换的特点 官方是这样解释的：子类型必须能够完全替代父类型。这是继承的原则简单来说就是父类的东西子类必须有，在面向对象的设计中比如父类有个飞的方法，但是子类是个不能飞的东西（尽量不重写父类方法）。这就违反了这个原则！！！ 再看依赖倒置原则 正是由于子类的可替换性，才使得不用修改父类模块的情况下就可以扩展。如果不依赖于这个原则，那谈什么开源-封闭。 这时候我们再来看看依赖倒置，不管是高层还是低层都依赖于抽象。看完这个应该更能理解依赖倒置原则了吧。如果代码不符合里式代换原则那么依赖倒置也是白谈了。所以依赖倒置大家谁都不依赖谁，除了约定接口外，自由发挥。 合成复用原则 合成复用的特点 这个原则的本质就是不要过多的依赖继承，尽量使用合成（合成是一种强拥有关系，表示部门与整体之间的关系。）或者聚合（聚合是一种弱拥有关系，可以这么理解就是a对象可以包含b对象但是b对象只是a对象的一部分。） 为什么使用合成复用原则 假设目前正在做一个数据库的连接功能，需要支持多种数据库，这时大家的想法肯定都是写一个操作类，然后具体实现类继承这个方法。这个思路是对的。但并不是继承就一定好，如果有一天万不得以，我需要修改的类的一个方法。这时是不是所有的实现类都需要去修改。这就有点牵一发而动全身。但是如果使用的是合成复用原则就不一样了。不管怎么改，我的实现类都是不需要去修改的。这样做其实也是解耦的一种方法。在程序中要遵循这个原则尽量少与人联系，以免遭到无妄之灾。 迪米特原则 迪米特的特点 官方解释：如果两个类不必彼此直接通信，那么两个类就不应该发生直接的相互作用。如果其中一个类调用其中的一个方法的话，应该通过第三者来转发。 为什么使用迪米特原则 在类的设计上，不必让第三者知道的字段或者方法封装好。迪米特原则的根本思想就是强调类之间的松耦合。类之间的耦合越弱越利于复用。一个弱耦合的类被修改，也不会对别的类造成波及。 接口隔离原则这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 如果对于这个六个原则理解已经很深了，那么你的代码质量应该是非常高的了。 23个设计模式（GoF23）总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 创建型模式单例模式单例其实就是相对于系统来说唯一的一个存在。这里引用百度百科中对单例的解释：“是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。” 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 单例模式的设计规则 由定义我们可以很清晰的抽象出： 实现Java单例模式类有哪些通用设计规则？ （1）私有化类构造器。 （2）定义静态私有的类对象。 （3）提供公共静态的获取该私有类对象的方法。 了解了单例模式的概念，以及单例模式的通用设计规则，对于如何实现一个Java单例，应该是没什么阻碍了。这里我们还是要思考下单例模式的优点，或者说有啥好处，使用场景是什么？带着这些问题我们就能更好的设计单例模式。 为什么使用单例 1.Java单例模式解决了什么问题？ 答：Java的单例模式主要解决了多线程并发访问共享资源的线程安全问题。 2.Java单例模式主要应用场景有哪些？ 答：1.共享资源的访问与操作场景，如Windows系统的资源管理器，Windows系统的回收站, 显卡的驱动程序，系统的配置文件，工厂本身（类模板），应用程序的日志对象等。 ​ 2.控制资源访问与操作的场景，如数据库的连接池，Java的线程池等。 单例模式的设计 单例模式的命名 单例的命名通常包含 singleton(以 singleton 开头或结尾) 或能按名称实际意义区分出在应用中唯一。 了解了Java单例模式出现的缘由以及出现的场合，那么，Java的单例究竟是以怎样的方式出现在这些场合中呢？ Java中单例模式的常用实现方式有哪些？ 实现我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。 SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。 饿汉式饿汉式，顾名思义，就是指在JVM首次访问到该单例类时，就会把该单例类对象创建出来，并保存在内存中，不管后续是否会使用到这个单例。 /** * 饿汉式 * 优点： * (1) 没有加任何的锁，执行效率较高 * (2) 线程安全 * 缺点： * (1) 类加载的时候就进行了初始化，程序后续未必会使用到该实例，导致内存浪费 * (2) 反射可破坏单例 */ public class HungrySingleton { /** 私有化类构造器 */ private HungrySingleton() {} /** 定义静态私有类对象 */ private static HungrySingleton instance = new HungrySingleton(); /** 提供公共静态的获取该私有类对象的方法 */ public static HungrySingleton getInstance() { return instance; } } 懒汉式（4种）懒汉式，相比于饿汉式，它是指JVM首次访问到该单例类时，并不会实例化该单例类对象，只有等到后续被外部调用时，才会实例化该单例类对象。 饿汉式的写法比较固定，懒汉式由于延时加载的特性，写法上有一些变化，一般来说，懒汉式存在4个变种。 1、懒汉式1——无锁懒汉式 /** * 懒汉式——无锁，线程不安全 * 优点: * 由于懒汉式延时加载特性，使用该实例时才实例化，节省了内存资源 * * 缺点: * (1) 该种实现方式存在线程不安全问题 * (2) 反序列化，反射与克隆可破坏单例 * * 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 */ public class LazySingletonWithoutSync { /** 私有化类构造器 */ private LazySingletonWithoutSync() {} /** 定义静态私有类对象 */ private static LazySingletonWithoutSync instance; /** 提供公共静态的获取该私有类对象的方法 */ public static LazySingletonWithoutSync getInstance() { if (instance == null) { instance = new LazySingletonWithoutSync(); } return instance; } } 2、懒汉式2——Sync同步锁懒汉式 /** * 懒汉式 * 优点: * (1) 由于懒汉式延时加载特性，使用该实例时才实例化，节省了内存资源 * (2) 线程安全 * 缺点: * (1) 给获取实例的公共方法加上同步锁synchronized，性能受到影响 * (2) 反序列化，反射与克隆可破坏单例 */ public class LazySingletonWithSync { /** 私有化类构造器 */ private LazySingletonWithSync() {} /** 定义静态私有类对象 */ private static LazySingletonWithSync instance; /** 提供公共静态的获取该私有类对象的方法 */ public static synchronized LazySingletonWithSync getInstance() { if (instance == null) { instance = new LazySingletonWithSync(); } return instance; } } 3、懒汉式3——双重锁检查 /** * 懒汉式——双重锁检查单例 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 * 优点: * (1) 由于懒汉式延时加载特性，使用该实例时才实例化，节省了内存资源 * (2) 线程安全 * 缺点: * (1) 如果不加volatile关键词防止指令重排，双重锁检查单例可能会出现不完整实例 * 分析：instance = new LazySingletonWithDoubleCheck() 操作并非原子操作，它包含如下三个操作指令： * 1) 分配对象的内存空间 memory = allocate() * 2) 初始化对象 ctorInstance(memory) * 3) 设置instance指向刚分配的内存地址 instance = memory * 经过指令重排序后，执行顺序可能如下： * 1) 分配对象的内存空间 memory = allocate() * 2) 设置instance指向刚分配的内存地址 instance = memory * 3) 初始化对象 ctorInstance(memory) * 若有A线程执行完上述重排序后的第二步，尚未初始化对象，此时B线程来获取单例instance，会发现instance不为空，于是返回该值，但实际该instance尚未构建完成，为不完整实例。 * (2) 反序列化，反射与克隆可破坏单例 */ public class LazySingletonWithDoubleCheck { /** 私有化类构造器 */ private LazySingletonWithDoubleCheck() {} /** 定义静态私有类对象 */ private static volatile LazySingletonWithDoubleCheck instance; /** 提供公共静态的获取该私有类对象的方法 */ public static LazySingletonWithDoubleCheck getInstance() { if (instance == null) { synchronized (LazySingletonWithDoubleCheck.class) { if (instance == null) { instance = new LazySingletonWithDoubleCheck(); } } } return instance; } } 4、懒汉式4——静态内部类 静态内部类和非静态内部类一样，都是在被调用时才会被加载，以此来实现懒汉模式。所用环境，在单例对象占用资源大，需要延时加载的情况下优选。 /** * 懒汉式——静态内部类单例 * 优点: * (1) 由于懒汉式延时加载特性，使用该实例时才实例化，节省了内存资源 * (2) 在外部类 getInstance 方法被调用的时候内部类才会被加载，巧妙地避免了线程安 全问题 * (3) 兼顾了synchronized的性能问题 * * 缺点: * 反序列化，反射与克隆可破坏单例 */ public class LazySingletonWithInnerClass { /** 私有化类构造器 */ private LazySingletonWithInnerClass() {} /** 使用内部类定义静态私有 LazySingletonWithInnerClass 类对象 */ private static class LazyHolder { private static final LazySingletonWithInnerClass INSTANCE = new LazySingletonWithInnerClass(); } /** 提供公共静态的获取该私有类对象的方法 */ public static LazySingletonWithInnerClass getInstance() { return LazyHolder.INSTANCE; } } 注册登记式每使用一次，都往一个固定的容器中去注册并将使用过的对象进行缓存，下次去取对象的时候，就直接从缓存中取值，以保证每次获取的都是同一个对象。Spring IOC中的单例模式，就是典型的注册登记式单例。 /** * 注册登记式——map容器单例 */ public class RegisterSingletonFromMap { /** 私有化类构造器 */ private RegisterSingletonFromMap() {} /** 使用 ConcurrentHashMap 容器，装载 RegisterSingletonFromMap 类对象 */ private static Map&lt;String, RegisterSingletonFromMap&gt; map = new ConcurrentHashMap&lt;String, RegisterSingletonFromMap&gt;(); /** 提供公共静态的获取该私有类对象的方法 */ public static RegisterSingletonFromMap getInstance() { String className = RegisterSingletonFromMap.class.getName(); synchronized (RegisterSingletonFromMap.class) { if (!map.containsKey(className)) { //ConcurrentMap提供线程安全和原子性保证 map.put(className, new RegisterSingletonFromMap()); } } return map.get(className); } } 枚举型单例/** * 注册登记式还有一种写法，枚举型单例 * 枚举单例 * 这种形式不能防止反射破坏单例，因为构造器还是暴露在枚举外面 */ public class RegisterSingletonFromEnum { /** 私有化类构造器 */ private RegisterSingletonFromEnum() {} /** 使用 enum 实例特性创建 RegisterSingletonFromEnum 类对象 */ private enum Singleton { INSTANCE; private RegisterSingletonFromEnum instance; // JVM保证此方法只调用一次 Singleton() { instance = new RegisterSingletonFromEnum(); } } /** 提供公共静态的获取该私有类对象的方法 */ public static RegisterSingletonFromEnum getInstance() { return Singleton.INSTANCE; } } /** * 这种方式可以防止反射破坏单例，推荐这个，上面不够准确 */ public class SingletonTest08 { public static void main(String[] args) { Singleton instance = Singleton.INSTANCE; Singleton instance2 = Singleton.INSTANCE; System.out.println(instance == instance2); System.out.println(instance.hashCode()); System.out.println(instance2.hashCode()); instance.sayOK(); } } //使用枚举，可以实现单例, 推荐 enum Singleton { INSTANCE; //属性 Singleton(){ //默认构造器，只执行一次 } public void sayOK() { System.out.println(\"ok~\"); } } 序列化与反序列化式序列化与反序列化式单例，需要重写readResolve()方法。 /** * 序列化与反序列化式单例 */ public class SerializableSingleton implements Serializable { /** 私有化类构造器 */ private SerializableSingleton() {} /** 定义静态私有类对象 */ private static final SerializableSingleton singleton = new SerializableSingleton(); /** 提供公共静态的获取该私有类对象的方法 */ public static SerializableSingleton getInstance() { return singleton; } /** 重写readResolve()方法，保证反序列化生成对象时获得的是同一个对象 */ private Object readResolve() throws ObjectStreamException { return singleton; } } 单例模式要点总结 Singleton 模式中的实例构造器可以设置为 protected 以允许子类派生。 Singleton 模式一般不要实现 Clone 接口，因为这有可能导致多个对象实例，与 Singleton 模式的初衷违背。 如何实现多线程环境下安全的 Singleton? 需注意对双检查锁的正确实现。 工厂模式​ 工厂方法模式是对简单工厂的一个衍生，解决了许多简单工厂模式的问题。首先完全实现‘开－闭 原则’，实现了可扩展。其次更复杂的层次结构，可以应用于产品结果复杂的场合。 说了这么多我们先来看看什么情况下使用工厂模式。 应用场景 第一种情况是对于某个产品，调用者清楚地知道应该使用哪个具体工厂服务，实例化该具体工厂，生产出具体的产品来。Java Collection中的iterator() 方法即属于这种情况。 第二种情况，只是需要一种产品，而不想知道也不需要知道究竟是哪个工厂为生产的，即最终选用哪个具体工厂的决定权在生产者一方，它们根据当前系统的情况来实例化一个具体的工厂返回给使用者，而这个决策过程这对于使用者来说是透明的。 工厂方法模式是在简单工厂模式的衍生，所以我们先来了解下什么是简单工厂。 简单工厂模式1、首先先创建一个car的抽象类定义一个run方法 public interface Car { public void run(); } 2、创建实现类 具体的两个产品 宝马车实现类 public class BMWCar implements Car { public void run() { System.out.println(\"bao ma car is running\"); } } 路虎车实现类 public class LandRoverCar implements Car { public void run() { System.out.println(\"LandRover car is runnning \"); } } 3、创建汽车工厂 public class CarFactory { public static Car createBMCar() { return new BMWCar(); } public static Car createLandRoverCar() { return new LandRoverCar(); } } 4、测试 public class Test { public static void main(String[] args) { Car car = CarFactory.createBMCar(); car.run(); } } 测试结果 : bao ma car is running 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。但是同时简单工厂存在于这几个缺点。 缺点： 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响； 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。 工厂方法模式​ 解决了什么问题 简单工厂模式存在着不易扩展，违背开闭原则的致命缺点。所以工厂方法就是在简单工厂的模式上解决它不易于扩展的缺点。 ​ 工厂方法的实现 首先先创建一个car的抽象类定义一个run方法 public interface Car { public void run(); } 创建实现类 具体的两个产品 宝马车实现类 public class BMWCar implements Car { public void run() { System.out.println(\"bao ma car is running\"); } } 路虎车实现类 public class LandRoverCar implements Car { public void run() { System.out.println(\"LandRover car is runnning \"); } } 抽象工厂 public interface CarFactory { public Car createCar(); } 工厂实现类 宝马工厂 public class BMWCarFactory implements CarFactory { public Car createCar() { return new BMWCar(); } } 路虎工厂 public class LandRoverCarFactory implements CarFactory { public Car createCar() { return new LandRoverCar(); } } 测试 public class Consumer { public static void main(String[] args) { Car car1 = new BMWCarFactory().createCar(); Car car2 = new LandRoverCarFactory().createCar(); car1.run(); car2.run(); } } 总结: 这里这样设计的好处，就是如果需要加新产品，只需要新增工厂实现类就行了，不需要去改原来的代码了。这就易于扩展，解决了简单工厂的缺点。缺点就是代码量也变多了。 抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。抽象工厂的源头是一个超级大厂，维护着若干个小厂。就算需求变了这边只需要改具体小厂的制作方法就行了。 1、产品类接口 手机类 public interface PhoneProducton { void start(); void shutdown(); void call(); void sendMSS(); } 路由器类 public interface RouterProduction { void start(); void shutdown(); void openWiFi(); } 2、具体品牌产品实现类 小米产品 //小米手机 public class XiaoMiPhone implements PhoneProducton { @Override public void start() { System.out.println(\"小米手机开启\"); } @Override public void shutdown() { System.out.println(\"小米手机关闭\"); } @Override public void call() { System.out.println(\"小米手机打电话\"); } @Override public void sendMSS() { System.out.println(\"小米手机发短信\"); } } //小米路由器 public class XiaoMiRouter implements RouterProduction{ @Override public void start() { System.out.println(\"小米路由器开启\"); } @Override public void shutdown() { System.out.println(\"小米路由器关闭\"); } @Override public void openWiFi() { System.out.println(\"小米WiFi开启\"); } } 华为产品 //华为手机 public class HuaWeiPhone implements PhoneProducton { @Override public void start() { System.out.println(\"华为手机开启\"); } @Override public void shutdown() { System.out.println(\"华为手机关闭\"); } @Override public void call() { System.out.println(\"华为手机打电话\"); } @Override public void sendMSS() { System.out.println(\"华为手机发短信\"); } } //华为路由器 public class HuaWeiRouter implements RouterProduction{ @Override public void start() { System.out.println(\"华为路由器开启\"); } @Override public void shutdown() { System.out.println(\"华为路由器关闭\"); } @Override public void openWiFi() { System.out.println(\"华为WiFi开启\"); } } 3、抽象工厂，生产抽象产品 public interface Factory { //生产手机 PhoneProducton createPhone(); //生产路由器 RouterProduction createRouter(); } 4、具体品牌工厂实现类，生产各自品牌产品 小米工厂 public class XiaoMiFactory implements Factory{ @Override public PhoneProducton createPhone() { return new XiaoMiPhone(); } @Override public RouterProduction createRouter() { return new XiaoMiRouter(); } } 华为工厂 public class HuaWeiFactory implements Factory{ @Override public PhoneProducton createPhone() { return new HuaWeiPhone(); } @Override public RouterProduction createRouter() { return new HuaWeiRouter(); } } 5、消费者测试 public class Consumer { public static void main(String[] args) { System.out.println(\"---------小米产品----------\"); PhoneProducton phone = new XiaoMiFactory().createPhone(); RouterProduction router = new XiaoMiFactory().createRouter(); phone.call(); router.openWiFi(); System.out.println(\"---------华为产品----------\"); phone = new HuaWeiFactory().createPhone(); router = new HuaWeiFactory().createRouter(); phone.call(); router.openWiFi(); } } 大概逻辑图 从代码可以看出，如果产品增加，我们就需要加实现类就行了。但是这样创建产品的过程就非常复杂了，需要增加很多代码。所以抽象工厂是真的工厂，工厂方法模式就相当于一条生产线。 建造者模式建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 何时使用：一些基本部件不会变，而其组合经常变化的时候。 如何解决：将变与不变分离开。 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 建造者模式将复杂产品的构建过程封装在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。用一个指挥官去指定需要创建哪个对象，指定了创建顺序。把具体的创建过程隐藏了起来。如果需要创建不同种类的对象只需要传入不同的实现类就行了。这就是建造者模式。 但是如果某个产品的内部结构过于复杂，将会导致整个系统变得非常庞大，不利于控制，同时若干个产品之间存在较大的差异，则不适用建造者模式，毕竟这个世界上存在相同点大的两个产品不多，所以它的使用范围有限。 实现 我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。 我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。 然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。 1、创建一个表示食物条目和食物包装的接口 食物接口 Item.java public interface Item { public String name(); public Packing packing(); public float price(); } 包装接口 Packing.java public interface Packing { public String pack(); } 2、创建实现 Packing 接口的实体类 纸盒 Wrapper.java public class Wrapper implements Packing { @Override public String pack() { return \"Wrapper\"; } } 瓶子 Bottle.java public class Bottle implements Packing { @Override public String pack() { return \"Bottle\"; } } 3、创建实现 Item 接口的抽象类，该类提供了默认的功能 汉堡抽象类 Burger.java public abstract class Burger implements Item { @Override public Packing packing() { return new Wrapper();//注意这里是一个包装类 } @Override public abstract float price(); } 冷饮抽象类 ColdDrink.java public abstract class ColdDrink implements Item { @Override public Packing packing() { return new Bottle(); //注意这里是一个包装类 } @Override public abstract float price(); } 4、创建扩展了 Burger 和 ColdDrink 的实体类。 素食汉堡 VegBurger.java public class VegBurger extends Burger { @Override public float price() { return 25.0f; } @Override public String name() { return \"Veg Burger\"; } } 鸡肉汉堡 ChickenBurger.java public class ChickenBurger extends Burger { @Override public float price() { return 50.5f; } @Override public String name() { return \"Chicken Burger\"; } } 可乐 Coke.java public class Coke extends ColdDrink { @Override public float price() { return 30.0f; } @Override public String name() { return \"Coke\"; } } 雪碧 Pepsi.java public class Pepsi extends ColdDrink { @Override public float price() { return 35.0f; } @Override public String name() { return \"Pepsi\"; } } 5、创建一个 Meal 类，带有上面定义的 Item 对象。 套餐 Meal.java import java.util.ArrayList; import java.util.List; public class Meal { private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); //套餐增加食物 public void addItem(Item item){ items.add(item); } //获取套餐总价格 public float getCost(){ float cost = 0.0f; for (Item item : items) { cost += item.price(); } return cost; } //打印套餐信息 public void showItems(){ for (Item item : items) { System.out.print(\"Item : \"+item.name()); //item.packing()返回的是packing 类对象 System.out.print(\", Packing : \"+item.packing().pack()); System.out.println(\", Price : \"+item.price()); } } } 6、创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。 各种套餐组合 MealBuilder.java（指挥官，核心类） public class MealBuilder { //套餐一：素食汉堡加可乐 public Meal prepareVegMeal (){ Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; } //套餐二：鸡肉汉堡加雪碧 public Meal prepareNonVegMeal (){ Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; } } 7、BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。 顾客点套餐 BuilderPatternDemo.java public class BuilderPatternDemo { public static void main(String[] args) { MealBuilder mealBuilder = new MealBuilder(); //套餐一：素食汉堡加可乐 Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println(\"Veg Meal\"); vegMeal.showItems(); System.out.println(\"Total Cost: \" +vegMeal.getCost()); //套餐二：鸡肉汉堡加雪碧 Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println(\"\\n\\nNon-Veg Meal\"); nonVegMeal.showItems(); System.out.println(\"Total Cost: \" +nonVegMeal.getCost()); } } 执行程序，输出结果： Veg Meal Item : Veg Burger, Packing : Wrapper, Price : 25.0 Item : Coke, Packing : Bottle, Price : 30.0 Total Cost: 55.0 Non-Veg Meal Item : Chicken Burger, Packing : Wrapper, Price : 50.5 Item : Pepsi, Packing : Bottle, Price : 35.0 Total Cost: 85.5 原型模式原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 介绍 意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 主要解决：在运行期建立和删除原型。 优点： 1、性能提高。 2、逃避构造函数的约束。 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 什么是浅复制，深复制？ 熟悉java的朋友都知道，java自带一个克隆方法（clone）。这是一个native的方法，这个方法不做任何改变的话默认是浅复制的。 浅复制 被复制对象的基本数据类型的值跟原来相同，引用对象类型的还是指向原对象的引用对象，也就是指向地址一样。 深复制 被复制对象的基本数据类型的值跟原来相同，引用对象类型的是指向新对象的，相当于创建了一个新的被引用对象，跟被克隆的原对象不是同一个引用对象。 默认浅复制数据类 Person public class Person implements Cloneable { private int age; private String name; private Address address; public Person(int age, String name, Address address) { this.age = age; this.name = name; this.address = address; } public Address getAddress() { return address; } @Override protected Person clone() throws CloneNotSupportedException { return (Person)super.clone(); } } 数据类 Address public class Address { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public Address(String name) { this.name=name; } } 测试 public class Test { public static void main(String[] args) throws CloneNotSupportedException { Address address = new Address(\"北京\"); Person p = new Person(19, \"李四\", address); //浅复制测试 System.out.println(\"浅复制测试\"); Person p1 = p.clone(); System.out.println(p == p1); p1.getAddress().setName(\"深圳\"); System.out.println(p); System.out.println(p1); } 输出结果 false Person{age=19, name='李四', address=Address{name='深圳'}} Person{age=19, name='李四', address=Address{name='深圳'}} 结论：java默认的clone方法是浅复制，复制后的对象address跟原来的对象指向是一样的。这时大家心里可能会有疑问，如果要使用java默认的clone方法实现深复制。实现深复制的话这边需要改一下原来方法的逻辑，代码如下 使用原生的clone方法实现深复制数据类 Person 重写clone方法的逻辑 @Override protected Person clone() throws CloneNotSupportedException { Person clone = (Person) super.clone(); Object o = clone.getAddress().clone(); clone.setAddress((Address) o); return clone; } 数据类 Address 需要实现 Cloneable 接口，并且重写Clone（）方法 public class Address implements Cloneable{ private String name; public void setName(String name) { this.name = name; } public String getName() { return name; } public Address(String name) { this.name = name; } @Override public String toString() { return \"Address{\" + \"name='\" + name + '\\'' + '}'; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } 测试 public class Test { public static void main(String[] args) throws CloneNotSupportedException { Address address = new Address(\"深圳\"); Person p = new Person(19, \"李四\", address); //深复制实现clone的方式 System.out.println(\"深复制测试\"); Person p2 = p.clone(); System.out.println(p == p2); p2.getAddress().setName(\"北京\"); System.out.println(p); System.out.println(p2); } } 根据我们测试用例在来跑一次 输出结果 false Person{age=19, name='李四', address=Address{name='深圳'}} Person{age=19, name='李四', address=Address{name='北京'}} 深复制总结: ① 如果有一个非原生成员，如自定义对象的成员，那么就需要深复制： 该成员实现Cloneable接口并覆盖clone()方法，不要忘记提升为protected可继承。 同时，修改被复制类的clone()方法，增加成员的克隆逻辑。 ② 如果被复制对象不是直接继承Object，中间还有其它继承层次，每一层super类都需要实现Cloneable接口并覆盖clone()方法。与对象成员不同，继承关系中的clone不需要被复制类的clone()做修改。 一句话来说，如果实现完整的深拷贝，需要被复制对象的继承链、引用链上的每一个对象都实现克隆机制。 前面的实例还可以接受，如果有N个对象成员，有M层继承关系，就会很麻烦。 使用序列化的方式实现深复制这个方式可以理解为，把对象转化成二进制流的形式，然后再把流序列化成对象。 具体实现方法 /** * person类和address类都要实现serializable接口 * @return 使用读二进制形式流的方式实现深克隆 * @throws CloneNotSupportedException */ public Person deepCopy() { /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try { bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(this); bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); return (Person) ois.readObject(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { bos.close(); oos.close(); bis.close(); ois.close(); } /* 读出二进制流产生的新对象 */ return null; } 测试 //深复制实现流的方式 System.out.println(\"深复制测试二进制流\"); Person p3 = p.deepCopy(); System.out.println(p == p3); p3.getAddress().setName(\"上海\"); System.out.println(p); System.out.println(p3); 输出结果 false Person{age=19, name='李四', address=Address{name='深圳'}} Person{age=19, name='李四', address=Address{name='上海'}} 序列化总结: 这种方式被复制对象的继承链、引用链上的每一个对象都实现java.io.Serializable接口。这个比较简单，不需要实现任何方法，serialVersionID的要求不强制，对深拷贝来说没毛病。这种是最常用，而且比较简单的方法。 总结 所谓原型模式，就是通过复制对象来创建对象。与通过使用构造函数来比，就是通过复制的对象带有原来对象的一些状态。尤其是在一些场景对象只存在细微差别。这时就可以使用原型模式去创建对象。 结构型模式适配器模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。在程序中这个模式也是会用到的，在不能直接去改变源码的情况，但是这个接口的又不能直接用。这时候就需要考虑适配模式，去复用一些现成的类。得到想要的业务逻辑。 由于java是不支持多继承的而类的适配器模式就是通过多重继承来实现的所以现在讲的主要是对象适配器模式。 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。 缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。 注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 网线 Adptee 类 //要被适配的类：网线 public class Adaptee { public void request() { System.out.println(\"连接网线上网\"); } } 适配器接口 NetToUsb //接口转换器的抽象实现 public interface NetToUsb { //作用：处理请求，网线=》USb public void handleRequest(); } 适配器 Adapter 类 （核心类） //真正的适配器： 需要连接uSB，连接网线 public class Adapter implements NetToUsb{ //网线 private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void handleRequest() { adaptee.request(); } } 客户端 Computer 类 //客户端 想上网 连不上网线~ public class Computer { public void net(NetToUsb adapter) { //上网的具体实现，找一个转接头 adapter.handleRequest(); } public static void main(String[] args) { Computer computer = new Computer(); Adaptee adaptee = new Adaptee(); Adapter adapter = new Adapter(adaptee); computer.net(adapter); } } 桥接模式桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 意图：将抽象部分与实现部分分离，使它们都可以独立的变化。 主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。 何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。 如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。 优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。 缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。 品牌类接口 Brand //品牌接口 public interface Brand { void info(); } 联想品牌类 Lenovo //联想品牌 public class Lenovo implements Brand { @Override public void info() { System.out.print(\"联想\"); } } 苹果品牌类 Apple //苹果品牌 public class Apple implements Brand { @Override public void info() { System.out.print(\"苹果\"); } } 电脑抽象类 Computer （核心类） //抽象的电脑类型类 public abstract class Computer { //组合，品牌 ,protected 子类继承才能使用，private 子类不能继承使用 protected Brand brand; public Computer(Brand brand) { this.brand = brand; } public void info() { brand.info();//自带品牌 } } 台式电脑类 Desktop //桌面电脑 public class Desktop extends Computer{ public Desktop(Brand brand) { super(brand); } @Override public void info() { super.info(); System.out.println(\"台式机\"); } } 笔记本电脑类 Laptop //笔记本电脑 public class Laptop extends Computer{ public Laptop(Brand brand) { super(brand); } @Override public void info() { super.info(); System.out.println(\"笔记本\"); } } 测试 public class Test { public static void main(String[] args) { //联想台式电脑 Desktop desktop = new Desktop(new Lenovo()); //苹果台式电脑 Desktop desktop1 = new Desktop(new Apple()); desktop.info(); desktop1.info(); //联想笔记本电脑 Laptop laptop = new Laptop(new Lenovo()); //苹果笔记本电脑 Laptop laptop1 = new Laptop(new Apple()); laptop.info(); laptop1.info(); } } 装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。 介绍 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。 何时使用：在不想增加很多子类的情况下扩展类。 如何解决：将具体功能职责划分，同时继承装饰者模式。 关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。 应用实例： 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层装饰比较复杂。 使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。 注意事项：可代替继承。 实现 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。 RedShapeDecorator 是实现了 ShapeDecorator 的实体类。 DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。 1、创建一个接口 Shape.java public interface Shape { void draw(); } 2、创建实现接口的实体类 Rectangle.java public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Shape: Rectangle\"); } } Circle.java public class Circle implements Shape { @Override public void draw() { System.out.println(\"Shape: Circle\"); } } 3、创建实现了 Shape 接口的抽象装饰类 ，想要实现图形修饰的具体实现类都得继承实现该抽象类 ShapeDecorator.java (核心类) //装饰抽象类 public abstract class ShapeDecorator implements Shape { // 注意这里得用protected修饰，不然子类无法继承 protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape){ this.decoratedShape = decoratedShape; } public void draw(){ decoratedShape.draw(); } } 4、创建扩展了 ShapeDecorator 类的实体装饰类 RedShapeDecorator.java //装饰具体实现类 public class RedShapeDecorator extends ShapeDecorator { public RedShapeDecorator(Shape decoratedShape) { super(decoratedShape); } @Override public void draw() { decoratedShape.draw(); setRedBorder(decoratedShape); } //添加红色边框装饰功能 private void setRedBorder(Shape decoratedShape){ System.out.println(\"Border Color: Red\"); } } 5、使用 RedShapeDecorator 来装饰 Shape 对象 DecoratorPatternDemo.java public class DecoratorPatternDemo { public static void main(String[] args) { Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); //Shape redCircle = new RedShapeDecorator(new Circle()); //Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(\"Circle with normal border\"); circle.draw(); System.out.println(\"\\nCircle of red border\"); redCircle.draw(); System.out.println(\"\\nRectangle of red border\"); redRectangle.draw(); } } 执行程序，输出结果： Circle with normal border Shape: Circle Circle of red border Shape: Circle Border Color: Red Rectangle of red border Shape: Rectangle Border Color: Red 代理模式在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 介绍 意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 实现 我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。 ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。 1、创建一个接口。 Image.java public interface Image { void display(); } 2、创建实现接口的实体类。 RealImage.java public class RealImage implements Image { private String fileName; public RealImage(String fileName){ this.fileName = fileName; loadFromDisk(fileName); } @Override public void display() { System.out.println(\"Displaying \" + fileName); } private void loadFromDisk(String fileName){ System.out.println(\"Loading \" + fileName); } } ProxyImage.java （核心类） //代理类 public class ProxyImage implements Image{ private RealImage realImage; private String fileName; public ProxyImage(String fileName){ this.fileName = fileName; } @Override public void display() { //如果没有被代理对象就新建一个 if(realImage == null){ realImage = new RealImage(fileName); } //代理展示功能 realImage.display(); } } 3、当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。 ProxyPatternDemo.java public class ProxyPatternDemo { public static void main(String[] args) { Image image = new ProxyImage(\"test_10mb.jpg\"); // 图像将从磁盘加载 image.display(); System.out.println(\"\"); // 图像不需要从磁盘加载 image.display(); } } 执行程序，输出结果： Loading test_10mb.jpg Displaying test_10mb.jpg Displaying test_10mb.jpg 外观模式外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 介绍 意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。 如何解决：客户端不与系统耦合，外观类与系统耦合。 关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。 应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。 优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。 缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。 使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。 注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。 实现 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。 ShapeMaker 类使用实体类来代表用户对这些类的调用。FacadePatternDemo，我们的演示类使用 ShapeMaker 类来显示结果。 1、创建一个接口 Shape.java public interface Shape { void draw(); } 2、创建实现接口的实体类 Rectangle.java public class Rectangle implements Shape { //子系统暴露给外部系统调用的接口 @Override public void draw() { System.out.println(\"Rectangle::draw()\"); } } Square.java public class Square implements Shape { //子系统暴露给外部系统调用的接口 @Override public void draw() { System.out.println(\"Square::draw()\"); } } Circle.java public class Circle implements Shape { //子系统暴露给外部系统调用的接口 @Override public void draw() { System.out.println(\"Circle::draw()\"); } } 3、创建一个外观类 ShapeMaker.java （核心类） public class ShapeMaker { private Shape circle; private Shape rectangle; private Shape square; //外部系统总系统--拥有很多子系统 public ShapeMaker() { circle = new Circle(); rectangle = new Rectangle(); square = new Square(); } //调用子系统接口 public void drawCircle(){ circle.draw(); } public void drawRectangle(){ rectangle.draw(); } public void drawSquare(){ square.draw(); } } 4、使用该外观类画出各种类型的形状 FacadePatternDemo.java public class FacadePatternDemo { public static void main(String[] args) { ShapeMaker shapeMaker = new ShapeMaker(); shapeMaker.drawCircle(); shapeMaker.drawRectangle(); shapeMaker.drawSquare(); } } 执行程序，输出结果： Circle::draw() Rectangle::draw() Square::draw() 组合模式组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了同类型对象组的树形结构。 这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。 介绍 意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。 关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。 应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。 优点： 1、高层模块调用简单。 2、节点自由增加。 缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。 使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。 注意事项：定义时为具体类。 实现 我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。 1、创建 Employee 类，该类带有 Employee 对象的列表 Employee.java （核心类） import java.util.ArrayList; import java.util.List; public class Employee { private String name; private String dept; private int salary; //下属员工集合，组合其他同类型对象 private List&lt;Employee&gt; subordinates; //构造函数 public Employee(String name,String dept, int sal) { this.name = name; this.dept = dept; this.salary = sal; subordinates = new ArrayList&lt;Employee&gt;(); } public void add(Employee e) { subordinates.add(e); } public void remove(Employee e) { subordinates.remove(e); } public List&lt;Employee&gt; getSubordinates(){ return subordinates; } public String toString(){ return (\"Employee :[ Name : \"+ name +\", dept : \"+ dept + \", salary :\" + salary+\" ]\"); } } 2、使用 Employee 类来创建和打印员工的层次结构 CompositePatternDemo.java public class CompositePatternDemo { public static void main(String[] args) { Employee CEO = new Employee(\"John\",\"CEO\", 30000); Employee headSales = new Employee(\"Robert\",\"Head Sales\", 20000); Employee headMarketing = new Employee(\"Michel\",\"Head Marketing\", 20000); Employee clerk1 = new Employee(\"Laura\",\"Marketing\", 10000); Employee clerk2 = new Employee(\"Bob\",\"Marketing\", 10000); Employee salesExecutive1 = new Employee(\"Richard\",\"Sales\", 10000); Employee salesExecutive2 = new Employee(\"Rob\",\"Sales\", 10000); CEO.add(headSales); CEO.add(headMarketing); headSales.add(salesExecutive1); headSales.add(salesExecutive2); headMarketing.add(clerk1); headMarketing.add(clerk2); //打印该组织的所有员工，层次结构 System.out.println(CEO); for (Employee headEmployee : CEO.getSubordinates()) { System.out.println(headEmployee); for (Employee employee : headEmployee.getSubordinates()) { System.out.println(employee); } } } } 执行程序，输出结果为： Employee :[ Name : John, dept : CEO, salary :30000 ] Employee :[ Name : Robert, dept : Head Sales, salary :20000 ] Employee :[ Name : Richard, dept : Sales, salary :10000 ] Employee :[ Name : Rob, dept : Sales, salary :10000 ] Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ] Employee :[ Name : Laura, dept : Marketing, salary :10000 ] Employee :[ Name : Bob, dept : Marketing, salary :10000 ] 享元模式享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。 介绍 意图：运用共享技术有效地支持大量细粒度的对象。 主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。 何时使用： 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。 如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。 关键代码：用 HashMap 存储这些对象。 应用实例： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。 优点：大大减少对象的创建，降低系统的内存，使效率提高。 缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。 使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。 注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。 实现 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。 ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。 FlyWeightPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red / green / blue/ black / white），以便获取它所需对象的颜色。 1、创建一个接口 Shape.java public interface Shape { void draw(); } 2、创建实现接口的实体类 Circle.java public class Circle implements Shape { private String color; private int x; private int y; private int radius; //根据颜色构造Circle public Circle(String color){ this.color = color; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } public void setRadius(int radius) { this.radius = radius; } @Override public void draw() { System.out.println(\"Circle: Draw() [Color : \" + color +\", x : \" + x +\", y :\" + y +\", radius :\" + radius); } } 3、创建一个工厂，生成基于给定信息的实体类的对象 ShapeFactory.java （核心类） import java.util.HashMap; public class ShapeFactory { //通过 Hashmap 来存储 Circle private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;(); public static Shape getCircle(String color) { //通过 颜色（color） key 来取 Circle Circle circle = (Circle)circleMap.get(color); if(circle == null) {//说明 map 里面没有存储该颜色的Circle circle = new Circle(color); circleMap.put(color, circle); // circleMap.put(color, new Circle(color)); 不能这样写，因为这样写下面return circle;返回的是null值 System.out.println(\"Creating circle of color : \" + color); } return circle; } } 4、使用该工厂，通过传递颜色信息来获取实体类的对象 FlyweightPatternDemo.java public class FlyweightPatternDemo { private static final String colors[] = { \"Red\", \"Green\", \"Blue\", \"White\", \"Black\" }; public static void main(String[] args) { for(int i=0; i &lt; 20; ++i) { //从工厂获取 Circle对象 Circle circle = (Circle)ShapeFactory.getCircle(getRandomColor()); circle.setX(getRandomX()); circle.setY(getRandomY()); circle.setRadius(100); circle.draw(); } } //获取随机颜色 private static String getRandomColor() { return colors[(int)(Math.random()*colors.length)]; } //获取随机X值 private static int getRandomX() { return (int)(Math.random()*100 ); } //获取随机Y值 private static int getRandomY() { return (int)(Math.random()*100); } } 执行程序，输出结果： Creating circle of color : Black Circle: Draw() [Color : Black, x : 36, y :71, radius :100 Creating circle of color : Green Circle: Draw() [Color : Green, x : 27, y :27, radius :100 Creating circle of color : White Circle: Draw() [Color : White, x : 64, y :10, radius :100 Creating circle of color : Red Circle: Draw() [Color : Red, x : 15, y :44, radius :100 Circle: Draw() [Color : Green, x : 19, y :10, radius :100 Circle: Draw() [Color : Green, x : 94, y :32, radius :100 Circle: Draw() [Color : White, x : 69, y :98, radius :100 Creating circle of color : Blue Circle: Draw() [Color : Blue, x : 13, y :4, radius :100 Circle: Draw() [Color : Green, x : 21, y :21, radius :100 Circle: Draw() [Color : Blue, x : 55, y :86, radius :100 Circle: Draw() [Color : White, x : 90, y :70, radius :100 Circle: Draw() [Color : Green, x : 78, y :3, radius :100 Circle: Draw() [Color : Green, x : 64, y :89, radius :100 Circle: Draw() [Color : Blue, x : 3, y :91, radius :100 Circle: Draw() [Color : Blue, x : 62, y :82, radius :100 Circle: Draw() [Color : Green, x : 97, y :61, radius :100 Circle: Draw() [Color : Green, x : 86, y :12, radius :100 Circle: Draw() [Color : Green, x : 38, y :93, radius :100 Circle: Draw() [Color : Red, x : 76, y :82, radius :100 Circle: Draw() [Color : Blue, x : 95, y :82, radius :100 行为型模式策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 介绍 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决：将这些算法封装成一个一个的类，任意地替换。 关键代码：实现同一个接口。 应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。 优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 实现 我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。 StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。 1、创建一个行为接口 Strategy.java public interface Strategy { public int doOperation(int num1, int num2); } 2、创建实现行为接口的具体行为类 OperationAdd.java public class OperationAdd implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 + num2; } } OperationSubtract.java public class OperationSubtract implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 - num2; } } OperationMultiply.java public class OperationMultiply implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 * num2; } } 3、创建行为根据构造参数不同而进行不同行为的Context 类 （核心类） Context.java public class Context { private Strategy strategy; //构造时传进来相应的具体行为类，具体的策略 public Context(Strategy strategy){ this.strategy = strategy; } //在这里通过传进来的具体的行为类，进行相应的行为方法 public int executeStrategy(int num1, int num2){ return strategy.doOperation(num1, num2); } } 4、使用 Context 来查看当它改变策略 Strategy 时的行为变化 StrategyPatternDemo.java public class StrategyPatternDemo { public static void main(String[] args) { Context context = new Context(new OperationAdd()); System.out.println(\"10 + 5 = \" + context.executeStrategy(10, 5)); context = new Context(new OperationSubtract()); System.out.println(\"10 - 5 = \" + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println(\"10 * 5 = \" + context.executeStrategy(10, 5)); } } 执行程序，输出结果： 10 + 5 = 15 10 - 5 = 5 10 * 5 = 50 模板模式在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 介绍 意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 主要解决：一些方法通用，却在每一个子类都重新写了这一方法。 何时使用：有一些通用的方法。 如何解决：将这些通用算法抽象出来。 关键代码：在抽象类实现，其他步骤在子类实现。 应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。 优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。 注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。 实现 我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。 TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。 1、创建一个抽象类，它的模板方法被设置为 final Game.java （核心类） public abstract class Game { abstract void initialize(); abstract void startPlay(); abstract void endPlay(); //模板方法 public final void play(){ //初始化游戏 initialize(); //开始游戏 startPlay(); //结束游戏 endPlay(); } } 2、创建扩展了上述类的实体类 Cricket.java public class Cricket extends Game { @Override void endPlay() { System.out.println(\"Cricket Game Finished!\"); } @Override void initialize() { System.out.println(\"Cricket Game Initialized! Start playing.\"); } @Override void startPlay() { System.out.println(\"Cricket Game Started. Enjoy the game!\"); } } Football.java public class Football extends Game { @Override void endPlay() { System.out.println(\"Football Game Finished!\"); } @Override void initialize() { System.out.println(\"Football Game Initialized! Start playing.\"); } @Override void startPlay() { System.out.println(\"Football Game Started. Enjoy the game!\"); } } 3、使用 Game 的模板方法 play() 来演示游戏的定义方式 TemplatePatternDemo.java public class TemplatePatternDemo { public static void main(String[] args) { Game game = new Cricket(); game.play();//play方法是模板方法，其包含了其他方法的执行启动 System.out.println(); game = new Football(); game.play(); } } 执行程序，输出结果： Cricket Game Initialized! Start playing. Cricket Game Started. Enjoy the game! Cricket Game Finished! Football Game Initialized! Start playing. Football Game Started. Enjoy the game! Football Game Finished! 观察者模式当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。 介绍 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 关键代码：在抽象类里有一个 ArrayList 存放观察者们。 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 使用场景： 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 实现 观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。 ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。 1、创建 Subject 类，用于绑定观察者到 Client 对象和从 Client 对象解绑观察者，被观察者对象 Subject.java （核心类） import java.util.ArrayList; import java.util.List; public class Subject { //观察者集合 private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); private int state;//subject的一个属性 public int getState() { return state; } public void setState(int state) { this.state = state; //一旦更改属性值，就通知所有的观察者 notifyAllObservers(); } public void attach(Observer observer){ //添加观察者 observers.add(observer); } public void notifyAllObservers(){ // 通知所有观察者，进行相应操作 for (Observer observer : observers) { observer.update(); } } } 2、创建抽象观察者类 Observer Observer.java public abstract class Observer { protected Subject subject; public abstract void update(); } 3、创建实体观察者类 BinaryObserver.java public class BinaryObserver extends Observer{ public BinaryObserver(Subject subject){ //构造该观察者时将该观察者绑定到subject中 this.subject = subject; this.subject.attach(this); } @Override public void update() { //subject对象的属性一旦进行set操作，subject就会通知该观察者进行该操作 System.out.println( \"Binary String: \" + Integer.toBinaryString( subject.getState() ) ); } } OctalObserver.java public class OctalObserver extends Observer{ public OctalObserver(Subject subject){ //构造该观察者时将该观察者绑定到subject中 this.subject = subject; this.subject.attach(this); } @Override public void update() { //subject对象的属性一旦进行set操作，subject就会通知该观察者进行该操作 System.out.println( \"Octal String: \" + Integer.toOctalString( subject.getState() ) ); } } HexaObserver.java public class HexaObserver extends Observer{ public HexaObserver(Subject subject){ //构造该观察者时将该观察者绑定到subject中 this.subject = subject; this.subject.attach(this); } @Override public void update() { //subject对象的属性一旦进行set操作，subject就会通知该观察者进行该操作 System.out.println( \"Hex String: \" + Integer.toHexString( subject.getState() ).toUpperCase() ); } } 4、使用 Subject 和实体观察者对象。 ObserverPatternDemo.java public class ObserverPatternDemo { public static void main(String[] args) { Subject subject = new Subject(); //将各个观察者绑定到subject new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println(\"First state change: 15\"); //subject属性进行set修改操作，通知所有观察者进行相应操作 subject.setState(15); System.out.println(\"Second state change: 10\"); subject.setState(10); } } 执行程序，输出结果： First state change: 15 Hex String: F Octal String: 17 Binary String: 1111 Second state change: 10 Hex String: A Octal String: 12 Binary String: 1010 迭代器模式迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。 介绍 意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 主要解决：不同的方式来遍历整个整合对象。 何时使用：遍历一个聚合对象。 如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。 关键代码：定义接口：hasNext, next。 应用实例：JAVA 中的 iterator。 优点： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。 注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。 实现 我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 Container 接口。实现了 Container 接口的实体类将负责实现 Iterator 接口。 IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的 Names。 1、创建接口: Iterator.java public interface Iterator { //判断是否有下一个元素 public boolean hasNext(); //返回下一个元素 public Object next(); } Container.java public interface Container { //获取迭代器 public Iterator getIterator(); } 2、创建实现了 Container 接口的实体类，该类有实现了 Iterator 接口的内部类 NameIterator NameRepository.java （核心类） public class NameRepository implements Container { public String names[] = {\"Robert\" , \"John\" ,\"Julie\" , \"Lora\"}; @Override public Iterator getIterator() { return new NameIterator(); } private class NameIterator implements Iterator { //创建对象时初始化默认为0 int index; @Override public boolean hasNext() { //为什么最后一个元素的hasNext为true？因为最后一个元素index为length-1 if(index &lt; names.length){ return true; } return false; } @Override public Object next() { if(this.hasNext()){ return names[index++];//返回元素后，index+1，下标指向下一个元素 } return null; } } } 3、使用 NameRepository 来获取迭代器，并打印名字 IteratorPatternDemo.java public class IteratorPatternDemo { public static void main(String[] args) { NameRepository namesRepository = new NameRepository(); for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){ String name = (String)iter.next(); System.out.println(\"Name : \" + name); } } } 执行程序，输出结果： Name : Robert Name : John Name : Julie Name : Lora 责任链模式顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 介绍 意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用：在处理消息的时候以过滤很多道。 如何解决：拦截的类都实现统一接口。 关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。 应用实例： 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。 注意事项：在 JAVA WEB 中遇到很多应用。 实现 我们创建抽象类 AbstractLogger，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 AbstractLogger。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。 1、创建抽象的记录器类。 AbstractLogger.java （核心类） public abstract class AbstractLogger { //等级划分 public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; //责任链中的下一个元素 protected AbstractLogger nextLogger; public void setNextLogger(AbstractLogger nextLogger){ this.nextLogger = nextLogger; } public void logMessage(int level, String message){ //如果传进来的事务等级大于等于接收者的等级，就打印信息 if(this.level &lt;= level){ write(message); } //如果接收者有下一个接受者，就传递下去 if(nextLogger !=null){ nextLogger.logMessage(level, message); } } abstract protected void write(String message); } 2、创建扩展了该记录器类的实体类。 ConsoleLogger.java public class ConsoleLogger extends AbstractLogger { public ConsoleLogger(int level){ this.level = level; } @Override protected void write(String message) { System.out.println(\"Standard Console::Logger: \" + message); } } ErrorLogger.java public class ErrorLogger extends AbstractLogger { public ErrorLogger(int level){ this.level = level; } @Override protected void write(String message) { System.out.println(\"Error Console::Logger: \" + message); } } FileLogger.java public class FileLogger extends AbstractLogger { public FileLogger(int level){ this.level = level; } @Override protected void write(String message) { System.out.println(\"File::Logger: \" + message); } } 3、创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。 ChainPatternDemo.java public class ChainPatternDemo { private static AbstractLogger getChainOfLoggers(){ //创建接受者，并赋予接受者等级 AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR); AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG); AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO); //设置接受者的下一个接收者 errorLogger.setNextLogger(fileLogger); fileLogger.setNextLogger(consoleLogger); //将最高级的接收者返回 return errorLogger; } public static void main(String[] args) { AbstractLogger loggerChain = getChainOfLoggers(); //传入事务等级以及事务内容 loggerChain.logMessage(AbstractLogger.INFO, \"This is an information.\"); loggerChain.logMessage(AbstractLogger.DEBUG, \"This is a debug level information.\"); loggerChain.logMessage(AbstractLogger.ERROR, \"This is an error information.\"); } } 执行程序，输出结果： Standard Console::Logger: This is an information. File::Logger: This is a debug level information. Standard Console::Logger: This is a debug level information. Error Console::Logger: This is an error information. File::Logger: This is an error information. Standard Console::Logger: This is an error information. 命令模式命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 介绍 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。 主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。 如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。 关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口 应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。 优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。 缺点：使用命令模式可能会导致某些系统有过多的具体命令类。 使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。 注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。 实现 我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。 Broker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。 1、创建一个命令接口 Order.java public interface Order { void execute(); } 2、创建一个请求类 （有什么请求就来这个类添加） Stock.java public class Stock { //所有要实现的功能请求都在这个类中 private String name = \"ABC\"; private int quantity = 10; public void buy(){ System.out.println(\"Stock [ Name: \"+name+ \", Quantity: \" + quantity +\" ] bought\"); } public void sell(){ System.out.println(\"Stock [ Name: \"+name+ \", Quantity: \" + quantity +\" ] sold\"); } } 3、创建实现了 Order 接口的实体类，具体的某一个命令请求 BuyStock.java public class BuyStock implements Order { private Stock abcStock; public BuyStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.buy(); } } SellStock.java public class SellStock implements Order { private Stock abcStock; public SellStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.sell(); } } 4、创建命令调用类 （执行所有命令请求） Broker.java import java.util.ArrayList; import java.util.List; public class Broker { private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); //添加执行命令对象 public void takeOrder(Order order){ orderList.add(order); } //执行所有命令对象的命令 public void placeOrders(){ for (Order order : orderList) { order.execute(); } orderList.clear(); } } 5、使用 Broker 类来接受并执行命令 CommandPatternDemo.java public class CommandPatternDemo { public static void main(String[] args) { Stock abcStock = new Stock();//包含所有命令请求的对象 BuyStock buyStockOrder = new BuyStock(abcStock);//执行具体某一命令的对象 SellStock sellStockOrder = new SellStock(abcStock); Broker broker = new Broker();//所有要执行命令对象的集合体 broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); //执行所有命令对象的命令 broker.placeOrders(); } } 执行程序，输出结果： Stock [ Name: ABC, Quantity: 10 ] bought Stock [ Name: ABC, Quantity: 10 ] sold 备忘录模式备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。 介绍 意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。 如何解决：通过一个备忘录类专门存储对象状态。 关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。 应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。 优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 使用场景： 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。 注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。 实现 备忘录模式使用三个类 Memento、Originator 和 CareTaker。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。 MementoPatternDemo，我们的演示类使用 CareTaker 和 Originator 对象来显示对象的状态恢复。 1、创建 Memento 类 ，存储对象状态信息的容器 Memento.java public class Memento { private String state; public Memento(String state){ this.state = state; } public String getState(){ return state; } } 2、创建 Originator 类，备忘录管理类 Originator.java public class Originator { private String state; public void setState(String state){ this.state = state; } public String getState(){ return state; } public Memento saveStateToMemento(){ //创建一个新的Memento对象并将自身的state变量赋值给Memento对象 return new Memento(state); } //从Memento中获取state并赋值给自己的state public void getStateFromMemento(Memento Memento){ state = Memento.getState(); } } 3、创建 CareTaker 类，备忘录类 CareTaker.java import java.util.ArrayList; import java.util.List; public class CareTaker { private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;(); //添加存档，每次存档都添加一个Memento对象 public void add(Memento state){ mementoList.add(state); } //读取存档集合 public Memento get(int index){ return mementoList.get(index); } } 4、使用 CareTaker 和 Originator 对象 MementoPatternDemo.java public class MementoPatternDemo { public static void main(String[] args) { Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState(\"State #1\"); originator.setState(\"State #2\"); //每次存档都是一个对象，会被记录 careTaker.add(originator.saveStateToMemento()); originator.setState(\"State #3\"); careTaker.add(originator.saveStateToMemento()); originator.setState(\"State #4\"); System.out.println(\"Current State: \" + originator.getState()); //从存档集合里面获取存档，存档再通过备忘录管理类获取存档信息 originator.getStateFromMemento(careTaker.get(0)); System.out.println(\"First saved State: \" + originator.getState()); originator.getStateFromMemento(careTaker.get(1)); System.out.println(\"Second saved State: \" + originator.getState()); } } 输出结果： Current State: State #4 First saved State: State #2 Second saved State: State #3 状态模式在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。 介绍 意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用：代码中包含大量与对象状态有关的条件语句。 如何解决：将各种具体的状态类抽象出来。 关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 应用实例： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。 优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。 注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。 实现 我们将创建一个 State 接口和实现了 State 接口的实体状态类。Context 是一个带有某个状态的类。 StatePatternDemo，我们的演示类使用 Context 和状态对象来演示 Context 在状态改变时的行为变化。 1、创建一个接口 State.java public interface State { public void doAction(Context context); } 2、创建实现接口的实体类。 StartState.java public class StartState implements State { public void doAction(Context context) { System.out.println(\"Player is in start state\"); //核心代码句，将自身作为状态属性值赋值给context对象，context对象可以根据所接收的参数来做相应的动作 context.setState(this); } public String toString(){ return \"Start State\"; } } StopState.java public class StopState implements State { public void doAction(Context context) { System.out.println(\"Player is in stop state\"); //核心代码句，将自身作为状态属性值赋值给context对象，context对象可以根据所接收的参数来做相应的动作 context.setState(this); } public String toString(){ return \"Stop State\"; } } 3、创建 Context 类，行为随着状态对象改变而改变的 context 对象 （核心类） Context.java public class Context { private State state; public Context(){ state = null; } public void setState(State state){ this.state = state; } public State getState(){ return state; } } 4、使用 Context 来查看当状态 State 改变时的行为变化 StatePatternDemo.java public class StatePatternDemo { public static void main(String[] args) { Context context = new Context(); StartState startState = new StartState(); //这里将startState自身作为状态属性赋值给context对象，context对象此时状态属性改变，getState所返回的state对象也是有所改变的，也就是行为改变 startState.doAction(context); System.out.println(context.getState().toString()); StopState stopState = new StopState(); //这里将startState自身作为状态属性赋值给context对象，context对象此时状态属性改变，getState所返回的state对象也是有所改变的,也就是行为改变 stopState.doAction(context); System.out.println(context.getState().toString()); } } 执行程序，输出结果： Player is in start state Start State Player is in stop state Stop State 访问者模式在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 介绍 意图：主要将数据结构与数据操作分离。 主要解决：稳定的数据结构和易变的操作耦合问题。 何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。 如何解决：在被访问的类里面加一个对外提供接待访问者的接口。 关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。 应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。 优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。 缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。 使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。 注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 实现 我们将创建一个定义接受操作的 ComputerPart 接口。Keyboard、Mouse、Monitor 和 Computer 是实现了 ComputerPart 接口的实体类。我们将定义另一个接口 ComputerPartVisitor，它定义了访问者类的操作。Computer 使用实体访问者来执行相应的动作。 VisitorPatternDemo，我们的演示类使用 Computer、ComputerPartVisitor 类来演示访问者模式的用法。 1、定义一个表示元素的接口 ComputerPart.java public interface ComputerPart { //接受访问者访问 public void accept(ComputerPartVisitor computerPartVisitor); } 2、创建扩展了上述类的实体类 Keyboard.java public class Keyboard implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); } } Monitor.java public class Monitor implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); } } Mouse.java public class Mouse implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); } } Computer.java public class Computer implements ComputerPart { ComputerPart[] parts; public Computer(){ parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()}; } @Override public void accept(ComputerPartVisitor computerPartVisitor) { for (int i = 0; i &lt; parts.length; i++) { //各个部件接受访问 parts[i].accept(computerPartVisitor); } //最后自己也访问 computerPartVisitor.visit(this); } } 3、定义一个表示访问者的接口 ComputerPartVisitor.java public interface ComputerPartVisitor { public void visit(Computer computer); public void visit(Mouse mouse); public void visit(Keyboard keyboard); public void visit(Monitor monitor); } 4、创建实现了上述类的实体访问者 ComputerPartDisplayVisitor.java public class ComputerPartDisplayVisitor implements ComputerPartVisitor { //各个部件被访问时分别进行的操作 @Override public void visit(Computer computer) { System.out.println(\"Displaying Computer.\"); } @Override public void visit(Mouse mouse) { System.out.println(\"Displaying Mouse.\"); } @Override public void visit(Keyboard keyboard) { System.out.println(\"Displaying Keyboard.\"); } @Override public void visit(Monitor monitor) { System.out.println(\"Displaying Monitor.\"); } } 5、使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分 VisitorPatternDemo.java public class VisitorPatternDemo { public static void main(String[] args) { ComputerPart computer = new Computer(); //接受访问者访问 computer.accept(new ComputerPartDisplayVisitor()); } } 执行程序，输出结果： Displaying Mouse. Displaying Keyboard. Displaying Monitor. Displaying Computer. 中介者模式中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 介绍 意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。 何时使用：多个类相互耦合，形成了网状结构。 如何解决：将上述网状结构分离为星型结构。 关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。 应用实例： 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。 优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。 缺点：中介者会庞大，变得复杂难以维护。 使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 注意事项：不应当在职责混乱的时候使用。 实现 我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 方法来分享他们的消息。 MediatorPatternDemo，我们的演示类使用 User 对象来显示他们之间的通信。 1、创建中介类 ChatRoom.java import java.util.Date; public class ChatRoom { public static void showMessage(User user, String message){ System.out.println(new Date().toString() + \" [\" + user.getName() +\"] : \" + message); } } 2、创建 user 类 User.java public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public User(String name){ this.name = name; } public void sendMessage(String message){ //通过中介者来发送消息 ChatRoom.showMessage(this,message); } } 3、使用 User 对象来显示他们之间的通信 MediatorPatternDemo.java public class MediatorPatternDemo { public static void main(String[] args) { User robert = new User(\"Robert\"); User john = new User(\"John\"); robert.sendMessage(\"Hi! John!\"); john.sendMessage(\"Hello! Robert!\"); } } 执行程序，输出结果： Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John! Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert! 解释器模式解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 介绍 意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 主要解决：对于一些固定文法构建一个解释句子的解释器。 何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 如何解决：构建语法树，定义终结符与非终结符。 关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。 应用实例：编译器、运算表达式计算。 优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。 缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。 使用场景： 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。 注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。 实现 我们将创建一个接口 Expression 和实现了 Expression 接口的实体类。定义作为上下文中主要解释器的 TerminalExpression 类。其他的类 OrExpression、AndExpression 用于创建组合式表达式。 InterpreterPatternDemo，我们的演示类使用 Expression 类创建规则和演示表达式的解析。 1、创建一个表达式接口 Expression.java public interface Expression { //对context进行判断 public boolean interpret(String context); } 2、创建实现了上述接口的实体类 TerminalExpression.java public class TerminalExpression implements Expression { private String data; public TerminalExpression(String data){ this.data = data; } @Override public boolean interpret(String context) { //只要作为判断的字符串context中含有字符串data就返回true，这里不够准确，写成equal又会太严谨，导致AndExpression不能正常判断，这里contains只要含有date字符串就行。 if(context.contains(data)){ return true; } return false; } } OrExpression.java public class OrExpression implements Expression { private Expression expr1 = null; private Expression expr2 = null; //这里的参数都是TerminalExpression类型的 public OrExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } @Override public boolean interpret(String context) { return expr1.interpret(context) || expr2.interpret(context); } } AndExpression.java public class AndExpression implements Expression { private Expression expr1 = null; private Expression expr2 = null; //这里的参数都是TerminalExpression类型的 public AndExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } @Override public boolean interpret(String context) { return expr1.interpret(context) &amp;&amp; expr2.interpret(context); } } 3、InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们。 InterpreterPatternDemo.java public class InterpreterPatternDemo { //规则：Robert 和 John 是男性 public static Expression getMaleExpression(){ Expression robert = new TerminalExpression(\"Robert\"); Expression john = new TerminalExpression(\"John\"); //只要被判断的字符串中含有 \"Robert\"或者\"John\" 就返回true return new OrExpression(robert, john); } //规则：Julie 是一个已婚的女性 public static Expression getMarriedWomanExpression(){ Expression julie = new TerminalExpression(\"Julie\"); Expression married = new TerminalExpression(\"Married\"); //只有被判断的字符串中同时含有 \"Julie\"或者\"Married\" 才返回true return new AndExpression(julie, married); } public static void main(String[] args) { Expression isMale = getMaleExpression(); Expression isMarriedWoman = getMarriedWomanExpression(); System.out.println(\"John is male? \" + isMale.interpret(\"John\")); System.out.println(\"Julie is a married women? \" + isMarriedWoman.interpret(\"Married Julie\")); } } 执行程序，输出结果： John is male? true Julie is a married women? true","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"JVM","slug":"JVM","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:25:47.260Z","comments":true,"path":"posts/ea4e9789.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9789.html","excerpt":"","text":"JVM 友情链接：常见OMM Error和七大垃圾回收器详解 友情链接：JVM调参、GCRoots与四大引用浅析 JVM介绍 1.方法区和堆区是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行时线程私有的内存区域。 2.Java栈又叫做jvm虚拟机栈 3.方法区（永久代）在 jdk8 中又叫做元空间 Metaspace 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT编译器，英文写作Just-In-Time Compiler）编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代 在JDK1.7 字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代 在JDK1.8之后JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。同时在 jdk 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。默认大概是用了20M的大小。 4.java代码执行流程： java程序–（编译javac）–&gt;字节码文件.class–&gt;类装载子系统化身为反射类Class—&gt;运行时数据区—&gt;（解释执行）–&gt;操作系统（Win，Linux，Mac JVM） 所有的栈和程序计数器并不会产生垃圾，所以不会有垃圾回收 我们所说的JVM调优是在方法区和堆里进行调优，99%是堆调优 注意：我们平时说的栈是指的Java栈，本地方法栈（native method stack） 里面装的都是native方法。 JVM生命周期 1.启动 通过引导类根加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的. 2.执行 一个运行中的java虚拟机有着一个清晰的任务：执行Java程序； 程序开始执行的时候他才运行，程序结束时他就停止； 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。 3.退出 程序正常执行结束 程序异常或错误而异常终止 操作系统错误导致终止 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作 除此之外，JNI 规范描述了用 JNI Invocation API 来加载或卸载Java虚拟机时，Java虚拟机的退出情况 类加载子系统作用1.类加载子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识，JVM并不是通过检查文件后缀是不是.class来判断是否需要加载的，而是通过文件开头的特定文件标志即16进制CA TE BA BE； 2.加载后的Class类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射） 来一张经典的JVM内存结构图：其中类加载器的工作范围只限于下图的左半部分，不包含调用构造器实例化对象 3.ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定 4.如果调用构造器实例化对象，则其实例存放在堆区 功能细分 加载模块1.通过一个类的全限定名获取定义此类的二进制字节流； 2.将这个字节流所代表的的静态存储结构转化为方法区的运行时数据； 3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 链接模块分为三块，即验证、准备、解析验证 1.目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 2.主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。 准备 1.为类变量分配内存并且设置该类变量的默认初始值，即零值； 2.这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化； 3.不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。 解析 1.将常量池内的符号引用转换为直接引用的过程。 2.事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行 3.符号引用就是一组符号来描述所引用的目标。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄 4.解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info/CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。 初始化模块，初始化阶段就是执行类构造器方法clinit（）的过程1.clinit()即“class or interface initialization method”，注意他并不是指构造器init() 2.此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 3.我们注意到如果没有静态变量c，那么字节码文件中就不会有clinit方法 构造器方法clinit()中指令按语句在源文件中出现的顺序执行 java程序对类的使用方式分为：主动使用和被动使用，即是否调用了clinit()方法 主动使用在类加载系统中的第三阶段initialization（初始化模块），即初始化阶段调用了clinit()方法 而被动使用不会去调用 主动使用，分为七种情况 1.创建类的实例 2.访问某各类或接口的静态变量，或者对静态变量赋值 3.调用类的静态方法 4.反射 比如Class.forName(com.dsh.jvm.xxx) 5.初始化一个类的子类 6.java虚拟机启动时被标明为启动类的类 7.JDK 7 开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化。 虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁即一个类只需被clinit一次，之后该类的内部信息就被存储在方法区。 可以看到线程2并不会重复执行初始化操作 类加载器种类 注意： Class loader有多种，可以说三个，也可以说是四个（第四个为自己定义的加载器，继承 ClassLoader），系统自带的三个分别为： 启动类加载器(Bootstrap) ，C++所写 这个类加载使用C/C++语言实现的，嵌套在JVM内部 它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar/resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类 并不继承自java.lang.ClassLoader,没有父加载器 加载拓展类和应用程序类加载器，并指定为他们的父加载器，即ClassLoader 出于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun等开头的类 扩展类加载器(Extension) ，Java所写 java语言编写 ，由sun.misc.Launcher$ExtClassLoader实现。 派生于ClassLoader类，不是继承 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会由拓展类加载器自动加载 应用程序类加载器 (AppClassLoader) java语言编写， 由sun.misc.Launcher$AppClassLoader实现。 派生于ClassLoader类，不是继承 它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库 该类加载器是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器： 在日常Java应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，必要时可以自定义类加载器来定制类的加载方式。 为什么要自定义类加载器呢？ 隔离加载类 修改类加载方式 扩展加载源 防止源码泄露 我们自己new的时候创建的是应用程序类加载器(AppClassLoader)。 import com.gmail.fxding2019.T; public class Test{ //Test:查看类加载器 public static void main(String[] args) { Object object = new Object(); //查看是那个“ClassLoader”（快递员把Object加载进来的） System.out.println(object.getClass().getClassLoader()); //查看Object的加载器的上一层 // error Exception in thread \"main\" java.lang.NullPointerException（已经是祖先了） //System.out.println(object.getClass().getClassLoader().getParent()); System.out.println(); Test t = new Test(); System.out.println(t.getClass().getClassLoader().getParent().getParent()); System.out.println(t.getClass().getClassLoader().getParent()); System.out.println(t.getClass().getClassLoader()); } } /* *output: * null * * null * sun.misc.Launcher$ExtClassLoader@4554617c * sun.misc.Launcher$AppClassLoader@18b4aac2 * */ 注意： 如果是JDK自带的类(Object、String、ArrayList等)，其使用的加载器是Bootstrap加载器；如果自己写的类，使用的是AppClassLoader加载器；Extension加载器是负责将把java更新的程序包的类加载进行 输出中，sun.misc.Launcher是JVM相关调用的入口程序 Java加载器个数为3+1。前三个是系统自带的，用户可以定制类的加载方式，通过继承Java. lang. ClassLoader JVM中表示两个class对象是否为同一个类 1.在jvm中表示两个class对象是否为同一个类存在的两个必要条件 类的完整类名必须一致，包括包名 即使类的完整类名一致，同时要求加载这个类的ClassLoader（指ClassLoader实例对象）必 须相同；是引导类加载器、还是定义类加载器 2.换句话说，在jvm中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的. 3.对类加载器的引用，JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的。如果一个类型由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证两个类型的加载器是相同的。 双亲委派机制 注意： 双亲委派机制：“我爸是李刚，有事找我爹”。例如：需要用一个A.java这个类，首先去顶部Bootstrap根加载器去找，找得到你就用，找不到再下降一层，去Extension加载器去找，找得到就用，找不到再将一层，去AppClassLoader加载器去找，找得到就用，找不到就会报”CLASS NOT FOUND EXCEPTION”。 //测试加载器的加载顺序 package java.lang; public class String { public static void main(String[] args) { System.out.println(\"hello world!\"); } } /* * output: * 错误: 在类 java.lang.String 中找不到 main 方法 * */ 上面代码是为了测试加载器的顺序：首先加载的是Bootstrap加载器，由于JVM中有java.lang.String这个类，所以会首先加载这个类，而不是自己写的类，而这个类中并无main方法，所以会报“在类 java.lang.String 中找不到 main 方法”。 这个问题就涉及到，如果有两个相同的类，那么java到底会用哪一个？如果使用用户自己定义的java.lang.String，那么别使用这个类的程序会去全部出错，所以，为了保证用户写的源代码不污染java出厂自带的源代码，而提供了一种“双亲委派”机制，保证“沙箱安全”。即先找到先使用。 沙箱安全机制 Java安全模型的核心就是Java沙箱(sandbox) , 什么是沙箱? 沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。 沙箱主要限制系统资源访问，那系统资源包括什么? CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。 所有的Java程序运行都可以指定沙箱，可以定制安全策略。 组成沙箱的基本组件●字节码校验器(bytecode verifier) :确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。●类裝载器(class loader) :其中类装载器在3个方面对Java沙箱起作用  它防止恶意代码去干涉善意的代码;  它守护了被信任的类库边界;  它将代码归入保护域,确定了代码可以进行哪些操作。 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成， 每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。 类装载器采用的机制是双亲委派模式。 1.从最内层JVM自带类加载器开始加载,外层恶意同名类得不到加载从而无法使用; 2.由于严格通过包来区分了访问域,外层恶意的类通过内置代码也无法获得权限访问到内层类，破 坏代码就自然无法生效。●存取控制器(access controller) :存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定,可以由用户指定。●安全管理器(security manager) : 是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。●安全软件包(security package) : java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:  安全提供者  消息摘要  数字签名  加密  鉴别 Native 本地 native :凡是带了native关键字的，说明java的作用范围达不到了，回去调用底层c语言的库! 会进入本地方法栈 调用本地方法本地接口 JNI (Java Native Interface) JNI作用:开拓Java的使用，融合不同的编程语言为Java所用!最初: C、C++ Java诞生的时候C、C++横行，想要立足，必须要有调用C、C++的程序 它在内存区域中专门开辟了一块标记区域: Native Method Stack，登记native方法 在最终执行的时候，加载本地方法库中的方法通过JNI 例如：Java程序驱动打印机，管理系统，掌握即可，在企业级应用比较少 private native void start0(); //调用其他接口:Socket. . WebService. .http Thread类的start方法如下： public synchronized void start() { /** * This method is not invoked for the main method thread or \"system\" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } private native void start0(); Thread类中竟然有一个只有声明没有实现的方法，并使用native关键字。用native表示，也此方法是系统级（底层操作系统或第三方C语言）的，而不是语言级的，java并不能对其进行操作。native方法装载在native method stack中。 本地方法栈1.Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法（一般非Java实现的方法）的调用 2.本地方法栈，也是线程私有的。 3.允许被实现成固定或者是可动态拓展的内存大小。（和Java虚拟机栈在内存溢出方面情况是相同的） 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverFlowError异常。 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。 4.本地方法是使用C语言实现的 5.它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。 6.当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限 本地方法可以通过本地方法接口来 访问虚拟机内部的运行时数据区 它甚至可以直接使用本地处理器中的寄存器 直接从本地内存的堆中分配任意数量的内存 7.并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。 PC寄存器 注意：native方法不归java管，所以计数器是空的 PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。 1.它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域 2.在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致 3.任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）,因为程序计数器不负责本地方法栈。 4.它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成 5.字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令 6.它是唯一一个在java虚拟机规范中没有规定任何OOM（Out Of Memery）情况的区域,而且没有垃圾回收 利用javap -v xxx.class反编译字节码文件，查看指令等信息 上面图中是亮色的地方有两个特点： 所有线程共享（灰色是线程私有） 亮色地方存在垃圾回收 PC寄存器面试常问1.使用PC寄存器存储字节码指令地址有什么用呢（为什么使用PC寄存器记录当前线程的执行地址呢） （1）多线程宏观上是并行（多个事件在同一时刻同时发生）的，但实际上是并发交替执行的 （2）因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行 （3）JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 所以，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。 2.PC寄存器为什么会设定为线程私有？ （1）我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停做任务切换，这样必然会导致经常中断或恢复，如何保证分毫无差呢？ （2）为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是**为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。 方法区 注意： 方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义,简单说，所有定义的方法的信息都保存在该区域,此区域属于共享区间; *静态变量、常量、类信息(构造方法、接口定义、普通方法)、运行时的常量池存在方法区中，但是实例变量（普通变量）存在堆内存中，和方法区无关** 方法区：绝对不是放方法的地方，他是存储的每一个类的结构信息(比如static) 永久代和元空间的解释：方法区是一种规范，类似于接口定义的规范：List list = new ArrayList();把这种比喻用到方法区则有： java 7中：方法区 f = new 永久代(); java 8中：方法去 f = new 元空间(); 栈 注意： 栈是运行时的单位，堆是存储的单位。 即，栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放在哪里。 栈是线程私有，不存在垃圾回收 虚拟机栈的生命周期同线程一致 栈帧的概念：java中的方法被扔进虚拟机的栈空间之后就成为“栈帧”，比如main方法，是程序的入口，被压栈之后就成为栈帧。 栈的作用： *主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。** 栈运行原理 不同线程所包含的栈帧是私有的，不允许存在相互引用，即不可能在一个栈帧之中引用另一个线程的栈帧。 如果当前方法调用了其他方法，被调用方法返回之际，当前栈帧会传回此被调用方法的执行结果给前一个栈帧（调用者方法），接着，虚拟机会丢弃当前栈帧（被调用方法的栈帧），使得前一个栈帧重新成为当前栈帧。 Java方法有两种返回函数的方式 。一种是正常的函数返回，使用return指令，另一种是如果出现未经捕捉的异常，则已抛出异常的形式返回。不管使用哪种方式，都会导致栈帧被弹出。 栈帧的内部结构1. 局部变量表 StartPC：变量的作用域起始字节码指令位置，Length：作用域长度；StartPC+Length=总字节码指令数 局部变量表也被称之为局部变量数组或者本地变量表。 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，包括8种基本数据类型、对象引用以及returnAddress类型。 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对于一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求，进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，局部变量表随着方法栈帧的销毁而销毁。 局部变量表最基本的存储单元是Slot（变量槽），其中，32位以内的类型只占一个slot(包括returnAddress类型)，64位的类型（long和double占用两个slot）；byte、short、char在存储前被转换为int，boolean也被转化为int，0表示false,非0表示true。 JVM会为每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，如果要访问一个64bit的局部变量值时，只需要使用两个slot中的第一个slot的索引即可。如果当前栈帧是由构造方法或者实例方法创建的，那么该对象引用this将会放在index=0的slot处，其余的参数按照参数表顺序继续排列，这也就解释了为什么静态方法中不可以引用this，因为this变量（当前对象的引用）不存在于静态方法的局部变量表中。此外，栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。 在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。局部变量表中的变量也是重要的垃圾回收的根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。 静态变量与局部变量的对比及小结 变量的分类： 按照数据类型分： ①基本数据类型; ②引用数据类型； 按照在类中声明的位置分： ①成员变量：在使用前，都经历过默认初始化赋值 static修饰：类变量：类加载链接的准备preparation阶段给类变量默认赋0值——&gt;初始化阶段initialization给类变量显式赋值即静态代码块赋值； 不被static修饰：实例变量：随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值 ②局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过 2. 操作数栈每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出的操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即操作数栈的入栈/出栈。例如某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈。（如字节码指令bipush操作） 比如：执行复制、交换、求和等操作 如果说Java虚拟机的解释引擎是基于栈的执行引擎，其中栈指的就是操作数栈。 操作数栈主要用于保存计算过程中的中间结果，同时作为计算过程中的变量临时的存储空间。 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的code属性中，为max_stack的值。 栈中任何一个元素都是可以任意的Java数据类型，其中，32bit类型占用一个栈单位深度，64bit类型占用两个。 操作数栈不同于局部变量表，并非采用访问索引的方式来进行数据访问，而是通过标准的入栈出栈操作来完成一次数据访问。 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。 操作数栈代码追踪 结合上图结合下面的图来看一下一个方法（栈帧）的执行过程 ①15入栈；②存储15，15进入局部变量表 注意：局部变量表的0号位被构造器占用，这里的15从局部变量表1号开始 ③压入8；④8出栈，存储8进入局部变量表； ⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈；⑥iadd相加操作 ⑦iadd操作结果23出栈⑧将23存储在局部变量表索引为3的位置上istore_3 栈顶缓存技术ToS（Top-of-Stack Cashing） 基于栈式架构的虚拟机所使用的零地址指令（即不考虑地址，单纯入栈出栈）更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率 3.动态链接（或指向运行时常量池的方法引用） 运行时常量池位于方法区（注意： JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。） ​ 每一个栈帧内部都包含一个指向运行时常量池（运行时常量池是在方法区里的）中该栈帧所属方法的引用。这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如：invokedynamic指令。 ​ 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其它方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。 ​ 常量池的作用就是为了提供一些符号和常量以便于指令的识别，以节约内存。 方法的调用 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关 静态链接当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。 动态链接如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。 对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。 早期绑定早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 晚期绑定如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 随着高级语言的横空出世，类似于java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装，集成和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。 虚方法和非虚方法 子类对象的多态性使用前提：①类的继承关系（父类的声明）②方法的重写（子类的实现） 实际开发编写代码中用的接口，实际执行是导入的的三方jar包已经实现的功能 非虚方法 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法 静态方法、私有方法、final方法、实例构造器（实例已经确定，this()表示本类的构造器）、父类方法（super调用）都是非虚方法 虚方法 其他所有体现多态特性的方法称为虚方法 虚拟机中提供了以下几条方法调用指令 普通调用指令：1**.invokestatic：调用静态方法，解析阶段确定唯一方法版本；2.invokespecial**:调用方法、私有及父类方法，解析阶段确定唯一方法版本；3.invokevirtual调用所有虚方法；4.invokeinterface：调用接口方法；动态调用指令（Java7新增）：5.invokedynamic：动态解析出需要调用的方法，然后执行 .前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。 其中invokestatic指令和invokespecial指令调用的方法称为非虚方法 其中invokevirtual（final修饰的除外，JVM会把final方法调用也归为invokevirtual指令，但要注意final方法调用不是虚方法）invokeinterface指令调用的方法称称为虚方法。 /** * 解析调用中非虚方法、虚方法的测试 */ class Father { public Father(){ System.out.println(\"Father默认构造器\"); } public static void showStatic(String s){ System.out.println(\"Father show static\"+s); } public final void showFinal(){ System.out.println(\"Father show final\"); } public void showCommon(){ System.out.println(\"Father show common\"); } } public class Son extends Father{ public Son(){ super(); } public Son(int age){ this(); } public static void main(String[] args) { Son son = new Son(); son.show(); } //不是重写的父类方法，因为静态方法不能被重写 public static void showStatic(String s){ System.out.println(\"Son show static\"+s); } private void showPrivate(String s){ System.out.println(\"Son show private\"+s); } public void show(){ //invokestatic showStatic(\" 大头儿子\"); //invokestatic super.showStatic(\" 大头儿子\"); //invokespecial showPrivate(\" hello!\"); //invokespecial super.showCommon(); //invokevirtual 因为此方法声明有final 不能被子类重写，所以也认为该方法是非虚方法 showFinal(); //虚方法如下 //invokevirtual showCommon();//没有显式加super，被认为是虚方法，因为子类可能重写showCommon info(); MethodInterface in = null; //invokeinterface 不确定接口实现类是哪一个 需要重写 in.methodA(); } public void info(){ } } interface MethodInterface { void methodA(); } 关于invokedynamic指令 JVM字节码指令集一直比较稳定，一直到java7才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进 但是java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令，直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接生成方式 Java7中增加的动态语言类型支持的本质是对java虚拟机规范的修改，而不是对java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在java平台的动态语言的编译器 动态类型语言和静态类型语言 动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言。 直白来说 静态语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征 Java是静态类型语言（尽管lambda表达式为其增加了动态特性），js，python是动态类型语言. Java：String info = \"硅谷\";//静态语言 JS：var name = \"硅谷“；var name = 10;//动态语言 Pythom: info = 130;//更加彻底的动态语言 方法重写的本质 找到操作数栈的第一个元素所执行的对象的实际类型，记作C。 如果在类型C中找到与常量池中的描述符、简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。IllegalAccessError介绍 程序视图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。 否则，按照继承关系从下往上依次对c的各个父类进行第二步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 虚方法表 在面向对象编程中，会很频繁期使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，jvm采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 那么虚方法表什么时候被创建？ 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，jvm会把该类的虚方法表也初始化完毕。 4.方法返回地址（或方法正常退出或者异常退出的定义）​ 存放调用该方法得到PC寄存器的值 ​ 一个方法的结束，有正常执行完成和出现未处理的异常从而非正常退出两种方式，无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条地址。如果是异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分的信息。 ​ 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。 ​ 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。 5.一些附加信息栈帧中还允许携带与java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。（很多资料都忽略了附加信息） 开发过程中，关于虚拟机栈可能的异常？ Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。 如果采用固定大小的虚拟机栈，拿每一个线程的Java虚拟机栈容量可以再线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机会抛出一个StackOverflowError的异常。在开发过程中，不合理的递归方法就会导致这个问题。 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMerroyError异常。 public class Test{ public static void m(){ m(); } public static void main(String[] args) { System.out.println(\"111\"); //Exception in thread \"main\" java.lang.StackOverflowError m(); System.out.println(\"222\"); } } /* *output: * 111 * Exception in thread \"main\" java.lang.StackOverflowError * */ 注意： StackOverflowError是一个“错误”，而不是“异常”。 关于Error我们再多说一点，上面的讨论不涉及Exception 首先Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。 Exception和Error体现了JAVA这门语言对于异常处理的两种方式。 Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。 Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。 其中的Exception又分为检查性异常和非检查性异常。两个根本的区别在于，检查性异常 必须在编写代码时，使用try catch捕获（比如：IOException异常）。非检查性异常 在代码编写使，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。 虚拟机栈的相关面试题1.举例栈溢出的情况？（StackOverflowError） 递归调用等，通过-Xss设置栈的大小； 2.调整栈的大小，就能保证不出现溢出么？ 不能 如递归无限次数肯定会溢出，调整栈大小只能保证溢出的时间晚一些，极限情况会导致OOM内存溢出（Out Of Memery Error）注意是Error 3.分配的栈内存越大越好么？ 不是 ，会挤占其他线程的空间 4.垃圾回收是否会涉及到虚拟机栈？ 不会 5.方法中定义的局部变量是否线程安全？ 具体问题具体分析，如果是线程内部产生内部消亡的，那一定是线程安全的，如果是外部传入或者是要返回到外部的局部变量，是线程不安全的，就是要注意局部变量的生命周期。 注意： HotSpot：如果没有明确指明，JDK的名字就叫HotSpot 元数据：描述数据的数据（即模板，也就是“大Class”）上面的关系图的一个实例为下图： 堆 核心概述 一个JVM实例值存在一个堆内存，堆也是Java内存管理的核心区域。 Java堆区在JVM启动的时候就被创建了，其空间大小也就确定了，是JVM管理的最大一块内存空间。《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（TLAB，Thread Local Allocation Buffer）。《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上（但并不是全部）。数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。堆，是GC（垃圾收集器）执行垃圾回收的重点区域。 注意： Java 7之前和图上一模一样，Java 8把永久区换成了元空间（方法区） 堆逻辑上由”新生+养老+元空间“三个部分组成，物理上由”新生+养老“两个部分组成 当执行new Person()；时，其实是new在新生区的伊甸园区，然后往下走，走到养老区，但是并未到元空间。 虽然说，逻辑上是将堆空间划分为新生代、老年代和永久代三部分，实际上是不考虑永久代（也就是Java8中提到的元空间）的，可以将其看做是方法区的落地实现。 注意： GC发生在伊甸园区，当对象快占满新生代时，就会发生YGC（Young GC，轻量级GC）操作，伊甸园区基本全部清空 幸存者0区(S0)，别名“from区”。伊甸园区没有被YGC清空的对象将移至幸存者0区，幸存者1区别名“to 区” 每次进行YGC操作，幸存的对象就会从伊甸园区移到幸存者0区，如果幸存者0区满了，就会继续往下移，如果经历数次YGC操作对象还没有消亡，最终会来到养老区 如果到最后，养老区也满了，那么就对养老区进行FGC(Full GC，重GC)，对养老区进行清洗 如果进行了多次FGC之后，还是无法腾出养老区的空间，就会报OOM（out of Memory）异常 from区和to区位置和名分不是固定的，每次GC过后都会交换，GC交换后，谁空谁是to区 大对象直接进入养老区，大对象就是需要大量连续内存空间的对象（比如：字符串、数组），为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。 注意： 整个堆分为新生区和养老区，新生区占整个堆的1/3，养老区占2/3。新生区又分为3份：伊甸园区：幸存者0区(from区):幸存者1区(to区) = 8:1:1 每次从伊甸园区经过GC幸存的对象，年龄(代数)会+1 -XX:MaxTenuringThreshold=15调整多少代进入老年区 关于默认的晋升年龄是15，这个说法的来源大部分都是《深入理解Java虚拟机》这本书。 如果你去Oracle的官网阅读相关的虚拟机参数，你会发现-XX:MaxTenuringThreshold=threshold这里有个说明 Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector. 默认晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6. 堆空间的分代思想 为什么需要把Java堆分代？不分代就不能正常工作了吗？ 经研究，不同对象的生命周期不同，70%-90%的对象是临时对象。 TLAB（Thread Local Allocation Buffer）我们知道，堆区是线程共享区域，任何线程都可以访问到堆区的共享数据，由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度，TLAB就是为了解决这一问题。 什么是TLAB？ 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配一个私有缓存区域，它包含在Eden空间内。 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但是JVM确实是将TLAB作为内存分配的首选。 在程序中，开发人员通过”-XX:UseTLAB”设置是否开启TLAB空间（可以通过 jinfo -flag UseTLAB 线程号 查询是否开启）。 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的１％，可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。 ​ 加入TLAB后的对象分配过程 注意： 临时对象就是说明，其在伊甸园区生，也在伊甸园区死。 堆逻辑上由”新生+养老+元空间“三个部分组成，物理上由”新生+养老“两个部分组成，元空间也叫方法区 永久代(方法区)几乎没有垃圾回收，里面存放的都是加载的rt.jar等，让你随时可用 注意 上面的图展示的是物理上的堆，分为两块，新生区和养老区。 堆的参数主要有两个：-Xms，Xmx： -Xms堆的初始化的内存大小 -Xmx堆的最大内存 Young Gen(新生代)有一个参数-Xmn，这个参数可以调新生区和养老区的比例。但是，这个参数一般不调。 永久代也有两个参数：-XX:PermSize，-XX:MaxPermSize，可以分别调永久代的初始值和最大值。Java 8 后没有这两个参数啦，因为Java 8后元空间不在虚拟机内啦，而是在本机物理内存中 //查看自己机器上的默认堆内存和最大堆内存 public class Test{ public static void main(String[] args) { System.out.println(Runtime.getRuntime().availableProcessors()); //返回 Java虚拟机试图使用的最大内存量。物理内存的1/4（-Xmx） long maxMemory = Runtime.getRuntime().maxMemory() ; //返回 Java虚拟机中的内存总量(初始值)。物理内存的1/64（-Xms） long totalMemory = Runtime.getRuntime().totalMemory() ; System.out.println(\"MAX_MEMORY =\" + maxMemory +\"(字节)、\" + (maxMemory / (double)1024 / 1024) + \"MB\"); System.out.println(\"DEFALUT_MEMORY = \" + totalMemory + \" (字节)、\" + (totalMemory / (double)1024 / 1024) + \"MB\"); } } /* * 8 MAX_MEMORY =1868038144(字节)、1781.5MB TOTAL_MEMORY = 126877696 (字节)、121.0MB * */ 注意：JVM参数调优，平时可以随便挑初始大小和最大大小，但是实际工作中，初始大小和最大大小应该是一致的，原因是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。避免内存忽高忽低产生停顿 IDEA 的JVM内存配置 点击Run列表下的Edit Configuration 在VM Options中输入以下参数:-Xms1024m -Xmx1024m -XX:+PrintGCDetails。 运行程序查看结果 把堆内存调成10M后，再一直new对象，导致Full GC也无法处理，直至撑爆堆内存，查看堆溢出错误(OOM)，程序及结果如下： GC收集日志信息详解 第一次进行YGC相关参数：[PSYoungGen: 2008K-&gt;482K(2560K)] 2008K-&gt;782K(9728K), 0.0011440 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 最后一次进行FGC相关参数：[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 4025K-&gt;4005K(7168K)] 4025K-&gt;4005K(9216K), [Metaspace: 3289K-&gt;3289K(1056768K)], 0.0082055 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 面试题：GC是什么（分代收集算法） 次数上频繁收集Young区 次数上较少收集Old区 基本不动元空间 面试题：GC的四大算法（后有详解） 引用计数法 复制算法(Copying) 标记清除(Mark-Sweep) 标记压缩(Mark-Compact) 面试题：下面程序中，有几个线程在运行Answer:有两个线程，一个是main线程，一个是后台的gc线程。 知识点： JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC or Young GC），一种是全局GC（major GC or Full GC） Minor GC和Full GC的区别 * 普通GC（minor GC）：只针对新生代区域的GC,指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快。 全局GC（major GC or Full GC）：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上 (因为养老区比较大，占堆的2/3) 对象实例化 从创建对象的执行步骤来分析 对象的创建过程： 判断对象对应的类是否加载、链接、初始化。虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象。 为对象分配内存。首先计算对象占用空间大小，接着在堆中划分一块内存给新对象，如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。如果内存是规整的，那么虚拟机将采用指针碰撞法来为对象分配内存。假设java堆中内存是绝对规整的，所有用过的内存放一边，未使用过的放一边，中间有一个指针作为临界点，如果新创建了一个对象则是把指针往未分配的内存挪动与对象内存大小相同距离，这个称为指针碰撞。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有整理过程的收集器时使用指针碰撞；如果内存不规整，则使用空闲列表法（Free List）。事实上，Java堆的内存并不是完整的，已分配的内存和空闲内存相互交错，JVM通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。使用的GC收集器：CMS，适用堆内存不规整的情况下。 处理并发安全问题。在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：一是采用CAS， CAS 是乐观锁的一种实现方式。所谓乐观锁就是每次不加锁，而是假设没有冲突而去完成某项操作，如果因为冲突失败，就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性；二是为每个线程预先分配一块TLAB——通过-XX:+/-UseTLAB参数来设定（JDK8及之后默认开启），为每一个线程预先分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。 初始化分配到的空间。所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用。（这里要区别一下类加载过程的准备阶段） 设置对象的对象头。将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM的实现。 执行init方法进行初始化。在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。 对象的访问定位 一、句柄访问。虚拟机栈的局部变量表中记录了对象引用，指向堆空间中对应的句柄，句柄位于Java堆空间的句柄池中，一个句柄包含两个指针，分别是到堆空间的实例池的对应对象实例数据的指针和到方法区的对象类型数据的指针。 二、直接指针，虚拟机栈的局部变量表中记录的对象引用直接指向了对象实例数据，而在对象实例数据中有一个到对象类型数据的指针，指向方法区中相应的对象类型数据。HotSpot采用的就是这种直接指针法。 三、两者比较。两种访问定位方式各有优劣，一方面，很明显直接指针法要比句柄访问的效率高一些，另一方面，对于句柄访问而言，reference中存储稳定的句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只需改变句柄中实例数据指针即可，reference本身不需要被修改，而对于直接指针而言，对象移动的话reference也要修改。 逃逸分析-堆是分配对象存储的唯一选择吗？ 随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识，但是，有一种特殊的情况，就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就有可能被优化成栈上分配。这样就无需在堆上分配内存，也无需进行垃圾回收了。这也是常见的堆外存储技术。 此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移到heap外，并且GC 不能管理GCIH内部的Java对象，以此达到降低GC回收频率跟提升GC的回收效率的目的。 逃逸分析 如何将堆上的对象分配到栈，需要使用逃逸分析手段。 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 逃逸分析的基本行为就是分析对象的动态作用域: 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸，那就使用栈上分配，随着方法执行的结束，栈空间就被移除。当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如，作为调用参数传递到其他地方中。几种常见的情况进行逃逸分析： public class EscapeAnalysis { public EscapeAnalysis obj; /* *方法返回EscapeAnalysis对象，发生逃逸 */ public EscapeAnalysis getInstance(){ return obj == null ? new EscapeAnalysis() : obj; } /* *为成员属性赋值，发生逃逸 */ public void setObj(){ this.obj = new EscapeAnalysis(); } /* * 对象的作用域只在当前方法中有效，没有发生逃逸 */ public void useEscapeAnalysis(){ EscapeAnalysis escapeAnalysis = new EscapeAnalysis(); } /* *引用成员变量的值，发生逃逸 */ public void useEscapeAnalysis1(){ EscapeAnalysis escapeAnalysis = getInstance(); } } 在JDK 6u23之后，HotSpot就默认开启了逃逸分析，较早的版本可以通过“-XX:+DoEscapeAnalysis”显示开启逃逸分析，“-XX: +PrintEscapeAnalysis”查看逃逸分析的筛选结果。 为了提高性能，使用逃逸分析，编译器可以对代码做如下优化： 栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配，这就要求开发中能使用局部变量的，就不要在方法外定义。同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。线程同步的代价是相当高的，同步的后果是降低并发性和性能。在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步，这个过程就叫做同步省略，也叫锁消除。分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。所谓标量，是指一个无法再分解成更小的数据的数据，Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量。在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个成员变量来代替，这个过程就是标量替换。可以通过-XX:+EliminateAllocation开启标量替换，默认是打开的，允许将对象打散分配在栈上。 其实即使到如今逃逸分析技术也不是特别成熟，其根本原因就是无法保证逃逸分析的性能消耗一定能低于其他的消耗，虽然经过逃逸分析可以以做标量替换、栈上分配和锁消除，但是逃逸分析本身也是需要进行一系列复杂的分析的。一个比较极端的例子就是，经过逃逸分析后，发现没有一个对象是不逃逸的，那这个逃逸分析的过程就白白浪费掉了。 四类垃圾收集器Java 8可以将垃圾收集器分为四类。 串行垃圾收集器Serial为单线程环境设计且只使用一个线程进行GC，会暂停所有用户线程，不适用于服务器。就像去餐厅吃饭，只有一个清洁工在打扫。 并行垃圾收集器Parrallel使用多个线程并行地进行GC，会暂停所有用户线程，适用于科学计算、大数据后台，交互性不敏感的场合。多个清洁工同时在打扫。停顿的时间会比串行垃圾收集器短。 并发垃圾收集器CMS用户线程和GC线程同时执行（不一定是并行，交替执行），GC时不需要停顿用户线程，互联网公司多用，适用对响应时间有要求的场合。清洁工打扫的时候，也可以就餐。 G1垃圾收集器对内存的划分与前面3种很大不同，G1将堆内存分割成不同的区域，然后并发地进行垃圾回收。 默认收集器有哪些？ 有Serial、Parallel、ConcMarkSweep（CMS）、ParNew、ParallelOld、G1。还有一个SerialOld，快被淘汰了。 查看默认垃圾收集器 使用java -XX:+PrintCommandLineFlags即可看到，**Java 8默认使用-XX:+UseParallelGC**。 -XX:InitialHeapSize=132375936 -XX:MaxHeapSize=2118014976 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 七大垃圾收集器(上面四种垃圾收集器的实现，重要！) 七种回收器的使用： Serial(串行) Parallel Scavenge(并行) ParNew(只在新生代使用并行)； SerialOld(原本用在养老区，已经不用啦) ParallelOld(老年代的并行) CMS(并发标记清除，用于回收老年代) G1收集器，既可以回收新生代，也可以回收老年代。 连线表示可以搭配使用，红叉表示不推荐一同使用，比如新生代用Serial，老年代用CMS搭配使用。并且，配置好新生代后，会默认配置好老年代相搭配的回收器。 1. Serial收集器（Serial/Serial Copying）一句话：一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。 串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在进行垃圾收集过程中可能会产生较长的停顿（Stop- The-World”状态）。虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是java虛拟机运行在 Client模式下默认的新生代垃圾收集器。其使用复制算法： 优点：单个线程收集，没有线程切换开销，拥有最高的单线程GC效率 缺点：收集的时候会暂停用户线程。 使用-XX:+UseSerialGC可以显式开启，开启后默认使用Serial+SerialOld的组合。 2. ParNew收集器ParNew收集器其实就是 Seria收集器新生代的并行多线程版本，最常见的应用场景是配合老年代的 CMS GC工作，其余的行为和Seria收集器完全一样， ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。它是很多java虚拟机运行在 Server的默认新生代收集器，采用复制算法。 使用-XX:+UseParNewGC可以显式开启，开启后默认使用ParNew+SerialOld的组合。但是由于SerialOld已经过时，所以建议配合CMS使用。ParNew收集器只影响新生代，不影响老年代。 3. Parallel Scavenge收集器(JDK 1.8后默认)ParNew收集器仅在新生代使用多线程收集，老年代默认是SerialOld，所以是单线程收集。而Parallel Scavenge在新、老两代都采用多线程收集。Parallel Scavenge还有一个特点就是吞吐量优先收集器，可以通过自适应调节，保证最大吞吐量。采用复制算法。 它重点关注的是:可控制的吞吐量（ Thoughput = 运行用户代码时间/ (运行用户代码时间+垃圾收集时间），也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99％）。高吞吐量意味着高效利用CPU的时间，它多用于在后台运算而不需要太多交互的任务。 自适应调节策略也是parallelScavenge收集器与 ParNew收集器的一个重要区别。（自适应调节策略:虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间: MaxGCPause Millis）或最大的吞吐量。 常用JVM参数: XX: +Use ParallelGC或-XX:+ Use ParallelOldGC（可互相激活）使用 Paralle！ Scavenge收集器开启该参数后:新生代使用复制算法，老年代使用标记-整理算法。 使用-XX:+UseParallelGC可以开启， 同时也会使用ParallelOld收集老年代。其它参数，比如-XX:ParallelGCThreads=N可以选择N个线程进行GC，-XX:+UseAdaptiveSizePolicy使用自适应调节策略。 4. SerialOld收集器Serial Old是 Seria 垃圾收集器老年代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的老年代垃圾收集器。 在 Server模式下，主要有两个用途（了解，版本已经到8及以后） 在JDK1.5之前版本中与新生代的 Parallel Scavenge收集器搭配使用。（ Parallel Scavenge+ Serial old） 作为老年代版中使用CMS收集器的后备垃圾收集方案 5. ParallelOld收集器Parallel Old收集器是 Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，parallel Old收集器在JDK1.6才开始提供。 在JDK1.6之前，新生代使用 ParalleIScavenge收集器只能搭配年老代的 Serial old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6之前（ Parallel Scavenge+ Serial old），Parallel old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8后可以优先考虑新生代Parallel Scavenge和老年代 Parallel old收集器的搭配策略。在JDK1.8及后（ Parallel Scavenge+ Parallel old） 使用-XX:+UseParallelOldGC可以开启， 同时也会使用Parallel收集新生代(JDK 1.8之后默认的就是这种组合)。 6. CMS收集器CMS并发标记清除收集器，是标记清除(Mark-Sweep)算法的实现，是一种以获得最短GC停顿为目标的收集器。适用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望停顿时间最短。是G1收集器出来之前大型应用的首选收集器。 在GC的时候，会与用户线程并发执行，不会停顿用户线程。但是在标记的时候，仍然会STW，只不过时间非常短。 使用-XX:+UseConcMarkSweepGC开启。开启过后，新生代默认使用ParNew，如果CMS收集效果不太理想，老年代会使用SerialOld作为CMS的后备收集器。 CMS有四步过程： 初始标记：只是标记一下GC Roots能直接关联的对象，速度很快，需要STW(暂停所有的工作线程)。 并发标记：主要标记过程，标记全部对象，和用户线程一起工作，不需要STW。 重新标记：修正在并发标记阶段出现的变动，需要STW。 并发清除：和用户线程一起，清除垃圾，不需要STW。 优缺点优点：停顿时间少，响应速度快，用户体验好 **(并发收集低停顿)**。 缺点： 由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间 对CPU资源非常敏感：由于需要并发工作，多少会占用系统线程资源。 无法处理浮动垃圾：由于标记垃圾的时候，用户进程仍然在运行，无法有效处理新产生的垃圾。 产生内存碎片：由于使用标记清除算法，会产生内存碎片。 回收器的选择： 7. G1收集器G1（Garbage-First）收集器，是一款面向服务器端应用的收集器。 G1收集器与之前垃圾收集器的一个显著区别就是——之前收集器都有三个区域，新、老两代和元空间。**而G1收集器只有G1区(garbage-first heap)和元空间(Metaspace)**。而G1区，不像之前的收集器，分为新、老两代，而是一个一个Region，每个Region既可能包含新生代，也可能包含老年代。 G1收集器既可以提高吞吐量，又可以减少GC时间。最重要的是STW可控，增加了预测机制，让用户指定停顿时间。 CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器——G1垃圾收集器。 主要改变是Eden， Survⅳor和 Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的 region，每个 region从1M到32M不等。一个 region有可能属于Eden， Survivor或者 Tenured内存区域。 G1收集器的设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色，G1与CMS的区别： G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。 G1的 Stop The World（STW）更可控，G1在停顿时间上添加预测机制，用户可以指定期望停顿时间 G1整理空闲空间更快 G1需要更多的时间来预测GC停顿的时间 G1不希望牺牲大量的吞吐性能 G1不需要更大的Java Heap 使用-XX:+UseG1GC开启，还有-XX:G1HeapRegionSize=n、-XX:MaxGCPauseMillis=n等参数可调。 特点对比： G1之前收集器的特点： 年轻代和老年代是各自独立且连续的内存块； 年轻代收集使用单Eden+S0+S1进行复制算法； 老年代收集必须扫描整个老年代区域； 都是以尽可能少而快速地执行GC为设计原则。 G1收集器的特点： 并行和并发：像CMS一样，能与应用程序线程并发执行。充分利用多核、多线程CPU，尽量缩短STW 分代收集：虽然还保留着新、老两代的概念（逻辑上分代），但物理上不再隔离，而是融合在Region中，Region也不要求连续，且会采用不同的GC方式处理不同的区域 空间整合：G1整体上看是标整算法，在局部看又是复制算法，不会产生内存碎片 可预测停顿：用户可以指定一个GC停顿时间，G1收集器会尽量满足 G1过程与CMS类似，最大的好处是化整为零，只需要按照区域来进行扫描即可。 在堆的使用上，G1并不要求对象的存储一定是物理上连续的只要逻辑上连续即可，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n可指定分区大小（1MB~32MB，且必须是2的幂），默认将整堆划分为2048个分区。 大小范围在1MB~32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048=65536MB=64G 内存。 G1 YGC过程： 针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片 Eden区数据移动到Survivor区，假如出现Survivor区空间不够，Eden区数据会部分晋升到Old区 Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区 最后Eden区收拾干净了，GC结束，用户的应用程序继续执行 G1收集过程小结： 初始标记。 并发标记。 最终标记。 筛选回收。 判断对象已经死亡堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。 引用计数法给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。 public class ReferenceCountingGc { Object instance = null; public static void main(String[] args) { ReferenceCountingGc objA = new ReferenceCountingGc(); ReferenceCountingGc objB = new ReferenceCountingGc(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; } } 可达性分析算法这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。 再谈引用无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。 JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。 JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱） 1．强引用（StrongReference） 以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 2．软引用（SoftReference） 如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。 3．弱引用（WeakReference） 如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。 4．虚引用（PhantomReference） “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。 虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。 不可达的对象并非“非死不可”即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。 如何判断一个常量是废弃常量运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？ 假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。 注意： JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 如何判断一个类是无用的类方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。 GC四大算法详解：1. 引用计数法（现在一般不采用） 代码示例如下：虽然objectA和objectB都置空，但是他们之前曾发生过相互引用，所以调用system.gc（手动版唤醒GC，后台也开着自动档）并不能进行垃圾回收。并且，system.gc执行完之后也不是立刻执行垃圾回收。 注意：在实际工作中，禁用system.gc() !!! 2. 复制算法(Copying)年轻代中使用的是Minor GC（YGC），这种GC算法采用的是复制算法(Copying)。 Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，即一旦收集后，Eden是就变成空的了。 当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过 -XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。 -XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数 年轻代中的GC,主要是复制算法（Copying）。 HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块(from)，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法的优点是不会产生内存碎片，缺点是耗费空间。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 上面动画中，Area空闲代表to，Area激活代表from，绿色代表不被回收的，红色代表被回收的。 复制算法它的缺点也是相当明显的: 它浪费了一半的内存，这太要命了。 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。 3 .标记清除(Mark-Sweep)复制算法的缺点就是费空间，其是用在年轻代的，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。 用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。 主要进行两项工作，第一项则是标记，第二项则是清除。 标记：从引用根节点开始标记遍历所有的GC Roots， 先标记出要回收的对象。 清除：遍历整个堆，把标记的对象清除。 缺点：此算法需要暂停整个应用，会产生内存碎片 标记清除算法小结： 1、首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止 应用程序，这会导致用户体验非常差劲 2、其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。 4. 标记压缩(Mark-Compact)标记压缩(Mark-Compact)又叫标记清除压缩(Mark-Sweep-Compact)，或者标记清除整理算法。老年代一般是由标记清除或者是标记清除与标记整理的混合实现 面试题：四种算法那个好Answer：没有那个算法是能一次性解决所有问题的，因为JVM垃圾回收使用的是分代收集算法，没有最好的算法，只有根据每一代他的垃圾回收的特性用对应的算法。新生代使用复制算法，老年代使用标记清除和标记整理算法。没有最好的垃圾回收机制，只有最合适的。 面试题：请说出各个垃圾回收算法的优缺点 内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。 内存整齐度：复制算法=标记整理算法&gt;标记清除算法。 内存利用率：标记整理算法=标记清除算法&gt;复制算法。 可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程 难道就没有一种最优算法吗？Java 9 之后出现了G1垃圾回收器，能够解决以上问题，有兴趣参考这篇文章。 总结： 年轻代(Young Gen)年轻代特点是区域相对老年代较小，对象存活率低。 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。 老年代(Tenure Gen) 老年代的特点是区域较大，对象存活率高。 这种情况，存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。 Mark（标记）阶段的开销与存活对象的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。 Sweep（清除）阶段的开销与所管理区域的大小正相关，但Sweep“就地处决”的特点，回收的过程没有对象的移动。使其相对其它有对象移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。 Compact（压缩）阶段的开销与存活对像的数量成正比，如上一条所描述，对于大量对象的移动是很大开销的，做为老年代的第一选择并不合适。 基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。 JMM1.什么是JMM？JMM：（Java Memory Model 的缩写）JAVA 内存模型 2.作用是什么？作用：缓存一致性协议，用于定义数据读写规则JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory） JMM规定了内存主要划分为主内存和工作内存两种。此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的层次上进行的，如果非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域，从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。 解决共享对象可见性问题：volatile或者synchronized 同步机制 内存交互操作 内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外） lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态 unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用 load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中 use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令 assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中 store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用 write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中 JMM对这八种指令的使用，制定了如下规则： 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 不允许一个线程将没有assign的数据从工作内存同步回主内存 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 对一个变量进行unlock操作之前，必须把此变量同步回主内存 JMM对这八种操作规则和对volatile的一些特殊规则就能确定哪些操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。 happens-before原则： Java内存模型中定义的两项操作之间的次序关系，如果说操作A先行发生于操作B，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。 下面是Java内存模型下一些”天然的“happens-before关系，这些happens-before关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。 a.程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。 b.管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于对同一个锁的lock操作的后面。lock先于unlock c.volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作。volatile变量写先于读。 d.线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。 e.线程终于规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。 f.线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。中断先于中断检测 g.对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。 f.传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。 Java编译与解释编程语言分为低级语言和高级语言，机器语言、汇编语言是低级语言，C、C++、java、python等是高级语言。机器语言是最底层的语言，能够直接执行。而我们编写的源代码是人类语言, 计算机只能识别某些特定的二进制指令，在程序真正运行之前必须将源代码转换成二进制指令。汇编语言通过汇编器翻译成机器指令后执行，一条汇编指令，对应着一条机器指令。高级语言编程的程序有三种执行方式： 1.一种是编译执行，源程序先通过编译器（负责将源程序翻译成目标机器指令）翻译成机器指令，通过编译–&gt;链接–&gt;目标可执行文件，然后执行；即提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序。比如C，C++等语言都是编译执行的。 2.一种是解释执行，是使用解释器会将我们的一句句代码解释成机器可以识别的二进制代码来执行，可以认为是，解释一句，执行一句。在这个过程中，不会生成中间文件。如：脚本方式是一条条命令，在执行时，是由系统的解释器，将其一条条翻译成机器可识别的指令，例如shell脚本是由shell程序执行的，js是由浏览器解释执行的。 3.最后一种是编译和解释相结合的执行方式，比如Java。 理解Java的几个编译器前端编译器：把.java文件转变成.class文件。包括Sun的Javac、Eclipse JDT中的增量式编辑器（ECJ） 后端运行期即时编译器（JIT编译器，Just In Time Compiler）：把字节码转成机器码。包括HotSpot VM的C1、C2编译器 静态提前编译器（AOT编译器，Ahead Of Time Compiler）：把*.java编译成本地机器码。包括GNU Compiler for the Java（GCJ）、Excelsior JET Java采用的是解释和编译混合的模式在编译时期，我们通过将源代码编译成.class ，配合JVM这种跨平台的抽象，屏蔽了底层计算机操作系统和硬件的区别，实现了“一次编译，到处运行” 。 而在运行时期，目前主流的JVM 都是混合模式（-Xmixed），即解释运行和编译运行配合使用。 Java一开始被定位为“解释执行”的语言，但是现在主流的虚拟机中都包含了即时编译器JIT。 程序从源代码到运行经历阶段：java程序–（编译javac）–&gt;字节码文件.class–&gt;类装载子系统化身为反射类Class—&gt;运行时数据区—&gt;（解释执行+JIT编译器编译）–&gt;操作系统（Win，Linux，Mac JVM）。 .class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码，这是是由JVM来执行的，即Java的第二次编译。 Java采用的是解释和编译混合的模式:基于JVM执行引擎当中的解释器interpreter与即使编译器JIT共存 执行引擎获取到由javac将源码编译成的字节码文件class，然后在运行的时候通过解释器interpreter转换成最终的机器码。（解释型） 另外JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，这种方式可以使执行效率大幅度提升（直接编译型） JIT将字节码转换成最终的机器码：以 Oracle JDK提供的HotSpot虚拟机为例，在HotSpot虚拟机中，提供了两种编译模式：解释执行 和 即时编译（JIT，Just-In-Time）。 解释执行即逐条翻译字节码为可运行的机器码，而即时编译则以方法为单位将字节码翻译成机器码（上述提到的“编译执行”）。前者的优势在于不用等待，后者则在实际运行当中效率更高。 即时编译存在的意义在于它是提高程序性能的重要手段之一。根据“二八定律”（即：百分之二十的代码占据百分之八十的系统资源），对于大部分不常用的代码，我们无需耗时间将之编译为机器码，而是采用解释执行的方式，用到就去逐条解释运行；对于一些仅占据小部分的热点代码（可认为是反复执行的重要代码），则可将之翻译为符合机器的机器码高效执行，提高程序的效率，即运行时的即时编译。 为了满足不同的场景，HotSpot虚拟机内置了多个即时编译器：C1,C2与Graal。Graal 是Java10正式引入的实验性即时编译器，在此暂不叙述。先看一下C1、C2 ，相信大家或多或少接触过。 C1：即Client编译器，面向对启动性能有要求的客户端GUI程序，采用的优化手段比较简单，因此编译的时间较短。 C2：即Server编译器，面向对性能峰值有要求的服务端程序，采用的优化手段复杂，因此编译时间长，但是在运行过程中性能更好。 从Java7开始，HotSpot虚拟机默认采用分层编译的方式：热点方法首先被C1编译器编译，而后 热点方法中的热点再进一步被C2编译，根据前面的运行计算出更优的编译优化。为了不干扰程序的正常运行，JIT编译时放在额外的线程中执行的，HotSpot根据实际CPU的资源，以 1:2的比例分配给C1和C2线程数。在计算机资源充足的情况，字节码的解释运行和编译运行时可以同时进行，JIT编译执行完后的机器码会在下次调用该方法时启动，已替换原本的解释执行（意思就是已经翻译出效率更高的机器码，自然替换原来的相对低效率执行的方法）。 以上，可以看出在Java中不单单是解释执行，即时编译（编译执行）在Java性能优化中彰显重要的作用，所以现在应该说：Java是解释执行和编译执行共同存在的，至少大部分是这样。 编译与解释比较？1.一段程序编译会浪费时间，并且移植到其他平台上时还要进行重新编译，但是其编译后生成的可执行文件运行速度快。 2.解释型程序可跨平台执行，无需将全部代码编译之后再运行，能够及时运行，但因为是逐条解释执行所以最终的运行速度不如编译型程序。 3.内存使用：编译执行需要生成编译后的机器码文件，而解释执行时逐句解释执行，所以解释执行对内存占用更少。 单独使用解释器的缺点： 抛弃了JIT可能带来的性能优势。如果代码没有被JIT编译的话，再次运行时需要重复解析。 单独使用JIT编译器的缺点： 需要将全部的代码编译成本地机器码。要花更多的时间，JVM启动会变慢非常多； 增加可执行代码的长度（字节码比JIT编译后的机器码小很多），这将导致页面调度，从而降低程序的速度。 有些JIT编译器的优化方式，比如分支预测，如果不进行profiling，往往并不能进行有效优化。 因此，HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。 JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。 注：JIT为方法级，它会缓存编译过的字节码在CodeCache中，而不需要被重复解释。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"MySQL","slug":"MySQL","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:27:50.747Z","comments":true,"path":"posts/ea4e972t.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e972t.html","excerpt":"","text":"MySQL 什么是数据库 数据库 ( DataBase , 简称DB ) 概念 : 长期存放在计算机内,有组织,可共享的大量数据的集合,是一个数据 “仓库” 作用 : 保存,并能安全管理数据(如:增删改查等),减少冗余… 数据库总览 : 关系型数据库 ( SQL) MySQL, Oracle , SQL Server , SQLite , DB2 , … 关系型数据库通过外键关联来建立表与表之间的关系 非关系型数据库 ( NOSQL ) Redis , MongoDB , … 非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定 什么是DBMS 数据库管理系统 ( DataBase Management System ) 数据库管理软件 , 科学组织和存储数据 , 高效地获取和维护数据 结构化查询语句分类 数据库操作命令行操作数据库创建数据库 : create database [if not exists] 数据库名; 删除数据库 : drop database [if exists] 数据库名; 查看数据库 : show databases; 使用数据库 : use 数据库名; 对比工具操作数据库 学习方法： 对照SQLyog工具自动生成的语句学习 固定语法中的单词需要记忆 创建数据表属于DDL的一种，语法 : create table [if not exists] `表名`( '字段名1' 列类型 [属性][索引][注释], '字段名2' 列类型 [属性][索引][注释], ... '字段名n' 列类型 [属性][索引][注释] )[表类型][表字符集][注释]; 说明 : 反引号用于区别MySQL保留字与普通字符而引入的 (键盘esc下面的键). 数据值和列类型列类型 : 规定数据库中该列存放的数据类型 数值类型 字符串类型 类型 说明 大小 char[M] 字符固定大小的字符串,M代表字符数 ， char（5）如果字符串为“abc” 则剩余的两个字符填补为空格 0~255字节 能容纳多少字符看编码，varchar同理 varchar[M] 可变长度的字符串,M代表字符数 0~65535字节 tinytext 微型文本 2^8^-1字节 text 文本串 2^16^-1字节 举两个例说明一下实际长度的计算。 a) 若一个表只有一个varchar类型，如定义为 create table t4(c varchar(N)) charset=gbk; 则此处N的最大值为(65535-1-2)/2= 32766。 ==减1的原因是实际行存储从第二个字节开始;== ==减2的原因是varchar头部的2个字节表示长度;== 除2的原因是字符编码是gbk。 b) 若一个表定义为 create table t4(c int, c2 char(30), c3 varchar(N)) charset=utf8; 则此处N的最大值为 (65535-1-2-4-30*3)/3=21812 减1和减2与上例相同; 减4的原因是int类型的c占4个字节; 减30*3的原因是char(30)占用90个字节，编码是utf8。 ==如果被varchar超过上述的b规则，被强转成text类型，则每个字段占用定义长度为11字节，当然这已经不是varchar了。== 日期和时间型数值类型 类型 格式 说明 DATE YYYY-MM-DD 日期格式 TIME HH:mm:ss 时间格式 DATETIME YY-MM-DD HH:mm:ss 最常用的时间格式 TIMESTAMP YYYYMMDDHHmmss 时间戳，1970.1.1到现在的毫秒数 year YYYY 1901~2155 ==插入数据时，用‘’单引号== timestamp 有两个属性，分别是 CURRENT_TIMESTAMP 和 ON UPDATE CURRENT_TIMESTAMP两种，使用情况分别如下： 1.==CURRENT_TIMESTAMP== 当要向数据库执行 insert 操作时，如果有个timestamp字段属性设为 CURRENT_TIMESTAMP，则无论这个字段有木有 set 值都插入当前系统时间 2.==ON UPDATE CURRENT_TIMESTAMP== 当执行 update 操作时，并且字段有ON UPDATE CURRENT_TIMESTAMP属性。则字段无论值有没有变化，他的值也会跟着更新为当前UPDATE操作时的时间。 NULL值 理解为 “没有值” 或 “未知值” ==不要用NULL进行算术运算 , 结果仍为NULL== 数据字段属性UnSigned 无符号的 声明该数据列不允许负数 . ZEROFILL 0填充的 不足位数的用0来填充 , 如int(3),5则为005 Auto_InCrement 自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认) 通常用于设置主键 , 且为整数类型 可定义起始值和步长 当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表 SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局) NULL 和 NOT NULL 默认为NULL , 即没有插入该列的数值 如果设置为NOT NULL , 则该列必须有值 DEFAULT 默认的 用于设置默认值 例如,性别字段,默认为”男” , 否则为 “女” ; 若无指定该列的值 , 则默认值为”男”的值 -- 目标 : 创建一个school数据库 -- 创建学生表(列,字段) -- 学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datetime),家庭住址,email -- 创建表之前 , 一定要先选择数据库 -- COMMENT 注释 ，英文逗号隔开语句，最后一句不用逗号 CREATE TABLE IF NOT EXISTS `student` ( `id` int(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` varchar(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` varchar(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` varchar(2) NOT NULL DEFAULT '男' COMMENT '性别', `birthday` datetime DEFAULT NULL COMMENT '生日', `address` varchar(100) DEFAULT NULL COMMENT '地址', `email` varchar(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 -- 查看-&gt;创建数据库的定义SQL语句 SHOW CREATE DATABASE school; -- 查看-&gt;创建数据表的定义SQL语句 SHOW CREATE TABLE student; -- 显示表结构 DESC student; -- 设置严格检查模式(不能容错了)SET sql_mode='STRICT_TRANS_TABLES'; 数据表的类型 设置数据表的类型 CREATE TABLE 表名( -- 省略一些代码 -- Mysql注释 -- 1. # 单行注释 -- 2. /*...*/ 多行注释 )ENGINE = MyISAM (or InnoDB) -- 查看mysql所支持的引擎类型 (表类型) SHOW ENGINES; MySQL的数据表的类型 : MyISAM , InnoDB , HEAP , BOB , CSV等… 常见的 MyISAM 与 InnoDB 类型： 名称 MyISAM InnoDB 事务处理 不支持 支持 数据行锁定 不支持（表级锁，是整个表锁定） 支持 外键约束 不支持 支持 全文索引 支持 不支持 (5.6以上支持) 表空间大小 较小 较大，约两倍 经验 ( 适用场合 ) : 适用 MyISAM : 节约空间及相应速度 适用 InnoDB : 安全性 , 事务处理及多用户操作数据表 数据表的存储位置 MySQL数据表以文件方式存放在磁盘中 包括表文件 , 数据文件 , 以及数据库的选项文件 位置 : Mysql安装目录\\data\\下存放数据表 . 目录名对应数据库名 , 该目录下文件名对应数据表 . 注意 : * . frm – 表结构定义文件 * . MYD – 数据文件 ( data ) * . MYI – 索引文件 ( index ) InnoDB类型数据表只有一个 *.frm文件 , 以及上一级目录的ibdata1文件 MyISAM类型数据表对应三个文件 : 设置数据表字符集 我们可为数据库,数据表,数据列设定不同的字符集，设定方法 : 创建时通过命令来设置 , 如 : CREATE TABLE 表名( …. )CHARSET = utf8; 如无设定 , 则根据MySQL数据库配置文件 my.ini 中的参数设定，这样子导入其他电脑的SQL文件会出现乱码 修改数据库 修改表 ( ALTER TABLE ) 修改表名 :ALTER TABLE 旧表名 RENAME AS 新表名 添加字段 : ALTER TABLE 表名 ADD 字段名 列属性[属性] 修改字段 : ALTER TABLE 表名 MODIFY 字段名 列类型[属性] ==修改属性约束== ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性] ==字段重命名==和修改约束 删除字段 : ALTER TABLE 表名 DROP 字段名 删除数据表 语法：DROP TABLE [IF EXISTS] 表名 IF EXISTS为可选 , 判断是否存在该数据表 如删除不存在的数据表会抛出错误 其他 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以==避免与关键字重名！中文也可以作为标识符！== 每个库目录存在一个保存当前数据库的选项文件db.opt。 注释：单行注释 # 注释内容多行注释 /* 注释内容 */单行注释 – 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 模式通配符：_ 任意单个字符% 任意多个字符，甚至包括零字符单引号需要进行转义 \\ ' CMD命令行内的语句结束符可以为 “;”, “\\G”, “\\g”，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 SQL对大小写不敏感 （关键字） 清除已有语句：\\c 外键 外键概念 如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。 在实际操作中，将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值(在必要时可包括复合主键值)。此时，第二个表中保存这些值的属性称为外键(foreign key)。 外键作用 保持数据一致性，完整性，主要目的是控制存储在外键表中的数据,约束。使两张表形成关联，外键只能引用外表中的列的值或使用空值。 创建外键 建表时指定外键约束 -- 创建外键的方式一 : 创建子表同时创建外键 -- 年级表 (id\\年级名称) CREATE TABLE `grade` ( `gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT '年级ID', `gradename` VARCHAR(50) NOT NULL COMMENT '年级名称', PRIMARY KEY (`gradeid`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 -- 学生信息表 (学号,姓名,性别,年级,手机,地址,出生日期,邮箱,身份证号) CREATE TABLE `student` ( `studentno` INT(4) NOT NULL COMMENT '学号', `studentname` VARCHAR(20) NOT NULL DEFAULT '匿名' COMMENT '姓名', `sex` TINYINT(1) DEFAULT '1' COMMENT '性别', `gradeid` INT(10) DEFAULT NULL COMMENT '年级', `phoneNum` VARCHAR(50) NOT NULL COMMENT '手机', `address` VARCHAR(255) DEFAULT NULL COMMENT '地址', `borndate` DATETIME DEFAULT NULL COMMENT '生日', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', `idCard` VARCHAR(18) DEFAULT NULL COMMENT '身份证号', PRIMARY KEY (`studentno`), KEY `FK_gradeid` (`gradeid`), CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 建表后修改 -- 创建外键方式二 : 创建子表完毕后,修改子表添加外键 ALTER TABLE `student` ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`); 删除外键 操作：删除 grade 表，发现报错 注意 : 删除具有主外键关系的表时 , 要先删（依赖）子表 , 后删（被依赖）主表 -- 删除外键 ALTER TABLE student DROP FOREIGN KEY FK_gradeid; -- 发现执行完上面的,索引还在,所以还要删除索引 -- 注:这个索引是建立外键的时候默认生成的 ALTER TABLE student DROP INDEX FK_gradeid; 以上操作都是物理外键，数据库级别的外键，不建议使用（避免数据库过多造成困扰） ==最佳实践== 数据库就是单纯的表，只用来存储数据，只有行（数据）和列（字段） 我们要使用多张表的数据，想用外键（程序去实现） DML语言数据库意义 ： 数据存储、数据管理 管理数据库数据方法： 通过SQLyog等管理工具管理数据库数据 通过DML语句管理数据库数据 DML语言 ：数据操作语言 用于操作数据库对象中所包含的数据 包括 : INSERT (添加数据语句) UPDATE (更新数据语句) DELETE (删除数据语句) 添加数据 INSERT命令 语法： INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES('值1','值2','值3') 注意 : 字段或值之间用英文逗号隔开 . ‘ 字段1,字段2…’ 该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致 . 可同时插入多条数据 , values 后用英文逗号隔开 . -- 使用语句如何增加语句? -- 语法 : INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES('值1','值2','值3') INSERT INTO grade(gradename) VALUES ('大一'); -- 主键自增,那能否省略呢? INSERT INTO grade VALUES ('大二'); -- 查询:INSERT INTO grade VALUE ('大二')错误代码：1136 Column count doesn`t match value count at row 1 -- 结论:'字段1,字段2...'该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致，一一对应。 -- 一次插入多条数据 INSERT INTO grade(gradename) VALUES ('大三'),('大四'); ==如果有外键，被依赖的表必须先有数据，依赖的表才可以插入数据，比如依赖的表要插入grade-id = 1，被依赖的表必须要有 grade-id = 1的数据。== 修改数据 update命令 语法： UPDATE 表名 SET column_name = value [,column_name2=value2,...] [WHERE condition]; 注意 : column_name 为要更改的数据列，多个用英文逗号隔开 value 为修改后的数据 , 可以为变量 , 具体值 , 表达式或者嵌套的SELECT结果 update `student` set `birth`= current_time() where `id`&gt;1 and `id`&lt;8; ==current_time()为变量== condition 为筛选条件 , 如不指定则修改该表的所有列数据 关闭和开启安全模式 SET SQL_SAFE_UPDATES = 0; -- 关闭安全模式 SET SQL_SAFE_UPDATES = 1; -- 开启安全模式 where条件子句 可以简单的理解为 : 有条件地从表中筛选数据 测试： -- 修改年级信息 UPDATE grade SET gradename = '高中' WHERE gradeid = 1; 删除数据 DELETE命令 语法： DELETE FROM 表名 [WHERE condition]; 注意：condition为筛选条件 , 如不指定则删除该表的所有列数据 -- 删除某一个数据 DELETE FROM grade WHERE gradeid = ？ TRUNCATE命令 作用：用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ; 语法： TRUNCATE [TABLE] table_name; -- 清空年级表 TRUNCATE grade 注意：区别于DELETE命令 相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快 ==不同== : 使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器 使用TRUNCATE TABLE不会对事务有影响 （事务后面会说） 测试： -- 创建一个测试表 CREATE TABLE `test` ( `id` INT(4) NOT NULL AUTO_INCREMENT, `coll` VARCHAR(20) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 -- 插入几个测试数据 INSERT INTO test(coll) VALUES('row1'),('row2'),('row3'); -- 删除表数据(不带where条件的delete) DELETE FROM test; -- 结论:如不指定Where则删除该表的所有列数据,自增当前值依然从原来基础上进行,会记录日志. -- 删除表数据(truncate) TRUNCATE TABLE test; -- 结论:truncate删除数据,自增当前值会恢复到初始值重新开始;不会记录日志. -- 同样使用DELETE清空不同引擎的数据库表数据.重启数据库服务后 -- InnoDB : 自增列从初始值重新开始 (因为是存储在内存中,断电即失) -- MyISAM : 自增列依然从上一个自增数据基础上开始 (存在文件中,不会丢失) 了解即可，==delete 删除后，重启数据库==，现象 InnoDB 自增列会重新从1开始 （存在内存当中，断电即失） MyISAM 继续从上一个自增量开始（存在文件中，不会丢失） DQL语言DQL( Data Query Language 数据查询语言 ) 查询数据库数据 , 如SELECT语句 简单的单表查询或多表的复杂查询和嵌套查询 是数据库语言中最核心,最重要的语句 使用频率最高的语句 SELECT语法 SELECT [ALL | DISTINCT] { * | table.* | [table.field1 [as 别名] [,table.field2 [as 别名]] [,...]] } FROM table_name [as 别名] [left | right | inner join table_name2 on....] -- 联合查询 [WHERE ...] -- 指定结果需满足的条件 [GROUP BY ...] -- 指定结果按照哪几个字段来分组 [HAVING] -- 过滤分组的记录必须满足的次要条件 [ORDER BY ...] -- 指定查询记录按一个或多个条件排序 [LIMIT {[offset,]row_count | row_countOFFSET offset}]; -- offset 起始数据行 row_count 行数 -- 指定查询的记录从哪条至哪条 注意 : [ ] 括号代表可选 , { }括号代表必选，条件限制 where 和 having 等语句顺序只能按照上面的顺序写 指定查询字段-- 查询表中所有的数据列结果 , 采用 **\" \\* \"** 符号; 但是效率低，不推荐 . -- 查询所有学生信息 SELECT * FROM student; -- 查询指定列(学号 , 姓名) SELECT studentno,studentname FROM student; AS 子句作为别名 作用： 可给数据列取一个新别名 可给表取一个新别名 可把经计算或总结的结果用另一个新名称来代替 -- 这里是为列取别名(当然as关键词可以省略) SELECT studentno AS 学号,studentname AS 姓名 FROM student; -- 使用as也可以为表取别名 SELECT studentno AS 学号,studentname AS 姓名 FROM student AS s; -- 使用as,为查询结果取一个新名字 -- CONCAT()函数拼接字符串 SELECT CONCAT('姓名:',studentname) AS 新姓名 FROM student; DISTINCT关键字的使用 作用 : 去掉SELECT查询返回的记录结果中重复的记录 ( 返回所有列的值都相同 ) , 只返回一条 -- # 查看哪些同学参加了考试(学号) 去除重复项 SELECT * FROM result; -- 查看考试成绩 SELECT studentno FROM result; -- 查看哪些同学参加了考试 SELECT DISTINCT studentno FROM result; -- 了解:DISTINCT 去除重复项 , (默认是ALL) 使用表达式的列 数据库中的表达式 : 一般由文本值 , 列值 , NULL , 函数和操作符等组成 应用场景 : SELECT语句返回结果列中使用 SELECT语句中的ORDER BY , HAVING等子句中使用 DML语句中的 where 条件语句中使用表达式 -- selcet查询中可以使用表达式 SELECT @@auto_increment_increment; -- 查询自增步长 SELECT VERSION(); -- 查询版本号 SELECT 100*3-1 AS 计算结果; -- 表达式 -- 学员考试成绩集体提分一分查看 SELECT studentno,StudentResult+1 AS '提分后' FROM result; 避免SQL返回结果中包含 ‘ . ‘ , ‘ * ‘ 和括号等干扰开发语言程序. where条件语句作用：用于检索数据表中 符合条件 的记录 搜索条件可由一个或多个逻辑表达式组成 , 结果一般为真或假. 逻辑操作符 测试 -- 满足条件的查询(where) SELECT Studentno,StudentResult FROM result; -- 查询考试成绩在95-100之间的 SELECT Studentno,StudentResult FROM result WHERE StudentResult&gt;=95 AND StudentResult&lt;=100; -- AND也可以写成 &amp;&amp; SELECT Studentno,StudentResult FROM result WHERE StudentResult&gt;=95 &amp;&amp; StudentResult&lt;=100; -- 模糊查询(对应的词:精确查询) SELECT Studentno,StudentResult FROM result WHERE StudentResult BETWEEN 95 AND 100; -- 除了1000号同学,要其他同学的成绩 SELECT studentno,studentresult FROM result WHERE studentno!=1000; -- 使用NOT SELECT studentno,studentresult FROM result WHERE NOT studentno=1000; 模糊查询 ：比较操作符 注意： 数值数据类型的记录之间才能进行算术运算 ; 相同数据类型的数据之间才能进行比较 ; 测试： -- 模糊查询 between and \\ like \\ in \\ null -- ============================================= -- LIKE -- ============================================= -- 查询姓刘的同学的学号及姓名 -- like结合使用的通配符 : % (代表0到任意个字符) _ (一个字符) SELECT studentno,studentname FROM student WHERE studentname LIKE '刘%'; -- 查询姓刘的同学,后面只有一个字的 SELECT studentno,studentname FROM student WHERE studentname LIKE '刘_'; -- 查询姓刘的同学,后面只有两个字的 SELECT studentno,studentname FROM student WHERE studentname LIKE '刘__'; -- 查询姓名中含有 嘉 字的 SELECT studentno,studentname FROM student WHERE studentname LIKE '%嘉%'; -- 查询姓名中含有特殊字符的需要使用转义符号 '\\' -- 自定义转义符关键字: ESCAPE ':' -- ============================================= -- IN -- ============================================= -- 查询学号为1000,1001,1002的学生姓名 SELECT studentno,studentname FROM student WHERE studentno IN (1000,1001,1002); -- 查询地址在北京,南京,河南洛阳的学生 SELECT studentno,studentname,address FROM student WHERE address IN ('北京','南京','河南洛阳'); -- ============================================= -- NULL 空 -- ============================================= -- 查询出生日期没有填写的同学 -- 不能直接写=NULL , 这是代表错误的 , 用 is null SELECT studentname FROM student WHERE BornDate IS NULL; -- 查询出生日期填写的同学 SELECT studentname FROM student WHERE BornDate IS NOT NULL; -- 查询没有写家庭住址的同学(空字符串不等于null) SELECT studentname FROM student WHERE Address='' OR Address IS NULL; ==没有填写数据为null，查询这样的数据时不能直接写=NULL , 这是代表错误的 , 用 is null== 连接查询 JOIN 对比 操作符名称 描述 INNER JOIN 如果表中有至少一个匹配，则返回匹配的数据 LEFT JOIN （以左表为基准）如果有的数据右表中没有匹配的数据，则以null填充，左表返回所有的行 RIGHT JOIN （以右表为基准）如果有的数据左表中没有匹配的数据，则以null填充，右表返回所有的行 七种Join： 测试 /* 连接查询 如需要多张数据表的数据进行查询,则可通过连接运算符实现多个查询 内连接 inner join 查询两个表中的结果集中的交集 外连接 outer join 左外连接 left join (以左表作为基准,右边表来一一匹配,匹配不上的,返回左表的记录,右表以NULL填充) 右外连接 right join (以右表作为基准,左边表来一一匹配,匹配不上的,返回右表的记录,左表以NULL填充) 等值连接和非等值连接 自连接 */ -- 查询参加了考试的同学信息(学号,学生姓名,科目编号,分数) SELECT * FROM student; SELECT * FROM result; /*思路: (1):分析需求,确定查询的列来源于两个类,student result,连接查询 (2):确定使用哪种连接查询?(内连接) */ SELECT s.studentno,studentname,subjectno,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno -- 右连接(也可实现) SELECT s.studentno,studentname,subjectno,StudentResult FROM student s RIGHT JOIN result r ON r.studentno = s.studentno -- 等值连接 SELECT s.studentno,studentname,subjectno,StudentResult FROM student s , result r WHERE r.studentno = s.studentno -- 左连接 (查询了所有同学,不考试的也会查出来) SELECT s.studentno,studentname,subjectno,StudentResult FROM student s LEFT JOIN result r ON r.studentno = s.studentno -- 查一下缺考的同学(左连接应用场景) SELECT s.studentno,studentname,subjectno,StudentResult FROM student s LEFT JOIN result r ON r.studentno = s.studentno WHERE StudentResult IS NULL -- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r -- 此处用 LEFT JOIN RIGHT JOIN 都行，因为都是要与 subject 表进行连接的，结果都一样 ON r.studentno = s.studentno INNER JOIN `subject` sub ON sub.subjectno = r.subjectno 自连接 /* 自连接 数据表与自身进行连接 需求:从一个包含栏目ID , 栏目名称和父栏目ID的表中 查询父栏目名称和其他子栏目名称 */ -- 创建一个表 CREATE TABLE `category` ( `categoryid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主题id', `pid` INT(10) NOT NULL COMMENT '父id', `categoryName` VARCHAR(50) NOT NULL COMMENT '主题名字', PRIMARY KEY (`categoryid`) ) ENGINE=INNODB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8 -- 插入数据 INSERT INTO `category` (`categoryid`, `pid`, `categoryName`) VALUES('2','1','信息技术'), ('3','1','软件开发'), ('4','3','数据库'), ('5','1','美术设计'), ('6','3','web开发'), ('7','5','ps技术'), ('8','2','办公信息'); -- 编写SQL语句,将栏目的父子关系呈现出来 (父栏目名称,子栏目名称) -- 核心思想:把一张表看成两张一模一样的表,然后将这两张表连接查询(自连接) SELECT a.categoryName AS '父栏目',b.categoryName AS '子栏目' FROM category AS a,category AS b WHERE a.`categoryid`=b.`pid` -- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON sub.subjectno = r.subjectno -- 查询学员及所属的年级(学号,学生姓名,年级名) SELECT studentno AS 学号,studentname AS 学生姓名,gradename AS 年级名称 FROM student s INNER JOIN grade g ON s.`GradeId` = g.`GradeID` -- 查询科目及所属的年级(科目名称,年级名称) SELECT subjectname AS 科目名称,gradename AS 年级名称 FROM SUBJECT sub INNER JOIN grade g ON sub.gradeid = g.gradeid -- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='数据库结构-1' 排序和分页测试 /*============== 排序 ================ 语法 : ORDER BY ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照ASC升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 */ -- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩) -- 按成绩降序排序 SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='数据库结构-1' ORDER BY StudentResult DESC /*============== 分页 ================ 语法 : SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset 好处 : (用户体验,网络传输,查询压力) 推导: 第一页 : limit 0,5 第二页 : limit 5,5 第三页 : limit 10,5 ...... 第N页 : limit (pageNo-1)*pageSzie,pageSzie [pageNo:页码,pageSize:单页面显示条数] */ -- 每页显示5条数据 SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='数据库结构-1' ORDER BY StudentResult DESC LIMIT 0,5 -- 查询 JAVA第一学年 课程成绩前10名并且分数大于80的学生信息(学号,姓名,课程名,分数) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='JAVA第一学年' ORDER BY StudentResult DESC LIMIT 0,10 子查询/*============== 子查询 ================ 什么是子查询? 在查询语句中的WHERE条件子句中,又嵌套了另一个查询语句 嵌套查询可由多个子查询组成,求解的方式是由里及外; 子查询返回的结果一般都是集合,故而建议使用IN关键字; */ -- 查询 数据库结构-1 的所有考试结果(学号,科目编号,成绩),并且成绩降序排列 -- 方法一:使用连接查询 SELECT studentno,r.subjectno,StudentResult FROM result r INNER JOIN `subject` sub ON r.`SubjectNo`=sub.`SubjectNo` WHERE subjectname = '数据库结构-1' ORDER BY studentresult DESC; -- 方法二:使用子查询(执行顺序:由里及外) SELECT studentno,subjectno,StudentResult FROM result WHERE subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = '数据库结构-1' ) ORDER BY studentresult DESC; -- 查询课程为 高等数学-2 且分数不小于80分的学生的学号和姓名 -- 方法一:使用连接查询 SELECT s.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo` = r.`StudentNo` INNER JOIN `subject` sub ON sub.`SubjectNo` = r.`SubjectNo` WHERE subjectname = '高等数学-2' AND StudentResult&gt;=80 -- 方法二:使用连接查询+子查询 -- 分数不小于80分的学生的学号和姓名 SELECT r.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo`=r.`StudentNo` WHERE StudentResult&gt;=80 -- 在上面SQL基础上,添加需求:课程为 高等数学-2 SELECT r.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo`=r.`StudentNo` WHERE StudentResult&gt;=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = '高等数学-2' ) -- 方法三:使用子查询 -- 分步写简单sql语句,然后将其嵌套起来 SELECT studentno,studentname FROM student WHERE studentno IN( SELECT studentno FROM result WHERE StudentResult&gt;=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = '高等数学-2' ) ) 分组和过滤 -- 查询不同课程的平均分,最高分,最低分 -- 前提:根据不同的课程进行分组 SELECT subjectname,AVG(studentresult) AS 平均分,MAX(StudentResult) AS 最高分,MIN(StudentResult) AS 最低分 FROM result AS r INNER JOIN `subject` AS s ON r.subjectno = s.subjectno GROUP BY r.subjectno -- 这里也可以用 sub.subjectno HAVING 平均分&gt;80; /* where写在group by前面. 分组后面的筛选，要使用HAVING.. 因为having是从前面筛选的字段再筛选，而where是从数据表中的&gt;字段直接进行筛选的 */ 常用函数数据函数 SELECT ABS(-8); /*绝对值*/ SELECT CEILING(9.4); /*向上取整*/ SELECT FLOOR(9.4); /*向下取整*/ SELECT RAND(); /*随机数,返回一个0-1之间的随机数，包含0，不包含1*/ SELECT SIGN(0); /*符号函数: 负数返回-1,正数返回1,0返回0*/ 字符串函数 SELECT CHAR_LENGTH('狂神说坚持就能成功'); /*返回字符串包含的字符数*/ SELECT CONCAT('我','爱','程序'); /*合并字符串,参数可以有多个*/ SELECT INSERT('我爱编程helloworld',1,2,'超级热爱'); /*这里的1是第一个字符，替换字符串,从某个位置开始替换某个长度*/ SELECT LOWER('KuangShen'); /*小写*/ SELECT UPPER('KuangShen'); /*大写*/ SELECT LEFT('hello,world',5); /*从左边第一个字符截取，长度*/ SELECT RIGHT('hello,world',5); /*从右边第一个字符截取，长度*/ SELECT REPLACE('狂神说坚持就能成功','坚持','努力'); /*替换字符串*/ SELECT SUBSTR('狂神说坚持就能成功',4,6); /*截取字符串,开始和长度*/ SELECT REVERSE('狂神说坚持就能成功'); /*反转 -- 查询姓周的同学,改成邹 SELECT REPLACE(studentname,'周','邹') AS 新名字 FROM student WHERE studentname LIKE '周%'; 日期和时间函数 SELECT CURRENT_DATE(); /*获取当前日期*/ SELECT CURDATE(); /*获取当前日期*/ SELECT NOW(); /*获取当前日期和时间*/ SELECT LOCALTIME(); /*获取当前日期和时间*/ SELECT SYSDATE(); /*获取当前日期和时间*/ -- 获取年月日,时分秒 SELECT YEAR(NOW()); SELECT MONTH(NOW()); SELECT DAY(NOW()); SELECT HOUR(NOW()); SELECT MINUTE(NOW()); SELECT SECOND(NOW()); 系统信息函数 SELECT VERSION(); /*版本*/ SELECT USER(); /*用户*/ 聚合函数（常用） 函数名称 描述 COUNT() 返回满足Select条件的记录总和数，如 select count(*) 【不建议使用 *，效率低】 SUM() 返回数字字段或表达式列作统计，返回一列的总和。 AVG() 通常为数值字段或表达列作统计，返回一列的平均值 MAX() 可以为数值字段，字符字段或表达式列作统计，返回最大的值。 MIN() 可以为数值字段，字符字段或表达式列作统计，返回最小的值。 -- 聚合函数 /*COUNT:非空的*/ SELECT COUNT(studentname) FROM student; SELECT COUNT(*) FROM student; SELECT COUNT(1) FROM student; /*推荐*/ -- 从含义上讲，count(1) 与 count(*) 都表示对全部数据行的查询。 -- count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 -- count(*) 包括了所有的列，相当于行数，在统计结果的时候，包含字段为null 的记录； -- count(1) 用1代表代码行，在统计结果的时候，包含字段为null 的记录 。 /* 很多人认为count(1)执行的效率会比count(*)高，原因是count(*)会存在全表扫描，而count(1)可以针对一个字段进行查询。其实不然，count(1)和count(*)都会对全表进行扫描，统计所有记录的条数，包括那些为null的记录，因此，它们的效率可以说是相差无几。而count(字段)则与前两者不同，它会统计该字段不为null的记录条数。 下面它们之间的一些对比： 1）列名不为主键时，count(1) 比 count(列名)快 2）有主键时，主键作为计算条件，count(主键) 效率最高； 3）表有多列并且没有主键，cout（1）比 count（*）效率高 4）若表格只有一个字段，则 count(*) 效率较高。 */ SELECT SUM(StudentResult) AS 总和 FROM result; SELECT AVG(StudentResult) AS 平均分 FROM result; SELECT MAX(StudentResult) AS 最高分 FROM result; SELECT MIN(StudentResult) AS 最低分 FROM result; MD5 加密一、MD5简介 MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。 二、实现数据加密 新建一个表 testmd5 CREATE TABLE `testmd5` ( `id` INT(4) NOT NULL, `name` VARCHAR(20) NOT NULL, `pwd` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 插入一些数据 INSERT INTO testmd5 VALUES(1,'kuangshen','123456'),(2,'qinjiang','456789') 如果我们要对pwd这一列数据进行加密，语法是： update testmd5 set pwd = md5(pwd); 如果单独对某个用户(如kuangshen)的密码加密： INSERT INTO testmd5 VALUES(3,'kuangshen','123456') update testmd5 set pwd = md5(pwd) where name = 'kuangshen'; 插入新的数据自动加密 INSERT INTO testmd5 VALUES(4,'kuangshen3',md5('123456')); 查询登录用户信息（md5对比使用，查看用户输入加密后的密码进行比对） SELECT * FROM testmd5 WHERE `name`='kuangshen' AND pwd=MD5('123456'); 每次加密后值都会变，可以在加密的基础上再次加密，如果同一个密码，一个加密一次 ，一个加密两次，这两个的加密值都是不一样的，数据校验（查询） 校验的是加密后的值是否相同。 小结-- ================ 内置函数 ================ -- 数值函数 abs(x) -- 绝对值 abs(-10.9) = 10 format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46 ceil(x) -- 向上取整 ceil(10.1) = 11 floor(x) -- 向下取整 floor (10.1) = 10 round(x) -- 四舍五入去整 mod(m, n) -- m%n m mod n 求余 10%3=1 pi() -- 获得圆周率 pow(m, n) -- m^n sqrt(x) -- 算术平方根 rand() -- 随机数 truncate(x, d) -- 截取d位小数 -- 时间日期函数 now(), current_timestamp(); -- 当前日期时间 current_date(); -- 当前日期 current_time(); -- 当前时间 date('yyyy-mm-dd hh:ii:ss'); -- 获取日期部分 time('yyyy-mm-dd hh:ii:ss'); -- 获取时间部分 date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间 unix_timestamp(); -- 获得unix时间戳 from_unixtime(); -- 从时间戳获得时间 -- 字符串函数 length(string) -- string长度，字节 char_length(string) -- string的字符个数 substring(str, position [,length]) -- 从str的position开始,取length个字符 replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_str instr(string ,substring) -- 返回substring首次在string中出现的位置 concat(string [,...]) -- 连接字串 charset(str) -- 返回字串字符集 lcase(string) -- 转换成小写 left(string, length) -- 从string2中的左边起取length个字符 load_file(file_name) -- 从文件读取内容 locate(substring, string [,start_position]) -- 同instr,但可指定开始位置 lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为length ltrim(string) -- 去除前端空格 repeat(string, count) -- 重复count次 rpad(string, length, pad) --在str后用pad补充,直到长度为length rtrim(string) -- 去除后端空格 strcmp(string1 ,string2) -- 逐字符比较两字串大小 -- 聚合函数 count() sum(); max(); min(); avg(); group_concat() -- 其他常用函数 md5(); default(); 视图什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，==视图并不在数据库中以存储的数据值集形式存在==。行和列数据来自定义视图的查询所引用的表，并且在引用视图时动态生成。 ==视图具有表结构文件，但不存在数据文件。== 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。 -- 创建视图 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement \\- 视图名必须唯一，同时不能与表重名。 \\- 视图可以使用 select 语句查询到的列名，也可以自己指定相应的列名。 \\- 可以指定视图执行的算法，通过 ALGORITHM 指定。 \\- column_list 如果存在，则数目必须等于SELECT语句检索的列数 -- 查看结构 SHOW CREATE VIEW view_name -- 删除视图 \\- 删除视图后，数据依然存在。 \\- 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ... -- 修改视图结构 \\- 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement -- 视图作用 \\1. 简化业务逻辑 \\2. 对客户端隐藏真实的表结构 -- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。 事务 什么是事务 事务就是将一组SQL语句放在同一批次内去执行 如果一个SQL语句出错,则该批次内的所有SQL都将被取消执行 MySQL事务处理只支持InnoDB和BDB数据表类型 事务的ACID原则 百度 ACID 原子性(Atomic) 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性(Consist) 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。 隔离性(Isolated) 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。 持久性(Durable) 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 并发事务带来的几个问题：更新丢失，脏读，不可重复读，幻读。 更新丢失：==多个事务对同一数据进行修改，最后只保留了最后修改的值，其他事务修改的值都被覆盖了==。 脏读：指一个事务读取了另外一个事务==已修改但未提交==的数据。 不可重复读：在一个事务内读取表中的某一行数据，多次读取结果不同。==读取到了另一个事务提交的修改数据，不符合隔离性==（这个不一定是错误，只是某些场合不对） 虚读(幻读)：是指在一个事务内==读取到了别的事务新增插入的数据==，导致前后读取不一致。（一般是行影响，多了一行） 事务隔离级别：未提交读(Read uncommitted)，已提交读(Read committed)，可重复读(Repeatable read)，可序列化(Serializable) select @@global.transaction_isolation,@@transaction_isolation; -- 查询隔离级别 -- @@global.transaction_isolation 全局事务隔离级别 -- @@transaction_isolation 当前表的事务隔离级别 四种隔离级别的比较 读数据一致性及并发副作用 隔离级别 读数据一致性 脏读 不可重复读 幻读 未提交读(read uncommitted) 最低级别，不读物理上顺环的数据 是 是 是 已提交读(read committed) 语句级 否 是 是 可重复读(Repeatable red) 事务级 否 否 是 可序列化(Serializable) 最高级别，事务级 否 否 否 ==MySQL InnoDB的事务隔离级别为 可重复读(Repeatable red) ，而MySQL 8.0 以上已经可以解决幻读问题，但是隔离级别还是 可重复读(Repeatable red) 。== 基本语法 -- 使用set语句来改变自动提交模式 SET autocommit = 0; /*关闭*/ SET autocommit = 1; /*开启*/ -- 注意: --- 1.MySQL中默认是自动提交 --- 2.使用事务时应先关闭自动提交 -- 开始一个事务,标记事务的起始点 START TRANSACTION -- 提交一个事务给数据库，commit 一次就提交一次事务 COMMIT -- 将事务回滚,数据回到本次事务的初始状态 ROLLBACK -- 还原MySQL数据库的自动提交 SET autocommit =1; -- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点 测试 /* 课堂测试题目 A在线买一款价格为500元商品,网上银行转账. A的银行卡余额为2000,然后给商家B支付500. 商家B一开始的银行卡余额为10000 创建数据库shop和创建表account并插入2条数据 */ CREATE DATABASE `shop`CHARACTER SET utf8 COLLATE utf8_general_ci; USE `shop`; CREATE TABLE `account` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(32) NOT NULL, `cash` DECIMAL(9,2) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO account (`name`,`cash`) VALUES('A',2000.00),('B',10000.00) -- 转账实现 SET autocommit = 0; -- 关闭自动提交 START TRANSACTION; -- 开始一个事务,标记事务的起始点 UPDATE account SET cash=cash-500 WHERE `name`='A'; UPDATE account SET cash=cash+500 WHERE `name`='B'; COMMIT; -- 提交事务 # rollback; SET autocommit = 1; -- 恢复自动提交 索引了解索引结构（参考博客）： https://blog.codinglabs.org/articles/theory-of-mysql-index.html 索引就是排好序的快速查找数据结构 。 在数据库之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 索引的优势 ==提高查询速度== 确保数据的唯一性 可以加速表和表之间的连接 , 实现表与表之间的参照完整性 使用分组和排序子句进行数据检索时 , 可以显著==减少分组和排序的时间== 全文检索字段进行搜索优化. 索引的劣势 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的 虽然索引大大提高了查询的速度，同时也会降低更新表的速度，如 insert， update，delete 。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。 索引准则 索引不是越多越好，一般建议5个 不要对经常变动的数据加索引 小数据量的表建议不要加索引 如果某个数据列包含许多重复内容，为它建立索引没有太大的实际效果 高并发下推荐使用复合索引 索引一般应加在频繁作为查找条件的字段 查询中与其他表关联的字段 where 条件里用不到的字段不建立索引 排序字段建立索引，大大提高排序速度 查询中统计或者分组的字段 索引的数据结构 -- 我们可以在创建上述索引的时候，为其指定索引类型，分两类 hash类型的索引：查询单条快，范围查询慢 btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它） -- 不同的存储引擎支持的索引类型也不一样 InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引； MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引； Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引； NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引； Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引； 分类 主键索引 (Primary Key) 唯一索引 (Unique) 常规索引 (Index) 全文索引 (FullText) 主键索引 主键 : 某一个属性组能唯一标识一条记录 特点 : 最常见的索引类型，是特殊的唯一索引 确保数据记录的唯一性 确定特定数据记录在数据库中的位置 不能为空 唯一索引 作用 : 避免同一个表中某数据列中的值重复 与主键索引的区别 ==主键索引只能有一个，唯一索引可能有多个== ==主键索引不能为空值，唯一索引可以为空值== CREATE TABLE `Grade`( `GradeID` INT(11) AUTO_INCREMENT PRIMARYKEY, `GradeName` VARCHAR(32) NOT NULL UNIQUE -- 或 UNIQUE KEY `GradeID` (`GradeID`) ) 常规索引 作用 : 快速定位特定数据 注意 : index 和 key 关键字都可以设置常规索引 应加在查询找条件的字段 ==不宜添加太多常规索引,影响数据的插入,删除和修改操作== CREATE TABLE `result`( -- 省略一些代码 INDEX/KEY `ind` (`studentNo`,`subjectNo`) -- 创建表时添加 ) -- 创建后添加 ALTER TABLE `result` ADD INDEX `ind`(`studentNo`,`subjectNo`); 全文索引 作用场景：当查询条件为where column like ‘%xxx%’时，会让索引失效，此时全文索引便派上用场了 作用 : 快速定位特定数据 注意 : ==只能用于MyISAM类型的数据表（5.6以上后 InnoDB 也支持）== ==只能用于CHAR , VARCHAR , TEXT数据列类型== 数据表越大，全文索引效果好，小表返回结果可能不理想 对于较大的数据集，将数据输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把数据输入现有FULLTEXT索引的速度更为快 生成全文索引是一个非常耗时且非常耗硬盘空间的做法 全文索引创建速度慢，而且对有全文索引的各种数据修改操作也慢 少于3个字符的单词不会被包含在全文索引里，可以通过修改my.cnf的ft_min_word_len选项进行设置 /* #方法一：创建表时 CREATE TABLE 表名 ( 字段名1 数据类型 [完整性约束条件…], 字段名2 数据类型 [完整性约束条件…], [UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY [索引名] (字段名[(长度)] [ASC |DESC]) ); #方法二：CREATE在已存在的表上创建索引 CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 ON 表名 (字段名[(长度)] [ASC |DESC]) ; #方法三：ALTER TABLE在已存在的表上创建索引 ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 (字段名[(长度)] [ASC |DESC]) ; #删除索引：DROP INDEX 索引名 ON 表名字; #删除主键索引: ALTER TABLE 表名 DROP PRIMARY KEY; #显示索引信息: SHOW INDEX FROM student; */ /*增加全文索引*/ ALTER TABLE `school`.`student` ADD FULLTEXT INDEX `studentname` (`StudentName`); /*EXPLAIN : 分析SQL语句执行性能*/ EXPLAIN SELECT * FROM student WHERE studentno='1000'; /*使用全文索引*/ -- 全文搜索通过 MATCH() 函数完成。 -- 搜索字符串作为 against() 的参数被给定。搜索以忽略字母大小写的方式执行。对于表中的每个记录行，MATCH() 返回一个相关性值。即，在搜索字符串与记录行在 MATCH() 列表中指定的列的文本之间的相似性尺度。 EXPLAIN SELECT *FROM student WHERE MATCH(studentname) AGAINST('love'); /* 开始之前，先说一下全文索引的版本、存储引擎、数据类型的支持情况 MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引； MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引; 只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。 测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。 */ 拓展：测试索引建表app_user： CREATE TABLE `app_user` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) DEFAULT '' COMMENT '用户昵称', `email` varchar(50) NOT NULL COMMENT '用户邮箱', `phone` varchar(20) DEFAULT '' COMMENT '手机号', `gender` tinyint(4) unsigned DEFAULT '0' COMMENT '性别（0:男；1：女）', `password` varchar(100) NOT NULL COMMENT '密码', `age` tinyint(4) DEFAULT '0' COMMENT '年龄', `create_time` datetime DEFAULT CURRENT_TIMESTAMP, -- 数据插入时更新值 `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- 数据插入和更新时，更新值 PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='app用户表' 批量插入数据：100w DROP FUNCTION IF EXISTS mock_data; DELIMITER $$ -- 要写函数必须写，设置成以 $$ 为语句结束符 CREATE FUNCTION mock_data() RETURNS INT BEGIN DECLARE num INT DEFAULT 1000000; DECLARE i INT DEFAULT 0; WHILE i &lt; num DO INSERT INTO app_user(`name`, `email`, `phone`, `gender`, `password`, `age`) VALUES(CONCAT('用户', i), '24736743@qq.com', CONCAT('18', FLOOR(RAND()*(999999999-100000000)+100000000)),FLOOR(RAND()*2),UUID(), FLOOR(RAND()*100)); SET i = i + 1; END WHILE; RETURN i; END $$; SELECT mock_data(); -- 执行函数 不能写自定义函数，被限制了，因为我们开启了 bin-log 二进制日志, 我们就必须为我们的function指定一个参数，而我们没有。 这时执行语句 ==set global log_bin_trust_function_creators=TRUE;==就行。 索引效率测试 无索引 SELECT * FROM app_user WHERE name = '用户9999'; -- 查看耗时 SELECT * FROM app_user WHERE name = '用户9999'; SELECT * FROM app_user WHERE name = '用户9999'; mysql&gt; EXPLAIN SELECT * FROM app_user WHERE name = '用户9999'\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: app_user partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 992759 filtered: 10.00 Extra: Using where 1 row in set, 1 warning (0.00 sec) 创建索引 CREATE INDEX idx_app_user_name ON app_user(name); 测试普通索引 mysql&gt; EXPLAIN SELECT * FROM app_user WHERE name = '用户9999'\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: app_user partitions: NULL type: ref possible_keys: idx_app_user_name key: idx_app_user_name key_len: 203 ref: const rows: 1 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) mysql&gt; SELECT * FROM app_user WHERE name = '用户9999'; 1 row in set (0.00 sec) mysql&gt; SELECT * FROM app_user WHERE name = '用户9999'; 1 row in set (0.00 sec) mysql&gt; SELECT * FROM app_user WHERE name = '用户9999'; 1 row in set (0.00 sec) 复合索引（联合索引） 复合索引 索引可以覆盖多个数据列，如像INDEX（columnA，columnB）索引。这种索引的特点是 MySQL可以有选择地使用一个这样的索引。如果查询操作只需要用到 columnA 数据列上的一个索引，就可以使用复合索引 INDEX（columnA,columnB）。不过，这种用法仅适用于在复合索引中==排列在前的数据列组合==。比如说，INDEX（A，B，C）可以当做A或（A, B）的索引来使用，但不能当做B、C或（B，C）的索引来使用。（这里的字段组合判断只跟select的 ==where条件、group by 、order by== 字段有关） ==特点== 创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。 复合索引的建立原则 如果您很可能仅对一个列多次执行搜索，则该列应该是复合索引中的第一列。==如果您很可能对一个两列索引中的两个列执行单独的搜索，则应该创建另一个仅包含第二列的索引。==如上图所示，如果查询中需要对年龄和性别做查询，则应当再新建一个包含年龄和性别的复合索引。==包含多个列的主键始终会自动以复合索引的形式创建索引，其列的顺序是它们在表定义中出现的顺序，而不是在主键定义中指定的顺序。==在考虑将来通过主键执行的搜索，确定哪一列应该排在最前面。请注意，创建复合索引应当包含少数几个列，并且这些列经常在select查询里使用。在复合索引里包含太多的列不仅不会给带来太多好处。而且由于使用相当多的内存来存储复合索引的列的值，其后果是内存溢出和性能降低。 查询优化了解 复合索引对排序的优化： 复合索引只对和索引中排序相同或相反的order by 语句优化。在创建复合索引时，每一列都定义了升序或者是降序。如定义一个复合索引： CREATE INDEX idx_example ON table1 (col1 ASC, col2 DESC, col3 ASC) 其中 有三列分别是：col1 升序，col2 降序， col3 升序。现在如果我们执行两个查询 1：Select col1, col2, col3 from table1 order by col1 ASC, col2 DESC, col3 ASC 和索引顺序相同 2：Select col1, col2, col3 from table1 order by col1 DESC, col2 ASC, col3 DESC 和索引顺序相反==查询1，2 都可以被复合索引优化。==如果查询为： Select col1, col2, col3 from table1 order by col1 ASC, col2 ASC, col3 ASC==排序结果和索引完全不同时，此时的查询不会被复合索引优化。== index（a，b，c） select * from myTest where a=3 and b&gt;7 and c=3; -- b范围值，断点，阻塞了c的索引 -- a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引 select * from myTest where a&gt;4 and b=7 and c=9; -- a用到了 b没有使用，c没有使用 覆盖索引在了解覆盖索引之前我们先大概了解一下什么是聚集索引(主键索引)和辅助索引(二级索引) ​ 聚集索引（主键索引）： ​ 聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。 ​ 聚集索引的叶子节点称为数据页，聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。 ​ 辅助索引（二级索引）： ​ 非主键索引，叶子节点=键值+书签。Innodb 存储引擎的书签就是相应行数据的主键索引值。 ​ 再来看看什么是覆盖索引，有下面三种理解：（==覆盖索引中的字段顺序无需与查询 select后的字段和条件的字段顺序一致==） 解释一： 就是select的数据列只用从（==一个或多个==）索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。 解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引==包含==了（==或覆盖==了）满足查询语句中字段与条件的数据就叫做覆盖索引。 解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。 不是所有类型的索引都可以成为覆盖索引。==覆盖索引必须要存储索引的列（因为SQL查询结果和查询条件的都涉及到具体的值，而覆盖索引需要覆盖查询结果和查询条件），而哈希索引、空间索引和全文索引等都不存储索引列的值==，所以==MySQL只能使用B-Tree索引做覆盖索引==，另外，不同的存储引擎实现覆盖索引的方式也不同，而且不是所有的引擎都支持覆盖索引。 覆盖索引：建索引的列和要查询的列相同，例如==索引列是c1，c2，select 查询的也是c1，c2==；定值是常量，范围之后必失效，最终看排序，一般order by 是给个范围；group by 分组，分组之前必排序，顺序不对会有临时表产生； 当发起一个被索引覆盖的查询(也叫作索引覆盖查询)时，在 EXPLAIN 的 Extra 列可以看到“==Using index==”的信息 使用覆盖索引注意事项 1，当只查询表的主键字段时，是索引覆盖查询，如下为索引覆盖查询 SELECT SQL_NO_CACHE id FROM user_group; 2，当where和select查询的列分别创建单独的索引时，不是索引覆盖查询 3，当无where时，select查询的列为主键和另==一个==索引时，是索引覆盖查询 ​ 有where时，则where条件必须是另==一个==非主键索引，才是索引覆盖查询 4，select查询的列为==两个及两个以上==单独加了索引(非主键)的字段时（或包含非索引字段），不是索引覆盖查询 如id为主键，分别为uid和group_id创建索引，如下查询不是索引覆盖查询 SELECT SQL_NO_CACHE uid,group_id FROM user_group; 因为此时不会使用到索引，而是会做全表查询。 5，如果select查询的列只要都同时属于同一个组合索引中的全部或部分列时，都是索引覆盖查询 ​ 带上where条件查询时，如果where后面要是包含除了该联合索引以外的字段（或不符合索引的前缀匹配原则）时，都不是索引覆盖查询（联合索引和主键同时作为查询条件也不行）。 ​ 如果where后面的查询条件都为联合索引中的字段且是符合前缀匹配原则时，是索引覆盖查询，如下是索引覆盖查询： 存在组合索引 group_id_uid( group_id, uid ) SELECT SQL_NO_CACHE id, group_id FROM user_group where uid = 2 and group_id = 123 6, where后面的查询条件包含非索引字段 或 ==两个及两个以上的所属不同索引字段== 时，都不是索引覆盖查询。 如group_id为联合索引的前缀，name为一个单独的索引，则如下不是索引覆盖查询 SELECT SQL_NO_CACHE group_id, name FROM user_group where group_id = 123 and name = \"test\" ; 分别为uid和group_id创建独立索引, 即使只查询其中一个索引字段的值或id的值，也不是索引覆盖查询。 SELECT SQL_NO_CACHE uid FROM user_group where uid = 2 and group_id = 123; 7，where条件中包含like的操作可能也是索引覆盖查询 如果id为主键，name为索引 7.1 执行如下，关键词前缀匹配查询，只范围查询具有对应前缀的数据值 explain SELECT name FROM `user_group` where name like \"test%\"; 总结：覆盖索引的优化及限制 覆盖索引是一种非常强大的工具，能大大提高查询性能，只需要读取索引而不需要读取数据，有以下优点： 1、索引项通常比记录要小，所以MySQL访问更少的数据。 2、索引都按值得大小存储，相对于随机访问记录，需要更少的I/O。 3、数据引擎能更好的缓存索引，比如MyISAM只缓存索引。 4、覆盖索引对InnoDB尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引包含查询所需的数据，就不再需要在聚集索引中查找了。 限制： 1、覆盖索引也并不适用于任意的索引类型，索引必须存储列的值。 2、Hash和full-text索引不存储值，因此MySQL只能使用BTree。 3、不同的存储引擎实现覆盖索引都是不同的，并不是所有的存储引擎都支持覆盖索引。 4、如果要使用覆盖索引，一定要注意SELECT列表值取出需要的列，==不可以SELECT *==，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。 创建索引（索引优化）**Join连接索引分析 **单表分析例：select id from A where c1 = 1 and c2 &gt; 1 order by v1 desc limit 1;建立联合索引（c1,c2,v1），但explain时候发现 type 是range，extra中使用using filesort，这需要优化；产生原因：按照BTree索引工作原理，先排序c1，如果c1相同，排序c2，c2相同再排序v1，当c2字段在联合索引中处于中间位置，因为c2 &gt; 1条件是一个范围值（range），MySQL无法利用索引在对后面的v1部分进行索引。所以建立（c1，v1）或建立（c1，c2）和（v1）解决这个问题。 双表分析==左连接索引加在右表，右连接索引加在左表；==Left Join 条件用于确定如何从右表搜索行，左边数据一定有，所以右边数据一定要建索引。 三表分析建索引和双表的原理相同，依次在连接表上添加索引； 总结尽可能减少 Join 语句的 NestedLoop 的循环总次数，永远用小结果集驱动大的结果集；优先优化 NestedLoop 的内层循环；保证 Join 语句中被驱动表上 On 条件字段已经被索引； 永远小表驱动大表in 和 exists 选择： -- 工作原理，先查B表数据，然后查A的 id select * from A where id in (select id from B) -- 工作原理，先查A表的id，然后查B表的id select * from A a where exists (select 1 from B b where a.id = b.id ) -- 结论：当B表的数据小于A表时候用 in；当A表数据小于B表时候用 exists -- 注意：A 表与 B 表的 id 字段应该有索引 exists select…..from table where exists (subquery ) 该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（true 或者 false）来决定主查询的数据结果是否得以保留。 提示：exists (subquery )只返回 TRUE 或者 FALSE，因此子查询的 select * 可以是 select 1或 select ‘x’ 等任意，官方说法是实际执行时会忽略 select 清单，因此没有区别。 Order By 排序MySQL支持两种排序，index 和 fileSort，index效率高，它指 MySQL扫描索引本身完成排序。Order By 满足两种情况使用 index：1、Order By 语句使用索引最左前列2、使用 ==where子句与Order By子句条件组合==满足索引最左前列 ，==where 的字段和 order by 的字段组合后是索引的最左前缀。==如果不满足上面情况，会产生临时表，fileSort 有两种算法，4.1版本之前==双路排序，进行两次IO（磁盘扫描），把全部数据都存在缓存，包括不查询的数据==；之后==单路排序，进行一次IO，把要查询的数据放在缓存里，如果重新查询的数据不包括在缓存里，则需要重新再次 IO ，这样效率会比之前的双路排序还要低==；==Order By 时不要select *==，只查询所需要的字段；当两种算法的数据超出 sort_buffer 的容量会创建tmp 文件进行合并运算，导致多次 IO，所以需要尝试提高 sort_buffer_size 和max_length_for_sort_ size 来提高 mysql 查询排序效率。 为排序使用索引，MySQL能为排序与查询使用相同的索引 -- 如果 where 使用索引的最左前缀定义为常量，则 order by 能使用索引 index（a，b，c） where a= const order by b,c; where a= const and b&gt; const order by b,c; -- 不能使用索引进行排序 order by a ASC,b DESC,c DESC; -- 排序不一致 where g = const order by b,c; -- 缺失a索引 where a = const order by c; -- 缺失b索引 where a = const order by a，d; -- d不是索引的一部分 where a in（....） order by b，c; -- 对于排序来说，多个相等条件也是范围查询 # group by 跟 order by 差不多 查询优化（索引失效）查询优化器在where查询中的作用： 如果一个多列索引存在于 列 Col1 和 Col2 上，则以下语句：Select * from table where col1 = val1 AND col2 = val2 查询优化器会试图通过决定哪个索引将找到更少的行。之后用得到的索引去取值。1． 如果存在一个多列索引，任何最左面的索引前缀能被优化器使用。所以联合索引的顺序不同，影响索引的选择，==尽量将值少的放在前面==。如：==一个多列索引为 (col1 ，col2， col3) 那么在索引在列 (col1) 、(col1 col2) 、(col1 col2 col3) 的搜索会有作用==。 SELECT * FROM tb WHERE col1 = val1 SELECT * FROM tb WHERE col1 = val1 and col2 = val2 SELECT * FROM tb WHERE col1 = val1 and col2 = val2 AND col3 = val3 ---------------------------------------------------------------------------- SELECT * FROM tb WHERE col3 = val3 and col2 = val2 AND col1 = val1 SELECT * FROM tb WHERE col1 = val1 and col3 = val3 AND col2 = val2 -- 上面这两例也会用到复合索引，因为是定值常量，查询优化器会进行优化排序，一般按索引字段顺序来，防止查询优化器重排出错。如果不是定值常量就会索引失效。 2． 如果列不构成索引的最左面前缀，则建立的索引将不起作用。如： SELECT * FROM tb WHERE col3 = val3 SELECT * FROM tb WHERE col2 = val2 SELECT * FROM tb WHERE col2 = val2 and col3=val3 --------------------------------------------------------------------------------- index（a，b，c） select * from myTest where a=3 and b&gt;7 and c=3; -- b范围值，断点，阻塞了c的索引 -- a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引 select * from myTest where a&gt;4 and b=7 and c=9; -- a用到了 b没有使用，c没有使用 select * from myTest where a=4 and c&gt;7 and b=9; -- a用到了，b也用到了，c也用到，查询优化器会重排 3． 如果一个 Like 语句的查询条件不以通配符起始则使用索引。如：==%车 或 %车% 不使用索引==。 ==车% 使用索引==。索引的缺点： \\1. 占用磁盘空间。 \\2. 增加了插入和删除的操作时间。一个表拥有的索引越多，插入和删除的速度越慢。如 要求快 速录入的系统不宜建过多索引。 如果一定要 like ‘%车%’ 这样查询的话怎么办？因为 like ‘车%’ 可能会没有数据 解决方法：==使用覆盖索引== ，使用 select 的查询 select 字段组成覆盖索引 下面是一些常见的索引限制问题 1、使用不等于操作符(==&lt;&gt;, !=======)下面这种情况，即使在列 dept_id 有一个索引，==查询语句仍然执行一次全表扫描== select * from dept where dept_id &lt;&gt; 1000;但是开发中的确需要这样的查询，难道没有解决问题的办法了吗？有！通过把==用 or 语法替代不等号进行查询，就可以使用索引，以避免全表扫描==：上面的语句改成下面这样的，就可以使用索引了。 ​ select * from dept where dept_id&lt; 1000 ==or== dept_id &gt; 1000; ==如果 or 连接的是两个不同的字段的话就会索引失效，如 where id = 1 or name = ‘xxx’ 。== 2、==使用 is null 或 is not null==使用 is null 或 is nuo null 也会限制索引的使用，因为数据库并没有定义null值。==如果被索引的列中有很多null，就不会使用这个索引==（除非索引是一个位图索引，关于位图索引，会在以后的blog文章里做详细解释）。在sql语句中使用null会造成很多麻烦。解决这个问题的办法就是：==建表时把需要索引的列定义为非空(not null)== 3、==使用函数====如果没有使用基于函数的索引，那么where子句中对存在索引的列使用函数时，会使优化器忽略掉这些索引==。下面的查询就不会使用索引： ​ select * from staff where trunc(birthdate) = ‘01-MAY-82’; 但是==把函数应用在条件上，索引是可以生效的==，把上面的语句改成下面的语句，就可以通过索引进行查找。 ​ select * from staff where birthdate &lt; (to_date(‘01-MAY-82’) + 0.9999); 4、==比较不匹配的数据类型==比较不匹配的数据类型也是难于发现的性能问题之一。下面的例子中，dept_id 是一个 varchar 型的字段，在这个字段上有索引，但是下面的语句会执行全表扫描，==类型输入不匹配==。 ​ select * from dept where dept_id = 900198; 这是因为 oracle 会自动把 where 子句转换成 to_number ( dept_id )=900198，就是3所说的情况，这样就限制了索引的使用。把SQL语句改为如下形式就可以使用索引 ​ select * from dept where dept_id = ‘900198’; 总结： 1、最好全值匹配（按照索引的顺序，查询里的字段是索引顺序的字段，并且全部使用）；2、最左前缀法则：如果索引了多列，查询从索引的最左前列开始，且不能跳过索引中的列；3、不在==索引列==(索引的字段)上做任何操作（计算，函数，（自动或手动）类型转换），会导致索引 时校而转向全表扫描；4、存储引擎不能使用索引中范围条件右边的列，即范围之后全失效（==范围的字段会用到索引==）；5、尽量使用覆盖索引，只访问索引的查询（索引列和查询列一致），减少selec *；6、MySQL在使用不等于（&lt;&gt; 和 !=）的时候无法使用索引会导致全表扫描；7、is null，is not null 也无法使用索引；8、like 以通配符开头（’%aa‘）索引会失效，变成全表扫描，==不以通配符开头就不会失效==； ​ 如果一定要 like ‘%车%’ 这样查询的话怎么办？因为 like ‘车%’ 可能会没有数据 ​ 解决方法：==使用覆盖索引== ，使用 select 的查询 select 字段组成覆盖索引 9、字符串不加单引号，索引失效；10、少用 or，用它来连接时候会索引失效，如 where id = 1 or name = ‘xxx’ 。 易错点index（col1，col2，col3） SELECT * FROM tb WHERE col3 = val3 and col2 = val2 AND col1 = val1 SELECT * FROM tb WHERE col1 = val1 and col3 = val3 AND col2 = val2 -- 上面这两例也会用到复合索引，因为是定值常量，查询优化器会进行优化排序，一般按索引字段顺序来，防止查询优化器重排出错。如果不是定值常量就会索引失效。 index（a，b，c） select * from myTest where a=3 and b&gt;7 and c=3; -- b范围值，断点，阻塞了c的索引 -- a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引 select * from myTest where a&gt;4 and b=7 and c=9; -- a用到了 b没有使用，c没有使用 select * from myTest where a=4 and c&gt;7 and b=9; -- a用到了，b也用到了，c也用到，查询优化器会重排 index（a，b，c，d） select * from myTest where a=4 and b=7 and d=9 order by c; select * from myTest where a=4 and b=7 order by c; -- 上面两个 explain 显示都是用到了a 和 b，但实际上还用到了c，用于排序 select * from myTest where a=4 and b=7 order by d; -- 用到了 a 和 b，mysql自己外部排序(不好) select * from myTest where a=4 and e=7 order by b,c; -- explain 显示只用到了a ，但实际上还用到了b 和 c，用于排序 select * from myTest where a=4 and e=7 order by c,b; -- 只用到了 a，mysql自己外部排序 select * from myTest where a=4 and b=7 and e=7 order by c,b; -- 用到了 a 和 b，b ，c用于排序（这里b是常量，即使用于排序也是无用） -- 相当于 select * from myTest where a=4 and b=7 and e=7 order by c; select * from myTest where a=4 and b=7 order by b,c; select * from myTest where a=4 and b=7 and e=9 order by b,c; -- 用到了 a 和 b，b 和 c用于排序 -- 相当于 select * from myTest where a=4 and b=7 and e=9 order by c; -- group by 和 order by 差不多 -- group by 基本上都要进行排序，会有临时表的产生 select * from myTest where a=4 and d=7 group by b,c; -- 只用到了 a， b 和 c 用于排序 select * from myTest where a=4 and d=7 group by c,b; -- 只用到了 a，产生临时表，mysql自己外部排序（最坏） explain 执行计划 explain 作用 使用 explain 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈。 explain执行计划包含的信息 其中最重要的字段为：==id、type、key、rows、Extra== 各字段详解idselect查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序 三种情况：1、id相同：执行顺序由上至下 2、id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 3、id相同又不同（两种情况同时存在）：id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行 select_type查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询 1、SIMPLE：简单的 select 查询，查询中不包含子查询或者 union2、PRIMARY：查询中包含任何复杂的子部分，最外层查询则被标记为 primary3、SUBQUERY：在select 或 where 列表中包含了子查询4、DERIVED：在 from 列表中包含的子查询被标记为 derived（衍生），mysql 或递归执行这些子查询，把结果放在临时表里5、UNION：若第二个 select 出现在 union 之后，则被标记为 union；若 union 包含在 from 子句的子查询中，外层 select 将被标记为 derived6、UNION RESULT：从 union 表获取结果的 select type访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是： system &gt; const **&gt; **eq_ref **&gt; **ref **&gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; **range &gt; index &gt; ALL 一般来说，好的sql查询至少达到range级别，最好能达到ref 1、system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计 2、const：表示通过索引一次就找到了，const用于比较primary key 或者 unique 索引。因为只需匹配一行数据，所以很快。如果将主键置于 where 列表中，mysql 就能将该查询转换为一个const 3、eq_ref：唯一性索引扫描，对于每个索引键，表中==只有一条记录==与之匹配。常见于主键 或 唯一索引扫描。 注意：ALL全表扫描的表记录最少的表如 t1表 4、ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他==可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体== 5、range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、&lt;、&gt;、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引 6、index：Full Index Scan，index与ALL区别为 index 类型==只遍历索引树==。这通常比 ALL快，因为索引文件通常比数据文件小。（Index 与 ALL 虽然都是读全表，但 index 是从索引中读取，而 ALL 是从硬盘读取） 7、ALL：Full Table Scan，遍历全表以找到匹配的行 possible_keys查询涉及到的字段上存在索引，则该索引将被列出，但==不一定被查询实际使用== key==实际使用的索引==，如果为NULL，则没有使用索引。查询中如果使用了==覆盖索引，则该索引仅出现在key列表中== key_len表示索引中使用的字节数，查询中使用的索引的长度（最大可能长度），==并非实际使用长度==，理论上长度越短越好。==key_len是根据表定义计算而得的，不是通过表内检索出的== ref显示索引的哪一列被使用了，如果可能，==可能是一个常量const==。 rows根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数 Extra不适合在其他字段中显示，但是十分重要的额外信息 1、Using filesort （九死一生）：mysql 对数据使用一个外部的索引==排序==，而不是按照表内的索引进行排序读取。也就是说 mysql 无法利用索引完成的排序操作成为“文件排序” 由于索引是先 email 排序、再按 address 排序，所以查询时如果直接按 address 排序，索引就不能满足要求了，mysql 内部必须再实现一次“文件排序”（虽然有覆盖索引，但没有实现复合索引） 2、Using temporary（十死无生）：使用临时表保存中间结果，也就是说mysql在对查询结果排序时使用了临时表，常见于order by 和 group by 3、Using index（好的）：表示相应的 select 操作中使用了覆盖索引（Covering Index），避免了访问表的数据行，效率高如果同时出现Using where，表明索引被用来执行索引键值的查找（参考上图）如果没用同时出现Using where，表明索引用来读取数据而非执行查找动作 覆盖索引（Covering Index）：也叫索引覆盖。就是select列表中的字段，只用从索引中就能获取，不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。注意：a、==如需使用覆盖索引，select列表中的字段只取出需要的列，不要使用select *==b、如果将所有字段都建索引会导致索引文件过大，反而降低crud性能 4、Using where ：使用了where过滤 5、Using join buffer ：使用了链接缓存 6、Impossible WHERE：where子句的值总是false，不能用来获取任何元组 7、select tables optimized away：在没有group by子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化COUNT（*）操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即可完成优化 8、distinct：优化distinct操作，在找到第一个匹配的元组后即停止找同样值得动作 综合Case 执行顺序1（id = 4）、【select id, name from t2】：select_type 为union，说明id=4的select是union里面的第二个select。 2（id = 3）、【select id, name from t1 where address = ‘11’】：因为是在from语句中包含的子查询所以被标记为DERIVED（衍生），where address = ‘11’ 通过复合索引idx_name_email_address的==索引覆盖==就能检索到，所以type为index。 3（id = 2）、【select id from t3】：因为是在select中包含的子查询所以被标记为SUBQUERY。 4（id = 1）、【select d1.name, … d2 from … d1】：select_type为PRIMARY表示该查询为最外层查询，table列被标记为 “derived3”表示查询结果来自于一个衍生表（id = 3 的select结果）。 5（id = NULL）、【 … union … 】：代表从union的临时表中读取行的阶段，table列的 ==“union 1, 4”表示用id=1 和 id=4 的select结果进行union操作。== 查询截取分析1、观察，查看慢SQL情况；2、开启查询日志，设置阀值，规定多少秒为慢SQL；3、explain 分析；4、show profile 查看执行细节和生命周期情况5、dba 进行参数调优 慢查询日志响应时间超过long_query_tine的SQL，被记录到慢查询日志中。 SHOW VARIABLES LIKE '%slow_query_log%' ; -- 查看是否开启，默认没开启 set global slow_quary_log = 1; -- 开启，仅本数据库有效，重启MySQL之后失效。 show variables like '%long_query_time%'; -- 查看当前多少秒算慢 set global long_query_time = 3; -- 设置慢的阙值时间，得重新开会话或重新连接才会看到值改变 show global status like '%Slow_queries%'; -- 查看当前数据库有多少条慢SQL Show Profile是MySQL提供可以用来分析当前会话中语句执行的资源情况，可以用于SQL的调优的测量。默认关闭，并保存最近15次结果； set profiling = on ; -- 开启 show profiles; -- 查看执行过的sql SHOW PROFILE cpu,block io FOR QUERY 87; -- 查看编号为87的执行sql（根据 show profiles 获得的表查看编号）的生命周期相关信息。 在生命周期相关信息表里面出现下面信息是不行的： converting HEAP to MyISAM ： 查询结果太大，内存不够用了往磁盘上搬； Creating tmp table ： 创建临时表，拷贝数据到临时表，用完再删除； Copying to tmp table on disk ： 把内存中临时表复制到磁盘，危险！ locked 全局查询日志==严禁在生产环境中开启这个功能。== set global general_log = 1; set global log_output = 'TABLE'; -- 此后，你所有编写的sql语句都会记录到mysql库中的general_log表； MySQL锁机制分类可以分为读锁（共享锁）和写锁（排它锁）；表锁和行锁； 表锁：==偏向 MyISAM== 存储引擎，开销小，加锁快，并发度低；加锁：lock table tablename read，tablename2 write；解锁：unlock tables;查看哪些表被锁了 show open tables; 加读锁 加写锁 ==MyISAM 在执行查询语句前，会自动给涉及的所有表加读锁，在执行增删改前，会自动给涉及的表加写锁==。1、对 MyISAM 表的操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求，只有当读锁释放后，才会执行其他进程的写操作。2、对MyISAM表的操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。 分析表锁定show status likes ‘table%’; 显示一个分析表 参数： Table_locks_immediate：产生表级锁定的次数；Table_locks_waited：出现表级锁定争用而发生等待的次数，不能立即获取锁的次数，每等待一次锁值加1；MyISAM 的读写锁调度是写优先，所以不适合做写为主的表的引擎。 行锁：==偏向InnoDB==存储引擎，开销大，会出现死锁，锁的粒度最小，发生锁冲突的概率最低，并发度高。 InnoDB与MyISAM最大不同是InnoDB支持事务，并且采用行级锁； 当我们使用范围条件而不是相等条件检索数据，并请求共享排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；==对于键值在条件范围内但不存在的记录，叫做间隙；InnoDB也会对这个间隙加锁，锁叫做间隙锁。==如 where a&gt;7 and a&lt;11,如果表没有 a = 10 的数据，a =10这个位置也会被锁上，其他会话不能进行操作。 用户管理 基本命令 /* 用户和权限管理 */ ------------------ 用户信息表：mysql.user -- 刷新权限 FLUSH PRIVILEGES -- 增加用户 CREATE USER kuangshen IDENTIFIED BY '123456' CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) -- 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 -- 只能创建用户，不能赋予权限。 -- 用户名，注意引号：如 'user_name'@'192.168.1.1'或者'user_name'@'localhost' -- 密码也需引号，纯数字密码也要加引号 -- 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD -- 重命名用户 RENAME USER kuangshen TO kuangshen2 RENAME USER old_user TO new_user -- 设置密码 SET PASSWORD = PASSWORD('密码') -- 为当前用户设置密码 SET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码 -- 8.0版本以上不支持上面命令，得下面命令 USE MYSQL; ALTER USER 'root'@'localhost' IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY '123456'; FLUSH PRIVILEGES; -- 删除用户 DROP USER kuangshen2 DROP USER 用户名 -- 分配权限/添加用户 GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password'] - all privileges 表示所有权限，但不包含授权给他人权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 -- 查看权限 SHOW GRANTS FOR root@localhost; SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER(); -- 撤消权限 REVOKE 权限列表 ON 表名 FROM 用户名 REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限 ==mysql 5.7.9以后废弃了password字段和password()函数；authentication_string:字段表示用户密码。== 权限解释 -- 权限列表 ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限 ALTER -- 允许使用ALTER TABLE ALTER ROUTINE -- 更改或取消已存储的子程序 CREATE -- 允许使用CREATE TABLE CREATE ROUTINE -- 创建已存储的子程序 CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLE CREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。 CREATE VIEW -- 允许使用CREATE VIEW DELETE -- 允许使用DELETE DROP -- 允许使用DROP TABLE EXECUTE -- 允许用户运行已存储的子程序 FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE INDEX -- 允许使用CREATE INDEX和DROP INDEX INSERT -- 允许使用INSERT LOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLES PROCESS -- 允许使用SHOW FULL PROCESSLIST REFERENCES -- 未被实施 RELOAD -- 允许使用FLUSH REPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址 REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件） SELECT -- 允许使用SELECT SHOW DATABASES -- 显示所有数据库 SHOW VIEW -- 允许使用SHOW CREATE VIEW SHUTDOWN -- 允许使用mysqladmin shutdown SUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。 UPDATE -- 允许使用UPDATE USAGE -- “无权限”的同义词 GRANT OPTION -- 允许授予权限 /* 表维护 */ -- 分析和存储表的关键字分布 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ... -- 检查一个或多个表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED} -- 整理数据文件的碎片 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... MySQL备份数据库备份必要性 保证重要数据不丢失 数据转移 MySQL数据库备份方法 mysqldump备份工具 数据库管理工具,如SQLyog 直接拷贝数据库文件和相关配置文件 mysqldump客户端 作用 : 转储数据库 搜集数据库进行备份 将数据转移到另一个SQL服务器,不一定是MySQL服务器 -- 导出 1. 导出一张表 -- mysqldump [-h主机名] -uroot -p123456 school student &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql) 2. 导出多张表 -- mysqldump [-h主机名] -uroot -p123456 school student result &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql) 3. 导出所有表 -- mysqldump [-h主机名] -uroot -p123456 school &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql) 4. 导出一个库 -- mysqldump [-h主机名] -uroot -p123456 -B school &gt;D:/a.sql mysqldump -u用户名 -p密码 -B 库名 &gt; 文件名(D:/a.sql) 可以-w携带备份条件 -- 导入 1. 在登录mysql的情况下：-- source D:/a.sql source 备份文件 -- 导入表的话需要指定导入的数据库，先 use 数据库。 2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 规范化数据库设计为什么需要数据库设计当数据库比较复杂时我们需要设计数据库 糟糕的数据库设计 : 数据冗余,存储空间浪费 数据更新和插入的异常 程序性能差 良好的数据库设计 : 节省数据的存储空间 能够保证数据的完整性 方便进行数据库应用系统的开发 软件项目开发周期中数据库设计 : 需求分析阶段: 分析客户的业务和数据处理需求 概要设计阶段:设计数据库的E-R模型图 , 确认需求信息的正确和完整. 设计数据库步骤 收集信息 与该系统有关人员进行交流 , 座谈 , 充分了解用户需求 , 理解数据库需要完成的任务. 标识实体[Entity] 标识数据库要管理的关键对象或实体,实体一般是名词 标识每个实体需要存储的详细信息[Attribute] 标识实体之间的关系[Relationship] 三大范式问题 : 为什么需要数据规范化? 不合规范的表设计会导致的问题： 信息重复 更新异常 插入异常 无法正确表示信息 删除异常 丢失有效信息 三大范式 第一范式 (1st NF) 第一范式的目标是确保每列的原子性,如果每列都是不可再分的最小数据单元,则满足第一范式 第二范式(2nd NF) 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。 第二范式要求每个表只描述一件事情 第三范式(3rd NF) 如果一个关系满足第二范式,并且除了主键以外的其他列都不传递依赖于主键列,则满足第三范式. 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 规范化和性能的关系 关联查询的表不得超过三张表 为满足某种商业目标 , 数据库性能比规范化数据库更重要 在数据规范化的同时 , 要综合考虑数据库的性能 通过在给定的表中添加额外的字段,以大量减少需要从中搜索信息所需的时间（从多表查询变为单表查询） 通过在给定的表中插入计算列,以方便查询通过在给定的表中插入计算列,以方便查询（从大数据量降低为小数据量的查询：索引） JDBC数据库驱动 应用程序通过数据库驱动，和数据库打交道，开发人员通过调用数据库驱动JDBC接口进行数据库和应用程序连接。 Sun公司为了简化开发人员的（对数据库的统一）操作，提供了一个规范（java操作数据库的规范），俗称 JDBC。这些规范的实现由具体的厂商去做，对于开发人员来说，我们只需要掌握接口的实现即可。 JDBC程序步骤： 1、加载驱动，通过 Class.forname（）加载 2、获取数据库连接对象 Connection ，通过 DriverManager 的 getConnection 方法获取 3、获得执行SQL的对象 Statement，通过连接对象 Connection 的createStatement 获取 4、获得返回的结果集 Resultset，通过 Statement 对象 executeQuery 或 executeUpdate 返回获得 5、关闭所有连接对象，Resultset、Statement、Connection 的关闭。 URL String url = \"jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=gbk&amp;useSSL=true\" ; //\"jdbc:oracle:thin:@localhost:1521:表名\" Oracle 默认端口是1521 Statement对象的一些常用方法 execute() ，返回的结果boolean，boolean表示是否有结果集返回（除select外为false），有为true，其他情况都为false executeUpdate() ，返回的结果int，int表是对数据库影响的行计数 executeQuery()， 返回的结果resultSet，一般情况存放的是select查询的结果集 PreparedStatement对象Statemetent 对象执行的是静态SQL语句，而 PreparedStatement 对象执行的是预编译SQL语句，Statement 对象执行 executeUpdate ( String sql ) 和 executeQuery ( String sql )，而PreparedStatement 对象执行的是无参的 executeUpdate ( )和 executeQuery ( )，从这两个方法可以看出这两个对象的特点，正因为如此，==PreparedStatement 可以预防SQL语句注入，更安全，当然它的效率也更高一些==。 SQL注入 SQL注入攻击指的是通过构建特殊的输入作为参数传入 Web 应用程序，而这些输入大都是 SQL 语法里的一些组合，通过执行 SQL语句 进而执行攻击者所要的操作，其主要原因是==程序没有细致地过滤用户输入的数据==，致使非法数据侵入系统。 根据相关技术原理，SQL注入可以分为==平台层注入==和==代码层注入==。==前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询==。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。 PreparedStatement 防止 SQL 注入的原理 PreparedStatement 把传递过来的参数当做字符，假设其中存在转义字符，比如说 ` 会被直接转义 示例 //STEP 1. Import required packages import java.sql.*; public class JDBCExample { // JDBC driver name and database URL static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost/Test?serverTimezone=UTC\"; // Database credentials static final String USER = \"root\"; static final String PASS = \"root\"; public static void main(String[] args) { Connection conn = null; PreparedStatement stmt = null; try { // STEP 2: Register JDBC driver Class.forName(\"com.mysql.jdbc.Driver\"); // STEP 3: Open a connection System.out.println(\"Connecting to database...\"); conn = DriverManager.getConnection(DB_URL, USER, PASS); // STEP 4: Execute a query System.out.println(\"Creating statement...\"); String sql = \"UPDATE Employees set age=? WHERE id=?\"; stmt = conn.prepareStatement(sql); // Bind values into the parameters. stmt.setInt(1, 35); // 设置参数 stmt.setInt(2, 102); //设置参数 // Let us update age of the record with ID = 102; int rows = stmt.executeUpdate(); System.out.println(\"Rows impacted : \" + rows); // Let us select all the records and display them. sql = \"SELECT id, first, last, age FROM Employees\"; ResultSet rs = stmt.executeQuery(sql); // STEP 5: Extract data from result set while (rs.next()) { // Retrieve by column name int id = rs.getInt(\"id\"); int age = rs.getInt(\"age\"); String first = rs.getString(\"first\"); String last = rs.getString(\"last\"); // Display values System.out.print(\"ID: \" + id); System.out.print(\", Age: \" + age); System.out.print(\", First: \" + first); System.out.println(\", Last: \" + last); } // STEP 6: Clean-up environment rs.close(); stmt.close(); conn.close(); } catch (SQLException se) { // Handle errors for JDBC se.printStackTrace(); } catch (Exception e) { // Handle errors for Class.forName e.printStackTrace(); } finally { // finally block used to close resources try { if (stmt != null) stmt.close(); } catch (SQLException se2) { } // nothing we can do try { if (conn != null) conn.close(); } catch (SQLException se) { se.printStackTrace(); } // end finally try } // end try System.out.println(\"Goodbye!\"); }// end main }// end JDBCExample 在java业务中实现事务package JDBC; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.SQLException; public class test { public static void main(String[] args) throws ClassNotFoundException { Class.forName(\"com.mysql.cj.jdbc.Driver\"); String url = \"jdbc:mysql://localhost:3306/account?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=UTC\"; String user = \"root\"; String password = \"admin\"; Connection connection = null; PreparedStatement preparedStatement = null; try { connection = DriverManager.getConnection(url, user, password); //关闭自动提交，就会自动开启事务，开启事务前必须先关闭自动提交 connection.setAutoCommit(false); String sql1 = \"update shop set money = money - 200 where name = '张三'\"; String sql2 = \"update shop set money = money + 200 where name = '李四'\"; preparedStatement = connection.prepareStatement(sql1); preparedStatement.executeUpdate(); preparedStatement = connection.prepareStatement(sql2); preparedStatement.executeUpdate(); connection.commit(); System.out.println(\"成功\"); } catch (Exception e) { //有异常默认会回滚事务 // connection.rollback(); e.printStackTrace(); }finally { if (preparedStatement != null) { try { preparedStatement.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } if (connection != null) { try { connection.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } } } } 1、开启事务 ==connection.setAutoCommit(false);== 2、一组业务执行完毕，提交事务 connection.commit(); 3、可以在 catch 中显示定义回滚语句 connection.rollback();，但是默认失败就会回滚 课外了解资料MySQL索引实现在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。 MyISAM索引实现MyISAM 引擎使用B+Tree作为索引结构，叶节点的==data域存放的是数据记录的地址==。下图是MyISAM 索引的原理图： ​ 图8 这里设表一共有三列，假设我们以Col1为主键，则图8是一个 MyISAM 表的主索引（Primary key）示意。可以看出 ==MyISAM 的索引文件仅仅保存数据记录的地址==。在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示： ​ 图9 同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照B+Tree搜索算法搜索索引，==如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。== ==MyISAM 的索引方式也叫做“非聚集”的==，之所以这么称呼是为了与 InnoDB 的聚集索引区分。 InnoDB索引实现虽然 InnoDB 也使用B+Tree作为索引结构，但具体实现方式却与 MyISAM 截然不同。 第一个重大区别是 ==InnoDB 的数据文件本身就是索引文件==。从上文知道，==MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址==。而在 InnoDB 中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点==data域保存了完整的数据记录==。这个索引的key是数据表的主键，因此 ==InnoDB 表数据文件本身就是主索引==。 ​ 图10 图10是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到==叶节点包含了完整的数据记录。这种索引叫做聚集索引==。因为 InnoDB 的数据文件本身要按主键聚集，所以 ==InnoDB 要求表必须有主键（MyISAM可以没有）==，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。 第二个==与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址==。换句话说，InnoDB 的所有辅助索引都==引用主键作为data域==。例如，图11为定义在Col3上的一个辅助索引： ​ 图11 这里以英文字符的 ASCII 码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是==辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。== 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了 InnoDB 的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，==因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大==。再例如，用非单调的字段作为主键在 InnoDB 中不是个好主意，因为 InnoDB 数据文件本身是一颗B+Tree，==非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效==，而使用自增字段作为主键则是一个很好的选择。 前缀索引（特殊建立索引）所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值： Index Selectivity = Cardinality / #T 显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。 如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建或&lt;first_name, last_name&gt;，看下两个索引的选择性： SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees; +-------------+ | Selectivity | +-------------+ | 0.0042 | +-------------+ SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees; +-------------+ | Selectivity | +-------------+ | 0.9313 | +-------------+ 显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性： SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees; +-------------+ | Selectivity | +-------------+ | 0.7879 | +-------------+ 选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4： SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees; +-------------+ | Selectivity | +-------------+ | 0.9007 | +-------------+ 这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上： ALTER TABLE employees.employeesADD INDEX `first_name_last_name4` (first_name, last_name(4)); 此时再执行一遍按名字查询，比较分析一下与建索引前的结果： SHOW PROFILES; +----------+------------+---------------------------------------------------------| Query_ID | Duration | Query | +----------+------------+---------------------------------------------------------| 87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido' | | 90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name='Eric' AND last_name='Anido' | +----------+------------+--------------------------------------------------------- 性能的提升是显著的，查询速度提高了120多倍。 ==前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index 覆盖索引（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）==。 InnoDB的主键选择与插入优化==在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。== 经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。 上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。 如果==表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页==。如下图所示： ​ 图13 这样就会形成一个紧凑的索引结构，近似顺序填满。由于==每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上==。 如果==使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置==： ​ 图14 此时==MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构==，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。 因此，只要可以，==请尽量在InnoDB上采用自增字段做主键==。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Spring MVC","slug":"Spring MVC笔记","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:30:33.423Z","comments":true,"path":"posts/ea4e933k.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e933k.html","excerpt":"","text":"Spring MVCSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。Spring MVC 是目前主流的实现 MVC 设计模式的企业级开发框架，Spring 框架的一个子模块，无需整合，开发起来更加便捷。 WEB-INF 下的资源用户不能直接访问，只能通过 servlet 和 controller 访问。 什么是 MVC 设计模式？将应用程序分为 Controller、Model、View 三层，Controller 接收客户端请求，调用 Model 生成业务数据，传递给 View。 MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 回顾Servlet 新建一个Maven工程当做父工程！pom依赖！ &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！ 导入servlet 和 jsp 的 jar 依赖 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; 编写一个Servlet类，用来处理用户的请求 package com.kuang.servlet; //实现Servlet接口 public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throwsServletException, IOException { //取得参数 String method = req.getParameter(\"method\"); if (method.equals(\"add\")){ req.getSession().setAttribute(\"msg\",\"执行了add方法\"); } if (method.equals(\"delete\")){ req.getSession().setAttribute(\"msg\",\"执行了delete方法\"); } //业务逻辑 //视图跳转 req.getRequestDispatcher(\"/WEB-INF/jsp/hello.jsp\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throwsServletException, IOException { doGet(req,resp); } } 编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 在web.xml中注册Servlet &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- 路径拦截映射，/user 路径由该 HelloServlet 处理 --&gt; &lt;url-pattern&gt;/user&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 会话超时设置 --&gt; &lt;session-config&gt; &lt;session-timeout&gt;&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!-- 默认启动页面 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 配置Tomcat，并启动测试 localhost:8080/user?method=add localhost:8080/user?method=delete MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： ​ 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. Hello，SpringMVC 第一个 SpringMVC 程序 配置版1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ 2、确定导入了SpringMVC 的依赖！ 3、配置web.xml ， 注册DispatcherServlet &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; 5、添加 处理映射器 &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; 6、添加 处理器适配器 &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; 7、添加 视图解析器 &lt;!--视图解析器:DispatcherServlet给他的ModelAndView 1、获取ModelAndView的数据 2、解析ModelAndView的视图名字 3、拼接视图名字，找到对应的视图 /WEB-INF/jsp/xx.jsp--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; 8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； package com.kuang.controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; //注意：这里我们先导入Controller接口 public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(\"msg\",\"HelloSpringMVC!\"); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); //: /WEB-INF/jsp/hello.jsp return mv; } } 9、将自己的类交给SpringIOC容器，注册bean &lt;!--Handler，这里加“/”是因为用的处理映射器是--&gt; &lt;bean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/&gt; 10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 11、配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布 Artifacts 中，在 WEB-INF 文件夹下添加lib 文件夹，然后添加 lib 依赖！ 重启Tomcat 即可解决！ 小结：看这个估计大部分同学都能理解其中的原理了，但是我们实际开发才不会这么写，不然就疯了，还学这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。 注解版1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 2、由于Maven可能存在资源过滤的问题，我们将配置完善 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 4、配置web.xml 注意点： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求，即.jsp 不会进入spring的 DispatcherServlet类 ,直接就进入jsp页面。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现视图解析器返回 jsp视图时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 5、添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!--视图解析器:DispatcherServlet给他的ModelAndView 1、获取ModelAndView的数据 2、解析ModelAndView的视图名字 3、拼接视图名字，找到对应的视图 /WEB-INF/jsp/xx.jsp--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 让IOC的注解生效 静态资源过滤 ：HTML 、 JS 、 CSS 、 图片 、 视频 ….. MVC的注解驱动 配置视图解析器 6、创建Controller 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/HelloController\") public class HelloController { //真实访问地址 : 项目名/HelloController/hello @RequestMapping(\"/hello\") public String sayHello(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值 //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(\"msg\",\"hello,SpringMVC\"); //web-inf/jsp/hello.jsp return \"hello\"; } } @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射URL请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 7、创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;SpringMVC&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 8、配置Tomcat运行 配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！ OK，运行成功！ 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置 Spring MVC 的核心组件 DispatcherServlet：前置控制器，是整个流程控制的核心，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。 Handler：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。 HandlerMapping：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。 HandlerInterceptor：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。 HandlerExecutionChain：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。 HandlerAdapter：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。 ModelAndView：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。 ViewResolver：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。 中心控制器 DispatcherServlet​ Spring 的web框架围绕 DispatcherServlet 设计。DispatcherServlet 的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的 @controller 声明方式。 ​ Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。 SpringMVC的原理如下图所示： ​ 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 Spring MVC 的工作流程 客户端请求被 DisptacherServlet 接收。 根据 HandlerMapping 映射到 Handler。 生成 Handler 和 HandlerInterceptor。 Handler 和 HandlerInterceptor 以 HandlerExecutionChain 的形式一并返回给 DisptacherServlet。 DispatcherServlet 通过 HandlerAdapter 调用 Handler 的方法完成业务逻辑处理。 Handler 返回一个 ModelAndView 给 DispatcherServlet。 DispatcherServlet 将获取的 ModelAndView 对象传给 ViewResolver 视图解析器，将逻辑视图解析为物理视图 View。 ViewResovler 返回一个 View 给 DispatcherServlet。 DispatcherServlet 根据 View 进行视图渲染（将模型数据 Model 填充到视图 View 中）。 DispatcherServlet 将渲染后的结果响应给客户端。 Spring MVC 流程非常复杂，实际开发中很简单，因为大部分的组件不需要开发者创建、管理，只需要通过配置文件的方式完成配置即可，真正需要开发者进行处理的只有 Handler 、View。 控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； //实现该接口的类获得控制器功能 public interface Controller { //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponsevar2) throws Exception; } 测试 新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 //定义控制器 //注意点：不要导错包，实现Controller接口，重写方法； public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"Test1Controller\"); mv.setViewName(\"test\"); return mv; } } 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 &lt;bean name=\"/t1\" class=\"com.kuang.controller.ControllerTest1\"/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; 增加一个ControllerTest2类，使用注解实现； //@Controller注解的类会自动添加到Spring上下文中 @Controller public class ControllerTest2{ //映射访问路径 @RequestMapping(\"/t2\") public String index(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"ControllerTest2\"); //返回视图位置 return \"test\"; } } 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！ @RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 @Controller public class TestController { @RequestMapping(\"/h1\") public String test(){ return \"test\"; } } 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 @Controller @RequestMapping(\"/admin\") public class TestController { @RequestMapping(\"/h1\") public String test(){ return \"test\"; } } 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 我们来测试一下： 增加一个方法 //映射访问路径,必须是POST请求 @RequestMapping(value = \"/hello\",method = {RequestMethod.POST}) public String index2(Model model){ model.addAttribute(\"msg\", \"hello!\"); return \"test\"; } 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； //映射访问路径,必须是Get请求 @RequestMapping(value = \"/hello\",method = {RequestMethod.GET}) public String index2(Model model){ model.addAttribute(\"msg\", \"hello!\"); return \"test\"; } 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 使用params：指定请求中必须包含某些参数，否则无法调用该方法。 @RequestMapping(value = \"/index\",method = RequestMethod.GET,params = {\"name\",\"id=10\"}) public String index(){ System.out.println(\"执行了index...\"); return \"index\"; } 上述代码表示请求中必须包含 name 和 id 两个参数，同时 id 的值必须是 10。 关于参数绑定，在形参列表中通过添加 @RequestParam 注解完成 HTTP 请求参数与业务方法形参的映射。 @RequestMapping(value = \"/index\",method = RequestMethod.GET,params = {\"name\",\"id=10\"}) public String index(@RequestParam(\"name\") String str,@RequestParam(\"id\") int age){ System.out.println(str); System.out.println(age); System.out.println(\"执行了index...\"); return \"index\"; } 上述代码表示将请求的参数 name 和 id 分别赋给了形参 str 和 age ，同时自动完成了数据类型转换，将 “10” 转为了 int 类型的 10，再赋给 age，这些工作都是由 HandlerAdapter 来完成的。 RestFul 风格概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 REST：Representational State Transfer，资源表现层状态转换，是目前比较主流的一种互联网软件架构，它结构清晰、标准规范、易于理解、便于扩展。 资源（Resource） 网络上的一个实体，或者说网络中存在的一个具体信息，一段文本、一张图片、一首歌曲、一段视频等等，总之就是一个具体的存在。可以用一个 URI（统一资源标识符）指向它，每个资源都有对应的一个特定的 URI，要获取该资源时，只需要访问对应的 URI 即可。 表现层（Representation） 资源具体呈现出来的形式，比如文本可以用 txt 格式表示，也可以用 HTML、XML、JSON等格式来表示。 状态转换（State Transfer） 客户端如果希望操作服务器中的某个资源，就需要通过某种方式让服务端发生状态转换，而这种转换是建立在表现层之上的，所以叫做”表现层状态转换”。 特点 URL 更加简洁。 有利于不同系统之间的资源共享，只需要遵守一定的规范，不需要进行其他配置即可实现资源共享。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get ​ http://127.0.0.1/item/queryItem.action?id=1 查询,GET ​ http://127.0.0.1/item/saveItem.action 新增,POST ​ http://127.0.0.1/item/updateItem.action 更新,POST ​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ ​ http://127.0.0.1/item/1 查询,GET ​ http://127.0.0.1/item 新增,POST ​ http://127.0.0.1/item 更新,PUT（根据请求方法类型来与上面区别） ​ http://127.0.0.1/item/1 删除,DELETE 学习测试 在新建一个类 RestFulController @Controller public class RestFulController { } 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 @Controller public class RestFulController { //映射访问路径 @RequestMapping(\"/commit/{p1}/{p2}\") public String index(@PathVariable int p1, @PathVariable int p2, Model model){ int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; } } 我们来测试请求查看下 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 ![img](https://gitee.com/xudongyin/img/raw/master/img/20200719181343) 我们来修改下对应的参数类型，再次测试 //映射访问路径 @RequestMapping(\"/commit/{p1}/{p2}\") public String index(@PathVariable int p1, @PathVariable String p2, Model model){ String result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; } 结果跳转方式ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; 对应的controller类 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; } } ServletAPI通过设置ServletAPI , 不需要视图解析器 . 1、通过HttpServletResponse进行输出 2、通过HttpServletResponse实现重定向 3、通过HttpServletResponse实现转发 @Controller public class ResultGo { @RequestMapping(\"/result/t1\") public void test1(HttpServletRequest req, HttpServletResponse rsp) throwsIOException { rsp.getWriter().println(\"Hello,Spring BY servlet API\"); } @RequestMapping(\"/result/t2\") public void test2(HttpServletRequest req, HttpServletResponse rsp) throwsIOException { rsp.sendRedirect(\"/index.jsp\"); } @RequestMapping(\"/result/t3\") public void test3(HttpServletRequest req, HttpServletResponse rsp) throwsException { //转发 req.setAttribute(\"msg\",\"/result/t3\"); req.getRequestDispatcher(\"/WEB-INF/jsp/test.jsp\").forward(req,rsp); } } SpringMVC通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 @Controller public class ResultSpringMVC { @RequestMapping(\"/rsm/t1\") public String test1(){ //转发 return \"/index.jsp\"; } @RequestMapping(\"/rsm/t2\") public String test2(){ //转发二 return \"forward:/index.jsp\"; } @RequestMapping(\"/rsm/t3\") public String test3(){ //重定向 return \"redirect:/index.jsp\"; } } 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . @Controller public class ResultSpringMVC2 { @RequestMapping(\"/rsm2/t1\") public String test1(){ //转发 return \"test\"; } @RequestMapping(\"/rsm2/t2\") public String test2(){ //重定向 //return \"redirect:/index.jsp\"; return \"redirect:/hello\"; //hello为另一个请求路径/ } } 数据处理处理提交数据1、提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/hello?name=kuangshen 处理方法 : @RequestMapping(\"/hello\") public String hello(String name){ System.out.println(name); return \"hello\"; } 后台输出 : kuangshen 2、提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=kuangshen 处理方法 : //@RequestParam(\"username\") : username提交的域的名称 . @RequestMapping(\"/hello\") public String hello(@RequestParam(\"username\") String name){ System.out.println(name); return \"hello\"; } 后台输出 : kuangshen 3、提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 1、实体类 public class User { private int id; private String name; private int age; //构造 //get/set //tostring() } 2、提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 3、处理方法 : @RequestMapping(\"/user\") public String user(User user){ System.out.println(user); return \"hello\"; } 后台输出 : User { id=1, name=’kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 数据显示到前端第一种 : 通过ModelAndView 实现controller接口 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; } } 第二种 : 通过ModelMap ModelMap @RequestMapping(\"/hello\") public String hello(@RequestParam(\"username\") String name, ModelMap model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"name\",name); System.out.println(name); return \"hello\"; } 第三种 : 通过Model Model @RequestMapping(\"/ct2/hello\") public String hello(@RequestParam(\"username\") String name, Model model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"msg\",name); System.out.println(name); return \"test\"; } 对比就对于新手而言简单来说使用区别就是： Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 乱码问题测试步骤： 1、我们可以在首页编写一个提交的表单 &lt;form action=\"/e/t\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; 2、后台编写对应的处理类 @Controller public class Encoding { @RequestMapping(\"/e/t\") public String test(Model model,String name){ model.addAttribute(\"msg\",name); //获取表单提交的值 return \"test\"; //跳转到test页面显示输入的值 } } 3、输入中文测试，发现乱码 不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！ 以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;&lt;!-- 自定义 --&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 对所有请求生效 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;&lt;!-- 跟上面自定义的名字对应 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 但是我们发现 , 有些极端情况下，这个过滤器对get的支持不好 . 处理方法 : 1、修改tomcat配置文件 ：设置编码！ &lt;Connector URIEncoding=\"utf-8\" port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 2、自定义过滤器 package com.kuang.filter; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.Map; /** * 解决get和post请求 全部乱码的过滤器 */ public class GenericEncodingFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChainchain) throws IOException, ServletException { //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(\"text/html;charset=UTF-8\"); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); } @Override public void init(FilterConfig filterConfig) throws ServletException { } } //自定义request对象，HttpServletRequest的包装类 class MyRequest extends HttpServletRequestWrapper { private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) { super(request);// super必须写 this.request = request; } // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() { // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(\"post\")) { // post请求 try { // 处理post乱码 request.setCharacterEncoding(\"utf-8\"); return request.getParameterMap(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } else if (method.equalsIgnoreCase(\"get\")) { // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) { // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) { String[] values = parameterMap.get(parameterName); if (values != null) { for (int i = 0; i &lt; values.length; i++) { try { // 处理get乱码 values[i] = new String(values[i] .getBytes(\"ISO-8859-1\"), \"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } } hasEncode = true; } return parameterMap; } return super.getParameterMap(); } //取一个值 @Override public String getParameter(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) { return null; } return values[0]; // 取回参数的第一个值 } //取所有值 @Override public String[] getParameterValues(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; } } 这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！ 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！ 什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"QinJiang\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试1、新建一个module ，springmvc-05-json ， 添加web的支持 2、在web目录下新建一个 json-1.html ， 编写测试内容 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSON_秦疆&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; //编写一个js的对象 var user = { name:\"秦疆\", age:3, sex:\"男\" }; //将js对象转换成json字符串，let与var一样 let s = JSON.stringify(usr); console.log(s); //将json字符串转换为js对象，let与var一样 let parse = JSON.parse(s); console.log(parse); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3、在IDEA中使用浏览器打开，查看控制台输出！ Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; 配置SpringMVC需要的配置 web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; springmvc-servlet.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； package com.kuang.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; //需要导入lombok @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； @Controller public class UserController { @RequestMapping(\"/json1\") @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 配置Tomcat ， 启动测试一下！ http://localhost:8080/json1 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMapping 的 produces 属性来实现，修改下代码 //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\") 再次测试， http://localhost:8080/json1 ， 乱码问题OK！ 【注意：使用json记得处理乱码问题】 代码优化 乱码统一解决上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 返回json字符串统一解决在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不会进行视图解析，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ @RestController public class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\") public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 启动tomcat测试，结果都正常输出！ 测试集合输出 增加一个新的方法 @RequestMapping(\"/json2\") public String json2() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str; } 运行结果 : 十分完美，没有任何问题！ 输出时间对象 增加一个新的方法 @RequestMapping(\"/json3\") public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str; } 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 @RequestMapping(\"/json4\") public String json4() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str; } 运行结果 : 成功的输出了时间！ 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 package com.kuang.utils; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import java.text.SimpleDateFormat; public class JsonUtils { public static String getJson(Object object) { return getJson(object,\"yyyy-MM-dd HH:mm:ss\"); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 我们使用工具类，代码就更加简洁了！ @RequestMapping(\"/json5\") public String json5() throws JsonProcessingException { Date date = new Date(); String json = JsonUtils.getJson(date); return json; } 大功告成！完美！ FastJsonfastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt; &lt;/dependency&gt; fastjson 三个主要的类： JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组 内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 package com.kuang.controller; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.kuang.pojo.User; import java.util.ArrayList; import java.util.List; public class FastJsonDemo { public static void main(String[] args) { //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\"*******Java对象 转 JSON字符串*******\"); String str1 = JSON.toJSONString(list); System.out.println(\"JSON.toJSONString(list)==&gt;\"+str1); String str2 = JSON.toJSONString(user1); System.out.println(\"JSON.toJSONString(user1)==&gt;\"+str2); System.out.println(\"\\n****** JSON字符串 转 Java对象*******\"); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\"JSON.parseObject(str2,User.class)==&gt;\"+jp_user1); System.out.println(\"\\n****** Java对象 转 JSON对象 ******\"); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\"(JSONObject) JSON.toJSON(user2)==&gt;\"+jsonObject1.getString(\"name\")); System.out.println(\"\\n****** JSON对象 转 Java对象 ******\"); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\"JSON.toJavaObject(jsonObject1, User.class)==&gt;\"+to_java_user); } } 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！ AJAX简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 伪造Ajax我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function(){ var myDate = new Date(); document.getElementById('currentTime').innerText = myDate.getTime(); }; function LoadPage(){ var targetUrl = document.getElementById('url').value; console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; } &lt;/script&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" value=\"https://www.baidu.com/\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage()\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3、使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 ….等等 jQuery.ajax纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!--静态资源过滤--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;beanclass=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 2、编写一个AjaxController @Controller public class AjaxController { @RequestMapping(\"/a1\") public void ajax1(String name , HttpServletResponse response) throwsIOException { if (\"admin\".equals(name)){ response.getWriter().print(\"true\"); }else{ response.getWriter().print(\"false\"); } } } 3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入 &lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; 4、编写index.jsp测试 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt;--%&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ &lt;%-- $ 是 jQuery 的缩写--%&gt; $.post({ url:\"${pageContext.request.contextPath}/a1\", data:{'name':$(\"#txtName\").val()}, success:function (data,status) { &lt;%-- 这里的data是后台controller返回的数据--%&gt; alert(data); alert(status); } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;%--onblur：失去焦点触发事件--%&gt; 用户名:&lt;input type=\"text\" id=\"txtName\" onblur=\"a1()\"/&gt; &lt;/body&gt; &lt;/html&gt; 5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ SpringMVC实现实体类user @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 我们来获取一个集合对象，展示到前端页面 @RequestMapping(\"/a2\") public List&lt;User&gt; ajax2(){ List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(\"秦疆1号\",3,\"男\")); list.add(new User(\"秦疆2号\",3,\"男\")); list.add(new User(\"秦疆3号\",3,\"男\")); return list; //由于@RestController注解，将list转成json格式返回 } 前端页面 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" id=\"btn\" value=\"获取数据\"/&gt; &lt;table width=\"80%\" align=\"center\"&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;tbody id=\"content\"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () { &lt;%-- 没有外面这层function嵌套的话，点击事件不能正常运行， 点击事件在这里不是一个函数--%&gt; $(\"#btn\").click(function () { &lt;%-- 缩写形式 $.post(url , param[可以省略], success)--%&gt; $.post(\"${pageContext.request.contextPath}/a2\",function (data) { console.log(data) var html=\"\"; for (var i = 0; i &lt;data.length ; i++) { html+= \"&lt;tr&gt;\" + \"&lt;td&gt;\" + data[i].name + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].age + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].sex + \"&lt;/td&gt;\" + \"&lt;/tr&gt;\" } $(\"#content\").html(html); }); }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 成功实现了数据回显！可以体会一下Ajax的好处！ 注册提示效果我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化 我们写一个Controller @RequestMapping(\"/a3\") public String ajax3(String name,String pwd){ String msg = \"\"; //模拟数据库中存在数据 if (name!=null){ if (\"admin\".equals(name)){ msg = \"OK\"; }else { msg = \"用户名输入错误\"; } } if (pwd!=null){ if (\"123456\".equals(pwd)){ msg = \"OK\"; }else { msg = \"密码输入有误\"; } } return msg; //由于@RestController注解，将msg转成json格式返回 } 前端页面 login.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ $.post({ url:\"${pageContext.request.contextPath}/a3\", data:{'name':$(\"#name\").val()}, success:function (data) { if (data.toString()=='OK'){ $(\"#userInfo\").css(\"color\",\"green\"); }else { $(\"#userInfo\").css(\"color\",\"red\"); } $(\"#userInfo\").html(data); } }); } function a2(){ $.post({ url:\"${pageContext.request.contextPath}/a3\", data:{'pwd':$(\"#pwd\").val()}, success:function (data) { if (data.toString()=='OK'){ $(\"#pwdInfo\").css(\"color\",\"green\"); }else { $(\"#pwdInfo\").css(\"color\",\"red\"); } $(\"#pwdInfo\").html(data); } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 用户名:&lt;input type=\"text\" id=\"name\" onblur=\"a1()\"/&gt; &lt;span id=\"userInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 密码:&lt;input type=\"text\" id=\"pwd\" onblur=\"a2()\"/&gt; &lt;span id=\"pwdInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 【记得处理json乱码问题】 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 测试一下效果，动态请求响应，局部刷新，就是如此！ 获取baidu接口Demo&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;JSONP百度搜索&lt;/title&gt; &lt;style&gt; #q{ width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; } #ul{ width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; } #ul li{ line-height: 30px; padding: 0 10px; } #ul li:hover{ background-color: #f60; color: #fff; } &lt;/style&gt; &lt;script&gt; // 2.步骤二 // 定义demo函数 (分析接口、数据) function demo(data){ var Ul = document.getElementById('ul'); var html = ''; // 如果搜索数据存在 把内容添加进去 if (data.s.length) { // 隐藏掉的ul显示出来 Ul.style.display = 'block'; // 搜索到的数据循环追加到li里 for(var i = 0;i&lt;data.s.length;i++){ html += '&lt;li&gt;'+data.s[i]+'&lt;/li&gt;'; } // 循环的li写入ul Ul.innerHTML = html; } } // 1.步骤一 window.onload = function(){ // 获取输入框和ul var Q = document.getElementById('q'); var Ul = document.getElementById('ul'); // 事件鼠标抬起时候 Q.onkeyup = function(){ // 如果输入框不等于空 if (this.value != '') { // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ // 创建标签 var script = document.createElement('script'); //给定要跨域的地址 赋值给src //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src ='https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='+this.value+'&amp;cb=demo'; // 将组合好的带src的script标签追加到body里 document.body.appendChild(script); } } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" id=\"q\" /&gt; &lt;ul id=\"ul\"&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; Ajax在我们开发中十分重要，一定要学会使用！ 拦截器 概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 自定义拦截器 那如何实现拦截器呢？ 想要自定义拦截器，必须实现 HandlerInterceptor 接口。 1、新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持 2、配置web.xml 和 springmvc-servlet.xml 文件 3、编写一个拦截器 package com.kuang.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 public boolean preHandle(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(\"------------处理前------------\"); return true; } //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)throws Exception { System.out.println(\"------------处理后------------\"); } //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(\"------------清理------------\"); } } 4、在springmvc的配置文件中配置拦截器 &lt;!--关于拦截器的配置--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;!--/admin/** 拦截的是/admin/下的所有--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=\"com.kuang.interceptor.MyInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 5、编写一个Controller，接收请求 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; //测试拦截器的控制器 @Controller public class InterceptorController { @RequestMapping(\"/interceptor\") @ResponseBody public String testFunction() { System.out.println(\"控制器中的方法执行了\"); return \"hello\"; } } 6、前端 index.jsp &lt;a href=\"${pageContext.request.contextPath}/interceptor\"&gt;拦截器测试&lt;/a&gt; 7、启动tomcat 测试一下！ 验证用户是否登录 (认证用户) 实现思路 1、有一个登陆页面，需要写一个controller访问页面。 2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。 3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面 测试： 1、编写一个登陆页面 login.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;h1&gt;登录页面&lt;/h1&gt; &lt;hr&gt; &lt;body&gt; &lt;form action=\"${pageContext.request.contextPath}/user/login\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码：&lt;input type=\"password\" name=\"pwd\"&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 2、编写一个Controller处理请求 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpSession; @Controller @RequestMapping(\"/user\") public class UserController { //跳转到登陆页面 @RequestMapping(\"/jumplogin\") public String jumpLogin() throws Exception { return \"login\"; } //跳转到成功页面 @RequestMapping(\"/jumpSuccess\") public String jumpSuccess() throws Exception { return \"success\"; } //登陆提交 @RequestMapping(\"/login\") public String login(HttpSession session, String username, String pwd) throwsException { // 向session记录用户身份信息 System.out.println(\"接收前端===\"+username); session.setAttribute(\"user\", username); return \"success\"; } //退出登陆 @RequestMapping(\"logout\") public String logout(HttpSession session) throws Exception { // session 过期 session.invalidate(); //移除节点数据 //session.removeAttribute(\"user\"); return \"login\"; } } 3、编写一个登陆成功的页面 success.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;登录成功页面&lt;/h1&gt; &lt;hr&gt; ${user} &lt;a href=\"${pageContext.request.contextPath}/user/logout\"&gt;注销&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！ &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;hr&gt; &lt;%--登录--%&gt; &lt;a href=\"${pageContext.request.contextPath}/user/jumplogin\"&gt;登录&lt;/a&gt; &lt;a href=\"${pageContext.request.contextPath}/user/jumpSuccess\"&gt;成功页面&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 5、编写用户登录拦截器 package com.kuang.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; public class LoginInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws ServletException, IOException { // 如果是登陆页面则放行 System.out.println(\"uri: \" + request.getRequestURI()); if (request.getRequestURI().contains(\"login\")) { return true; } HttpSession session = request.getSession(); // 如果用户已登陆也放行 if(session.getAttribute(\"user\") != null) { return true; } // 用户没有登陆跳转到登陆页面 request.getRequestDispatcher(\"/WEB-INF/jsp/login.jsp\").forward(request,response); return false; } public void postHandle(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)throws Exception { } public void afterCompletion(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { } } 6、在Springmvc的配置文件中注册拦截器 &lt;!--关于拦截器的配置--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean id=\"loginInterceptor\" class=\"com.kuang.interceptor.LoginInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 7、再次重启Tomcat测试！ OK，测试登录拦截功能无误. Spring MVC 数据绑定数据绑定：在后端的业务方法中直接获取客户端 HTTP 请求中的参数，将请求参数映射到业务方法的形参中，Spring MVC 中数据绑定的工作是由 HandlerAdapter 来完成的。 基本数据类型 @RequestMapping(\"/baseType\") @ResponseBody public String baseType(int id){ return id+\"\"; } @ResponseBody 表示 Spring MVC 会直接将业务方法的返回值响应给客户端，如果不加 @ResponseBody 注解，Spring MVC 会将业务方法的放回值传递给 DispatcherServlet，再由 DisptacherServlet 调用 ViewResolver 对返回值进行解析，映射到一个 JSP 资源。（这里没有指定JSP，所以去掉的话就会找不到页面） 包装类 @RequestMapping(\"/packageType\") @ResponseBody public String packageType(@RequestParam(value = \"num\",required = false,defaultValue = \"0\") Integer id){ return id+\"\"; } 包装类可以接收 null，当 HTTP 请求没有参数时，使用包装类定义形参的数据类型，程序不会抛出异常。 @RequestParam value = “num”：将 HTTP 请求中名为 num 的参数赋给形参 id。 requried：设置 num 是否为必填项，true 表示必填，false 表示非必填，可省略。 defaultValue = “0”：如果 HTTP 请求中没有 num 参数，默认值为0. 数组 @RestController @RequestMapping(\"/data\") public class DataBindHandler { @RequestMapping(\"/array\") public String array(String[] name){ String str = Arrays.toString(name); return str; } } @RestController 表示该控制器会直接将业务方法的返回值响应给客户端，不进行视图解析。 @Controller 表示该控制器的每一个业务方法的返回值都会交给视图解析器进行解析，如果只需要将数据响应给客户端，而不需要进行视图解析，则需要在对应的业务方法定义处添加 @ResponseBody。 @RestController @RequestMapping(\"/data\") public class DataBindHandler { @RequestMapping(\"/array\") public String array(String[] name){ String str = Arrays.toString(name); return str; } } 等同于 @Controller @RequestMapping(\"/data\") public class DataBindHandler { @RequestMapping(\"/array\") @ResponseBody public String array(String[] name){ String str = Arrays.toString(name); return str; } } List Spring MVC 不支持 List 类型的直接转换，需要对 List 集合进行包装。 集合封装类 package com.southwind.entity; import lombok.Data; import java.util.List; @Data public class UserList { private List&lt;User&gt; users; } JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 09:12 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/data/list\" method=\"post\"&gt; 用户1编号：&lt;input type=\"text\" name=\"users[0].id\"/&gt;&lt;br/&gt; 用户1名称：&lt;input type=\"text\" name=\"users[0].name\"/&gt;&lt;br/&gt; 用户2编号：&lt;input type=\"text\" name=\"users[1].id\"/&gt;&lt;br/&gt; 用户2名称：&lt;input type=\"text\" name=\"users[1].name\"/&gt;&lt;br/&gt; 用户3编号：&lt;input type=\"text\" name=\"users[2].id\"/&gt;&lt;br/&gt; 用户3名称：&lt;input type=\"text\" name=\"users[2].name\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 业务方法 @RequestMapping(\"/list\") public String list(UserList userList){ StringBuffer str = new StringBuffer(); for(User user:userList.getUsers()){ str.append(user); } return str.toString(); } 处理 @ResponseBody 中文乱码，在 springmvc.xml 中配置消息转换器。 &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; ==register-defaults=”Boolean” 是否添加其他默认的HttpMessageConverter注册，消息转化器默认总共有七个== Map 自定义封装类 package com.southwind.entity; import lombok.Data; import java.util.Map; @Data public class UserMap { private Map&lt;String,User&gt; users; } 业务方法 @RequestMapping(\"/map\") public String map(UserMap userMap){ StringBuffer str = new StringBuffer(); for(String key:userMap.getUsers().keySet()){ User user = userMap.getUsers().get(key); str.append(user); } return str.toString(); } JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 09:12 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/data/map\" method=\"post\"&gt; 用户1编号：&lt;input type=\"text\" name=\"users['a'].id\"/&gt;&lt;br/&gt; 用户1名称：&lt;input type=\"text\" name=\"users['a'].name\"/&gt;&lt;br/&gt; 用户2编号：&lt;input type=\"text\" name=\"users['b'].id\"/&gt;&lt;br/&gt; 用户2名称：&lt;input type=\"text\" name=\"users['b'].name\"/&gt;&lt;br/&gt; 用户3编号：&lt;input type=\"text\" name=\"users['c'].id\"/&gt;&lt;br/&gt; 用户3名称：&lt;input type=\"text\" name=\"users['c'].name\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; JSON 客户端发生 JSON 格式的数据，直接通过 Spring MVC 绑定到业务方法的形参中。 处理 Spring MVC 无法加载静态资源的问题(被 ==dispatcherServlet== 拦截)，在 web.xml 中添加配置即可。 &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 10:35 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;!--这里引用了jquery文件，需要自己去找下载--&gt; &lt;script type=\"text/javascript\"&gt; $(function(){ var user = { \"id\":1, \"name\":\"张三\" }; $.ajax({ url:\"/data/json\", data:JSON.stringify(user), &lt;这里进入到handler里的业务方法&gt; type:\"POST\", contentType:\"application/json;charset=UTF-8\", dataType:\"JSON\", success:function(data){ alert(data.id+\"---\"+data.name); } }) }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 业务方法 @RequestMapping(\"/json\") public User json(@RequestBody User user){ System.out.println(user); user.setId(6); user.setName(\"张六\"); return user; } Spring MVC 中的 JSON 和 JavaBean 的转换需要借助于 fastjson，pom.xml 引入相关依赖。 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.32&lt;/version&gt; &lt;/dependency&gt; springmvc.xml 添加 fastjson 配置。 &lt;mvc:annotation-driven&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\" value=\"text/html;charset=UTF-8\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置fastjson --&gt; &lt;bean class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4\"&gt;&lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; Spring MVC 模型数据解析JSP 四大作用域对应的内置对象：pageContext、request、session、application。 模型数据的绑定是由 ViewResolver 来完成的，实际开发中，我们需要先添加模型数据，再交给 ViewResolver 来绑定。 Spring MVC 提供了以下几种方式添加模型数据： Map Model ModelAndView HttpServletRequest @SessionAttribute @ModelAttribute 将模式数据绑定到 request 对象。 1、Map @RequestMapping(\"/map\") public String map(Map&lt;String,User&gt; map){ User user = new User(); user.setId(1L); user.setName(\"张三\"); map.put(\"a\",user); //这里把key值改为“1”的话，jsp调用的时候不能调用，只能是字符串 return \"view\"; } JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 11:36 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${requestScope.a} //这里requestScope. 后面只能是字符串，不能是数字 &lt;/body&gt; &lt;/html&gt; ==&lt;%@ page isELIgnored=”false” %&gt;== 不写这行代码，浏览器会将 ${requestScope.user} 作为文本输出，而不会解析 2、Model pom.xml &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; Handler @RequestMapping(\"/model\") public String model(Model model){ User user = new User(); user.setId(1L); user.setName(\"张三\"); model.addAttribute(\"user\",user); return \"view\"; } 3、ModelAndView @RequestMapping(\"/modelAndView\") public ModelAndView modelAndView(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"user\",user); modelAndView.setViewName(\"view\"); return modelAndView; } @RequestMapping(\"/modelAndView2\") public ModelAndView modelAndView2(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"user\",user); View view = new InternalResourceView(\"/view.jsp\"); modelAndView.setView(view); return modelAndView; } @RequestMapping(\"/modelAndView3\") public ModelAndView modelAndView3(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView = new ModelAndView(\"view\"); modelAndView.addObject(\"user\",user); return modelAndView; } @RequestMapping(\"/modelAndView4\") public ModelAndView modelAndView4(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); View view = new InternalResourceView(\"/view.jsp\"); ModelAndView modelAndView = new ModelAndView(view); modelAndView.addObject(\"user\",user); return modelAndView; } @RequestMapping(\"/modelAndView5\") public ModelAndView modelAndView5(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); Map&lt;String,User&gt; map = new HashMap&lt;&gt;(); map.put(\"user\",user); ModelAndView modelAndView = new ModelAndView(\"view\",map); return modelAndView; } @RequestMapping(\"/modelAndView6\") public ModelAndView modelAndView6(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); Map&lt;String,User&gt; map = new HashMap&lt;&gt;(); map.put(\"user\",user); View view = new InternalResourceView(\"/view.jsp\"); ModelAndView modelAndView = new ModelAndView(view,map); return modelAndView; } @RequestMapping(\"/modelAndView7\") public ModelAndView modelAndView7(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView = new ModelAndView(\"view\",\"user\",user); return modelAndView; } @RequestMapping(\"/modelAndView8\") public ModelAndView modelAndView8(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); View view = new InternalResourceView(\"/view.jsp\"); ModelAndView modelAndView = new ModelAndView(view,\"user\",user); return modelAndView; } 4、HttpServletRequest @RequestMapping(\"/request\") public String request(HttpServletRequest request){ User user = new User(); user.setId(1L); user.setName(\"张三\"); request.setAttribute(\"user\",user); return \"view\"; } 5、@ModelAttribute 定义一个方法，该方法专门用来返回要填充到模型数据中的对象。 @ModelAttribute //返回一个user对象，交给框架自己去处理 public User getUser(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); return user; } @ModelAttribute //把对象装map里，也就是自己处理，不用返回对象 public void getUser(Map&lt;String,User&gt; map){ User user = new User(); user.setId(1L); user.setName(\"张三\"); map.put(\"user\",user); } @ModelAttribute //把对象装model里，也就是自己处理，不用返回对象 public void getUser(Model model){ User user = new User(); user.setId(1L); user.setName(\"张三\"); model.addAttribute(\"user\",user); } 业务方法中无需再处理模型数据，只需返回视图即可。 @RequestMapping(\"/modelAttribute\") public String modelAttribute(){ return \"view\"; } 将模型数据绑定到 session 对象 1、直接使用原生的 Servlet API。 @RequestMapping(\"/session\") public String session(HttpServletRequest request){ HttpSession session = request.getSession(); User user = new User(); user.setId(1L); user.setName(\"张三\"); session.setAttribute(\"user\",user); return \"view\"; } //或者这个方法也一样 @RequestMapping(\"/session2\") public String session2(HttpSession session){ User user = new User(); user.setId(1L); user.setName(\"张三\"); session.setAttribute(\"user\",user); return \"view\"; } 2、@SessionAttribute（==慎用==，全局注解，对所有方法都生效，注解在Handler类上） @SessionAttributes(value = {\"user\",\"address\"}) public class ViewHandler { } 对于 ViewHandler 中的所有业务方法，只要向 request 中添加了 key = “user”、key = “address” 的对象时，Spring MVC 会自动将该数据添加到 session 中，保存 key 不变。 @SessionAttributes(types = {User.class,Address.class}) public class ViewHandler { } 对于 ViewHandler 中的所有业务方法，只要向 request 中添加了数据类型是 User 、Address 的对象时，Spring MVC 会自动将该数据添加到 session 中，保存 key 不变。 将模型数据绑定到 application 对象 @RequestMapping(\"/application\") public String application(HttpServletRequest request){ ServletContext application = request.getServletContext(); User user = new User(); user.setId(1L); user.setName(\"张三\"); application.setAttribute(\"user\",user); return \"view\"; } Spring MVC 自定义数据转换器数据转换器是指将客户端 HTTP 请求中的参数转换为业务方法中定义的形参，自定义表示开发者可以自主设计转换的方式，HandlerApdter 已经提供了通用的转换，String 转 int，String 转 double，表单数据的封装等，但是在特殊的业务场景下，HandlerAdapter 无法进行转换，就需要开发者自定义转换器。 客户端输入 String 类型的数据 “2019-03-03”，自定义转换器将该数据转为 Date 类型的对象。 创建 DateConverter 转换器，实现 Conveter 接口。 package com.southwind.converter; import org.springframework.core.convert.converter.Converter; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class DateConverter implements Converter&lt;String, Date&gt; { private String pattern; public DateConverter(String pattern){ this.pattern = pattern; //这里pattern是\"yyyy-MM-dd\" } @Override public Date convert(String s) { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(this.pattern); //创建对应\"yyyy-MM-dd\"的日期格式 Date date = null; try { date = simpleDateFormat.parse(s); } catch (ParseException e) { e.printStackTrace(); } return date; } } springmvc.xml 配置转换器。 &lt;!-- 配置自定义转换器 --&gt; &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"com.southwind.converter.DateConverter\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"yyyy-MM-dd\"&gt;&lt;/constructor-arg&gt; &lt;!--这里有参构造是给DateConverter的有参构造传\"yyyy-MM-dd\"的日期格式--&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--conversion-service=\"conversionService\" 注册一个转化器 --&gt; &lt;mvc:annotation-driven conversion-service=\"conversionService\"&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\" value=\"text/html;charset=UTF-8\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置fastjson --&gt; &lt;bean class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4\"&gt;&lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 14:47 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/converter/date\" method=\"post\"&gt; 请输入日期:&lt;input type=\"text\" name=\"date\"/&gt;(yyyy-MM-dd)&lt;br/&gt; &lt;!--这里的name=\"date\"与Handler的public String date(Date date)的参数date一致--&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; Handler package com.southwind.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.Date; @RestController @RequestMapping(\"/converter\") public class ConverterHandler { @RequestMapping(\"/date\") public String date(Date date){ return date.toString(); } } String 转 Student StudentConverter package com.southwind.converter; import com.southwind.entity.Student; import org.springframework.core.convert.converter.Converter; public class StudentConverter implements Converter&lt;String, Student&gt; { @Override public Student convert(String s) { String[] args = s.split(\"-\"); Student student = new Student(); student.setId(Long.parseLong(args[0])); student.setName(args[1]); student.setAge(Integer.parseInt(args[2])); return student; } } springmvc.xml &lt;!-- 配置自定义转换器 --&gt; &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"com.southwind.converter.DateConverter\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"yyyy-MM-dd\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class=\"com.southwind.converter.StudentConverter\"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven conversion-service=\"conversionService\"&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\" value=\"text/html;charset=UTF-8\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置fastjson --&gt; &lt;bean class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4\"&gt;&lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 15:23 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/converter/student\" method=\"post\"&gt; 请输入学生信息：&lt;input type=\"text\" name=\"student\"/&gt;(id-name-age)&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; Handler @RequestMapping(\"/student\") public String student(Student student){ return student.toString(); } Spring MVC 文件上传下载 单文件上传 底层是使用 Apache fileupload 组件完成上传，Spring MVC 对这种方式进行了封装。 pom.xml &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-15 Time: 09:09 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/file/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"img\"/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;img src=\"${path}\"&gt; &lt;/body&gt; &lt;/html&gt; 1、input 的 type 设置为 file。 2、form 的 method 设置为 post（get 请求只能将文件名传给服务器） 3、from 的 enctype 设置为 multipart-form-data（如果不设置只能将文件名传给服务器） springmvc.xml &lt;!-- 配置上传组件 --&gt; &lt;!--这个bena的id必须为：multipartResolver ，否则上传文件会报400的错误！--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 下面几个属性可以不配置，会有默认值 --&gt; &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt; &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt; &lt;property name=\"maxInMemorySize\" value=\"40960\"/&gt; &lt;/bean&gt; Handler package com.southwind.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.File; import java.io.IOException; @Controller @RequestMapping(\"/file\") public class FileHandler { @PostMapping(\"/upload\") public String upload(MultipartFile img, HttpServletRequest request){ if(img.getSize()&gt;0){ //获取保存上传文件的file路径 String path = request.getServletContext().getRealPath(\"file\"); //这里可以做一个目录存在否判断 // File realPath = new File(path); // if (!realPath.exists()){ // realPath.mkdir(); // } //获取上传的文件名 String name = img.getOriginalFilename(); File file = new File(path,name); try { img.transferTo(file); //保存上传之后的文件路径 request.setAttribute(\"path\",\"/file/\"+name); } catch (IOException e) { e.printStackTrace(); } } return \"upload\"; } } CommonsMultipartFile 的 常用方法： String getOriginalFilename()：获取上传文件的原名 InputStream getInputStream()：获取文件流 void transferTo(File dest)：将上传文件保存到一个目录文件中 web.xml 添加如下配置，否则客户端无法访问 png &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 多文件上传 pom.xml &lt;!-- 标准表单标签库依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-15 Time: 09:32 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/file/uploads\" method=\"post\" enctype=\"multipart/form-data\"&gt; file1:&lt;input type=\"file\" name=\"imgs\"/&gt;&lt;br/&gt; file2:&lt;input type=\"file\" name=\"imgs\"/&gt;&lt;br/&gt; file3:&lt;input type=\"file\" name=\"imgs\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;c:forEach items=\"${files}\" var=\"file\" &gt; &lt;img src=\"${file}\" width=\"300px\"&gt; &lt;/c:forEach&gt; &lt;/body&gt; &lt;/html&gt; Handler @PostMapping(\"/uploads\") public String uploads(MultipartFile[] imgs,HttpServletRequest request){ List&lt;String&gt; files = new ArrayList&lt;&gt;();//用来存储上传文件名 for (MultipartFile img:imgs){ if(img.getSize()&gt;0){ //获取保存上传文件的file路径 String path = request.getServletContext().getRealPath(\"file\"); //获取上传的文件名 String name = img.getOriginalFilename(); File file = new File(path,name); try { img.transferTo(file); //保存上传之后的文件路径 files.add(\"/file/\"+name); } catch (IOException e) { e.printStackTrace(); } } } request.setAttribute(\"files\",files); return \"uploads\"; } 下载 Rest格式 JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-15 Time: 10:36 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"/file/download/1\"&gt;1.png&lt;/a&gt; &lt;a href=\"/file/download/2\"&gt;2.png&lt;/a&gt; &lt;a href=\"/file/download/3\"&gt;3.png&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; Handler @GetMapping(\"/download/{name}\") //这里是rest格式URL，所以下面需要@PathVariable(\"name\")来映射取值 public void download(@PathVariable(\"name\") String name, HttpServletRequest request, HttpServletResponse response){ if(name != null){ name += \".png\"; String path = request.getServletContext().getRealPath(\"file\"); File file = new File(path,name); OutputStream outputStream = null; if(file.exists()){ response.setContentType(\"application/forc-download\"); //设置为下载类型 response.setHeader(\"Content-Disposition\",\"attachment;filename=\"+name); //告诉浏览器文件的名字和类型，Content-Disposition中指定的类型是文件的扩展名，并且弹出的下载对话框中的文件类型图片是按照文件的扩展名显示的，点保存后，文件以filename的值命名，保存类型以Content中设置的为准。 注意：在设置Content-Disposition头字段之前，一定要设置Content-Type头字段。 try { outputStream = response.getOutputStream(); outputStream.write(FileUtils.readFileToByteArray(file)); outputStream.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if(outputStream != null){ try { outputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } } } } 普通方式 JSP &lt;a href=\"/download\"&gt;点击下载&lt;/a&gt; Handler @RequestMapping(value=\"/download\") public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{ //要下载的图片地址 String path = request.getServletContext().getRealPath(\"/upload\"); String fileName = \"基础语法.jpg\"; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(\"UTF-8\"); //字符编码 response.setContentType(\"multipart/form-data\"); //二进制传输数据 //设置响应头 response.setHeader(\"Content-Disposition\", \"attachment;fileName=\"+URLEncoder.encode(fileName, \"UTF-8\")); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1){ out.write(buff, 0, index); out.flush(); } out.close(); input.close(); return null; } Spring MVC 表单标签库 Handler @GetMapping(\"/get\") public ModelAndView get(){ ModelAndView modelAndView = new ModelAndView(\"tag\"); Student student = new Student(1L,\"张三\",22); modelAndView.addObject(\"student\",student); return modelAndView; } JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-15 Time: 10:53 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;学生信息&lt;/h1&gt; &lt;form:form modelAttribute=\"student\"&gt; &lt;!--第一个form是&lt;%@ taglib prefix=\"form\" %&gt;的form，第二个form才是form标签--&gt; 学生ID：&lt;form:input path=\"id\"/&gt;&lt;br/&gt; 学生姓名：&lt;form:input path=\"name\"/&gt;&lt;br/&gt; 学生年龄：&lt;form:input path=\"age\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 1、JSP 页面导入 Spring MVC 表单标签库，与导入 JSTL 标签库的语法非常相似，前缀 prefix 可以自定义，通常定义为 from。 &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; 2、将 form 表单与模型数据进行绑定，通过 modelAttribute 属性完成绑定，将 modelAttribute 的值设置为模型数据对应的 key 值。 Handeler: modelAndView.addObject(\"student\",student); JSP: &lt;form:form modelAttribute=\"student\"&gt; 3、form 表单完成绑定之后，将模型数据的值取出绑定到不同的标签中，通过设置标签的 path 属性完成，将 path 属性的值设置为模型数据对应的属性名即可。 学生ID：&lt;form:input path=\"id\"/&gt;&lt;br/&gt; 学生姓名：&lt;form:input path=\"name\"/&gt;&lt;br/&gt; 学生年龄：&lt;form:input path=\"age\"/&gt;&lt;br/&gt; 常用的表单标签 form &lt;form:form modelAttribute=\"student\"/&gt; 渲染的是 HTML 中的&lt;form&gt;&lt;/from&gt;，通过 modelAttribute 属性绑定具体的模型数据。 input &lt;form:input path=\"name\"/&gt; 渲染的是 HTML 中的 ==&lt;input type=\"text\"/&gt;==(文本类型的input标签)，form 标签绑定的是模型数据，input 标签绑定的是模型数据中的属性值，通过 path 属性可以与模型数据中的属性名对应，并且支持及联操作。 &lt;form:input path=\"address.name\"/&gt; password &lt;form:password path=\"password\"/&gt; 渲染的是 HTML 中的 &lt;input type=\"password\"/&gt;，通过 path 属性与模型数据的属性值进行绑定，password 标签的值不会在页面显示。 checkbox &lt;form:checkbox path=\"hobby\" value=\"读书\"/&gt; student.setFlag(false); checkbox：&lt;form:checkbox path=\"flag\" value=\"flag\"&gt;&lt;/form:checkbox&gt;&lt;br/&gt; 上面代码行的 ==value=”flag”==是设置表单提交后这个CheckBox标签的value值，不关乎这个CheckBox的勾选状态 渲染的是 HTML 中的 &lt;input type=\"checkbox\"/&gt;，通过 path 与模型数据的属性值进行绑定，可以绑定 boolean、数组和集合。 如果绑定 boolean 值，若该变量的值为 true，则表示该复选框选中，否则表示不选中。 ==如果绑定数组或者集合，数组/集合中的元素等于 checkbox 的 value 值，则选中。== student.setHobby(Arrays.asList(\"读书\",\"看电影\",\"玩游戏\")); modelAndView.addObject(\"student\",student); 爱好：&lt;form:checkbox path=\"hobby\" value=\"摄影\"&gt;&lt;/form:checkbox&gt;摄影&lt;br/&gt; &lt;form:checkbox path=\"hobby\" value=\"读书\"&gt;&lt;/form:checkbox&gt;读书&lt;br/&gt; &lt;form:checkbox path=\"hobby\" value=\"听音乐\"&gt;&lt;/form:checkbox&gt;听音乐&lt;br/&gt; &lt;form:checkbox path=\"hobby\" value=\"看电影\"&gt;&lt;/form:checkbox&gt;看电影&lt;br/&gt; &lt;form:checkbox path=\"hobby\" value=\"旅游\"&gt;&lt;/form:checkbox&gt;旅游&lt;br/&gt; &lt;form:checkbox path=\"hobby\" value=\"玩游戏\"&gt;&lt;/form:checkbox&gt;玩游戏&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; checkboxes &lt;form:checkboxes items=${student.hobby} path=\"selecHobby\"/&gt; 渲染的是 HTML 中的一组 &lt;input type=\"checkbox\"/&gt;，是对 &lt;form:checkbox/&gt; 的一种简化，需要结合 items 和 path 属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的集合或数组，可以这样理解，items 为全部可选集合，path 为默认的选中集合 (student 选择的 hobby 的数据)。 student.setHobby(Arrays.asList(\"摄影\",\"读书\",\"听音乐\",\"看电影\",\"旅游\",\"玩游戏\")); student.setSelectHobby(Arrays.asList(\"摄影\",\"读书\",\"听音乐\")); modelAndView.addObject(\"student\",student); 爱好：&lt;form:checkboxes path=\"selectHobby\" items=\"${student.hobby}\"/&gt;&lt;br/&gt; &lt;!-- items=\"${student.hobby}\" 只能这样写，规定--&gt; 需要注意的是 path 可以直接绑定模型数据的属性值，items 则需要通过 EL 表达式的形式从域对象中获取数据，不能直接写属性名。==items=”${student.hobby}” 只能这样写，规定== rad-iobutton &lt;form:radiobutton path=\"radioId\" value=\"0\"/&gt; 渲染的是 HTML 中的一个 &lt;input type=\"radio\"/&gt;，绑定的数据与标签的 value 值相等则为选中，否则不选中。 student.setRadioId(1); modelAndView.addObject(\"student\",student); radiobutton:&lt;form:radiobutton path=\"radioId\" value=\"1\"/&gt;radiobutton&lt;br/&gt; radiobuttons &lt;form:radiobuttons itmes=\"${student.grade}\" path=\"selectGrade\"/&gt; 渲染的是 HTML 中的一组 &lt;input type=\"radio\"/&gt;，这里需要结合 items 和 path 两个属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的值，items 为全部的可选类型，path 为默认选中的选项，用法与 &lt;form:checkboxes/&gt; 一致。 Map&lt;Integer,String&gt; gradeMap = new HashMap&lt;&gt;(); gradeMap.put(1,\"一年级\"); gradeMap.put(2,\"二年级\"); gradeMap.put(3,\"三年级\"); gradeMap.put(4,\"四年级\"); gradeMap.put(5,\"五年级\"); gradeMap.put(6,\"六年级\"); student.setGradeMap(gradeMap); student.setSelectGrade(3); modelAndView.addObject(\"student\",student); 学生年级：&lt;form:radiobuttons items=\"${student.gradeMap}\" path=\"selectGrade\"/&gt;&lt;br/&gt; select &lt;form:select items=\"${student.citys}\" path=\"selectCity\"/&gt; 渲染的是 HTML 中的一个 &lt;select/&gt; 标签，需要结合 items 和 path 两个属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的值，用法与 &lt;from:radiobuttons/&gt;一致。 Map&lt;Integer,String&gt; cityMap = new HashMap&lt;&gt;(); cityMap.put(1,\"北京\"); cityMap.put(2,\"上海\"); cityMap.put(3,\"广州\"); cityMap.put(4,\"深圳\"); student.setCityMap(cityMap); student.setSelectCity(3); modelAndView.addObject(\"student\",student); 所在城市：&lt;form:select items=\"${student.cityMap}\" path=\"selectCity\"&gt;&lt;/form:select&gt;&lt;br/&gt; options form:select 结合 form:options 的使用，from:select 只定义 path 属性，在 form:select 标签内部添加一个子标签 form:options ，设置 items 属性，获取被遍历的集合。 所在城市：&lt;form:select path=\"selectCity\"&gt; &lt;form:options items=\"${student.cityMap}\"&gt;&lt;/form:options&gt; &lt;/form:select&gt;&lt;br/&gt; option form:select 结合 form:option 的使用，from:select 定义 path 属性，给每一个 form:option 设置 value 值，path 的值与哪个 value 值相等，该项默认选中。 所在城市：&lt;form:select path=\"selectCity\"&gt; &lt;form:option value=\"1\"&gt;杭州&lt;/form:option&gt; &lt;form:option value=\"2\"&gt;成都&lt;/form:option&gt; &lt;form:option value=\"3\"&gt;西安&lt;/form:option&gt; &lt;/form:select&gt;&lt;br/&gt; textarea 渲染的是 HTML 中的一个 &lt;textarea/&gt; ，path 绑定模型数据的属性值，作为文本输入域的默认值。 student.setIntroduce(\"你好，我是...\"); modelAndView.addObject(\"student\",student); 信息：&lt;form:textarea path=\"introduce\"/&gt;&lt;br/&gt; errors 处理错误信息，一般用在数据校验，该标签需要结合 Spring MVC 的验证器结合起来使用。 Spring MVC 数据校验Spring MVC 提供了两种数据校验的方式：1、基于 Validator 接口。2、使用 Annotation JSR - 303 标准进行校验。 基于 Validator 接口的方式需要自定义 Validator 验证器，每一条数据的验证规则需要开发者手动完成，使用 Annotation JSR - 303 标准则不需要自定义验证器，通过注解的方式可以直接在实体类中添加每个属性的验证规则，这种方式更加方便，实际开发中推荐使用。 基于 Validator 接口 实体类 Account package com.southwind.entity; import lombok.Data; @Data public class Account { private String name; private String password; } 自定义验证器 AccountValidator，实现 Validator 接口。 package com.southwind.validator; import com.southwind.entity.Account; import org.springframework.validation.Errors; import org.springframework.validation.ValidationUtils; import org.springframework.validation.Validator; public class AccountValidator implements Validator { @Override public boolean supports(Class&lt;?&gt; aClass) { return Account.class.equals(aClass); } @Override public void validate(Object o, Errors errors) { ValidationUtils.rejectIfEmpty(errors,\"name\",null,\"姓名不能为空\"); ValidationUtils.rejectIfEmpty(errors,\"password\",null,\"密码不能为空\"); } } 控制器 package com.southwind.controller; import com.southwind.entity.Account; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.validation.BindingResult; import org.springframework.validation.annotation.Validated; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/validator\") public class ValidatorHandler { @GetMapping(\"/login\") public String login(Model model){ model.addAttribute(\"account\",new Account()); return \"login\"; } @PostMapping(\"/login\") public String login(@Validated Account account, BindingResult bindingResult){ if(bindingResult.hasErrors()){ return \"login\"; } return \"index\"; } } springmvc.xml 配置验证器。 &lt;bean id=\"accountValidator\" class=\"com.southwind.validator.AccountValidator\"&gt;&lt;/bean&gt; &lt;mvc:annotation-driven validator=\"accountValidator\"&gt;&lt;/mvc:annotation-driven&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-18 Time: 10:31 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=\"account\" action=\"/validator/login\" method=\"post\"&gt; 姓名：&lt;form:input path=\"name\"/&gt;&lt;form:errors path=\"name\"&gt;&lt;/form:errors&gt;&lt;br/&gt; 密码：&lt;form:input path=\"password\"/&gt;&lt;form:errors path=\"password\"&gt;&lt;/form:errors&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; Annotation JSR - 303 标准使用 Annotation JSR - 303 标准进行验证，需要导入支持这种标准的依赖 jar 文件，这里我们使用 Hibernate Validator。 pom.xml &lt;!-- JSR-303 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.3.6.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt; &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt; &lt;version&gt;3.3.2.Final&lt;/version&gt; &lt;/dependency&gt; 通过注解的方式直接在实体类中添加相关的验证规则。 package com.southwind.entity; import lombok.Data; import org.hibernate.validator.constraints.Email; import org.hibernate.validator.constraints.NotEmpty; import javax.validation.constraints.Pattern; import javax.validation.constraints.Size; @Data public class Person { @NotEmpty(message = \"用户名不能为空\") private String username; @Size(min = 6,max = 12,message = \"密码6-12位\") private String password; @Email(regexp = \"^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\\\\\\\\.[a-zA-Z0-9-]+)*\\\\\\\\.[a-zA-Z0-9]{2,6}$\",message = \"请输入正确的邮箱格式\") private String email; @Pattern(regexp = \"^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\\\\\\\\\\\\\\\d{8}$\",message = \"请输入正确的电话\") private String phone; } ValidatorHandler @GetMapping(\"/register\") public String register(Model model){ model.addAttribute(\"person\",new Person()); return \"register\"; } @PostMapping(\"/register\") public String register(@Valid Person person, BindingResult bindingResult){ if(bindingResult.hasErrors()){ return \"register\"; } return \"index\"; } springmvc.xml &lt;mvc:annotation-driven /&gt; 这里的配置必须单独配，即使上面已经配过，不配会不能正常验证。 JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-18 Time: 11:29 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=\"person\" action=\"/validator/register2\" method=\"post\"&gt; 用户名：&lt;form:input path=\"username\"&gt;&lt;/form:input&gt;&lt;form:errors path=\"username\"/&gt;&lt;br/&gt; 密码：&lt;form:password path=\"password\"&gt;&lt;/form:password&gt;&lt;form:errors path=\"password\"/&gt;&lt;br/&gt; 邮箱：&lt;form:input path=\"email\"&gt;&lt;/form:input&gt;&lt;form:errors path=\"email\"/&gt;&lt;br/&gt; 电话：&lt;form:input path=\"phone\"&gt;&lt;/form:input&gt;&lt;form:errors path=\"phone\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 校验规则详解： @Null 被注解的元素必须为null @NotNull 被注解的元素不能为null @Min(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注解的元素必须是一个数字，其值必须小于于等于指定的最大值 @Email 被注解的元素必须是电子邮箱地址 @Pattern 被注解的元素必须符合对应的正则表达式 @Length 被注解的元素的大小必须在指定的范围内 @NotEmpty 被注解的字符串的值必须非空 Null 和 Empty 是不同的结果，String str = null，str 是 null，String str = “”，str 不是 null，其值为空。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"SpringBoot","slug":"Spring Boot笔记","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:29:34.626Z","comments":true,"path":"posts/ea4e97sk.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e97sk.html","excerpt":"","text":"1、SpringBoot：Hello,World！1.1、回顾什么是SpringSpring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson 。 Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。 1.2、Spring是如何简化Java开发的为了降低Java开发的复杂性，Spring采用了以下4种关键策略： 1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean； 2、通过IOC，依赖注入（DI）和面向接口实现松耦合； 3、基于切面（AOP）和惯例进行声明式编程； 4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate； 1.3、什么是SpringBoot学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍； 言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。 所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。 是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件； Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。 Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 1.4、准备工作我们将学习如何快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。 我的环境准备： java version “1.8.0_181” Maven-3.6.1 SpringBoot 2.x 最新版 开发工具： IDEA 1.5、创建基础项目说明Spring官方提供了非常方便的工具让我们快速构建应用 Spring Initializr：https://start.spring.io/ 项目创建方式一：使用Spring Initializr 的 Web页面创建项目 1、打开 https://start.spring.io/ 2、填写项目信息 3、点击”Generate Project“按钮生成项目；下载此项目 4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。 5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。 项目创建方式二：使用 IDEA 直接创建项目 1、创建一个新项目 2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 3、填写项目信息 4、选择初始化的组件（初学勾选 Web 即可） 5、填写项目路径 6、等待项目构建成功 项目结构分析： 通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 1、程序的主启动类 2、一个 application.properties 配置文件 3、一个 测试类 4、一个 pom.xml 1.6、pom.xml 分析打开pom.xml，看看Spring Boot项目的依赖： &lt;!-- 父依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- web场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 剔除依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 打包插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 1.7、编写一个http接口1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到 2、在包中新建一个HelloController类 @RestController public class HelloController { @RequestMapping(\"/hello\") public String hello() { return \"Hello World\"; } } 3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！ 简单几步，就完成了一个web接口的开发，SpringBoot就是这么简单。所以我们常用它来建立我们的微服务项目！ 1.8、将项目打成jar包，点击 maven的 package 如果遇到以上错误，可以配置打包时 跳过项目运行测试用例 &lt;!-- 在工作中,很多情况下我们打包是不想执行测试用例的 可能是测试用例不完事,或是测试用例会影响数据库数据 跳过测试用例执行 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--跳过项目运行测试用例--&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; 彩蛋 如何更改启动时显示的字符拼成的字母，SpringBoot呢？也就是 banner 图案； 只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。 图案可以到：https://www.bootschool.net/ascii 这个网站生成，然后拷贝到文件中即可！ 2、SpringBoot：运行原理初探我们之前写的HelloSpringBoot，到底是怎么运行的呢，Maven项目，我们一般从pom.xml文件探究起； pom.xml 2.1、父依赖其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！ &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 点进去，发现还有一个父依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt; 这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心； 以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了； 2.2、启动器 spring-boot-starter&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; springboot-boot-starter-xxx：就是spring-boot的场景启动器 spring-boot-starter-web：帮我们导入了web模块正常运行所依赖的组件； SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter； 主启动类 分析完了 pom.xml 来看看这个启动类 2.3、默认的主启动类//@SpringBootApplication 来标注一个主程序类 //说明这是一个Spring Boot应用 @SpringBootApplication public class SpringbootApplication { public static void main(String[] args) { //以为是启动了一个方法，没想到启动了一个服务 SpringApplication.run(SpringbootApplication.class, args); } } 但是一个简单的启动类并不简单！我们来分析一下这些注解都干了什么 2.4、@SpringBootApplication作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 进入这个注解：可以看到上面还有很多其他注解！ @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) public @interface SpringBootApplication { // ...... } 2.5、@ComponentScan这个注解在Spring中很重要 ,它对应XML配置中的元素。 作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中 2.6、@SpringBootConfiguration作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类； 我们继续进去这个注解查看 // 点@Configuration进去得到下面的 @Component @Configuration public @interface SpringBootConfiguration {} @Component public @interface Configuration {} 这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件； 里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！ 我们回到 SpringBootApplication 注解中继续看。 2.7、@EnableAutoConfiguration@EnableAutoConfiguration ：开启自动配置功能 以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效； 点进注解接续查看： @AutoConfigurationPackage ：自动配置包 @Import({Registrar.class}) public @interface AutoConfigurationPackage { } @import ：Spring底层注解@import ， 给容器中导入一个组件 Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ； 这个分析完了，退到上一步，继续看 @Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ； AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码： 1、这个类中有一个这样的方法 // 获得候选的配置 protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { //这里的getSpringFactoriesLoaderFactoryClass（）方法 //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"); return configurations; } 2、这个方法又调用了 SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法 public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) { String factoryClassName = factoryClass.getName(); //这里它又调用了 loadSpringFactories 方法 return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList()); } 3、我们继续点击查看 loadSpringFactories 方法 private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) { //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身 MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) { return result; } else { try { //去获取一个资源 \"META-INF/spring.factories\" Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\"); LinkedMultiValueMap result = new LinkedMultiValueMap(); //将读取到的资源遍历，封装成为一个Properties while(urls.hasMoreElements()) { URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) { Entry&lt;?, ?&gt; entry = (Entry)var6.next(); String factoryClassName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for(int var11 = 0; var11 &lt; var10; ++var11) { String factoryName = var9[var11]; result.add(factoryClassName, factoryName.trim()); } } } cache.put(classLoader, result); return result; } catch (IOException var13) { throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var13); } } } 4、发现一个多次出现的文件：spring.factories，全局搜索它 2.8、spring.factories我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！ WebMvcAutoConfiguration 我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration 可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！ 所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。 结论： SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作； 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中； 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ； 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作； 现在大家应该大概的了解了下，SpringBoot的运行原理，后面我们还会深化一次！ SpringApplication 2.9、不简单的方法我最初以为就是运行了一个main方法，没想到却开启了一个服务； @SpringBootApplication public class SpringbootApplication { public static void main(String[] args) { SpringApplication.run(SpringbootApplication.class, args); } } SpringApplication.run分析 分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行； 2.10、SpringApplication这个类主要做了以下四件事情： 1、推断应用的类型是普通的项目还是Web项目 2、查找并加载所有可用初始化器 ， 设置到initializers属性中 3、找出所有的应用程序监听器，设置到listeners属性中 4、推断并设置main方法的定义类，找到运行的主类 查看构造器： public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) { // ...... this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.setInitializers(this.getSpringFactoriesInstances(); this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = this.deduceMainApplicationClass(); } 2.11、run方法流程分析跟着源码和这幅图就可以一探究竟了！ 3、SpringBoot：yaml配置注入yaml语法学习 3.1、配置文件SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key=value application.yml 语法结构 ：key：空格 value 配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了； 比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！ server.port=8081 3.2、yaml概述YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言） 这种语言以数据\\**作**\\为中心，而不是以标记语言为重点！** 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml 传统xml配置： &lt;server&gt; &lt;port&gt;8081&lt;port&gt; &lt;/server&gt; yaml配置： server： prot: 8080 3.3、yaml基础语法说明：语法要求严格！ 1、空格不能省略 2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 3、属性和值的大小写都是十分敏感的。 字面量：普通的值 [ 数字，布尔值，字符串 ] 字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号； k: v 注意： “ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思； 比如 ：name: “kuang \\n shen” 输出 ：kuang 换行 shen ‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出 比如 ：name: ‘kuang \\n shen’ 输出 ：kuang \\n shen 对象、Map（键值对） #对象、Map格式 map: key1: value1 key2: value2 在下一行来写对象的属性和值得关系，注意缩进；比如： student: name: qinjiang age: 3 行内写法 student: {name: qinjiang,age: 3} 数组（ List、set ） 用 - 值表示数组中的一个元素,比如： pets: - cat - dog - pig 行内写法 pets: [cat,dog,pig] 修改SpringBoot的默认端口号 配置文件中添加，端口号的参数，就可以切换端口； server: port: 8082 注入配置文件 yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！ 3.4、yaml注入配置文件1、在springboot项目中的resources目录下新建一个文件 application.yml 2、编写一个实体类 Dog； package com.kuang.springboot.pojo; @Component //注册bean到容器中 public class Dog { private String name; private Integer age; //有参无参构造、get、set方法、toString()方法 } 3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下： @Component //注册bean public class Dog { @Value(\"阿黄\") private String name; @Value(\"18\") private Integer age; } 4、在SpringBoot的测试类下注入狗狗输出一下； @SpringBootTest class DemoApplicationTests { @Autowired //将狗狗自动注入进来 Dog dog; @Test public void contextLoads() { System.out.println(dog); //打印看下狗狗对象 } } 结果成功输出，@Value注入成功，这是我们原来的办法对吧。 5、我们在编写一个复杂一点的实体类：Person 类 @Component //注册bean到容器中 public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; //有参无参构造、get、set方法、toString()方法 } 6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！ person: name: qinjiang age: 3 happy: false birth: 2000/01/01 maps: {k1: v1,k2: v2} lists: - code - girl - music dog: name: 旺财 age: 1 7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！ /* @ConfigurationProperties作用： 将配置文件中配置的每一个属性的值，映射到这个组件中； 告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定 参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应 */ @Component //注册bean @ConfigurationProperties(prefix = \"person\") public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; } 8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！ &lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 9、确认以上配置都OK之后，我们去测试类中测试一下： @SpringBootTest class DemoApplicationTests { @Autowired Person person; //将person自动注入进来 @Test public void contextLoads() { System.out.println(person); //打印person信息 } } 结果：所有值全部注入成功！ yaml配置注入到实体类完全OK！ 3.5、加载指定的配置文件@PropertySource ：加载指定的配置文件； @configurationProperties：默认从全局配置文件中获取值； 1、我们去在resources目录下新建一个person.properties文件 name=kuangshen 2、然后在我们的代码中指定加载person.properties文件 @PropertySource(value = \"classpath:person.properties\") @Component //注册bean public class Person { @Value(\"${name}\") private String name; ...... } 3、再次输出测试一下：指定配置文件绑定成功！ 3.6、配置文件占位符配置文件还可以编写占位符生成随机数 person: name: qinjiang${random.uuid} # 随机uuid age: ${random.int} # 随机int happy: false birth: 2000/01/01 maps: {k1: v1,k2: v2} lists: - code - girl - music dog: name: ${person.hello:other}_旺财 #如果person有hello属性，则前缀为hello的值，否则前缀为other age: 1 3.7、回顾properties配置我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！ 【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8； settings–&gt;FileEncodings 中配置； 测试步骤： 1、新建一个实体类User @Component //注册bean public class User { private String name; private int age; private String sex; } 2、编辑配置文件 user.properties user1.name=kuangshen user1.age=18 user1.sex=男 3、我们在User类上使用@Value来进行注入！ @Component //注册bean @PropertySource(value = \"classpath:user.properties\") public class User { //直接使用@value @Value(\"${user.name}\") //从配置文件中取值 private String name; @Value(\"#{9*2}\") // #{SPEL} Spring表达式 private int age; @Value(\"男\") // 字面量 private String sex; } 4、Springboot测试 user1.name=kuangshen user1.age=18 user1.sex=男 结果正常输出： 3.8、对比小结@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图 1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加 2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下 3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性 4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持 结论： 配置yml和配置properties都可以获取到值 ， 强烈推荐 yml； 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value； 如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！ 4、SpringBoot：JSR303数据校验及多环境切换JSR303数据校验 4.1、先看看如何使用Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式； @Component //注册bean @ConfigurationProperties(prefix = \"person\") @Validated //数据校验 public class Person { @Email(message=\"邮箱格式错误\") //这样子name必须是邮箱格式 private String name; } 运行结果 ：default message [不是一个合法的电子邮件地址]; 使用数据校验，可以保证数据的正确性； 4.2、常见参数@NotNull(message=\"名字不能为空\") private String userName; @Max(value=120,message=\"年龄最大不能查过120\") private int age; @Email(message=\"邮箱格式错误\") private String email; 空检查 @Null 验证对象是否为null @NotNull 验证对象是否不为null, 无法查检长度为0的字符串 @NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格. @NotEmpty 检查约束元素是否为NULL或者是EMPTY. Booelan检查 @AssertTrue 验证 Boolean 对象是否为 true @AssertFalse 验证 Boolean 对象是否为 false 长度检查 @Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) 验证字符串长度是否在给定范围内 日期检查 @Past 验证 Date 和 Calendar 对象是否在当前时间之前 @Future 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern 验证 String 对象是否符合正则表达式的规则 .......等等 除此以外，我们还可以自定义一些数据校验规则 多环境切换 profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境； 4.3、多配置文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本； 例如： application-test.properties 代表测试环境配置 application-dev.properties 代表开发环境配置 但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件； 我们需要通过一个配置来选择需要激活的环境： #比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试； #我们启动SpringBoot，就可以看到已经切换到dev下的配置了； spring.profiles.active=dev 4.4、yaml的多文档块和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 ! server: port: 8081 #选择要激活那个环境块 spring: profiles: active: prod --- server: port: 8083 spring: profiles: dev #配置环境的名称 --- server: port: 8084 spring: profiles: prod #配置环境的名称 注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！ 4.5、配置文件加载位置外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！ springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件： 优先级1：项目路径下的config文件夹配置文件 优先级2：项目路径下配置文件 优先级3：resources资源路径下的config文件夹配置文件 优先级4：resources资源路径下配置文件 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； 我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题； #配置项目的访问路径 server.servlet.context-path=/kuang 4.6、拓展，运维小技巧指定位置加载配置文件 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高 5、SpringBoot：自动配置原理自动配置原理 配置文件到底能写什么？怎么写？ SpringBoot官方文档中有大量的配置，我们无法全部记住 5.1、分析自动配置原理我们以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； //表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件； @Configuration //启动指定类的ConfigurationProperties功能； //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； //并把HttpProperties加入到ioc容器中 @EnableConfigurationProperties({HttpProperties.class}) //Spring底层@Conditional注解 //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效 @ConditionalOnWebApplication( type = Type.SERVLET ) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器； @ConditionalOnClass({CharacterEncodingFilter.class}) //判断配置文件中是否存在某个配置：spring.http.encoding.enabled； //如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的； @ConditionalOnProperty( prefix = \"spring.http.encoding\", value = {\"enabled\"}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器有没有这个组件，没有则执行下面方法 public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; } //。。。。。。。 } 一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！ 一但这个配置类生效；这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 //从配置文件中获取指定的值和bean的属性进行绑定 @ConfigurationProperties(prefix = \"spring.http\") public class HttpProperties { // ..... } 我们去配置文件里面试试前缀，看提示！ 这就是自动装配的原理！ 5.2、精髓1、SpringBoot启动会加载大量的自动配置类 2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中； 3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了） 4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可； xxxxAutoConfigurartion：自动配置类；给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 5.3、了解：@Conditional了解完自动装配的原理后，我们来关注一个细节问题，自动配置类必须在一定的条件下才能生效； @Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效； 那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。 我们怎么知道哪些自动配置类生效？ 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； #开启springboot的调试类 debug=true Positive matches:（自动配置类启用的：正匹配） Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配） Unconditional classes: （没有条件的类） 【演示：查看输出的日志】 6、SpringBoot：自定义starter 为什么要自定义starter 在我们的日常开发工作中，经常会有一些独立于业务之外的配置模块，我们经常将其放到一个特定的包下，然后如果另一个工程需要复用这块功能的时候，需要将代码硬拷贝到另一个工程，重新集成一遍，麻烦至极。如果我们将这些可独立于业务代码之外的功配置模块封装成一个个starter，复用的时候只需要将其在pom中引用依赖即可，SpringBoot为我们完成自动装配，简直不要太爽。 6.1、说明启动器模块是一个 空 jar（就是我们下面创建的maven项目，相当于一个索引，这样子maven可以引入其他模块功能，如果只创建springboot项目的话就不太好扩展功能） 文件，仅提供辅助性依赖管理，这些依赖可能用于自动装配或者其他类库； 命名归约： 官方命名： 前缀：spring-boot-starter-xxx 比如：spring-boot-starter-web…. 自定义命名： xxx-spring-boot-starter 比如：mybatis-spring-boot-starter 6.2、编写启动器1、在IDEA中新建一个空项目 spring-boot-starter-diy 2、新建一个普通Maven模块：kuang-spring-boot-starter 3、新建一个Springboot模块：kuang-spring-boot-starter-autoconfigure 4、点击apply即可，基本结构 5、在我们的 starter 中 导入 autoconfigure 的依赖！ &lt;!-- 启动器 --&gt; &lt;dependencies&gt; &lt;!-- 引入自动配置模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;artifactId&gt;kuang-spring-boot-starter-autoconfigure&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 6、将 autoconfigure 项目下多余的文件都删掉（test文件也删掉），Pom中只留下一个 starter（build也去掉），这是所有的启动器基本配置！ &lt;!-- 导入消除注解警告提示 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 7、在 autoconfigure 项目下，我们编写一个自己的服务 package com.kuang; public class HelloService { HelloProperties helloProperties; public HelloProperties getHelloProperties() { return helloProperties; } public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; } public String sayHello(String name){ return helloProperties.getPrefix() + name + helloProperties.getSuffix(); } } 8、在 autoconfigure 项目下，编写HelloProperties 配置类 package com.kuang; import org.springframework.boot.context.properties.ConfigurationProperties; // 前缀 kuang.hello @ConfigurationProperties(prefix = \"kuang.hello\") public class HelloProperties { private String prefix; private String suffix; public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; } } 9、在 autoconfigure 项目下，编写我们的自动配置类并注入bean，测试！ package com.kuang; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @ConditionalOnWebApplication //web应用生效 @EnableConfigurationProperties(HelloProperties.class) public class HelloServiceAutoConfiguration { @Autowired HelloProperties helloProperties; @Bean public HelloService helloService(){ HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; } } 10、在 autoconfigure 项目下，在resources编写一个自己的 META-INF\\spring.factories # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.kuang.HelloServiceAutoConfiguration 11、编写完成后，可以安装到maven仓库中！先安装autoconfigure 项目，再安装starter项目 我们也可以只建一个springboot项目，然后跟上面一样pom配置，删掉一些冗余的东西，编写好业务代码，然后直接maven安装jar包到本地仓库，新建springboot项目导入该jar包依赖（注意版本快照号），进行starter设置，进行测试成功。 6.3、新建项目测试我们自己写的启动器1、新建一个SpringBoot 项目 2、导入我们自己写的启动器 &lt;dependency&gt; &lt;groupId&gt;com.kuang&lt;/groupId&gt; &lt;artifactId&gt;kuang-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 3、编写一个 HelloController 进行测试我们自己的写的接口！ package com.kuang.controller; @RestController public class HelloController { @Autowired HelloService helloService; @RequestMapping(\"/hello\") public String hello(){ return helloService.sayHello(\"zxc\"); } } 4、编写配置文件 application.properties kuang.hello.prefix=\"ppp\" kuang.hello.suffix=\"sss\" 5、启动项目进行测试，结果成功 ! 7、SpringBoot整合JDBC7.1、SpringData简介对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。 Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。 Sping Data 官网：https://spring.io/projects/spring-data 数据库相关的启动器 ：可以参考官方文档： https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter 整合JDBC 7.2、创建测试项目测试数据源1、我去新建一个项目测试：springboot-data-jdbc ; 引入相应的模块！基础模块 2、项目建好之后，发现自动帮我们导入了如下的启动器 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 3、编写yaml配置文件连接数据库； spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver 4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下 @SpringBootTest class SpringbootDataJdbcApplicationTests { //DI注入数据源 @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException { //看一下默认数据源 System.out.println(dataSource.getClass()); //获得连接 Connection connection = dataSource.getConnection(); System.out.println(connection); //关闭连接 connection.close(); } } 结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置 我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件： @Import( {Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class} ) protected static class PooledDataSourceConfiguration { protected PooledDataSourceConfiguration() { } } 这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源； HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀； 可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。 关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate 7.3、JDBCTemplate1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库； 2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。 3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。 4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用 5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类 JdbcTemplate主要提供以下几类方法： execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句； update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句； query方法及queryForXXX方法：用于执行查询相关语句； call方法：用于执行存储过程、函数相关语句。 7.4、测试编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试； package com.kuang.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.Date; import java.util.List; import java.util.Map; @RestController @RequestMapping(\"/jdbc\") public class JdbcController { /** * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作 * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接 */ @Autowired JdbcTemplate jdbcTemplate; //查询employee表中所有数据 //List 中的1个 Map 对应数据库的 1行数据 //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值 @GetMapping(\"/list\") public List&lt;Map&lt;String, Object&gt;&gt; userList(){ String sql = \"select * from employee\"; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql); return maps; } //新增一个用户 @GetMapping(\"/add\") public String addUser(){ //插入语句，注意时间问题 String sql = \"insert into employee(last_name, email,gender,department,birth)\" + \" values ('狂神说','24736743@qq.com',1,101,'\"+ new Date().toLocaleString() +\"')\"; jdbcTemplate.update(sql); //查询 return \"addOk\"; } //修改用户信息 @GetMapping(\"/update/{id}\") public String updateUser(@PathVariable(\"id\") int id){ //插入语句 String sql = \"update employee set last_name=?,email=? where id=\"+id; //数据 Object[] objects = new Object[2]; objects[0] = \"秦疆\"; objects[1] = \"24736743@sina.com\"; jdbcTemplate.update(sql,objects); //查询 return \"updateOk\"; } //删除用户 @GetMapping(\"/delete/{id}\") public String delUser(@PathVariable(\"id\") int id){ //插入语句 String sql = \"delete from employee where id=?\"; jdbcTemplate.update(sql,id); //查询 return \"deleteOk\"; } } 测试请求，结果正常； 到此，CURD的基本操作，使用 JDBC 就搞定了。https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#using-boot-starter) 7.5、原理探究 ：org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration 数据源配置类作用 ：根据逻辑判断之后，添加数据源； SpringBoot默认支持以下数据源： com.zaxxer.hikari.HikariDataSource （Spring Boot 2.0 以上，默认使用此数据源） org.apache.tomcat.jdbc.pool.DataSource org.apache.commons.dbcp2.BasicDataSource 可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。默认情况下，它是从类路径自动检测的。 @Configuration @ConditionalOnMissingBean({DataSource.class}) @ConditionalOnProperty( name = {\"spring.datasource.type\"} ) static class Generic { Generic() { } @Bean public DataSource dataSource(DataSourceProperties properties) { return properties.initializeDataSourceBuilder().build(); } } 8、SpringBoot整合Druid8.1、Druid简介Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。 Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。 Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。 Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。 Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。 Github地址：https://github.com/alibaba/druid/ com.alibaba.druid.pool.DruidDataSource 基本配置参数如下： 配置 缺省值 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-“ + System.identityHashCode(this). 另外配置此属性至少在1.0.5版本中是不起作用的，强行设置name会出错 。 url 连接数据库的url，不同数据库不一样。例如： mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/使用ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 validationQueryTimeout 单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 1分钟（1.0.14） 有两个含义： 1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接 2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis 30分钟（1.0.14） 连接保持空闲而不被驱逐的最长时间 connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall proxyFilters 类型是List&lt;com.alibaba.druid.filter.Filter&gt;，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 8.2、配置数据源1、添加上 Druid 数据源依赖。 &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.23&lt;/version&gt; &lt;/dependency&gt; 2、切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源。 spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源 3、数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换； 4、切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码 spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 5、导入Log4j 的依赖 &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 6、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性； package com.kuang.config; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; @Configuration public class DruidConfig { /* 将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建 绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效 @ConfigurationProperties(prefix = \"spring.datasource\")：作用就是将 全局配置文件中 前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中 */ @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druidDataSource() { return new DruidDataSource(); } } 7、去测试类中测试一下；看是否成功！ @SpringBootTest class SpringbootDataJdbcApplicationTests { //DI注入数据源 @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException { //看一下默认数据源 System.out.println(dataSource.getClass()); //获得连接 Connection connection = dataSource.getConnection(); System.out.println(connection); DruidDataSource druidDataSource = (DruidDataSource) dataSource; System.out.println(\"druidDataSource 数据源最大连接数：\" + druidDataSource.getMaxActive()); System.out.println(\"druidDataSource 数据源初始化连接数：\" + druidDataSource.getInitialSize()); //关闭连接 connection.close(); } } 输出结果 ：可见配置参数已经生效！ 8.3、配置Druid数据源监控Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。 所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理； //配置 Druid 监控管理后台的Servlet； //内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式 @Bean public ServletRegistrationBean statViewServlet() { ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\", \"admin\"); //后台管理界面的登录账号 initParams.put(\"loginPassword\", \"123456\"); //后台管理界面的登录密码 //后台允许谁可以访问 //initParams.put(\"allow\", \"localhost\")：表示只有本机可以访问 //initParams.put(\"allow\", \"\")：为空或者为null时，表示允许所有访问 initParams.put(\"allow\", \"\"); //deny：Druid 后台拒绝谁访问 //initParams.put(\"kuangshen\", \"192.168.1.20\");表示禁止此ip访问 //设置初始化参数 bean.setInitParameters(initParams); return bean; } 配置完毕后，我们可以选择访问 ：http://localhost:8080/druid/login.html 进入之后 配置 Druid web 监控 filter 过滤器 //配置 Druid 监控 之 web 监控的 filter //WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计 @Bean public FilterRegistrationBean webStatFilter() { FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\", \"*.js,*.css,/druid/*,/jdbc/*\"); bean.setInitParameters(initParams); //\"/*\" 表示过滤所有请求 bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; } 平时在工作中，按需求进行配置即可，主要用作监控 9、SpringBoot 整合mybatis9.1、导入mybatis所需要的依赖&lt;!-- 引入 myBatis，这是 MyBatis官方提供的适配 Spring Boot 的，而不是Spring Boot自己的--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; 9.2、配置数据库连接信息spring.datasource.username=root spring.datasource.password=123456 spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.driver-class-name=com.mysql.jdbc.Driver 9.3、我们这里就是用默认的数据源了；先去测试一下连接是否成功！@RunWith(SpringRunner.class) @SpringBootTest public class SpringbootDemoMybatisApplicationTests { @Autowired DataSource dataSource; @Test public void contextLoads() throws SQLException { System.out.println(\"数据源&gt;&gt;&gt;&gt;&gt;&gt;\" + dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(\"连接&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" + connection); System.out.println(\"连接地址&gt;&gt;&gt;&gt;&gt;\" + connection.getMetaData().getURL()); connection.close(); } } 查看输出结果，数据库配置OK！ 9.4、创建实体类package com.kuang.mybatis.pojo; public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '}'; } } 9.5、配置Mapper接口类package com.kuang.mybatis.pojo.mapper; import com.kuang.mybatis.pojo.User; import org.apache.ibatis.annotations.Mapper; import org.springframework.stereotype.Repository; import java.util.List; //@Mapper : 表示本类是一个 MyBatis 的 Mapper，等价于以前 Spring 整合 MyBatis 时的 Mapper 接口 @Mapper @Repository public interface UserMapper { //选择全部用户 List&lt;User&gt; selectUser(); //根据id选择用户 User selectUserById(int id); //添加一个用户 int addUser(User user); //修改一个用户 int updateUser(User user); //根据id删除用户 int deleteUser(int id); } 9.6、对应Mapper映射文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.kuang.mybatis.pojo.mapper.UserMapper\"&gt; &lt;select id=\"selectUser\" resultType=\"User\"&gt; select * from user &lt;/select&gt; &lt;select id=\"selectUserById\" resultType=\"User\"&gt; select * from user where id = #{id} &lt;/select&gt; &lt;insert id=\"addUser\" parameterType=\"User\"&gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) &lt;/insert&gt; &lt;update id=\"updateUser\" parameterType=\"User\"&gt; update user set name=#{name},pwd=#{pwd} where id = #{id} &lt;/update&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; delete from user where id = #{id} &lt;/delete&gt; &lt;/mapper&gt; 9.7、maven配置资源过滤问题&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; 9.8、SpringBoot 整合！以前 MyBatis 未与 spring 整合时，配置数据源、事务、连接数据库的账号、密码等都是在 myBatis 核心配置文件中进行的myBatis 与 spring 整合后，配置数据源、事务、连接数据库的账号、密码等就交由 spring 管理。因此，在这里我们即使不使用mybatis配置文件也完全ok！既然已经提供了 myBatis 的映射配置文件，自然要告诉 spring boot 这些文件的位置 spring.datasource.username=root spring.datasource.password=123456 spring.datasource.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.driver-class-name=com.mysql.jdbc.Driver #指定myBatis的核心配置文件与Mapper映射文件 mybatis.mapper-locations=classpath:mybatis/mapper/*.xml # 注意：对应实体类的路径 mybatis.type-aliases-package=com.kuang.mybatis.pojo 已经说过 spring boot 官方并没有提供 myBaits 的启动器，是 myBatis 官方提供的开发包来适配的 spring boot，从 pom.xml 文件中的依赖包名也能看出来，并非是以 spring-boot 开头的； 同理上面全局配置文件中的这两行配置也是以 mybatis 开头 而非 spring 开头也充分说明这些都是 myBatis 官方提供的 可以从 org.mybatis.spring.boot.autoconfigure.MybatisProperties 中查看所有配置项 @ConfigurationProperties( prefix = \"mybatis\" ) public class MybatisProperties { public static final String MYBATIS_PREFIX = \"mybatis\"; private static final ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver(); private String configLocation; private String[] mapperLocations; private String typeAliasesPackage; private Class&lt;?&gt; typeAliasesSuperType; private String typeHandlersPackage; private boolean checkConfigLocation = false; private ExecutorType executorType; private Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver; private Properties configurationProperties; @NestedConfigurationProperty private Configuration configuration; 也可以直接去查看 官方文档 9.9、编写controllerpackage com.kuang.mybatis.controller; import com.kuang.mybatis.pojo.User; import com.kuang.mybatis.pojo.mapper.UserMapper; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; @RestController public class UserController { @Autowired private UserMapper userMapper; //选择全部用户 @GetMapping(\"/selectUser\") public String selectUser(){ List&lt;User&gt; users = userMapper.selectUser(); for (User user : users) { System.out.println(user); } return \"ok\"; } //根据id选择用户 @GetMapping(\"/selectUserById\") public String selectUserById(){ User user = userMapper.selectUserById(1); System.out.println(user); return \"ok\"; } //添加一个用户 @GetMapping(\"/addUser\") public String addUser(){ userMapper.addUser(new User(5,\"阿毛\",\"456789\")); return \"ok\"; } //修改一个用户 @GetMapping(\"/updateUser\") public String updateUser(){ userMapper.updateUser(new User(5,\"阿毛\",\"421319\")); return \"ok\"; } //根据id删除用户 @GetMapping(\"/deleteUser\") public String deleteUser(){ userMapper.deleteUser(5); return \"ok\"; } } 9.10、启动项目访问进行测试！步骤： Mybatis整合包 mybatis-spring-boot-starter 1.导入包 2.配置文件 3.mybatis配置 4.编写sql 5.service层调用dao层 6.controller调用service层 注：配置数据库连接信息（不变）spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址： https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 10、SpringBoot：Web开发静态资源处理Web开发探究 10.1、简介其实SpringBoot的东西用起来非常简单，因为SpringBoot最大的特点就是自动装配。 使用SpringBoot的步骤： 1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好 2、手动在配置文件中配置部分配置项目就可以运行起来了 3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。 要熟悉掌握开发，之前学习的自动配置的原理一定要搞明白！ 比如SpringBoot到底帮我们配置了什么？我们能不能修改？我们能修改哪些配置？我们能不能扩展？ 向容器中自动配置组件 ：*** Autoconfiguration 自动配置类，封装配置文件的内容：***Properties 没事就找找类，看看自动装配原理！ 静态资源处理 10.2、静态资源映射规则首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！ 写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？ 如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！ 我们先来聊聊这个静态资源映射规则： SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面； 我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法； 有一个方法：addResourceHandlers 添加资源处理 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //如果自己在properties中定义了静态资源扫描路径 if (!this.resourceProperties.isAddMappings()) { // 禁用默认资源处理 logger.debug(\"Default resource handling disabled\"); return; } // 缓存控制 Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); // webjars 配置，需要导入webjars的依赖 if (!registry.hasMappingForPattern(\"/webjars/**\")) { customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } // 静态资源配置 String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } } 读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源； 10.3、什么是webjars 呢？Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。 使用SpringBoot需要使用Webjars，我们可以去搜索一下： 网站：https://www.webjars.org 要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！ &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; 导入完毕，查看webjars目录结构，并访问Jquery.js文件！ 访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：http://localhost:8080/webjars/jquery/3.4.1/jquery.js 10.4、第二种静态资源映射规则那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码； 我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析： // 进入方法 public String[] getStaticLocations() { return this.staticLocations; } // 找到对应的值 private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; // 找到路径 private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" }; ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。 所以得出结论，以下四个目录存放的静态资源可以被我们识别： \"classpath:/META-INF/resources/\" //根目录resources \"classpath:/resources/\" \"classpath:/static/\" \"classpath:/public/\" // 优先级：resources&gt;static&gt;public 我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件； 比如我们访问 http://localhost:8080/1.js , 他就会去这些文件夹中寻找对应的静态资源文件； 10.5、自定义静态资源路径我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置； spring.resources.static-locations=classpath:/coding/,classpath:/kuang/ 一旦自己定义了静态文件夹的路径，原来的自动路径配置就都会失效了！ 首页处理 静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！ @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService,ResourceUrlProvider mvcResourceUrlProvider) { WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页 this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); return welcomePageHandlerMapping; } 点进去继续看 private Optional&lt;Resource&gt; getWelcomePage() { String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations()); // ::是java8 中新引入的运算符 // Class::function的时候function是属于Class的，应该是静态方法。 // this::function的funtion是属于这个对象的。 // 简而言之，就是一种语法糖而已，是一种简写 return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst(); } // 欢迎页就是一个location下的的 index.html 而已 private Resource getIndexHtml(String location) { return this.resourceLoader.getResource(location + \"index.html\"); } 欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。 \"classpath:/resources/\" \"classpath:/static/\" \"classpath:/public/\" 比如我访问 http://localhost:8080/ ，就会找静态资源文件夹下的 index.html 新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试 http://localhost:8080/ 看结果！ 关于网站图标说明（高版本不支持，高版本直接在静态资源下放favicon.ico就行）： 与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。 1、关闭SpringBoot默认图标 #关闭默认图标 spring.mvc.favicon.enabled=false 2、自己放一个图标在静态资源目录下，可以放在 public 目录下 3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！ 11、SpringBoot：Thymeleaf模板引擎11.1、模板引擎前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。 jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的。 那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？ SpringBoot推荐你可以来使用模板引擎： 模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图： 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。 我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。 11.2、引入Thymeleaf怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址： Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf Spring官方文档：找到我们对应的版本 https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter 找到对应的pom依赖：可以适当点进源码看下本来的包！ &lt;!--thymeleaf--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; Maven会自动下载jar包，我们可以去看下下载的东西； 11.3、Thymeleaf分析前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？ 我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。 我们去找一下Thymeleaf的自动配置类：ThymeleafPropert @ConfigurationProperties( prefix = \"spring.thymeleaf\" ) public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; private Charset encoding; } 我们可以在其中看到默认的前缀和后缀！ 我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。 使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！ 测试 1、编写一个TestController @Controller public class TestController { @RequestMapping(\"/t1\") public String test1(){ //classpath:/templates/test.html return \"test\"; } } 2、编写一个测试页面 test.html 放在 templates 目录下 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;测试页面&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 3、启动项目请求测试 11.4、Thymeleaf 语法学习要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下； Thymeleaf 官网：https://www.thymeleaf.org/ ， 简单看一下官网！我们去下载Thymeleaf的官方文档！ 我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示 1、修改测试请求，增加数据传输； @RequestMapping(\"/t1\") public String test1(Model model){ //存入数据 model.addAttribute(\"msg\",\"Hello,Thymeleaf\"); //classpath:/templates/test.html return \"test\"; } 2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。 我们可以去官方文档的#3中看一下命名空间拿来过来： xmlns:th=\"http://www.thymeleaf.org\" 3、我们去编写下前端页面 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;测试页面&lt;/h1&gt; &lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt; &lt;div th:text=\"${msg}\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 4、启动测试！ OK，入门搞定，我们来认真研习一下Thymeleaf的使用语法！ 1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！ 2、我们能写哪些表达式呢？ Simple expressions:（表达式语法） Variable Expressions: ${...}：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象：#18 #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 3）、内置的一些工具对象： #execInfo : information about the template being processed. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. ================================================================================== Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样； Message Expressions: #{...}：获取国际化内容 Link URL Expressions: @{...}：定义URL； Fragment Expressions: ~{...}：片段引用表达式 Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is ${name}| Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): - Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne ) Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) Special tokens: No-Operation: _ 练习测试： 1、 我们编写一个Controller，放一些数据 @RequestMapping(\"/t2\") public String test2(Map&lt;String,Object&gt; map){ //存入数据 map.put(\"msg\",\"&lt;h1&gt;Hello&lt;/h1&gt;\"); map.put(\"users\", Arrays.asList(\"qinjiang\",\"kuangshen\")); //classpath:/templates/test.html return \"test\"; } 2、测试页面取出数据 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;狂神说&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;测试页面&lt;/h1&gt; &lt;div th:text=\"${msg}\"&gt;&lt;/div&gt; &lt;!--不转义--&gt; &lt;div th:utext=\"${msg}\"&gt;&lt;/div&gt; &lt;!--遍历数据--&gt; &lt;!--th:each每次遍历都会生成当前这个标签--&gt; &lt;h4 th:each=\"user :${users}\" th:text=\"${user}\"&gt;&lt;/h4&gt; &lt;h4&gt; &lt;!--行内写法,不推荐--&gt; &lt;span th:each=\"user:${users}\"&gt;[[${user}]]&lt;/span&gt; &lt;/h4&gt; &lt;/body&gt; &lt;/html&gt; 3、启动项目测试！ 我们看完语法，很多样式，我们即使现在学习了，也会忘记，所以我们在学习过程中，需要使用什么，根据官方文档来查询，才是最重要的，要熟练使用官方文档！ 12、SpringBoot：MVC自动配置原理12.1、官网阅读在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。 只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！ 地址 ：https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration Spring MVC Auto-configuration // Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。 Spring Boot provides auto-configuration for Spring MVC that works well with most applications. // 自动配置在Spring默认设置的基础上添加了以下功能： The auto-configuration adds the following features on top of Spring’s defaults: // 包含视图解析器 Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. // 支持静态资源文件夹的路径，以及webjars Support for serving static resources, including support for WebJars // 自动注册了Converter： // 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把\"1\"字符串自动转换为int类型 // Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】 Automatic registration of Converter, GenericConverter, and Formatter beans. // HttpMessageConverters // SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释； Support for HttpMessageConverters (covered later in this document). // 定义错误代码生成规则的 Automatic registration of MessageCodesResolver (covered later in this document). // 首页定制 Static index.html support. // 图标定制 Custom Favicon support (covered later in this document). // 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！ Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). /* 如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。 */ If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. // 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？ 12.2、ContentNegotiatingViewResolver 内容协商视图解析器自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器； 即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。 我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！ @Bean @ConditionalOnBean(ViewResolver.class) @ConditionalOnMissingBean(name = \"viewResolver\", value = ContentNegotiatingViewResolver.class) public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) { ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级 resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver; } 我们可以点进这类看看！找到对应的解析视图的代码； @Nullable // 注解说明：@Nullable 即参数可为null public View resolveViewName(String viewName, Locale locale) throws Exception { RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, \"No current ServletRequestAttributes\"); List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest()); if (requestedMediaTypes != null) { // 获取候选的视图对象 List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes); // 选择一个最适合的视图对象，然后把这个对象返回 View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) { return bestView; } } // ..... } 我们继续点进去看，他是怎么获得候选的视图的呢？ getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！ Iterator var5 = this.viewResolvers.iterator(); 所以得出结论：ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的 我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！ protected void initServletContext(ServletContext servletContext) { // 这里它是从beanFactory工具中获取容器中的所有视图解析器 // ViewRescolver.class 把所有的视图解析器来组合的 Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values(); ViewResolver viewResolver; if (this.viewResolvers == null) { this.viewResolvers = new ArrayList(matchingBeans.size()); } // ............... } 既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？ 我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；我们去实现一下 1、我们在我们的主程序中去写一个视图解析器来试试； @Bean //放到bean中 public ViewResolver myViewResolver(){ return new MyViewResolver(); } //我们写一个静态内部类，视图解析器就需要实现ViewResolver接口 private static class MyViewResolver implements ViewResolver{ @Override public View resolveViewName(String s, Locale locale) throws Exception { return null; } } 2、怎么看我们自己写的视图解析器有没有起作用呢？ 我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中 3、我们启动我们的项目，然后随便访问一个页面，看一下Debug信息； 找到this 找到视图解析器，我们看到我们自己定义的就在这里了； 所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！ 12.3、转换器和格式化器找到格式化转换器： @Bean @Override public FormattingConversionService mvcConversionService() { // 拿到配置文件中的格式化规则 WebConversionService conversionService = new WebConversionService(this.mvcProperties.getDateFormat()); addFormatters(conversionService); return conversionService; } 点击去： public String getDateFormat() { return this.dateFormat; } /** * Date format to use. For instance, `dd/MM/yyyy`. 默认的 */ private String dateFormat; 可以看到在我们的Properties文件中，我们可以进行自动配置它！ 如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则： 其余的就不一一举例了，大家可以下去多研究探讨即可！ 12.4、修改SpringBoot的默认配置这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。 SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论； SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的； 如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！ 扩展使用SpringMVC 官方文档如下： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. 我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig； //应为类型要求为WebMvcConfigurer，所以我们实现其接口 //可以使用自定义类扩展MVC的功能 @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { // 浏览器发送/test ， 就会跳转到test页面； registry.addViewController(\"/test\").setViewName(\"test\"); } } 我们去浏览器访问一下： 确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！ 我们可以去分析一下原理： 1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter 2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class) 3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration 这个父类中有这样一段代码： public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); // 从容器中获取所有的webmvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); } } } 4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个 protected void addViewControllers(ViewControllerRegistry registry) { this.configurers.addViewControllers(registry); } 5、我们点进去看一下 public void addViewControllers(ViewControllerRegistry registry) { Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) { // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的 WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); } } 所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用； 12.5、全面接管SpringMVC官方文档： If you want to take complete control of Spring MVC you can add your own @Configuration annotated with @EnableWebMvc. 全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！ 只需在我们的配置类中要加一个@EnableWebMvc。 我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射一定会无效，我们可以去测试一下； 不加注解之前，访问首页： 给配置类加上注解：@EnableWebMvc 我们发现所有的SpringMVC自动配置都失效了！回归到了最初的样子； 当然，我们开发中，不推荐使用全面接管SpringMVC 思考问题？为什么加了一个注解，自动配置就失效了！我们看下源码： 1、这里发现它是导入了一个类，我们可以继续进去看 @Import({DelegatingWebMvcConfiguration.class})public @interface EnableWebMvc {} 2、它继承了一个父类 WebMvcConfigurationSupport public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { // ......} 3、我们来回顾一下Webmvc自动配置类 @Configuration(proxyBeanMethods = false) @ConditionalOnWebApplication(type = Type.SERVLET) @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) // 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效 @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10) @AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class }) public class WebMvcAutoConfiguration { } 总结一句话：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了； 而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！ 在SpringBoot中会有非常多的扩展配置，只要看见了这个，我们就应该多留心注意~ 13、SpringBoot：Web开发13.1、准备工作我们现在可以来导入我们的所有提供的资源！ pojo 及 dao 放到项目对应的路径下： pojo实体类 Department.java Employee.java dao层 DepartmentDao EmployeeDao 导入完毕这些之后，我们还需要导入我们的前端页面，及静态资源文件！ css，js等放在static文件夹下 html放在templates文件夹下 准备工作：OK！！！ 要求一：默认访问首页 方式一：写一个controller实现！ //会解析到templates目录下的index.html页面 @RequestMapping({\"/\",\"/index.html\"}) public String index(){ return \"index\"; } 方式二：自己编写MVC的扩展配置 package com.kuang.myproject.config; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index.html\").setViewName(\"index\"); } } 解决了这个问题，我们还需要解决一个资源导入的问题； 我们可以将我们项目的启动名改掉 server.servlet.context-path=/kuang 现在你访问localhost：8080 就不行了，需要访问localhost：8080/kuang 为了保证资源导入稳定，我们建议在所有资源导入时候使用 th:去替换原有的资源路径！ &lt;link href=\"/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;link th:href=\"@{/css/bootstrap.min.css}\" rel=\"stylesheet\"&gt; 有的时候，我们的网站会去涉及中英文甚至多语言的切换，这时候我们就需要学习国际化了！ 先在IDEA中统一设置properties的编码问题！ 编写国际化配置文件，抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！ 13.2、配置文件编写1、我们在resources资源文件下新建一个i18n目录，存放国际化配置文件 2、建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹变了！ 3、我们可以在这上面去新建一个文件； 弹出如下页面：我们再添加一个英文的； 这样就快捷多了！ 4、接下来，我们就来编写配置，我们可以看到idea下面有另外一个视图； 这个视图我们点击 + 号就可以直接添加属性了；我们新建一个login.tip，可以看到边上有三个文件框可以输入 我们添加一下首页的内容！ 然后依次添加其他页面内容即可！ 然后去查看我们的配置文件； login.properties ：默认 login.btn=登录 login.password=密码 login.remember=记住我 login.tip=请登录 login.username=用户名 英文： login.btn=Sign in login.password=Password login.remember=Remember me login.tip=Please sign in login.username=Username 中文： login.btn=登录 login.password=密码 login.remember=记住我 login.tip=请登录 login.username=用户名 OK，配置文件步骤搞定！ 13.3、配置文件生效探究我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration 里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件 ResourceBundleMessageSource； // 获取 properties 传递过来的值进行判断 @Bean public MessageSource messageSource(MessageSourceProperties properties) { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(properties.getBasename())) { // 设置国际化文件的基础名（去掉语言国家代码的） messageSource.setBasenames( StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(properties.getBasename()))); } if (properties.getEncoding() != null) { messageSource.setDefaultEncoding(properties.getEncoding().name()); } messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) { messageSource.setCacheMillis(cacheDuration.toMillis()); } messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource; } 我们真实 的情况是放在了i18n目录下，所以我们要去配置这个messages的路径； spring.messages.basename=i18n.login 13.4、配置页面国际化值去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{…}。我们去页面测试下： IDEA还有提示，非常智能的！ 我们可以去启动项目，访问一下，发现已经自动识别为中文的了！ 但是我们想要更好！可以根据按钮自动切换中文英文！ 13.5、配置国际化解析在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！ 我们去我们webmvc自动配置文件，寻找一下！看到SpringBoot默认配置： @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\") public LocaleResolver localeResolver() { // 容器中没有就自己配，有的话就用用户配置的 if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.mvcProperties.getLocale()); } // 浏览器消息接收头国际化分解 AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; } AcceptHeaderLocaleResolver 这个类中有一个方法 public Locale resolveLocale(HttpServletRequest request) { Locale defaultLocale = this.getDefaultLocale(); // 默认的就是根据请求头带来的区域信息获取Locale进行国际化 if (defaultLocale != null &amp;&amp; request.getHeader(\"Accept-Language\") == null) { return defaultLocale; } else { Locale requestLocale = request.getLocale(); List&lt;Locale&gt; supportedLocales = this.getSupportedLocales(); if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) { Locale supportedLocale = this.findSupportedLocale(request, supportedLocales); if (supportedLocale != null) { return supportedLocale; } else { return defaultLocale != null ? defaultLocale : requestLocale; } } else { return requestLocale; } } } 那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！ 我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！ 修改一下前端页面的跳转连接： &lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt; &lt;a class=\"btn btn-sm\" th:href=\"@{/index.html(l='zh_CN')}\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\" th:href=\"@{/index.html(l='en_US')}\"&gt;English&lt;/a&gt; 我们去写一个处理的组件类！ package com.kuang.component; import org.springframework.util.StringUtils; import org.springframework.web.servlet.LocaleResolver; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Locale; //可以在链接上携带区域信息 public class MyLocaleResolver implements LocaleResolver { //解析请求 @Override public Locale resolveLocale(HttpServletRequest request) { String language = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); // 如果没有获取到就使用系统默认的 //如果请求链接不为空 if (!StringUtils.isEmpty(language)){ //分割请求参数 String[] split = language.split(\"_\"); //国家，地区 locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) { } } 为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MyMvcConfig下添加bean； @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index.html\").setViewName(\"index\"); } @Bean public LocaleResolver localeResolver() { return new MyLocaleResolver(); } } 我们重启项目，来访问一下，发现点击按钮可以实现成功切换！搞定收工！ 13.6、登录 + 拦截器我们这里就先不连接数据库了，输入任意用户名都可以登录成功！ 声明一个之前没有提到的问题： templates下的页面只能通过Controller跳转实现，而static下的页面是能直接被外界访问的，就能正常访问了。 我们把登录页面的表单提交地址写一个controller！ &lt;form class=\"form-signin\" action=\"dashboard.html\" th:action=\"@{/user/login}\" method=\"post\"&gt; //这里面的所有表单标签都需要加上一个name属性,请求传递参数值 &lt;/form&gt; 去编写对应的controller package com.kuang.myproject.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.util.StringUtils; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; @Controller public class LoginController { //@RequestMapping(value = \"/user/login\",method = RequestMethod.POST) @PostMapping(\"/user/login\") public String login(@RequestParam(\"username\") String username, @RequestParam(\"password\") String password, Model model){ if (!StringUtils.isEmpty(username) &amp;&amp; \"123456\".equals(password)){ //登录成功！ return \"dashboard\"; }else { //登录失败！存放错误信息 model.addAttribute(\"msg\",\"用户名密码错误\"); return \"index\"; } } } 页面存在缓存，所以我们需要禁用模板引擎的缓存 #禁用模板缓存 spring.thymeleaf.cache=false 模板引擎修改后，想要实时生效！页面修改完毕后，IDEA小技巧 ： Ctrl + F9 重新编译！ 登录失败的话，我们需要将后台信息输出到前台，可以在首页标题下面加上判断！ &lt;!--判断是否显示，使用if, ${}可以使用工具类，可以看thymeleaf的中文文档--&gt; &lt;p style=\"color: red\" th:text=\"${msg}\" th:if=\"${not #strings.isEmpty(msg)}\"&gt;&lt;/p&gt; 刷新测试 ： 优化，登录成功后，由于是转发，链接不变，我们可以重定向到内容页！ 我们再添加一个视图控制映射，在我们的自己的MyMvcConfig中： registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); 将 Controller 的代码改为重定向； //登录成功！防止表单重复提交，我们重定向 return \"redirect:/main.html\"; 但是又发现新的问题，我们可以直接登录到后台主页，不用登录也可以实现！ 怎么处理这个问题呢？我们可以使用拦截器机制，实现登录检查！ Controller里添加session，传递loginUser session.setAttribute(\"loginUser\", username); 我们先自定义一个拦截器 package com.kuang.myproject.component; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class LoginHandlerInterceptor implements HandlerInterceptor { //目标方法执行之前,进行拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object user = request.getSession().getAttribute(\"loginUser\"); if (user == null){//未登录，返回登录页面 request.setAttribute(\"msg\",\"没有权限，请先登录\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; }else { //登录，放行 return true; } } } 然后将拦截器注册到我们的SpringMVC配置类MyMvcConfig当中！ //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { //注册拦截器，及拦截请求和要剔除哪些请求! //我们还需要过滤静态资源文件，否则样式显示不出来 registry.addInterceptor(new LoginHandlerInterceptor()) .addPathPatterns(\"/**\") //不拦截的链接 .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\", \"/css/**\"，\"/js/**\"，\"/img/**\"); } 我们然后在后台主页，获取用户登录的信息 &lt;!--后台主页显示登录用户的信息--&gt; &lt;a class=\"----\" href=\"#\"&gt;[[${session.loginUser}]]&lt;/a&gt; &lt;a class=\"----\" href=\"#\" th:text=\"${{session.loginUser}}\"&gt;&lt;/a&gt; &lt;!--${{xxx}}表示把表达式里的值转换为string类型--&gt; 然后我们登录测试！完美！ 13.7、员工列表功能要求 ： 我们需要使用 Restful风格实现我们的crud操作！ 看看一些具体的要求，就是我们小实验的架构； 我们根据这些要求，来完成第一个功能，就是我们的员工列表功能！ 我们在主页点击Customers，就显示列表页面；我们去修改下 1.将首页的侧边栏Customers改为员工管理 2.a链接添加请求 &lt;a class=\"nav-link\" href=\"#\" th:href=\"@{/emps}\"&gt;员工管理&lt;/a&gt; 3.将list放在emp文件夹下 4.编写处理请求的controller @Controller public class EmployeeController { @Autowired EmployeeDao employeeDao; //查询所有员工，返回列表页面 @GetMapping(\"/emps\") public String list(Model model){ Collection&lt;Employee&gt; employees = employeeDao.getAll(); //将结果放在请求中 model.addAttribute(\"emps\",employees); return \"emp/list\"; } } 我们启动项目，测试一下看是否能够跳转，测试OK！我们只需要将数据渲染进去即可！ 但是发现一个问题，侧边栏和顶部都相同，我们是不是应该将它抽取出来呢？ Thymeleaf 公共页面元素抽取 1.抽取公共片段 th:fragment 定义模板名 2.引入公共片段 th:insert 插入模板名 我们来抽取一下，使用list列表做演示！我们要抽取头部，nav标签 我们在dashboard中将nav（顶部栏）部分定义一个模板名 &lt;nav class=\"navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0\" th:fragment=\"topbar\" &gt; &lt;!--后台主页显示登录用户的信息--&gt; &lt;a class=\"navbar-brand col-sm-3 col-md-2 mr-0\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\"&gt; [[${session.loginUser}]]&lt;/a&gt; &lt;input class=\"form-control form-control-dark w-100\" type=\"text\" placeholder=\"Search\" aria-label=\"Search\"&gt; &lt;ul class=\"navbar-nav px-3\"&gt; &lt;li class=\"nav-item text-nowrap\"&gt; &lt;a class=\"nav-link\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\"&gt; Sign out&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; 然后我们在list页面中去引入，可以删掉原来的nav &lt;!--引入抽取的topbar--&gt; &lt;!--模板名 ： 会使用thymeleaf的前后缀配置规则进行解析 使用~{模板::标签名}--&gt; &lt;div th:insert=\"~{dashboard::topbar}\"&gt;&lt;/div&gt; 效果：可以看到已经成功加载过来了！ 除了使用insert插入，还可以使用replace替换，或者include包含，三种方式会有一些小区别，可以见名知义； 我们使用replace替换，可以解决div多余的问题，可以查看thymeleaf的文档学习 侧边栏也是同理，当做练手，可以也同步一下！ 保证这一步做完！ 我们发现一个小问题，侧边栏激活的问题，它总是激活第一个；按理来说，这应该是动态的才对！ 为了重用更清晰，我们建立一个commons文件夹，专门存放公共页面html； &lt;body&gt; &lt;!--底部栏模板--&gt; &lt;nav class=\"navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0\" th:fragment=\"topbar\"&gt; ----------- &lt;/nav&gt; &lt;!--侧边栏模板--&gt; &lt;nav class=\"col-md-2 d-none d-md-block bg-light sidebar\" th:fragment=\"sidebar\" &gt; -------------- &lt;/nav&gt; &lt;/body&gt; 我们去页面中引入一下 &lt;div th:replace=\"~{commons/bar::topbar}\"&gt;&lt;/div&gt; &lt;div th:replace=\"~{commons/bar::sidebar}\"&gt;&lt;/div&gt; 我们先测试一下，保证所有的页面没有出问题！ok！ 我们来解决我们侧边栏选项高亮问题！ 1.将main.html首页的超链接地址改到项目中 &lt;a class=\"nav-link active\" th:href=\"@{/main.html}\"&gt; 首页 &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt; &lt;/a&gt; 2.我们在a标签中加一个判断，使用class改变标签的值； &lt;!--模板页面 --&gt; &lt;a th:class=\"${activeUrl=='main.html'?'nav-link active':'nav-link'}\" th:href=\"@{/main.html}\"&gt; 首页 &lt;/a&gt; 其余同理，判断请求携带的参数，进行激活测试 &lt;a th:class=\"${active=='list.xml'?'nav-link active':'nav-link'}\" href=\"/emps\"&gt; 员工管理&lt;/a&gt; 3.修改页面模板插入链接 &lt;!--dashboard页面 activeUrl是自定义参数名，值也是自定义的，只要与模板class判断时参数对应就行--&gt; &lt;div th:replace=\"~{commons/bar::sidebar(activeUrl='main.html')}\"&gt;&lt;/div&gt; &lt;!--list页面 --&gt; &lt;div th:replace=\"~{commons/bar::sidebar(activeUrl='emps')}\"&gt;&lt;/div&gt;其余要用都是同理。 我们刷新页面，去测试一下，OK，动态激活搞定！ 现在我们来遍历我们的员工信息！顺便美化一些页面，增加添加，修改，删除的按钮 &lt;main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4\"&gt; &lt;!--添加员工按钮--&gt; &lt;h2&gt; &lt;button class=\"btn btn-sm btn-success\"&gt;添加员工&lt;/button&gt;&lt;/h2&gt; &lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-striped table-sm\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;department&lt;/th&gt; &lt;th&gt;birth&lt;/th&gt; &lt;!--我们还可以在显示的时候带一些操作按钮--&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"emp:${emps}\"&gt; &lt;td th:text=\"${emp.id}\"&gt;&lt;/td&gt; &lt;td&gt;[[${emp.lastName}]]&lt;/td&gt; &lt;td th:text=\"${emp.email}\"&gt;&lt;/td&gt; &lt;td th:text=\"${emp.gender==0?'女':'男'}\"&gt;&lt;/td&gt; &lt;td th:text=\"${emp.department.departmentName}\"&gt;&lt;/td&gt; &lt;!--&lt;td th:text=\"${emp.birth}\"&gt;&lt;/td&gt;--&gt; &lt;!--使用时间格式化工具--&gt; &lt;td th:text=\"${#dates.format(emp.birth,'yyyy-MM-dd HH:mm')}\"&gt;&lt;/td&gt; &lt;!--操作--&gt; &lt;td&gt; &lt;a class=\"btn btn-sm btn-primary\"&gt;编辑&lt;/a&gt; &lt;a class=\"btn btn-sm btn-danger\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/main&gt; OK，显示全部员工OK！ 添加员工信息1.将添加员工信息改为超链接 &lt;!--添加员工按钮--&gt; &lt;h2&gt; &lt;a class=\"btn btn-sm btn-success\" th:href=\"@{/emp}\"&gt;添加员工&lt;/a&gt;&lt;/h2&gt; 2.编写对应的controller //to员工添加页面 @GetMapping(\"/emp\") public String toAddPage(){ return \"emp/add\"; } 3.添加前端页面；复制 list页面，修改即可 bootstrap官网文档 ： https://v4.bootcss.com/docs/4.0/components/forms/ ， 我们去可以里面找自己喜欢的样式！ 我这里给大家提供了编辑好的，注意该form表单必须包含在main标签下，不让显示会错乱 &lt;form th:action=\"@{/emp}\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=\"text\" name=\"lastName\" class=\"form-control\" placeholder=\"emlpoyeeName\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=\"email\" name=\"email\" class=\"form-control\" placeholder=\"email\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!-- 注意这里是获取了department的id，不是department对象，所以要用name属性--&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;option th:each=\"dep:${deps}\" th:text=\"${dep.departmentName}\" th:value=\"${dep.id}\"&gt; &lt;!-- 注意这里是获取了department的id，不是department对象--&gt; &lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=\"text\" name=\"birth\" class=\"form-control\" placeholder=\"2000-1-1\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" &gt;添加&lt;/button&gt; &lt;/form&gt; 4.部门信息下拉框应该选择的是我们提供的数据，所以我们要修改一下前端和后端 controller //to员工添加页面 @GetMapping(\"/emp\") public String toAddPage(Model model){ //查出所有的部门，提供选择 Collection&lt;Department&gt; departments = departmentDao.getDepartments(); model.addAttribute(\"departments\",departments); return \"emp/add\"; } 前端 &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的ID--&gt; &lt;select class=\"form-control\"&gt; &lt;option th:each=\"dept:${departments}\" th:text=\"${dept.departmentName}\" th:value=\"${dept.id}\"&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; OK，修改了controller，重启项目测试！ 我们来具体实现添加功能； 1.修改add页面form表单提交地址和方式 &lt;form th:action=\"@{/emp}\" method=\"post\"&gt; 2.编写controller； //员工添加功能，使用post接收 @PostMapping(\"/emp\") public String addEmp(){ //回到员工列表页面，可以使用redirect或者forward，就不会被视图解析器解析 return \"redirect:/emps\"; } 回忆：重定向和转发 以及 /的问题？ 原理探究 ： ThymeleafViewResolver public static final String REDIRECT_URL_PREFIX = \"redirect:\"; public static final String FORWARD_URL_PREFIX = \"forward:\"; protected View createView(String viewName, Locale locale) throws Exception { if (!this.alwaysProcessRedirectAndForward &amp;&amp; !this.canHandle(viewName, locale)) { vrlogger.trace(\"[THYMELEAF] View \\\"{}\\\" cannot be handled by ThymeleafViewResolver. Passing on to the next resolver in the chain.\", viewName); return null; } else { String forwardUrl; if (viewName.startsWith(\"redirect:\")) { vrlogger.trace(\"[THYMELEAF] View \\\"{}\\\" is a redirect, and will not be handled directly by ThymeleafViewResolver.\", viewName); forwardUrl = viewName.substring(\"redirect:\".length(), viewName.length()); RedirectView view = new RedirectView(forwardUrl, this.isRedirectContextRelative(), this.isRedirectHttp10Compatible()); return (View)this.getApplicationContext().getAutowireCapableBeanFactory().initializeBean(view, viewName); } else if (viewName.startsWith(\"forward:\")) { vrlogger.trace(\"[THYMELEAF] View \\\"{}\\\" is a forward, and will not be handled directly by ThymeleafViewResolver.\", viewName); forwardUrl = viewName.substring(\"forward:\".length(), viewName.length()); return new InternalResourceView(forwardUrl); } else if (this.alwaysProcessRedirectAndForward &amp;&amp; !this.canHandle(viewName, locale)) { vrlogger.trace(\"[THYMELEAF] View \\\"{}\\\" cannot be handled by ThymeleafViewResolver. Passing on to the next resolver in the chain.\", viewName); return null; } else { vrlogger.trace(\"[THYMELEAF] View {} will be handled by ThymeleafViewResolver and a {} instance will be created for it\", viewName, this.getViewClass().getSimpleName()); return this.loadView(viewName, locale); } } } OK，看完源码，我们继续编写代码！ 我们要接收前端传过来的属性，将它封装成为对象！首先需要将前端页面空间的name属性编写完毕！【操作】 编写controller接收调试打印【操作】 //员工添加功能 //接收前端传递的参数，自动封装成为对象[要求前端传递的参数名，和属性名一致] @PostMapping(\"/emp\") public String addEmp(Employee employee){ System.out.println(employee); employeeDao.save(employee); //保存员工信息 //回到员工列表页面，可以使用redirect或者forward return \"redirect:/emps\"; } 前端填写数据，注意时间问题 点击提交，后台输出正常！页面跳转及数据显示正常！OK！ 那我们将时间换一个格式提交 提交发现页面出现了400错误！ 生日我们提交的是一个日期 ， 我们第一次使用的 / 正常提交成功了，后面使用 - 就错误了，所以这里面应该存在一个日期格式化的问题； SpringMVC会将页面提交的值转换为指定的类型，默认日期是按照 / 的方式提交 ； 比如将2019/01/01 转换为一个date对象。 那思考一个问题？我们能不能修改这个默认的格式呢？ 我们去看webmvc的自动配置文件；找到一个日期格式化的方法，我们可以看一下 @Bean public FormattingConversionService mvcConversionService() { WebConversionService conversionService = new WebConversionService(this.mvcProperties.getDateFormat()); this.addFormatters(conversionService); return conversionService; } 调用了 getDateFormat 方法； public String getDateFormat() { return this.dateFormat; } 这个在配置类中，所以我们可以自定义的去修改这个时间格式化问题，我们在我们的配置文件中修改一下； spring.mvc.date-format=yyyy-MM-dd **这样的话，我们现在就支持 - 的格式了，但是又不支持 / 了 ** 测试OK！ 员工修改功能我们要实现员工修改功能，需要实现两步； 1.点击修改按钮，去到编辑页面，我们可以直接使用添加员工的页面实现 2.显示原数据，修改完毕后跳回列表页面！ 我们去实现一下：首先修改跳转链接的位置； &lt;a class=\"btn btn-sm btn-primary\" th:href=\"@{/emp/}+${emp.id}\"&gt;编辑&lt;/a&gt; 编写对应的controller //to员工修改页面 @GetMapping(\"/emp/{id}\") public String toUpdateEmp(@PathVariable(\"id\") Integer id,Model model){ //根据id查出来员工 Employee employee = employeeDao.get(id); //将员工信息返回页面 model.addAttribute(\"emp\",employee); //查出所有的部门，提供修改选择 Collection&lt;Department&gt; departments = departmentDao.getDepartments(); model.addAttribute(\"departments\",departments); return \"emp/update\"; } 我们需要在这里将add页面复制一份，改为update页面；需要修改页面，将我们后台查询数据回显 &lt;form th:action=\"@{/emp}\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" th:value=\"${emp.lastName}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" th:value=\"${emp.email}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"${emp.gender==1}\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"${emp.gender==0}\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的ID--&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;option th:selected=\"${dept.id == emp.department.id}\" th:each=\"dept:${departments}\" th:text=\"${dept.departmentName}\" th:value=\"${dept.id}\"&gt; &lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" th:value=\"${emp.birth}\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;修改&lt;/button&gt; &lt;/form&gt; 测试OK！ 发现我们的日期显示不完美，可以使用日期工具，进行日期的格式化！ &lt;input name=\"birth\" type=\"text\" class=\"form-control\" th:value=\"${#dates.format(emp.birth,'yyyy-MM-dd HH:mm')}\"&gt; 数据回显OK，我们继续完成数据修改问题！ 修改表单提交的地址： &lt;form th:action=\"@{/updateEmp}\" method=\"post\"&gt; 编写对应的controller @PostMapping(\"/updateEmp\") public String updateEmp(Employee employee){ employeeDao.save(employee); //回到员工列表页面 return \"redirect:/emps\"; } 发现页面提交的没有id；我们在前端加一个隐藏域，提交id； &lt;input name=\"id\" type=\"hidden\" class=\"form-control\" th:value=\"${emp.id}\"&gt; 重启，修改信息测试OK！ 删除员工list页面，编写提交地址 &lt;a class=\"btn btn-sm btn-danger\" th:href=\"@{/delEmp/}+${emp.id}\"&gt;删除&lt;/a&gt; 编写Controller @GetMapping(\"/delEmp/{id}\") public String delEmp(@PathVariable(\"id\") Integer id){ employeeDao.delete(id); return \"redirect:/emps\"; } 测试OK！ 定制错误页面我们只需要在模板目录下添加一个error文件夹，文件夹中存放我们相应的错误页面，比如404.html 或者 4xx.html 等等，SpringBoot就会帮我们自动使用了！ 注销功能&lt;a class=\"nav-link\" href=\"#\" th:href=\"@{/user/loginOut}\"&gt;Sign out&lt;/a&gt; 对应的controller @GetMapping(\"/user/loginOut\") public String loginOut(HttpSession session){ session.invalidate(); return \"redirect:/index.html\"; } 学到这里，SpringBoot的基本开发就以及没有问题了，我们后面去学习一下SpringBoot如何操作数据库以及配置Mybatis； 14、SpringBoot：集成Swagger终极版 学习目标： 了解Swagger的概念及作用 掌握在项目中集成Swagger自动生成API文档 14.1、Swagger简介前后端分离 前端 -&gt; 前端控制层、视图层 后端 -&gt; 后端控制层、服务层、数据访问层 前后端通过API进行交互 前后端相对独立且松耦合 产生的问题 前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发 解决方案 首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险 Swagger 号称世界上最流行的API框架 Restful Api 文档在线自动生成器 =&gt; API 文档 与API 定义同步更新 直接运行，在线测试API 支持多种语言 （如：Java，PHP等） 官网：https://swagger.io/ 14.2、SpringBoot集成SwaggerSpringBoot集成Swagger =&gt; springfox，两个jar包 Springfox-swagger2 swagger-springmvc 使用Swagger 要求：jdk 1.8 + 否则swagger2无法运行 步骤： 1、新建一个SpringBoot-web项目 2、添加Maven依赖 &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.10.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.10.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-spring-webmvc&lt;/artifactId&gt; &lt;version&gt;2.10.5&lt;/version&gt; &lt;/dependency&gt; 3、编写HelloController，测试确保运行成功！ 4、要使用Swagger，我们需要在config文件夹下编写一个配置类-SwaggerConfig来配置 Swagger @Configuration //配置类 @EnableSwagger2WebMvc// 开启Swagger2的自动配置 public class SwaggerConfig { } 5、访问测试 ：http://localhost:8080/swagger-ui.html ，可以看到swagger的界面； 14.3、配置Swagger1、Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger。 @Bean //配置docket以配置Swagger具体参数 public Docket docket() { return new Docket(DocumentationType.SWAGGER_2); } 2、可以通过apiInfo()属性配置文档信息 //配置文档信息 private ApiInfo apiInfo() { Contact contact = new Contact(\"联系人名字\", \"http://xxx.xxx.com/联系人访问链接\", \"联系人邮箱\"); return new ApiInfo( \"Swagger学习\", // 标题 \"学习演示如何配置Swagger\", // 描述 \"v1.0\", // 版本 \"http://terms.service.url/组织链接\", // 组织链接 contact, // 联系人信息 \"Apach 2.0 许可\", // 许可 \"许可链接\", // 许可连接 new ArrayList&lt;&gt;()// 扩展 ); } 3、Docket 实例关联上 apiInfo() @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()); } 4、重启项目，访问测试 http://localhost:8080/swagger-ui.html 看下效果； 14.4、配置扫描接口1、构建Docket时通过select()方法配置怎么扫描接口。 @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(\"com.kuang.swagger.controller\")) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(\"/kuang/**\")) .build(); } 2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类 3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下RequestHandlerSelectors所有的配置方式： any() // 扫描所有，项目中的所有接口都会被扫描到 none() // 不扫描接口 // 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求 withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation) // 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口 withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation) basePackage(final String basePackage) // 根据包路径扫描接口 4、除此之外，我们还可以配置接口扫描过滤，PathSelectors配置如何过滤： @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(\"com.kuang.swagger.controller\")) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(\"/kuang/**\")) .build(); } 5、PathSelectors这里的可选值还有 any() // 任何请求都扫描 none() // 任何请求都不扫描 regex(final String pathRegex) // 通过正则表达式控制 ant(final String antPattern) // 通过ant()控制 14.5、配置Swagger开关1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了 @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问 .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(\"com.kuang.swagger.controller\")) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(\"/kuang/**\")) .build(); } 2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？ @Bean public Docket docket(Environment environment) { // 设置要显示swagger的环境 Profiles of = Profiles.of(\"dev\", \"test\"); // 判断当前是否处于该环境 // 通过 enable() 接收此参数判断是否要显示 boolean flag = environment.acceptsProfiles(of); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(flag) //配置是否启用Swagger，如果是false，在浏览器将无法访问 .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口 .apis(RequestHandlerSelectors.basePackage(\"com.kuang.swagger.controller\")) // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口 .paths(PathSelectors.ant(\"/kuang/**\")) .build(); } 3、可以在项目中增加一个dev的配置文件查看效果！ 14.6、配置API分组 1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组： @Bean public Docket docket(Environment environment) { return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()) .groupName(\"hello\") // 配置分组 // 省略配置.... } 2、重启项目查看分组 3、如何配置多个分组？配置多个分组只需要配置多个docket即可： @Bean public Docket docket1(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"group1\"); } @Bean public Docket docket2(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"group2\"); } @Bean public Docket docket3(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"group3\"); } 4、重启项目查看即可 14.7、实体配置1、新建一个实体类 @ApiModel(\"用户实体\") public class User { @ApiModelProperty(\"用户名\") public String username; @ApiModelProperty(\"密码\") public String password; } 2、只要这个实体在请求接口的返回值上（即使是泛型），都能映射到实体项中： @RequestMapping(\"/getUser\") public User getUser(){ return new User(); } 3、重启查看测试 注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。 @ApiModel为类添加注释 @ApiModelProperty为类属性添加注释 14.8、常用注解Swagger的所有注解定义在io.swagger.annotations包下 下面列一些经常用到的，未列举出来的可以另行查阅说明： Swagger注解 简单说明 @Api(tags = “xxx模块说明”) 作用在模块类上 @ApiOperation(“xxx接口说明”) 作用在接口方法上 @ApiModel(“xxxPOJO说明”) 作用在模型类上：如VO、BO @ApiModelProperty(value = “xxx属性说明”,hidden = true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(“xxx参数说明”) 作用在参数、方法和字段上，类似@ApiModelProperty 我们也可以给请求的接口配置一些注释 @ApiOperation(\"狂神的接口\") @PostMapping(\"/kuang\") @ResponseBody public String kuang(@ApiParam(\"这个名字会被返回\")String username){ return username; } 这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！ 相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。 Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。 14.9、拓展：其他皮肤我们可以导入不同的包实现不同的皮肤定义： 1、默认的 访问 http://localhost:8080/swagger-ui.html &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 2、bootstrap-ui 访问 http://localhost:8080/doc.html &lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt; &lt;/dependency&gt; 3、Layui-ui 访问 http://localhost:8080/docs.html &lt;!-- 引入swagger-ui-layer包 /docs.html--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt; &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; 4、mg-ui 访问 http://localhost:8080/document.html &lt;!-- 引入swagger-ui-layer包 /document.html--&gt; &lt;dependency&gt; &lt;groupId&gt;com.zyplayer&lt;/groupId&gt; &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt; &lt;/dependency&gt; 15、SpringBoot：异步、定时、邮件任务前言 在我们的工作中，常常会用到异步处理任务，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。还有一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息。还有就是邮件的发送，微信的前身也是邮件服务呢？这些东西都是怎么实现的呢？其实SpringBoot都给我们提供了对应的支持，我们上手使用十分的简单，只需要开启一些注解支持，配置一些配置文件即可！那我们来看看吧~ 15.1、异步任务1、创建一个service包 2、创建一个类AsyncService 异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。 编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况； @Service public class AsyncService { public void hello(){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"业务进行中....\"); } } 3、创建controller包 4、编写AsyncController类 我们去写一个Controller测试一下 @RestController public class AsyncController { @Autowired AsyncService asyncService; @GetMapping(\"/hello\") public String hello(){ asyncService.hello(); return \"success\"; } } 5、访问http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。 问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下： 6、给hello方法添加@Async注解； //告诉Spring这是一个异步方法 @Async public void hello(){ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"业务进行中....\"); } SpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能； @EnableAsync //开启异步注解功能 @SpringBootApplication public class SpringbootTaskApplication { public static void main(String[] args) { SpringApplication.run(SpringbootTaskApplication.class, args); } } 7、重启测试，网页瞬间响应，后台代码依旧执行！ 15.2、定时任务项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。 TaskExecutor接口 TaskScheduler接口 两个注解： @EnableScheduling @Scheduled cron表达式： 测试步骤： 1、创建一个ScheduledService 我们里面存在一个hello方法，他需要定时执行，怎么处理呢？ @Service public class ScheduledService { //秒 分 时 日 月 周几 //0 * * * * MON-FRI //注意cron表达式的用法； @Scheduled(cron = \"0 * * * * 0-7\") public void hello(){ System.out.println(\"hello.....\"); } } 2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能 @EnableAsync //开启异步注解功能 @EnableScheduling //开启基于注解的定时任务 @SpringBootApplication public class SpringbootTaskApplication { public static void main(String[] args) { SpringApplication.run(SpringbootTaskApplication.class, args); } } 3、我们来详细了解下cron表达式； http://www.bejson.com/othertools/cron/ 4、常用的表达式 (1）0/2 * * * * ? 表示每2秒 执行任务 （1）0 0/2 * * * ? 表示每2分钟 执行任务 （1）0 0 2 1 * ? 表示在每月的1日的凌晨2点调整任务 （2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 （3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 （4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 （5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 （6）0 0 12 ? * WED 表示每个星期三中午12点 （7）0 0 12 * * ? 每天中午12点触发 （8）0 15 10 ? * * 每天上午10:15触发 （9）0 15 10 * * ? 每天上午10:15触发 （10）0 15 10 * * ? 每天上午10:15触发 （11）0 15 10 * * ? 2005 2005年的每天上午10:15触发 （12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 （14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 （15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 （16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 （17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 （18）0 15 10 15 * ? 每月15日上午10:15触发 （19）0 15 10 L * ? 每月最后一日的上午10:15触发 （20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 （21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 （22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 15.3、邮件任务邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持 邮件发送需要引入spring-boot-start-mail SpringBoot 自动配置MailSenderAutoConfiguration 定义MailProperties内容，配置在application.yml中 自动装配JavaMailSender 测试邮件发送 测试： 1、引入pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 看它引入的依赖，可以看到 jakarta.mail &lt;dependency&gt; &lt;groupId&gt;com.sun.mail&lt;/groupId&gt; &lt;artifactId&gt;jakarta.mail&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 2、查看自动配置类：MailSenderAutoConfiguration 这个类中存在bean，JavaMailSenderImpl 然后我们去看下配置文件 @ConfigurationProperties( prefix = \"spring.mail\" ) public class MailProperties { private static final Charset DEFAULT_CHARSET; private String host; private Integer port; private String username; private String password; private String protocol = \"smtp\"; private Charset defaultEncoding; private Map&lt;String, String&gt; properties; private String jndiName; } 3、配置文件： spring.mail.username=24736743@qq.com spring.mail.password=你的qq授权码 spring.mail.host=smtp.qq.com #qq需要配置ssl spring.mail.properties.mail.smtp.ssl.enable=true 获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务 4、Spring单元测试 @Autowired JavaMailSenderImpl mailSender; @Test public void contextLoads() { //邮件设置1：一个简单的邮件 SimpleMailMessage message = new SimpleMailMessage(); message.setSubject(\"通知-明天来狂神这听课\"); message.setText(\"今晚7:30开会\"); message.setTo(\"24736743@qq.com\"); message.setFrom(\"24736743@qq.com\"); mailSender.send(message); } @Test public void contextLoads2() throws MessagingException { //邮件设置2：一个复杂的邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); //要发送附件得带上 true 参数 MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject(\"通知-明天来狂神这听课\"); helper.setText(\"&lt;b style='color:red'&gt;今天 7:30来开会&lt;/b&gt;\",true); //发送附件 helper.addAttachment(\"1.jpg\",new File(\"\")); helper.addAttachment(\"2.jpg\",new File(\"\")); helper.setTo(\"24736743@qq.com\"); helper.setFrom(\"24736743@qq.com\"); mailSender.send(mimeMessage); } 查看邮箱，邮件接收成功！ 我们只需要使用Thymeleaf进行前后端结合即可开发自己网站邮件收发功能了！ 16、SpringBoot：富文本编辑器16.1、简介思考：我们平时在博客园，或者CSDN等平台进行写作的时候，有同学思考过他们的编辑器是怎么实现的吗？ 在博客园后台的选项设置中，可以看到一个文本编辑器的选项： 其实这个就是富文本编辑器，市面上有许多非常成熟的富文本编辑器，比如： Editor.md——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费 官网：https://pandao.github.io/editor.md/ wangEditor——基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、界面美观、易用、开源免费。 官网：http://www.wangeditor.com/ TinyMCE——TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对IE6+和Firefox1.5+都有着非常良好的支持。功能齐全，界面美观，就是文档是英文的，对开发人员英文水平有一定要求。 官网：https://www.tiny.cloud/docs/demo/full-featured/ 博客园 百度ueditor——UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，功能齐全，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码，缺点是已经没有更新了 官网：https://ueditor.baidu.com/website/onlinedemo.html kindeditor——界面经典。 官网：http://kindeditor.net/demo.php Textbox——Textbox是一款极简但功能强大的在线文本编辑器，支持桌面设备和移动设备。主要功能包含内置的图像处理和存储、文件拖放、拼写检查和自动更正。此外，该工具还实现了屏幕阅读器等辅助技术，并符合WAI-ARIA可访问性标准。 官网：https://textbox.io/ CKEditor——国外的，界面美观。 官网：https://ckeditor.com/ckeditor-5/demo/ quill——功能强大，还可以编辑公式等 官网：https://quilljs.com/ simditor——界面美观，功能较全。 官网：https://simditor.tower.im/ summernote——UI好看，精美 官网：https://summernote.org/ jodit——功能齐全 官网：https://xdsoft.net/jodit/ froala Editor——界面非常好看，功能非常强大，非常好用（非免费） 官网：https://www.froala.com/wysiwyg-editor 总之，目前可用的富文本编辑器有很多……这只是其中的一部分 16.2、Editor.md我这里使用的就是Editor.md，作为一个资深码农，Mardown必然是我们程序猿最喜欢的格式，看下面，就爱上了！ 我们可以在官网下载它：https://pandao.github.io/editor.md/ ， 得到它的压缩包！ 解压以后，在examples目录下面，可以看到他的很多案例使用！学习，其实就是看人家怎么写的，然后进行模仿就好了！ 我们可以将整个解压的文件倒入我们的项目，将一些无用的测试和案例删掉即可！ 16.3、基础工程搭建 数据库设计 article：文章表 字段 备注 id int 文章的唯一ID author varchar 作者 title varchar 标题 content longtext 文章的内容 建表SQL： CREATE TABLE `article` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'int文章的唯一ID', `author` varchar(50) NOT NULL COMMENT '作者', `title` varchar(100) NOT NULL COMMENT '标题', `content` longtext NOT NULL COMMENT '文章的内容', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 基础项目搭建 1、建一个SpringBoot项目配置 spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; 2、实体类： //文章类 @Data @NoArgsConstructor @AllArgsConstructor public class Article implements Serializable { private int id; //文章的唯一ID private String author; //作者名 private String title; //标题 private String content; //文章的内容 } 3、mapper接口： @Mapper @Repository public interface ArticleMapper { //查询所有的文章 List&lt;Article&gt; queryArticles(); //新增一个文章 int addArticle(Article article); //根据文章id查询文章 Article getArticleById(int id); //根据文章id删除文章 int deleteArticleById(int id); } 既然已经提供了 myBatis 的映射配置文件，自然要告诉 spring boot 这些文件的位置 mybatis: mapper-locations: classpath:com/kuang/mapper/*.xml type-aliases-package: com.kuang.pojo 编写一个Controller测试下，是否ok； 16.4、文章编辑整合（重点）1、导入 editor.md 资源 ，删除多余文件 2、编辑文章页面 editor.html、需要引入 jQuery； &lt;!DOCTYPE html&gt; &lt;html class=\"x-admin-sm\" lang=\"zh\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;秦疆'Blog&lt;/title&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi\" /&gt; &lt;!--Editor.md--&gt; &lt;link rel=\"stylesheet\" th:href=\"@{/editormd/css/editormd.css}\"/&gt; &lt;link rel=\"shortcut icon\" href=\"https://pandao.github.io/editor.md/favicon.ico\" type=\"image/x-icon\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"layui-fluid\"&gt; &lt;div class=\"layui-row layui-col-space15\"&gt; &lt;div class=\"layui-col-md12\"&gt; &lt;!--博客表单--&gt; &lt;form name=\"mdEditorForm\"&gt; &lt;div&gt; 标题：&lt;input type=\"text\" name=\"title\"&gt; &lt;/div&gt; &lt;div&gt; 作者：&lt;input type=\"text\" name=\"author\"&gt; &lt;/div&gt; &lt;div id=\"article-content\"&gt; &lt;textarea name=\"content\" id=\"content\" style=\"display:none;\"&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;!--editormd--&gt; &lt;script th:src=\"@{/editormd/lib/jquery.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/editormd.js}\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var testEditor; //window.onload = function(){ } $(function() { testEditor = editormd(\"article-content\", { width : \"95%\", height : 400, syncScrolling : \"single\", path : \"../editormd/lib/\", saveHTMLToTextarea : true, // 保存 HTML 到 Textarea emoji: true, theme: \"dark\",//工具栏主题 previewTheme: \"dark\",//预览主题 editorTheme: \"pastel-on-dark\",//编辑主题 tex : true, // 开启科学公式TeX语言支持，默认关闭 flowChart : true, // 开启流程图支持，默认关闭 sequenceDiagram : true, // 开启时序/序列图支持，默认关闭, //图片上传 imageUpload : true, imageFormats : [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"], imageUploadURL : \"/article/file/upload\", onload : function() { console.log('onload', this); }, /*指定需要显示的功能按钮*/ toolbarIcons : function() { return [\"undo\",\"redo\",\"|\", \"bold\",\"del\",\"italic\",\"quote\",\"ucwords\",\"uppercase\",\"lowercase\",\"|\", \"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"|\", \"list-ul\",\"list-ol\",\"hr\",\"|\", \"link\",\"reference-link\",\"image\",\"code\",\"preformatted-text\", \"code-block\",\"table\",\"datetime\",\"emoji\",\"html-entities\",\"pagebreak\",\"|\", \"goto-line\",\"watch\",\"preview\",\"fullscreen\",\"clear\",\"search\",\"|\", \"help\",\"info\",\"releaseIcon\", \"index\"] }, /*自定义功能按钮，下面我自定义了2个，一个是发布，一个是返回首页*/ toolbarIconTexts : { releaseIcon : \"&lt;span bgcolor=\\\"gray\\\"&gt;发布&lt;/span&gt;\", index : \"&lt;span bgcolor=\\\"red\\\"&gt;返回首页&lt;/span&gt;\", }, /*给自定义按钮指定回调函数*/ toolbarHandlers:{ releaseIcon : function(cm, icon, cursor, selection) { //表单提交 mdEditorForm.method = \"post\"; mdEditorForm.action = \"/article/addArticle\";//提交至服务器的路径 mdEditorForm.submit(); }, index : function(){ window.location.href = '/'; }, } }); }); &lt;/script&gt; &lt;/html&gt; 3、编写Controller，进行跳转，以及保存文章 @Controller @RequestMapping(\"/article\") public class ArticleController { @GetMapping(\"/toEditor\") public String toEditor(){ return \"editor\"; } @PostMapping(\"/addArticle\") public String addArticle(Article article){ articleMapper.addArticle(article); return \"editor\"; } } 图片上传问题 1、前端js中添加配置 //图片上传 imageUpload : true, imageFormats : [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"], imageUploadURL : \"/article/file/upload\", // //这个是上传图片时的访问地址 2、后端请求，接收保存这个图片, 需要导入 FastJson 的依赖！ //博客图片上传问题 @RequestMapping(\"/file/upload\") @ResponseBody public JSONObject fileUpload(@RequestParam(value = \"editormd-image-file\", required = true) MultipartFile file, HttpServletRequest request) throws IOException { //上传路径保存设置 //获得SpringBoot当前项目的路径：System.getProperty(\"user.dir\") String path = System.getProperty(\"user.dir\")+\"/upload/\"; //按照月份进行分类： Calendar instance = Calendar.getInstance(); String month = (instance.get(Calendar.MONTH) + 1)+\"月\"; path = path+month; File realPath = new File(path); if (!realPath.exists()){ realPath.mkdir(); } //上传文件地址 System.out.println(\"上传文件保存地址：\"+realPath); //解决文件名字问题：我们使用uuid; String filename = \"ks-\"+UUID.randomUUID().toString().replaceAll(\"-\", \"\"); //通过CommonsMultipartFile的方法直接写文件（注意这个时候） file.transferTo(new File(realPath +\"/\"+ filename)); //给editormd进行回调 JSONObject res = new JSONObject(); res.put(\"url\",\"/upload/\"+month+\"/\"+ filename); res.put(\"success\", 1); res.put(\"message\", \"upload success!\"); return res; } 3、解决文件回显显示的问题，设置虚拟目录映射！在我们自己拓展的MvcConfig中进行配置即可！ @Configuration public class MyMvcConfig implements WebMvcConfigurer { // 文件保存在真实目录/upload/下， // 访问的时候使用虚路径/upload，比如文件名为1.png，就直接/upload/1.png就ok了。 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/upload/**\") .addResourceLocations(\"file:\"+System.getProperty(\"user.dir\")+\"/upload/\"); } } 表情包问题 自己手动下载，emoji 表情包，放到图片路径下： 修改editormd.js文件 // Emoji graphics files url path editormd.emoji = { path : \"../editormd/plugins/emoji-dialog/emoji/\", ext : \".png\" }; 16.5、文章展示1、Controller 中增加方法 @GetMapping(\"/{id}\") public String show(@PathVariable(\"id\") int id,Model model){ Article article = articleMapper.getArticleById(id); model.addAttribute(\"article\",article); return \"article\"; } 2、编写页面 article.html &lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;title th:text=\"${article.title}\"&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;!--文章头部信息：标题，作者，最后更新日期，导航--&gt; &lt;h2 style=\"margin: auto 0\" th:text=\"${article.title}\"&gt;&lt;/h2&gt; 作者：&lt;span style=\"float: left\" th:text=\"${article.author}\"&gt;&lt;/span&gt; &lt;!--文章主体内容--&gt; &lt;div id=\"doc-content\"&gt; &lt;textarea style=\"display:none;\" placeholder=\"markdown\" th:text=\"${article.content}\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;link rel=\"stylesheet\" th:href=\"@{/editormd/css/editormd.preview.css}\" /&gt; &lt;script th:src=\"@{/editormd/lib/jquery.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/marked.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/prettify.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/raphael.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/underscore.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/sequence-diagram.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/flowchart.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/lib/jquery.flowchart.min.js}\"&gt;&lt;/script&gt; &lt;script th:src=\"@{/editormd/editormd.js}\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var testEditor; $(function () { testEditor = editormd.markdownToHTML(\"doc-content\", {//注意：这里是上面DIV的id htmlDecode: \"style,script,iframe\", emoji: true, taskList: true, tocm: true, tex: true, // 默认不解析 flowChart: true, // 默认不解析 sequenceDiagram: true, // 默认不解析 codeFold: true });}); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 重启项目，访问进行测试！大功告成！ 小结： 有了富文本编辑器，我们网站的功能就会又多一项，大家到了这里完全可以有时间写一个属于自己的博客网站了，根据所学的知识是完全没有任何问题的！ 17、SpringBoot：Dubbo和Zookeeper集成分布式理论 17.1、什么是分布式系统？在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”； 分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。 分布式系统（distributed system）是建立在网络之上的软件系统。 首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。 17.2、Dubbo文档随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。 在Dubbo的官网文档有这样一张图 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。 缺点： 1、性能扩展比较难 2、协同开发问题 3、不利于升级维护 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。 缺点：公用模块无法重复利用，开发性的浪费 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键。 什么是RPC RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。 也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数； 推荐阅读文章：https://www.jianshu.com/p/2accc2840a1b RPC基本原理 步骤解析： RPC两个核心模块：通讯，序列化。 测试环境搭建 DubboApache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 dubbo官网 http://dubbo.apache.org/zh-cn/index.html 1.了解Dubbo的特性 2.查看官方文档 dubbo基本概念 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 调用关系说明 l 服务容器负责启动，加载，运行服务提供者。 l 服务提供者在启动时，向注册中心注册自己提供的服务。 l 服务消费者在启动时，向注册中心订阅自己所需的服务。 l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo环境搭建 点进dubbo官方文档，推荐我们使用Zookeeper 注册中心 什么是zookeeper呢？可以查看官方文档 Window下安装zookeeper 1、下载zookeeper ：地址， 我们下载3.4.14 ， 最新版！解压zookeeper 2、运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件； 可能遇到问题：闪退 ! 解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。 3、修改zoo.cfg配置文件 将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。 注意几个重要位置： dataDir=./ 临时数据存储的目录（可写相对路径） clientPort=2181 zookeeper的端口号 修改完成后再次启动zookeeper 4、使用zkCli.cmd测试 ls /：列出zookeeper根下保存的所有节点 [zk: 127.0.0.1:2181(CONNECTED) 4] ls / [zookeeper] create –e /kuangshen 123：创建一个kuangshen节点，值为123 get /kuangshen：获取/kuangshen节点的值 我们再来查看一下节点 window下安装dubbo-admin dubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。 但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。 我们这里来安装一下： 1、下载dubbo-admin 地址 ：https://github.com/apache/dubbo-admin/tree/master 2、解压进入目录 修改 dubbo-admin\\src\\main\\resources \\application.properties 指定zookeeper地址 server.port=7001 spring.velocity.cache=false spring.velocity.charset=UTF-8 spring.velocity.layout-url=/templates/default.vm spring.messages.fallback-to-system-locale=false spring.messages.basename=i18n/message spring.root.password=root spring.guest.password=guest dubbo.registry.address=zookeeper://127.0.0.1:2181 3、在项目根目录下打包dubbo-admin mvn clean package -Dmaven.test.skip=true 第一次打包的过程有点慢，需要耐心等待！直到成功！ 4、执行 dubbo-admin\\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar java -jar dubbo-admin-0.0.1-SNAPSHOT.jar 【注意：zookeeper的服务一定要打开！】 执行完毕，我们去访问一下 http://localhost:7001/ ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root； 登录成功后，查看界面 安装完成！ 17.3、SpringBoot + Dubbo + zookeeper框架搭建 1. 启动zookeeper ！ 2. IDEA创建一个空项目； 3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可 4.项目创建完毕，我们写一个服务，比如卖票的服务； 编写接口 package com.kuang.provider.service; public interface TicketService { public String getTicket(); } 编写实现类 package com.kuang.provider.service; public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"《狂神说Java》\"; } } 5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可 6.项目创建完毕，我们写一个服务，比如用户的服务； 编写service package com.kuang.consumer.service; public class UserService { //我们需要去拿去注册中心的服务 } 需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？ 服务提供者 1、将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包 我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包 &lt;!-- Dubbo Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; zookeeper的包我们去maven仓库下载，zkclient； &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; 【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖； &lt;!-- 引入zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 2、在springboot配置文件中配置dubbo相关属性！ #当前应用名字，对应项目模块名称 dubbo.application.name=provider-server #注册中心地址 dubbo.registry.address=zookeeper://127.0.0.1:2181 #扫描指定包下服务 dubbo.scan.base-packages=com.kuang.provider.service 3、在service的实现类中配置服务注解，发布服务！注意导包问题 import org.apache.dubbo.config.annotation.Service; import org.springframework.stereotype.Component; @Service //将服务发布出去，这个service注解不是spring的service注解 @Component //放在容器中 public class TicketServiceImpl implements TicketService { @Override public String getTicket() { return \"《狂神说Java》\"; } } 逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！ 服务消费者 1、导入依赖，和之前的依赖一样； &lt;!--dubbo--&gt; &lt;!-- Dubbo Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--zookeeper--&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 引入zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;!--排除这个slf4j-log4j12--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 2、配置参数 #当前应用名字 dubbo.application.name=consumer-server #注册中心地址 dubbo.registry.address=zookeeper://127.0.0.1:2181 3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同； 4. 完善消费者的服务类 package com.kuang.consumer.service; import com.kuang.provider.service.TicketService; import org.apache.dubbo.config.annotation.Reference; import org.springframework.stereotype.Service; @Service //注入到容器中 public class UserService { @Reference //远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名 TicketService ticketService; public void bugTicket(){ String ticket = ticketService.getTicket(); System.out.println(\"在注册中心买到\"+ticket); } } 5. 测试类编写； @RunWith(SpringRunner.class) @SpringBootTest public class ConsumerServerApplicationTests { @Autowired UserService userService; @Test public void contextLoads() { userService.bugTicket(); } } 启动测试 1. 开启zookeeper 2. 打开dubbo-admin实现监控【可以不用做】 3. 开启服务者 4. 消费者消费测试，结果： 监控中心 ： ok , 这就是SpingBoot + dubbo + zookeeper实现分布式开发的应用，其实就是一个服务拆分的思想； 18、SpringBoot：集成SpringSecurity18.1、安全简介在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。 市面上存在比较有名的：Shiro，Spring Security ！ 这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？ 首先我们看下它的官网介绍：Spring Security官网地址 Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications. Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。 Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求 从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。 怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。 Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。 对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。 18.2、实战测试18.2.1、实验环境搭建1、新建一个初始的springboot项目web模块，thymeleaf模块 2、导入静态资源 |views |level1 1.html 2.html 3.html |level2 1.html 2.html 3.html |level3 1.html 2.html 3.html |login.html index.html 3、controller跳转！ package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class RouterController { @RequestMapping({\"/\",\"/index\"}) public String index(){ return \"index\"; } @RequestMapping(\"/toLogin\") public String toLogin(){ return \"views/login\"; } @RequestMapping(\"/level1/{id}\") public String level1(@PathVariable(\"id\") int id){ return \"views/level1/\"+id; } @RequestMapping(\"/level2/{id}\") public String level2(@PathVariable(\"id\") int id){ return \"views/level2/\"+id; } @RequestMapping(\"/level3/{id}\") public String level3(@PathVariable(\"id\") int id){ return \"views/level3/\"+id; } } 4、测试实验环境是否OK！ 18.2.2、认识SpringSecuritySpring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！ 记住几个类： WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式 Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。 “认证”（Authentication） 身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。 身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。 “授权” （Authorization） 授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。 这个概念是通用的，而不是只在Spring Security 中存在。 18.2.3、认证和授权目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能 1、引入 Spring Security 模块 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 2、编写 Spring Security 配置类 参考官网：https://spring.io/projects/spring-security 查看我们自己项目中的版本，找到对应的帮助文档： https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5 3、编写基础配置类 package com.kuang.config; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; @EnableWebSecurity // 开启WebSecurity模式 public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { } } 4、定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { // 定制请求的授权规则 // 首页所有人可以访问 http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"vip1\") .antMatchers(\"/level2/**\").hasRole(\"vip2\") .antMatchers(\"/level3/**\").hasRole(\"vip3\"); } 5、测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！ 6、在configure()方法中加入以下配置，开启自动配置的登录功能！ // 开启自动配置的登录功能 // /login 请求来到登录页 // /login?error 重定向到这里表示登录失败 http.formLogin(); 7、测试一下：发现，没有权限的时候，会跳转到登录的页面！ 8、查看刚才登录页的注释信息； 我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法 //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //在内存中定义，也可以在jdbc中去拿.... auth.inMemoryAuthentication() .withUser(\"kuangshen\").password(\"123456\").roles(\"vip2\",\"vip3\") .and() .withUser(\"root\").password(\"123456\").roles(\"vip1\",\"vip2\",\"vip3\") .and() .withUser(\"guest\").password(\"123456\").roles(\"vip1\",\"vip2\"); } 9、测试，我们可以使用这些账号登录进行测试！发现会报错！ There is no PasswordEncoder mapped for the id “null” 10、原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码 //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //在内存中定义，也可以在jdbc中去拿.... //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。 //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密 //spring security 官方推荐的是使用bcrypt加密方式。 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(\"kuangshen\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip2\",\"vip3\") .and() .withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\",\"vip3\") .and() .withUser(\"guest\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\"); } 11、测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定 18.2.4、权限控制和注销1、开启自动配置的注销的功能 //定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { //.... //开启自动配置的注销的功能 // /logout 注销请求 http.logout(); } 2、我们在前端，增加一个注销的按钮，index.html 导航栏中 &lt;a class=\"item\" th:href=\"@{/logout}\"&gt; &lt;i class=\"sign out icon\"&gt;&lt;/i&gt; 注销 &lt;/a&gt; 3、我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！ 4、但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？ // .logoutSuccessUrl(\"/\"); 注销成功来到首页 http.logout().logoutSuccessUrl(\"/\"); 5、测试，注销完毕后，发现跳转到首页OK 6、我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？ 我们需要结合thymeleaf中的一些功能 sec：authorize=”isAuthenticated()”:是否认证登录！来显示不同的页面 Maven依赖： &lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 7、修改我们的 前端页面 导入命名空间 xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\" 修改导航栏，增加认证判断 &lt;!--登录注销--&gt; &lt;div class=\"right menu\"&gt; &lt;!--如果未登录--&gt; &lt;div sec:authorize=\"!isAuthenticated()\"&gt; &lt;a class=\"item\" th:href=\"@{/login}\"&gt; &lt;i class=\"address card icon\"&gt;&lt;/i&gt; 登录 &lt;/a&gt; &lt;/div&gt; &lt;!--如果已登录--&gt; &lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;a class=\"item\"&gt; &lt;i class=\"address card icon\"&gt;&lt;/i&gt; 用户名：&lt;span sec:authentication=\"principal.username\"&gt;&lt;/span&gt; 角色：&lt;span sec:authentication=\"principal.authorities\"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;a class=\"item\" th:href=\"@{/logout}\"&gt; &lt;i class=\"sign out icon\"&gt;&lt;/i&gt; 注销 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; 8、重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面； 9、如果注销404了，就是因为它默认防止csrf 跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 http.csrf().disable(); http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求 http.logout().logoutSuccessUrl(\"/\"); 10、我们继续将下面的角色功能块认证完成！ &lt;!-- sec:authorize=\"hasRole('vip1')\" --&gt; &lt;!-- 用户含有vip1规则就展示 --&gt; &lt;div class=\"column\" sec:authorize=\"hasRole('vip1')\"&gt; &lt;div class=\"ui raised segment\"&gt; &lt;div class=\"ui\"&gt; &lt;div class=\"content\"&gt; &lt;h5 class=\"content\"&gt;Level 1&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=\"@{/level1/1}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level1/2}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level1/3}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 用户含有vip2规则就展示 --&gt; &lt;div class=\"column\" sec:authorize=\"hasRole('vip2')\"&gt; &lt;div class=\"ui raised segment\"&gt; &lt;div class=\"ui\"&gt; &lt;div class=\"content\"&gt; &lt;h5 class=\"content\"&gt;Level 2&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=\"@{/level2/1}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level2/2}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level2/3}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 用户含有vip3规则就展示 --&gt; &lt;div class=\"column\" sec:authorize=\"hasRole('vip3')\"&gt; &lt;div class=\"ui raised segment\"&gt; &lt;div class=\"ui\"&gt; &lt;div class=\"content\"&gt; &lt;h5 class=\"content\"&gt;Level 3&lt;/h5&gt; &lt;hr&gt; &lt;div&gt;&lt;a th:href=\"@{/level3/1}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level3/2}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a th:href=\"@{/level3/3}\"&gt;&lt;i class=\"bullhorn icon\"&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 11、测试一下！ 12、权限控制和注销搞定！ 18.2.5、记住我现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单 1、开启记住我功能 //定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { //。。。。。。。。。。。 //记住我 http.rememberMe(); } 2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！ 思考：如何实现的呢？其实非常简单 我们可以查看浏览器的cookie 3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie 4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！ 18.2.6、定制登录页现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？ 1、在刚才的登录页配置后面指定 loginpage http.formLogin().loginPage(\"/toLogin\"); 2、然后前端也需要指向我们自己定义的 login请求 &lt;a class=\"item\" th:href=\"@{/toLogin}\"&gt; &lt;i class=\"address card icon\"&gt;&lt;/i&gt; 登录 &lt;/a&gt; 3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post: 在 loginPage()源码中的注释上有写明： &lt;form th:action=\"@{/login}\" method=\"post\"&gt; &lt;div class=\"field\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;div class=\"ui left icon input\"&gt; &lt;input type=\"text\" placeholder=\"Username\" name=\"name\"&gt; &lt;i class=\"user icon\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"field\"&gt; &lt;label&gt;Password&lt;/label&gt; &lt;div class=\"ui left icon input\"&gt; &lt;input type=\"password\" name=\"pwd\"&gt; &lt;i class=\"lock icon\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;input type=\"submit\" class=\"ui blue submit button\"/&gt; &lt;/form&gt; 4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！ http.formLogin() .usernameParameter(\"name\")//默认参数名是username，要与前端表单提交的属性名一样 .passwordParameter(\"pwd\")//默认参数名是password，，要与前端表单提交的属性名一样 .loginPage(\"/toLogin\") .loginProcessingUrl(\"/login\"); // 登陆表单提交请求 5、在登录页增加记住我的多选框 &lt;input type=\"checkbox\" name=\"remember\"&gt; 记住我 6、后端验证处理！ //定制记住我的参数！ http.rememberMe().rememberMeParameter(\"remember\"); 7、测试，OK 18.3、完整配置代码package com.kuang.config; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { //定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"vip1\") .antMatchers(\"/level2/**\").hasRole(\"vip2\") .antMatchers(\"/level3/**\").hasRole(\"vip3\"); //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！ // /login 请求来到登录页 // /login?error 重定向到这里表示登录失败 http.formLogin() .usernameParameter(\"username\") .passwordParameter(\"password\") .loginPage(\"/toLogin\") .loginProcessingUrl(\"/login\"); // 登陆表单提交请求 //开启自动配置的注销的功能 // /logout 注销请求 // .logoutSuccessUrl(\"/\"); 注销成功来到首页 http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求 http.logout().logoutSuccessUrl(\"/\"); //记住我 http.rememberMe().rememberMeParameter(\"remember\"); } //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //在内存中定义，也可以在jdbc中去拿.... //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。 //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密 //spring security 官方推荐的是使用bcrypt加密方式。 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(\"kuangshen\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip2\",\"vip3\") .and() .withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\",\"vip3\") .and() .withUser(\"guest\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\"); } } 去进行一波源码分析！ 19、SpringBoot：整合Shiro19.1、Shiro介绍1. Shiro是什么 Apache Shiro是一个强大灵活的开源安全框架，可以完全处理身份验证，授权，企业会话管理和加密。 Apache Shiro的首要目标是易于使用和理解。 安全有时可能非常复杂，甚至痛苦，但使用Shiro后就不一定是这样了。 框架应该在可能的情况下掩盖复杂性，并展示一个干净，直观的API，这简化了开发人员工作，并使应用程序更安全。 这里有一些可以使用Apache Shiro完全的应用场景： 验证用户以及验证其身份。 对用户执行访问控制，例如：在任何环境中使用会话API，即使没有Web或EJB容器。 确定用户是否分配了某个安全角色。 确定用户是否被允许执行操作。 在身份验证，访问控制或会话有效期内对事件做出反应。 聚合1个或多个用户安全数据的数据源，并将此全部显示为单个复合用户的“视图”。 启用单点登录(SSO)功能。 为用户关联启用“记住我”服务，无需登录。… 和更多 - 所有都集成到一个内聚易于使用的API。 Shiro尝试为所有应用程序环境实现这些目标 - 从最简单的命令行应用程序到最大的企业应用程序，而不强制依赖于其他第三方框架，容器或应用程序服务器。 当然，该项目(Shiro)旨在尽可能地集成到这个Shiro环境中，从而可以在任何环境中想用即用。 2. Shiro体系结构 Shiro目标是什么？Shiro开发团队称为“应用程序安全的四个基石” - 即：认证，授权，会话管理和加密： Authentication：身份认证 / 登录，验证用户是不是拥有相应的身份； Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限； Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的； Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储； 在不同的应用环境中还有其他特性支持和强化这些问题，特别是： Web Support：Web 支持，可以非常容易的集成到 Web 环境； Caching：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率； Concurrency：并发性，shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去； Testing：测试，存在测试支持，可帮助您编写单元测试和集成测试，并确保代码按预期得到保障； Run As：运行方式，允许用户承担另一个用户的身份(如果允许)的功能，有时在管理方案中很有用； Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。 记住一点，Shiro 不会去维护用户、维护权限；这些需要我们自己去设计 / 提供；然后通过相应的接口注入给 Shiro 即可。 3. 内外分析Shiro架构 从外部和内部来看看 Shiro 的架构，对于一个好的框架，从外部来看应该具有非常简单易于使用的 API，且 API 契约明确；从内部来看的话，其应该有一个可扩展的架构，即非常容易插入用户自定义实现，因为任何框架都不能满足所有需求。 3.1 从外部来看 Shiro（从应用程序角度的来观察如何使用 Shiro 完成工作） 可以看到：应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject。 其每个 API 的含义： Subject：主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者； SecurityManager：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器； Realm：域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。 也就是说对于我们而言，最简单的一个 Shiro 应用： 应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager； 我们需要给 Shiro 的 SecurityManager 注入 Realm，从而让 SecurityManager 能得到合法的用户及其权限进行判断。 从以上也可以看出，Shiro 不提供维护用户 / 权限，而是通过 Realm 让开发人员自己注入。 3.2 从内部来看 Shiro 的架构 其每个 API 的含义： Subject：主体，可以看到主体可以是任何可以与应用交互的 “用户”； SecurityManager：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。 Authenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了； Authorizer：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能； Realm：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm； SessionManager：如果写过 Servlet 就应该知道 Session 的概念，Session 需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所以，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）； SessionDAO：DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能； CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能 Cryptography：密码模块，Shiro 提高了一些常见的加密组件用于如密码加密 / 解密的。 19.2、快速入门maven项目目录： 1.shiro快速入门需要的依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- configure logging --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.shiro.ini文件 [users] # user 'root' with password 'secret' and the 'admin' role root = secret, admin # user 'guest' with the password 'guest' and the 'guest' role guest = guest, guest # user 'presidentskroob' with password '12345' (\"That's the same combination on my luggage!!!\" ;)), and role 'president' presidentskroob = 12345, president # user 'darkhelmet' with password 'ludicrousspeed' and roles 'darklord' and 'schwartz' darkhelmet = ludicrousspeed, darklord, schwartz # user 'lonestarr' with password 'vespa' and roles 'goodguy' and 'schwartz' lonestarr = vespa, goodguy, schwartz # ----------------------------------------------------------------------------- # Roles with assigned permissions # # Each line conforms to the format defined in the # org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc # ----------------------------------------------------------------------------- [roles] # 'admin' role has all permissions, indicated by the wildcard '*' admin = * # The 'schwartz' role can do anything (*) with any lightsaber: schwartz = lightsaber:* # The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with # license plate 'eagle5' (instance specific id) goodguy = winnebago:drive:eagle5 [users]下面包含了 （用户名）=（密码），（角色名） [roles]下面包含了 角色名、对应的权限 3.Quickstart.java public class Quickstart { private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class); public static void main(String[] args) { //创建具有配置的领域，用户，角色和权限的Shiro SecurityManager的最简单方法是使用简单的INI配置。 //我们将通过使用可以提取.ini文件并返回SecurityManager实例的工厂来做到这一点： //在类路径的根目录下使用shiro.ini文件 ，使用工厂生成一个securityManager实例，将提前定义好的shiro.ini文件内容加载进去 Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\"); SecurityManager securityManager = factory.getInstance(); // 对于这个简单的示例快速入门，使SecurityManager作为JVM单例进行访问。大多数应用程序不这样做，而是依靠其容器配置或web.xml来 // webapps。这超出了此简单快速入门的范围，因此我们将只做最少的工作，以便您可以继续对事物有所了解。 SecurityUtils.setSecurityManager(securityManager); //获取当前用户对象, 1.这里的currentUser对象说白了就是一个用户容器，可以用来载入前端输入的真实用户信息 Subject currentUser = SecurityUtils.getSubject(); //通过当前用户获取session Session session = currentUser.getSession(); session.setAttribute(\"someKey\", \"aValue\"); String value = (String) session.getAttribute(\"someKey\"); if (value.equals(\"aValue\")) { log.info(\"Retrieved the correct value! [\" + value + \"]\"); } // 判断当前用户是否被认证， 2.这时currentUser还没有载入用户信息，执行isAuthenticated()实现与之前ini定义好的内容进行检索比较，肯定匹配不成功 if (!currentUser.isAuthenticated()) { //Token:令牌 3.把输入的真实用户信息封装到token对象中 UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\"); token.setRememberMe(true); //记住我 try { // 4.把token注入currentUser对象的.login()方法中执行登录操作,这里的.login(XXX)方法会将token中的用户信息 // 和shiro.ini定义的用户信息进行匹配，若匹配成功则登录成功，且currentUser也会成为一个真正意义上的用户对象，而不是一个空的用户容器， // 若匹配失败，则会catch 以下种类的异常信息 currentUser.login(token); //执行登录操作 } catch (UnknownAccountException uae) { //4.1 用户名不存在的异常 log.info(\"There is no user with username of \" + token.getPrincipal()); } catch (IncorrectCredentialsException ice) { //4.2 密码不对的异常 log.info(\"Password for account \" + token.getPrincipal() + \" was incorrect!\"); } catch (LockedAccountException lae) { //4.3 用户被锁定的异常 log.info(\"The account for username \" + token.getPrincipal() + \" is locked. \" + \"Please contact your administrator to unlock it.\"); } // ... catch more exceptions here (maybe custom ones specific to your application? catch (AuthenticationException ae) { // 认证异常，上面的异常都是其子类 //unexpected condition? error? } } //say who they are: //打印其标识主体（在这种情况下为用户名） log.info(\"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\"); //test a role: //判断当前用户是否拥有某种角色 if (currentUser.hasRole(\"schwartz\")) { log.info(\"May the Schwartz be with you!\"); } else { log.info(\"Hello, mere mortal.\"); } //测试用户是否具备某一个行为权限，调用subject的isPermitted()方法（不是实例级别） //粗粒度 if (currentUser.isPermitted(\"lightsaber:wield\")) { log.info(\"You may use a lightsaber ring. Use it wisely.\"); } else { log.info(\"Sorry, lightsaber rings are for schwartz masters only.\"); } //（非常强大的）实例级别权限： //细粒度 if (currentUser.isPermitted(\"winnebago:drive:eagle5\")) { log.info(\"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'. \" + \"Here are the keys - have fun!\"); } else { log.info(\"Sorry, you aren't allowed to drive the 'eagle5' winnebago!\"); } //下面三行代码，第二行用于执行用户的退出操作，第一行和第三行用于检验退出操作是否成功 System.out.println(\"----&gt;\" + currentUser.isAuthenticated()); // 5.currentUser.logout()方法会清空currentUser中session的所有用户信息 currentUser.logout(); System.out.println(\"----&gt;\" + currentUser.isAuthenticated()); System.exit(0); } } 以上就是最简单的shiro快速入门，其中shiro.ini用来模拟数据库中存储的用户相关信息，代码中标黄放大的注释表达方式可能比较口语化且意思不一定十分准确，但主要还是为了便于理解，希望对你有所帮助。 19.3、SpringBoot 整合目录： 1.该整合项目所需的依赖&lt;dependencies&gt; &lt;!-- subject 用户 securityManager 管理所有用户 realm 连接数据 --&gt; &lt;!--连接数据库的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.23&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入mybatis,这是mybatis官方提供的适配springboot的，而不是springboot自己的--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--不想书写setter、getter方法，导入此依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.22&lt;/version&gt; &lt;/dependency&gt; &lt;!--shiro整合spring的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--导入thymeleaf依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--shiro-thymeleaf整合--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;aliyun-plugin&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 2.application.yml设置连接数据库的相关配置spring: datasource: username: root password: 123456 #?serverTimezone=UTC解决时区的报错 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 3.index.html&lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.w3.org/1999/xhtml?\" xmlns:shiro=\"http://www.thymeleaf.org/thymeleaf-extras-shiro\" &gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;div th:if=\"${session.loginUser==null}\"&gt; &lt;a th:href=\"@{/toLogin}\"&gt;登录&lt;/a&gt; &lt;/div&gt; &lt;p th:text=\"${msg}\"&gt;&lt;/p&gt; &lt;hr&gt; &lt;div shiro:hasPermission=\"user:add\"&gt; &lt;a th:href=\"@{/user/add}\"&gt;add&lt;/a&gt; &lt;/div&gt; &lt;div shiro:hasPermission=\"user:update\"&gt; &lt;a th:href=\"@{/user/update}\"&gt;update&lt;/a&gt; &lt;/div&gt; &lt;a th:href=\"@{/logout}\"&gt;注销&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 4.add.html和update.html&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;add&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; ------------------------------------------------- &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;update&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 5.login.html&lt;!DOCTYPE html&gt; &lt;html lang=\"en\" xmlns:th=\"http://www.w3.org/1999/xhtml?\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;登录&lt;/h1&gt; &lt;hr&gt; &lt;p th:text=\"${msg}\" style=\"color:red;\"&gt;&lt;/p&gt; &lt;form th:action=\"@{/login}\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt; 密码：&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" name=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 6.MyController.java@Controller public class MyController { @RequestMapping({\"/\",\"/index\"}) public String toIndex(Model model){ model.addAttribute(\"msg\",\"hello,shiro!\"); return \"index\"; } @RequestMapping(\"/user/add\") public String add(){ return \"user/add\"; } @RequestMapping(\"/user/update\") public String update(){ return \"user/update\"; } @RequestMapping(\"/toLogin\") public String toLogin(){ return \"login\"; } @RequestMapping(\"/login\") public String login(String username,String password,Model model){ //获取当前用户 Subject subject = SecurityUtils.getSubject(); //封装用户的登录数据 UsernamePasswordToken token = new UsernamePasswordToken(username, password); try{ subject.login(token); //执行登录的方法，如果没有异常就说明ok了 return \"index\"; }catch (UnknownAccountException e){ //用户名不存在 model.addAttribute(\"msg\",\"用户名不存在！\"); return \"login\"; }catch (IncorrectCredentialsException e){ model.addAttribute(\"msg\",\"密码错误！\"); return \"login\"; } } @RequestMapping(\"/noauth\") @ResponseBody public String unauthorized(){ return \"未授权无法访问此页面\"; } @RequestMapping(\"/logout\") public String logout(){ //获取当前用户 Subject subject = SecurityUtils.getSubject(); System.out.println(subject.getSession().getAttribute(\"loginUser\")); subject.logout(); // session 会销毁，在SessionListener监听session销毁，清理权限缓存 System.out.println(subject.getSession().getAttribute(\"loginUser\")); System.out.println(\"执行了退出\"); return \"login\"; } } 7.ShiroConfig.java@Configuration public class ShiroConfig { //ShiroFilterFactoryBean （第三步:连接到前端） @Bean public ShiroFilterFactoryBean getShiroFilterBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager defaultWebSecurityManager){ ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean(); //设置安全管理器 bean.setSecurityManager(defaultWebSecurityManager); //添加shiro的内置过滤器 /* anon: 无需认证即可访问 authc: 必须认证才能用 user: 必须拥有 “记住我” 功能才能用 perms: 拥有对某个资源的权限才能用 role: 拥有某个角色权限才能访问 */ Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;(); //授权，正常情况下没有授权会跳转到未授权页面 filterMap.put(\"/user/add\",\"perms[user:add]\"); filterMap.put(\"/user/update\",\"perms[user:update]\"); //拦截 filterMap.put(\"/user/add\",\"authc\"); filterMap.put(\"/user/update\",\"authc\"); //也可使用通配符* //filterMap.put(\"/user/*\",\"authc\"); 这样写就必须得在权限验证链接下面，不然无法正常进行权限验证授权 bean.setFilterChainDefinitionMap(filterMap); //若访问时用户未认证，则跳转至登录页面 bean.setLoginUrl(\"/toLogin\"); //若访问时用户未被授权，则跳转至未授权页面 bean.setUnauthorizedUrl(\"/noauth\"); return bean; } //DefaultWebSecurityManager （第二步：管理realm对象） @Bean(name=\"securityManager\") //@Bean注解后便被spring托管,不加name属性，默认name值为方法名,这里就加一下吧 public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm){ DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); //关联UserRealm securityManager.setRealm(userRealm); return securityManager; } //创建realm对象，需要自定义类 (第一步:创建realm对象) @Bean(name=\"userRealm\") //@Bean注解后便被spring托管,不加name属性，默认name值为方法名,这里就加一下吧 public UserRealm userRealm(){ return new UserRealm(); } //整合ShiroDialect:用来整合shiro thymeleaf @Bean public ShiroDialect getShiroDialect(){ return new ShiroDialect(); } } 注意：**filterMap.put(\"/user/*\",\"authc\");必须写在 filterMap.put(\"/user/add\",\"perms[user:add]\");下面** 8.UserRealm.java//自定义UserRealm extends AuthorizingRealm public class UserRealm extends AuthorizingRealm { @Autowired UserService userService; //授权 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { System.out.println(\"执行了授权\"); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); //info.addStringPermission(\"user:add\"); //拿到当前登录的对象 Subject subject = SecurityUtils.getSubject(); User currentUser = (User) subject.getPrincipal(); //拿到user对象 info.addStringPermission(currentUser.getPerms()); return info; } //认证 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { System.out.println(\"执行了认证\"); //令牌 UsernamePasswordToken userToken = (UsernamePasswordToken) token; /* //用户名、密码 模拟从数据库中获取 String name = \"root\"; String password = \"1111\"; if (!userToken.getUsername().equals(name)){ return null; //抛出异常 UnknownAccountException } //密码认证，shiro做~ return new SimpleAuthenticationInfo(\"\",password,\"\"); */ //连接真实数据库 User user = userService.queryUserByName(userToken.getUsername()); if (user==null){ //没有这个人 return null; //抛出异常 UnknownAccountException } Subject currentSubject = SecurityUtils.getSubject(); Session session = currentSubject.getSession(); session.setAttribute(\"loginUser\",user); //可以加密： MD5加密 MD5盐值加密 //密码认证，shiro做~ return new SimpleAuthenticationInfo(user,user.getPwd(),\"\"); } } 9.UserMapper.java@Repository @Mapper public interface UserMapper { public User queryUserByName(String name); } 10.UserMapper.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.ztx.mapper.UserMapper\"&gt; &lt;select id=\"queryUserByName\" parameterType=\"String\" resultType=\"User\"&gt; select * from mybatis.user where name=#{name} &lt;/select&gt; &lt;/mapper&gt; 11.User.java@Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; private String pwd; private String perms; } 12.UserService.java和UserServiceImpl.javapublic interface UserService { public User queryUserByName(String name); } ----------------------------------------------------- @Service public class UserServiceImpl implements UserService{ @Autowired UserMapper userMapper; @Override public User queryUserByName(String name) { return userMapper.queryUserByName(name); } } 13.数据库中的user表（perms前缀user：并无作用，可以去掉，修饰作用而已，相应位置使用到也要跟着去掉前缀，如果要多权限，只要在数据库perms列逗号再加加上权限参数就行） 个人对该项目执行流程进行了梳理，如有错误，请指正： 1.ShiroConfig.java中设置好拦截器，规定哪些页面需要用户具备何种要求才可访问，同时还设置当用户不满足要求时应该跳转至什么页面。对应本项目的代码： 2.用户在未认证下，会跳转到登陆页面login.html。输入用户名密码，提交执行controller中的login()方法，该方法内将用户信息封装成token对象，传入subject.login()方法内进行登录验证。对应项目代码： 3.执行登录验证时会跳转到UserRealm类，首先执行认证(doGetAuthenticationInfo)：连接数据库判断是否有此人，若没有则返回结果null，若有，则将数据库中的用户信息存储在subject的session中。接着进行密码验证，若验证失败，则将登录不通过返回失败认证信息，反之，返回成功的认证信息，并执行用户授权(doGetAuthorizationInfo)操作，返回授权信息。对应项目代码： 认证： 授权： 4.本项目中登录成功后跳转到index.html时依旧会再次执行授权操作，因为前端页面需要一个判断展示功能，代码如下： 故控制台信息会是这样：（出现两次授权） 5.之后进入add.html或update.html时，因为会被拦截，所以都要进行授权验证，而此时认证将不会在执行。 20、SpringBoot：整合 RedisSpringBoot 操作数据：spring-data jpa jdbc mongodb redis！ SpringData 也是和 SpringBoot 齐名的项目！ 说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce? jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接 池！ 更像 BIO 模式 lettuce : 采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据 了，更像 NIO 模式 源码分析： @Bean // 我们可以自己定义一个redisTemplate来替换这个默认的！ @ConditionalOnMissingBean(name = \"redisTemplate\") public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory isConnectionFactory) throws UnknownHostException { // 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！ // 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean // 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！ public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } 整合测试一下 1 、导入依赖 &lt;!-- 操作redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2 、配置连接 # 配置redis spring.redis.host=127.0.0.1 spring.redis.port= 6379 3 、测试！ @SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { // redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // opsForValue 操作字符串 类似String ，位图在这个里面 // opsForList 操作List 类似List // opsForSet // opsForHash // opsForZSet // opsForGeo // opsForHyperLogLog // 除了进本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD // 获取redis的连接对象 // RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); // connection.flushDb(); // connection.flushAll(); redisTemplate.opsForValue().set(\"mykey\",\"关注狂神说公众号\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\")); } } 关于对象的保存： 我们来编写一个自己的 RedisTemplete package com.kuang.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration public class RedisConfig { // 自己定义了一个 RedisTemplate @Bean @SuppressWarnings(\"all\") public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) { // 固定模板，在企业中，拿去就可以直接使用！ // 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); // Json序列化配置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // String 的序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; } 所有的redis操作，其实对于java开发人员来说，十分的简单，更重要是要去理解redis的思想和每一种数据结构的用处和作用场景！ 21、总结## 聊聊现在和未来 三层架构 + MVC 架构 ---&gt; 解耦 开发框架 Spring IOC AOP ​ IOC ：控制反转 ​ 约泡： ​ 泡温泉，泡茶.....泡友 ​ 附近的人，打招呼。加微信，聊天，天天聊，---&gt;约泡 ​ 浴场(容器) :温泉， 茶庄，泡友 ​ 直接进温泉，就有人和你一起了! ​ 原来我们都是自己一步步操作，现在交给容器了!我们需要什么就去拿就可以了 ​ AOP :切面(本质，动态代理) ​ 为了解决什么?不影响业务本来的情况下，实现动态增加功能，大量应用在日志，事务...等等方面 ​ Spring是一个轻量级的Java开源框架，容器 ​ 目的:解决企业开发的复杂性问题 ​ Spring是春天，觉得他是春天，也十分复杂，配置文件! ​ SpringBoot ​ SpringBoot并不是新东西，就是Spri ng的升级版! 新一代JavaEE的开发标准，开箱即用! -&gt;拿过来就可以用! 它自动帮我们配置了非常多的东西，我们拿来即用! ​ 特性:约定大于配置! 随着公司体系越来越大，用户越来越多! 微服务架构---&gt;新架构 ​ 模块化，功能化! ​ 用户，支付，签到，娱乐，..... ; ​ 人多余多:一台服务器解决不了;在增加服务器 ! 横向 ​ 假设A服务器占用98%资源，B服务器只占用了10% 。一-负载均衡; ​ 将原来的整体项目，分成模块化，用户就是一个单独的项目，签到也是一个单独的项目， 项目和项目之前需要通信，如何通信? ​ 用户非常多，而签到十分少! 给用户多一点服务器，给签到少一点服务器! 微服务架构问题? 分布式架构会遇到的四个核心问题? 1. 这么多服务，客户端该如何去访问? 2. 这么多服务，服务之间如何进行通信? 3. 这么多服务，如何治理呢? 4. 服务挂了，怎么办? 解决方案: ​ SpringCloud,是一套生态，就是来解决以上分布式架构的4个问题 ​ 想使用SpringCloud,必须要掌握SpringBoot,因为SpringCloud是基 于SpringBoot; 1. Spring Cloud NetFlix ，出来了一套解决方案! - -站式解决方案。我们都可以直接去这里拿? ​ Api网关，zuu1组件 ​ Feign --&gt; HttpClient ---&gt; HTTP的通信方式，同步并阻塞 ​ 服务注册与发现，Eureka ​ 熔断机制，Hystrix ​ ​ 2018年年底，NetFlix宣布无限期停止维护。生态不再维护，就会脱节。 2. Apache Dubbo zookeeper，第二套解决系统 ​ API ： 没有! 要么找第三方组件，要么自己实现 ​ Dubbo是一个高性能的基于Java实现的RPC通信框架！ 2.6.x ​ 服务注册与发现，zookeeper: 动物园管理者(Hadoop ，Hive) ​ 没有： 借助了Hystrix ​ ​ 不完善，Dubbo . 3. SpringCloud Alibaba-站式解决方案 ! 目前，又提出了一种方案: ​ 服务网格：下一代微服务标准，Service Mesh ​ 代表解决方案: istio (你们未来可能需要掌握! ) 万变不离其宗，一通百通! 1. API网关，服务路由 2. HTTP，RPC框架，异步调用 3. 服务注册与发现，高可用 4. 熔断机制，服务降级 为什么要解决这个问题？ 本质：网络是不可靠的！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"数据结构和算法","slug":"Java数据结构和算法","date":"2021-05-02T03:37:34.000Z","updated":"2021-09-14T09:23:56.825Z","comments":true,"path":"posts/ea4e9726.html","link":"","permalink":"https://gitee.com/td278121/posts/ea4e9726.html","excerpt":"","text":"数据结构和算法的关系 数据 data 结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以编写出更加漂亮,更加有效率的代码。 要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决. 3) 程序 = 数据结构 + 算法 数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。 数据结构包括：线性结构和非线性结构。 线性结构 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系 线性结构有两种不同的存储结构，即**顺序存储结构数组)和链式存储结构(链表)**。顺序存储的线性表称为顺序 表，顺序表中的存储元素是连续的 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地 址信息 线性结构常见的有：数组、队列、链表和栈，后面我们会详细讲解 非线性结构 非线性结构包括：二维数组，多维数组，广义表，树结构，图结构 稀疏 sparsearray 数组 基本介绍 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方法是: 记录数组一共有几行几列，有多少个不同的值 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模 第一行数组表示整个二维数组有6行7列，共有8个数据 应用实例 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等) 把稀疏数组存盘，并且可以从新恢复原来的二维数组数 整体思路分析 package sparseArray; public class SparseArray { public static void main(String[] args) { //创建一个二维数组 // 0: 表示没有棋子， 1 表示 黑子 2 表蓝子 int[][] ChessArray1 = new int[11][11]; ChessArray1[2][1] = 1; ChessArray1[3][2] = 2; //输出原数组 System.out.println(\"原始的二维数组~~~~\"); for (int[] row : ChessArray1) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); } //将二维数组 转为 稀疏数组 //先遍历二维数组 int sum =0; //统计原数组里面的数据个数 for (int i = 0; i &lt; 11; i++) { for (int j = 0; j &lt; 11; j++) { if (ChessArray1[i][j] != 0) { sum++; } } } //创建稀疏数组 int[][] sparseArray = new int[sum + 1][3]; //给稀疏数组赋值,第一行存放原二维数组的数据 sparseArray[0][0] = 11; sparseArray[0][1] = 11; sparseArray[0][2] = sum; //遍历二维数组，将非0 的数赋值给稀疏数组 int count = 0; //用于记录第几个非0 数据 for (int i = 0; i &lt; 11; i++) { for (int j = 0; j &lt; 11; j++) { if (ChessArray1[i][j] != 0) { count++; sparseArray[count][0] = i; //存放行索引 sparseArray[count][1] = j; //存放列索引 sparseArray[count][2] = ChessArray1[i][j]; //存放数值 } } } //输出稀疏数组 System.out.println(\"稀疏数组为~~~~\"); for (int[] row : sparseArray) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); } //将稀疏数组 转为 原二维数组 //1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 int[][] ChessArray2 = new int[sparseArray[0][0]][sparseArray[0][1]]; //2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可 for (int i = 1; i &lt; sparseArray.length; i++) { ChessArray2[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2]; } //输出转换后的原二维数组 System.out.println(\"转换后的原二维数组为~~~~\"); for (int[] row : ChessArray2) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); } } } 队列 队列是一个有序列表，可以用数组或是链表来实现。 遵循先入先出的原则。即：**先存入队列的数据，要先取出。后存入的要后取出 ** 示意图：(使用数组模拟队列示意图) 数组模拟队列 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。  因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变，如图所示:  当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析 将尾指针往后移：rear+1 , 当 front == rear 【空】 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。 rear == maxSize - 1[队列满] package Array.ArrayQueue; import java.util.Scanner; public class arrayQueuedemo { public static void main(String[] args) { ArrayQueue queue = new ArrayQueue(3); boolean loop = true; char key;//接收用户输入 Scanner scanner = new Scanner(System.in); //输出一个菜单 while (loop) { System.out.println(\"s(show): 显示队列\"); System.out.println(\"e(exit): 退出程序\"); System.out.println(\"a(add): 添加数据到队列\"); System.out.println(\"g(get): 从队列取出数据\"); System.out.println(\"h(head): 查看队列头的数据\"); key = scanner.next().charAt(0); switch (key) { case 's': queue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': try { queue.addQueue(scanner.nextInt()); } catch (Exception e) { System.out.println(e.getMessage()); } break; case 'g'://取出数据 try { int head = queue.getQueue(); System.out.println(\"出列的数据为\" + head); } catch (Exception e) { System.out.println(e.getMessage()); } break; case 'h'://查看队列头的数据 try { int head = queue.headQueue(); System.out.printf(\"队列的头部数据为%d\\n\", head); } catch (Exception e) { System.out.println(e.getMessage()); } } } System.out.println(\"程序退出\"); } } // 使用数组模拟队列-编写一个 ArrayQueue 类 class ArrayQueue { private int maxSize; //队列的最大容量 private int head;//队列头 private int tail;//队列尾 private int[] arr;//存放队列数据 ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; head = -1;//指向队列头部的前一个位置 tail = -1;//指向队列最后一个数据 } //判断队列是否满 public boolean isFull() { if (tail == maxSize - 1) { return true; } return false; } //判断队列是否为空 public boolean isEmpty() { return tail == head; } //输出队列的所有数据 public void showQueue() { if (isEmpty()) { System.out.println(\"队列为空\"); return; } for (int i = head + 1; i &lt; arr.length; i++) { //因为头部指针指向头部前一个位置所以要加一 System.out.printf(\"arr[%d]=%d\\n\", i, arr[i]); } } //添加数据,进队列 public void addQueue(int data) { if (isFull()) { throw new RuntimeException(\"队列已经满了\"); } tail++; //尾部指针向后移 arr[tail] = data; } //出队列，获取头部数据 public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"队列为空，不能获取头部\"); } head++; //头部指针向后移 return arr[head]; } // 显示队列的头数据， 注意不是取出数据 public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"队列空的，没有数据~~\"); } return arr[head + 1]; } } 问题分析并优化 目前数组使用一次就不能用， 没有达到复用的效果 将这个数组使用算法，改进成一个环形的队列 取模：% 数组模拟环形队列对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)  分析说明： 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear + 1) % maxSize == front 满] rear == front [空] 分析示意图 package Array.ArrayQueue; import java.util.Scanner; public class CircleArrayQueueDemo { public static void main(String[] args) { CircleArrayQueue queue = new CircleArrayQueue(4);//实际容量只有3，因为有一个空间作为约定 boolean loop = true; char key;//接收用户输入 Scanner scanner = new Scanner(System.in); //输出一个菜单 while (loop) { System.out.println(\"s(show): 显示队列\"); System.out.println(\"e(exit): 退出程序\"); System.out.println(\"a(add): 添加数据到队列\"); System.out.println(\"g(get): 从队列取出数据\"); System.out.println(\"h(head): 查看队列头的数据\"); key = scanner.next().charAt(0); switch (key) { case 's': queue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': try { queue.addQueue(scanner.nextInt()); } catch (Exception e) { System.out.println(e.getMessage()); } break; case 'g': try { int head = queue.getQueue(); System.out.println(\"出列的数据为\" + head); } catch (Exception e) { System.out.println(e.getMessage()); } break; case 'h': try { int head = queue.headQueue(); System.out.printf(\"队列的头部数据为%d\\n\", head); } catch (Exception e) { System.out.println(e.getMessage()); } } } System.out.println(\"程序退出\"); } } class CircleArrayQueue { private int maxSize; //队列的最大容量 private int head;//队列头 private int tail;//队列尾 private int[] arr;//存放队列数据 CircleArrayQueue(int maxSize) { this.maxSize = maxSize; //环形数组队列的实际容量是参数-1，因为要留一个空间做约定 arr = new int[maxSize]; //front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 head = 0; //rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定 tail = 0; } //判断队列是否满 public boolean isFull() { return (tail + 1) % maxSize == head; } //判断队列是否为空 public boolean isEmpty() { return tail == head; } //输出队列的所有数据 public void showQueue() { if (isEmpty()) { System.out.println(\"队列为空\"); return; } for (int i = head ; i &lt; head+getsize(); i++) { System.out.printf(\"arr[%d]=%d\\n\", i%maxSize, arr[i%maxSize]); } } //添加数据,进队列 public void addQueue(int data) { if (isFull()) { throw new RuntimeException(\"队列已经满了\"); } arr[tail] = data; tail=(tail+1)%maxSize; //尾部指针向后移 } //出队列，获取头部数据 public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"队列为空，不能获取头部\"); } int val = arr[head]; head=(head+1)%maxSize; //头部指针向后移 return val; } // 显示队列的头数据， 注意不是取出数据 public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"队列空的，没有数据~~\"); } return arr[head]; } //获得队列的长度 public int getsize() { return (tail + maxSize - head) % maxSize; } } 链表链表是有序的列表，但是它在内存中是存储如下 小结上图: 链表是以节点的方式来存储,是链式存储 每个节点包含 data 域， next 域：指向下一个节点. 如图：发现链表的各个节点不一定是连续存储. 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 单链表 单链表(带头结点) 逻辑结构示意图如下 单链表的应用实例 使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作， 注: 删除和修改,查找 可以考虑学员独立完成，也可带学员完成 ​ 1) 第一种方法在添加英雄时，直接添加到链表的尾部 ​ 思路分析示意图: ​ 2) 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) ​ 思路的分析示意图: ​ 3) 修改节点功能 ​ 思路 (1) 先找到该节点，通过遍历， ​ (2) temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname ​ 4) 删除节点 ​ 思路分析的示意图: package LinkedList; public class SingleLinkedListDemo { public static void main(String[] args) { SingleLinkedList singleLinkedList = new SingleLinkedList(); // //添加节点 // singleLinkedList.addHero(new HeroNode(1, \"宋江\", \"及时雨\")); // singleLinkedList.addHero(new HeroNode(2, \"吴用\", \"智多星\")); // singleLinkedList.addHero(new HeroNode(3, \"林冲\", \"豹子头\")); //按顺序排序 singleLinkedList.addHeroByOrder(new HeroNode(2, \"吴用\", \"智多星\")); singleLinkedList.addHeroByOrder(new HeroNode(1, \"宋江\", \"及时雨\")); singleLinkedList.addHeroByOrder(new HeroNode(3, \"林冲\", \"豹子头\")); singleLinkedList.addHeroByOrder(new HeroNode(1, \"宋江\", \"及时雨\")); //遍历输出 System.out.println(\"修改前\"); singleLinkedList.list(); //修改节点信息 singleLinkedList.update(new HeroNode(1, \"宋江1号\", \"及时雨来了\")); //遍历输出 System.out.println(\"修改后\"); singleLinkedList.list(); //删除3号节点 singleLinkedList.delete(3); singleLinkedList.delete(2); System.out.println(\"删除后\"); singleLinkedList.list(); } } //单向链表用来管理英雄 class SingleLinkedList { //先初始化一个头节点, 头节点不要动, 不存放具体的数据 private HeroNode headNode = new HeroNode(0, \"\", \"\"); //添加节点到单向链表 // 思路，当不考虑编号顺序时 // 1. 找到当前链表的最后节点 // 2. 将最后这个节点的 next 指向 新的节点 public void addHero(HeroNode heroNode) { //temp辅助指针 HeroNode temp = headNode; //头结点，不动，没有数据 while (temp.next != null) { temp = temp.next; //直到最后一个节点 } temp.next = heroNode; } //按编号排序添加 public void addHeroByOrder(HeroNode heroNode) { //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置 // 因为单链表，因为我们找的 temp 是位于 添加位置的前一个节点，否则插入不了 HeroNode temp = headNode; boolean flag = false; //标志添加的节点编号是否已经存在 while (true) { if (temp.next == null) {//说明 temp 已经在链表的最后 break; } if (temp.next.No &gt; heroNode.No) {//位置找到，就在 temp 的后面插入 break; } if (temp.next.No == heroNode.No) {//说明希望添加的 heroNode 的编号已然存在 flag = true; break; } temp = temp.next; //后移，遍历当前链表 } if (flag) {//为真则不能添加，说明编号存在 System.out.println(\"要添加的编号\" + heroNode.No + \"已经存在\"); return; } else { //插入到链表中, temp 的后面 heroNode.next = temp.next; temp.next = heroNode; } } //修改节点的信息, 根据 no 编号来修改，即 no 编号不能改. // 说明 // 1. 根据 newHeroNode 的 no 来修改即可 public void update(HeroNode heroNode) { if (headNode.next == null) { System.out.println(\"链表为空\"); return; } //找到需要修改的节点, 根据 no 编号 // 定义一个辅助变量，指向第一个节点，不是头结点 HeroNode temp = headNode.next; while (true) { if (temp == null) {//已经遍历完链表 System.out.println(\"没有相对应的节点\"); break; } if (temp.No == heroNode.No) { temp.Name = heroNode.Name; temp.nickName = heroNode.nickName; System.out.println(\"修改节点成功\"); break; } temp = temp.next;//temp 后移，遍历 } } //删除节点 // 1. head 不能动，因此我们需要一个 temp 辅助节点找到待删除节点的前一个节点 // 2. 说明我们在比较时，是 temp.next.no 和 需要删除的节点的 no 比较 public void delete(int no) { if (headNode.next == null) { System.out.println(\"链表为空\"); return; } HeroNode temp = headNode; while (true) { if (temp.next == null) {//已经到链表的最后 System.out.println(\"没有找到相对应的节点\"); break; } if (temp.next.No == no) {//找到的待删除节点的前一个节点 temp temp.next = temp.next.next; System.out.println(\"节点删除成功\"); break; } temp = temp.next;//temp 后移，遍历 } } //显示链表[遍历] public void list() { HeroNode temp = headNode;//头结点，不动，没有数据 while (temp.next != null) { temp = temp.next; //头结点没有数据，所以要先指向下一个 System.out.println(temp); } return; } } //定义HeroNode节点，每个HeroNode节点就是一个节点 class HeroNode { public int No; //英雄排名 public String Name; //英雄名字 public String nickName; //别名 public HeroNode next; //指向下一个节点 HeroNode(int no, String name, String nickName) { this.No = no; this.Name=name; this.nickName = nickName; } @Override public String toString() { return \"HeroNode{\" + \"No=\" + No + \", Name='\" + Name + '\\'' + \", nickName='\" + nickName + '\\'' + '}'; } } 单链表面试题(新浪、百度、腾讯)单链表的常见面试题有如下: 求单链表中有效节点的个数 /** *获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点) * @param headNode 链表头结点 * @return 返回链表节点个数 */ public static int getLength(HeroNode headNode) { if (headNode.next == null) { //链表为空 return 0; } HeroNode temp = headNode.next; //辅助指针，指向第一个节点 int length = 0; //记录链表节点个数 while (temp != null) { length++; temp = temp.next; //向后遍历 } return length; } 查找单链表中的倒数第 k 个结点 【新浪面试题】 //查找单链表中的倒数第 k 个结点 【新浪面试题】 // 思路 // 1. 编写一个方法，接收 head 节点，同时接收一个 index // 2. index 表示是倒数第 index 个节点 // 3. 先把链表从头到尾遍历，得到链表的总的长度 getLength // 4. 得到 size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到 // 5. 如果找到了，则返回该节点，否则返回 null public static HeroNode findNode(HeroNode headNode, int index) { if (headNode.next == null) { System.out.println(\"链表为空\"); return null; } int size = getLength(headNode);//第一次遍历,获取链表长度 //第二次遍历 size-index 位置，就是我们倒数的第 K 个节点 // 先做一个 index 的校验 if (index &lt;= 0 || index &gt; size) { return null; } //定义给辅助变量， for 循环定位到倒数的 index HeroNode temp = headNode.next; for (int i = 0; i &lt; size - index; i++) {//3 // 3 - 1 = 2 temp = temp.next; } return temp; } 单链表的反转【腾讯面试题，有点难度】  思路分析图解 //将单链表反转 public static void reverseList(HeroNode headNode) { //如果链表为空或者只有一个节点 if (headNode.next == null || headNode.next.next == null) { return; } HeroNode cur = headNode.next;//指向第一个节点 HeroNode next = null; //记录位置，把节点转移到反转链表后，可以找到下一个节点 HeroNode reverseNode = new HeroNode(0, \"\", \"\");//反转链表的头结点 while (cur != null) { next = cur.next; //指向下一个节点 cur.next = reverseNode.next; //把要转移的节点的下一个节点指针指向反转链表的第一个节点 reverseNode.next = cur; //把节点连接到反转链表的第一个节点位置 cur = next;//轮到下一个节点 } //全部节点移动到反转链表后，把原链表的头结点替换反转链表的头结点 headNode.next = reverseNode.next; } 从尾到头打印单链表 【百度，要求方式 1：反向遍历 。 方式 2：Stack 栈】  思路分析图解 //方式 2： // 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果 public static void reversePrint(HeroNode headNode) { if (headNode.next == null) { return;//链表为空 } HeroNode temp = headNode.next;//指向第一个节点 Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;();//创建一个栈 //将链表的所有节点压入栈 while (temp != null) { stack.push(temp); //入栈 temp = temp.next;//指针后移 } //将栈中的节点进行打印 while (stack.size() &gt; 0) { System.out.println(stack.pop());//逐个出栈 } } 双向链表使用带 head 头的双向链表实现 –水浒英雄排行榜  管理单向链表的缺点分析: 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会). 分析了双向链表如何完成遍历，添加，修改和删除的思路 对上图的说明: 分析 双向链表的遍历，添加，修改，删除的操作思路===》代码实现 遍历 和 单链表一样，只是可以向前，也可以向后查找 添加 (默认添加到双向链表的最后) ​ (1) 先找到双向链表的最后这个节点 ​ (2) temp.next = newHeroNode ​ (3) newHeroNode.pre = temp; 修改 思路和 原来的单向链表一样. 删除 ​ (1) 因为是双向链表，因此，我们可以实现自我删除某个节点 ​ (2) 直接找到要删除的这个节点，比如 temp ​ (3) temp.pre.next = temp.next ​ (4) temp.next.pre = temp.pre; package LinkedList; public class DoubleLinkedListDemo { public static void main(String[] args) { DoubleLinkedList doubleLinkedList = new DoubleLinkedList(); //添加节点 doubleLinkedList.addHeroByOrder(new HeroNode2(2, \"吴用\", \"智多星\")); doubleLinkedList.addHeroByOrder(new HeroNode2(1, \"宋江\", \"及时雨\")); doubleLinkedList.addHeroByOrder(new HeroNode2(3, \"林冲\", \"豹子头\")); doubleLinkedList.addHeroByOrder(new HeroNode2(1, \"宋江\", \"及时雨\")); doubleLinkedList.addHeroByOrder(new HeroNode2(4, \"武松\", \"捕头\")); System.out.println(\"原链表为\"); doubleLinkedList.list(); //修改节点 doubleLinkedList.update(new HeroNode2(1, \"小宋\", \"及时雨来哦\")); System.out.println(\"修改后\"); doubleLinkedList.list(); //删除 doubleLinkedList.delete(1); System.out.println(\"删除后\"); doubleLinkedList.list(); } } //双向链表用来管理英雄 class DoubleLinkedList { //先初始化一个头节点, 头节点不要动, 不存放具体的数据 private HeroNode2 headNode = new HeroNode2(0, \"\", \"\"); public HeroNode2 getHeadNode() { return headNode; } // 添加一个节点到双向链表的最后. public void addHero(HeroNode2 heroNode) { //temp辅助指针 HeroNode2 temp = headNode; //头结点，不动，没有数据 while (temp.next != null) { temp = temp.next; //直到最后一个节点 } // 当退出 while 循环时，temp 就指向了链表的最后 // 形成一个双向链表 temp.next = heroNode; heroNode.pre = temp; } //按编号排序添加 public void addHeroByOrder(HeroNode2 heroNode) { //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置 // 因为单链表，因为我们找的 temp 是位于 添加位置的前一个节点，否则插入不了 HeroNode2 temp = headNode; boolean flag = false; //标志添加的节点编号是否已经存在 while (true) { if (temp.next == null) {//说明 temp 已经在链表的最后 break; } if (temp.next.No &gt; heroNode.No) {//位置找到，就在 temp 的后面插入 break; } if (temp.next.No == heroNode.No) {//说明希望添加的 heroNode 的编号已然存在 flag = true; break; } temp = temp.next; //后移，遍历当前链表 } if (flag) {//为真则不能添加，说明编号存在 System.out.println(\"要添加的编号\" + heroNode.No + \"已经存在\"); return; } else { //插入到链表中, temp 的后面 if (temp.next != null) { // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针 temp.next.pre = heroNode; } heroNode.next = temp.next; temp.next = heroNode; heroNode.pre = temp; } } //修改节点的信息, 根据 no 编号来修改，即 no 编号不能改. // 说明 // 1. 根据 newHeroNode 的 no 来修改即可 public void update(HeroNode2 heroNode) { if (headNode.next == null) { System.out.println(\"链表为空\"); return; } //找到需要修改的节点, 根据 no 编号 // 定义一个辅助变量，指向第一个节点，不是头结点 HeroNode2 temp = headNode.next; while (true) { if (temp == null) {//已经遍历完链表 System.out.println(\"没有相对应的节点\"); break; } if (temp.No == heroNode.No) { temp.Name = heroNode.Name; temp.nickName = heroNode.nickName; System.out.println(\"修改节点成功\"); break; } temp = temp.next; } } // 从双向链表中删除一个节点, // 说明 // 1 对于双向链表，我们可以直接找到要删除的这个节点 // 2 找到后，自我删除即可 public void delete(int no) { if (headNode.next == null) { System.out.println(\"链表为空\"); return; } HeroNode2 temp = headNode.next; while (true) { if (temp == null) {//已经到链表的最后 System.out.println(\"没有找到相对应的节点\"); break; } if (temp.No == no) {//找到的待删除节点的前一个节点 temp // temp.next = temp.next.next;[单向链表] temp.pre.next = temp.next; // 这里我们的代码有问题? // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针 if (temp.next != null) { temp.next.pre = temp.pre; } System.out.println(\"节点删除成功\"); break; } temp = temp.next;//temp 后移，遍历 } } //显示链表[遍历] public void list() { HeroNode2 temp = headNode;//头结点，不动，没有数据 while (temp.next != null) { temp = temp.next; //头结点没有数据，所以要先指向下一个 System.out.println(temp); } return; } } //定义HeroNode节点，每个HeroNode节点就是一个节点 class HeroNode2 { public int No; //英雄排名 public String Name; //英雄名字 public String nickName; //别名 public HeroNode2 next; //指向下一个节点 public HeroNode2 pre; //指向上一个节点 HeroNode2(int no, String name, String nickName) { this.No = no; this.Name = name; this.nickName = nickName; } @Override public String toString() { return \"HeroNode{\" + \"No=\" + No + \", Name='\" + Name + '\\'' + \", nickName='\" + nickName + '\\'' + '}'; } } 单向环形链表Josephu(约瑟夫、约瑟夫环) 问题 Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。  约瑟夫问题的示意图  约瑟夫问题-创建环形链表的思路图解  约瑟夫问题-小孩出圈的思路分析图 package LinkedList; public class JosephuDemo { public static void main(String[] args) { CircleSingleLinkedList list = new CircleSingleLinkedList(5); list.showBoy(); list.countBoy(1, 2, 5); } } //环形单向链表 class CircleSingleLinkedList { private Boy first = null; //指向第一个节点的辅助指针 CircleSingleLinkedList(int num) { Boy curBoy = null; //辅助指针，用于指向要操作的当前节点 if (num &lt; 1) { //节点数量少于1 System.out.println(\"无法构成环形单向链表\"); return; } for (int i = 1; i &lt;= num; i++) { if (i == 1) { first = new Boy(1); //首节点不能动 curBoy = first; //当前节点，为首节点 first.setNext(first); // 构成环 } else { Boy boy = new Boy(i); curBoy.setNext(boy); //当前节点连接加入节点 boy.setNext(first); //加入节点下个节点指向首节点 curBoy = boy; //当前节点辅助指针指向加入节点 } } } //遍历环形单向链表 public void showBoy() { if (first == null) { System.out.println(\"连表为空\"); return; } // 因为 first 不能动，因此我们仍然使用一个辅助指针完成遍历 Boy curBoy = first; while (true) { System.out.println(\"小孩的编号\"+curBoy.getNo()); if (curBoy.getNext() == first) {// 说明已经遍历完毕 break; } curBoy = curBoy.getNext(); //指针后移 } } //根据用户的输入，计算出小孩出圈的顺序 /** * * @param startNo 开始报数的节点编号 * @param countNum 表示数几下 * @param num 表示圈内节点个数 */ public void countBoy(int startNo, int countNum, int num) { if (startNo &gt; num || countNum &lt; 1 || num &lt; 1) { System.out.println(\"参数输入有误\"); return; } //创建一个辅助指针helper，指向要删除节点的前一个节点 //要删除的节点用first指针指定 Boy helper = first; // 辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点 while (true) { if (helper.getNext() == first) {// 说明 helper 指向最后小孩节点 break; } helper = helper.getNext();//后移 } //将first指针指向开始数数的位置，helper指针也跟着移动 for (int i = 0; i &lt; startNo-1; i++) { first = first.getNext(); helper = helper.getNext(); } //进行报数出圈 while (true) { if (helper == first) {//只剩最后一个节点 break; } //进行报数移动,循环结束，first指向应该移除的节点 for (int i = 0; i &lt; countNum - 1; i++) { first = first.getNext(); helper = helper.getNext(); } System.out.println(\"节点\"+first.getNo()+\"出圈\"); first = first.getNext(); //first指向下一个节点 helper.setNext(first); } System.out.println(\"剩余的节点为\" + helper.getNo()); } } //节点 class Boy { private int no; //节点编号 private Boy next; //指向下一个节点 public Boy(int no) { this.no = no; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public Boy getNext() { return next; } public void setNext(Boy next) { this.next = next; } } 栈栈是一个先入后出(FILO-First In Last Out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除 图解方式说明出栈(pop)和入栈(push)的概念 栈的应用场景 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 二叉树的遍历。 图形的深度优先(depth 一 first)搜索法。 栈的快速入门 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容， 下面我们就用数组模拟栈的出栈，入栈等操作。 实现思路分析,并画出示意图 package Stack; import java.util.Scanner; public class ArrayStackDemo{ public static void main(String[] args) { ArrayStack stack = new ArrayStack(6); String key; Scanner scanner = new Scanner(System.in); boolean loops = true; while (loops) { System.out.println(\"show: 表示显示栈\"); System.out.println(\"exit: 退出程序\"); System.out.println(\"push: 表示添加数据到栈(入栈)\"); System.out.println(\"pop: 表示从栈取出数据(出栈)\"); System.out.println(\"请输入你的选择\"); key = scanner.next(); switch (key) { case \"show\": stack.showStack(); break; case \"exit\": scanner.close(); loops = false; break; case \"push\": System.out.println(\"请输入一个值\"); int val = scanner.nextInt(); stack.push(val); break; case \"pop\": try { int i = stack.pop(); System.out.println(\"出栈的值为\"+i); } catch (Exception e) { e.getMessage(); } break; default: break; } } System.out.println(\"程序退出\"); } } //栈的数组实现 class ArrayStack { private int top ; //栈顶指针 private int[] arr; //栈 private int maxSize; //栈的最大容量 ArrayStack(int num) { this.maxSize = num; this.arr = new int[maxSize]; top = -1; } //判断栈是否满 public boolean isFull() { return top == maxSize - 1; } //判断栈是否空 public boolean isEmpty() { return top == - 1; } //入栈 public void push(int val) { //先判断是否栈满 if (isFull()) { System.out.println(\"栈满\"); return; } top++; arr[top] = val; } //出栈 public int pop() { //先判断栈是否为空 if (isEmpty()) { throw new RuntimeException(\"栈空\"); } int val = arr[top]; top--; return val; } //遍历栈 public void showStack() { if (isEmpty()) { System.out.println(\"栈为空\"); return; } for (int i = top; i &gt;= 0; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, arr[i]); } } } 栈实现综合计算器(中缀表达式) 使用栈来实现综合计算器-  思路分析(图解) 代码实现[1. 先实现一位数的运算， 2. 扩展到多位数的运算] package Stack; public class Calculator { public static void main(String[] args) { String expression = \"70*200-4\"; // 15//如何处理多位数的问题？ //创建两个栈，一个数栈，一个符号栈 ArrayStack2 numStack = new ArrayStack2(10); ArrayStack2 operStack = new ArrayStack2(10); //定义需要的相关变量 int index = 0; //指针，用于扫描 int num1 ; int num2 ; int oper ; int res ; char ch ;//用于存放扫描到的字符 String SplicingNum = \"\";//用于拼接数字 //开始 while 循环的扫描 expression while (true) { //依次得到 expression 的每一个字符 ch = expression.substring(index, index + 1).charAt(0); //判断获取的字符是什么 if (operStack.isOper(ch)) {//如果是运算符 if (!operStack.isEmpty()) { //如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符, 就需要从数栈中 pop 出两个数 //在从符号栈中 pop 出一个符号，进行运算，将得到结果入数栈，然后将当前的操作符入符号栈 if (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) { num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); //把运算的结果如数栈 numStack.push(res); //然后将当前的操作符入符号栈 operStack.push(ch); } else { //如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈. operStack.push(ch); } } else { //如果为空直接入符号栈 operStack.push(ch); } } else {//如果是数，则直接入数栈 // numStack.push(ch-48); //ch 为字符，要转为int //分析思路 // 1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数 // 2. 在处理数，需要向 expression 的表达式的 index 后再看一位,如果是数就进行扫描，如果是符号才入栈 // 3. 因此我们需要定义一个变量 字符串，用于拼接 SplicingNum += ch; //如果 ch 已经是 expression 的最后一位，就直接入栈 if (index == expression.length() - 1) { numStack.push(Integer.parseInt(SplicingNum)); } else { //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈 // 注意是看后一位，不是 index++,index 没有后移 if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) { //如果后一位是运算符，则入栈 keepNum = \"1\" 或者 \"123\" numStack.push(Integer.parseInt(SplicingNum)); //重要的!!!!!!, keepNum 清空 SplicingNum = \"\"; } } } index++;//后移一位字符 if (index &gt;= expression.length()) {//扫描完 break; } } //当表达式扫描完毕，就顺序的从数栈和符号栈中 pop 出相应的数和符号，并计算 while (true) { //如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】 if (operStack.isEmpty()) { break; } num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); //把运算的结果如数栈 numStack.push(res); } System.out.println(\"表达式：\"+expression+\"计算结果为\" + numStack.pop()); } } //栈的数组实现 class ArrayStack2 { private int top ; //栈顶指针 private int[] arr; //栈 private int maxSize; //栈的最大容量 ArrayStack2(int num) { this.maxSize = num; this.arr = new int[maxSize]; top = -1; } //判断栈是否满 public boolean isFull() { return top == maxSize - 1; } //判断栈是否空 public boolean isEmpty() { return top == - 1; } //获取栈顶的值 public int peek() { return arr[top]; } //入栈 public void push(int val) { //先判断是否栈满 if (isFull()) { System.out.println(\"栈满\"); return; } top++; arr[top] = val; } //出栈 public int pop() { //先判断栈是否为空 if (isEmpty()) { throw new RuntimeException(\"栈空\"); } int val = arr[top]; top--; return val; } //遍历栈 public void showStack() { if (isEmpty()) { System.out.println(\"栈为空\"); return; } for (int i = top; i &gt;= 0; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, arr[i]); } } //返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示 // 数字越大，则优先级就越高 public int priority(int oper) { if (oper == '*' || oper == '/') { return 1; } else if (oper == '+' || oper == '-') { return 0; } else { return -1;// 假定目前的表达式只有 +, - , * , / } } //判断是否是运算符 public boolean isOper(char val) { return val == '+' || val == '-' || val == '*' || val == '/'; } //进行运算 public int cal(int num1, int num2, int oper) { int res = 0; //用于存放计算结果 switch (oper) { case '+': res = num1 + num2; break; case '-': res = num2 - num1; //注意参数顺序，不能反 break; case '*': res = num1 * num2; break; case '/': res = num2 / num1; //注意参数顺序，不能反 break; default: break; } return res; } } 逆波兰计算器我们完成一个逆波兰计算器，要求完成如下任务: 输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。 思路分析 package Stack; import java.util.ArrayList; import java.util.List; import java.util.Stack; public class NepolandNotation { public static void main(String[] args) { //说明为了方便，逆波兰表达式 的数字和符号使用空格隔开 //String suffixExpression = \"30 4 + 5 * 6 -\"; String suffixExpression = \"4 5 * 8 - 60 + 8 2 / +\"; // 76 //思路 // 1. 先将 \"3 4 + 5 × 6 - \" =&gt; 放到 ArrayList 中 // 2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算 List&lt;String&gt; list = getList(suffixExpression); int res = calculate(list); System.out.println(\"运算结果为\"+res); } //将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中 public static List&lt;String&gt; getList(String Expression) { String[] strings = Expression.split(\" \"); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String item : strings) { list.add(item); } return list; } //完成对逆波兰表达式的运算 /** * 1)从左至右扫描，将 3 和 4 压入堆栈； * 2)遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈； * 3)将 5 入栈； * 4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈； * 5)将 6 入栈； * 6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果 * */ public static int calculate(List&lt;String&gt; list) { // 创建一个栈, 只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;&gt;(); int num1; int num2; int res; //用于存放计算结果 for (String item : list) { if (item.matches(\"\\\\d+\")) { // 匹配的是多位数 stack.push(item); }else {// pop 出两个数，并运算， 再入栈 num1 = Integer.parseInt(stack.pop()); num2 = Integer.parseInt(stack.pop()); if (item.equals(\"+\")) { res = num1 + num2; }else if (item.equals(\"-\")) { res = num2 - num1; }else if (item.equals(\"*\")) { res = num1 * num2; } else if (item.equals(\"/\")) { res = num2 / num1; } else { throw new RuntimeException(\"运算符错误\"); } //把 res 入栈 stack.push(\"\" + res); } } //最后留在 stack 中的数据是运算结果 return Integer.parseInt(stack.pop()); } } 中缀表达式转换为后缀表达式大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发 中，我们需要将 中缀表达式转成后缀表达式。 具体步骤如下: 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2； 从左至右扫描中缀表达式； 遇到操作数时，将其压 s2； 遇到运算符时，比较其与 s1 栈顶运算符的优先级： ​ 1.如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； ​ 2.否则，若优先级比栈顶运算符的高，也将运算符压入 s1； ​ 3.否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较； 遇到括号时： ​ (1) 如果是左括号“(”，则直接压入 s1 ​ (2) 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃 重复步骤 2 至 5，直到表达式的最右边 将 s1 中剩余的运算符依次弹出并压入 s2 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 举例说明 将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下 因此结果为 :”1 2 3 + 4 × + 5 –” package Stack; import java.util.ArrayList; import java.util.List; import java.util.Stack; public class NepolandNotation { public static void main(String[] args) { String expression = \"1+((2+3)*4)-5+(6*6)\";//注意表达式 List&lt;String&gt; list = toInfixExpressionList(expression); System.out.println(\"中缀表达式为:\"+list); List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(list); System.out.println(\"后缀表达式为:\" + suffixExpreesionList); int result = calculate(suffixExpreesionList); System.out.println(\"计算结果为\" + result); /* //说明为了方便，逆波兰表达式 的数字和符号使用空格隔开 //String suffixExpression = \"30 4 + 5 * 6 -\"; String suffixExpression = \"4 5 * 8 - 60 + 8 2 / +\"; // 76 //思路 // 1. 先将 \"3 4 + 5 × 6 - \" =&gt; 放到 ArrayList 中 // 2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算 List&lt;String&gt; list = getList(suffixExpression); int res = calculate(list); System.out.println(\"运算结果为\" + res); */ } //将一个中缀表达式封装成list public static List&lt;String&gt; toInfixExpressionList(String s) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); int index = 0;//这是一个指针，用于遍历 中缀表达式字符串 String temp;// 对多位数的拼接 char c;// 每遍历到一个字符，就放入到 c do { //如果 c 是一个非数字，我需要加入到 ls if ((c = s.charAt(index)) &lt; 48 || (c = s.charAt(index)) &gt; 57) { list.add(\"\" + c); index++;//后移 } else {//如果是一个数，需要考虑多位数 temp = \"\"; //先将 temp 置成空 '0'[48]-&gt;'9'[57] while (index &lt; s.length() &amp;&amp; (c = s.charAt(index)) &gt;= 48 &amp;&amp; (c = s.charAt(index)) &lt;= 57) { temp += c;//拼接 index++;//后移 }//直到index指向的字符不是数字 list.add(temp); } } while (index &lt; s.length()); return list; } /////////////////////////////////////////////////////////////////////////////// //将中缀表达式转化为后缀表达式 //即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–] // 方法：将得到的中缀表达式对应的 List =&gt; 后缀表达式对应的 List public static List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; list) { //定义两个栈 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;(); // 符号栈 // 说明：因为 s2 这个栈，在整个转换过程中，没有 pop 操作，而且后面我们还需要逆序输出 // 因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2 // Stack&lt;String&gt; s2 = new Stack&lt;String&gt;();// 储存中间结果的栈 s2 List&lt;String&gt; s2 = new ArrayList&lt;String&gt;();// 储存中间结果的 Lists2 for (String item : list) { if (item.matches(\"\\\\d+\")) { s2.add(item); //遇到操作数时，将其压 s2 } else if (s1.isEmpty() || s1.peek().equals(\"(\") || item.equals(\"(\")) { s1.push(item);//如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈,如果是左括号“(”，则直接压入 s1 } else if (item.equals(\")\")) { do {//如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃 s2.add(s1.pop()); } while (!s1.peek().equals(\"(\")); s1.pop();//!!! 将 ( 弹出 s1 栈， 消除小括号 } else { //当 item 的优先级小于等于 s1 栈顶运算符, 将 s1 栈顶的运算符弹出并加入到 s2 中，再次转到(4.1) 与 s1 中新的栈顶运算符相比较 // 问题：我们缺少一个比较优先级高低的方法 while (s1.size() != 0 &amp;&amp; Operation.getValue(item) &lt;= Operation.getValue(s1.peek())) { s2.add(s1.pop()); } //直到item比栈顶运算符优先级高 s1.push(item); } } //将 s1 中剩余的运算符依次弹出并加入 s2 while (s1.size() != 0) { s2.add(s1.pop()); } return s2; //注意因为是存放到 List, 因此按顺序输出就是对应的后缀表达式对应的 List } /////////////////////////////////////////////////////////////////////////////// //将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中 public static List&lt;String&gt; getList(String Expression) { String[] strings = Expression.split(\" \"); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String item : strings) { list.add(item); } return list; } //完成对逆波兰表达式的运算 /** * 1)从左至右扫描，将 3 和 4 压入堆栈； * 2)遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈； * 3)将 5 入栈； * 4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈； * 5)将 6 入栈； * 6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果 */ public static int calculate(List&lt;String&gt; list) { // 创建一个栈, 只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;&gt;(); int num1; int num2; int res; //用于存放计算结果 for (String item : list) { if (item.matches(\"\\\\d+\")) { // 匹配的是多位数 stack.push(item); } else {// pop 出两个数，并运算， 再入栈 num1 = Integer.parseInt(stack.pop()); num2 = Integer.parseInt(stack.pop()); if (item.equals(\"+\")) { res = num1 + num2; } else if (item.equals(\"-\")) { res = num2 - num1; } else if (item.equals(\"*\")) { res = num1 * num2; } else if (item.equals(\"/\")) { res = num2 / num1; } else { throw new RuntimeException(\"运算符错误\"); } //把 res 入栈 stack.push(\"\" + res); } } //最后留在 stack 中的数据是运算结果 return Integer.parseInt(stack.pop()); } } /////////////////////////////////////////////////////////////////////////////// //编写一个类 Operation 可以返回一个运算符 对应的优先级 class Operation { private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; //写一个方法，返回对应的优先级数字 public static int getValue(String operation) { int val; switch (operation) { case \"+\": val = ADD; break; case \"-\": val = SUB; break; case \"*\": val = MUL; break; case \"/\": val = DIV; break; default: throw new RuntimeException(\"运算符有误\"); } return val; } } 递归简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁 递归调用机制 打印问题 阶乘问题 使用图解方式说明了递归的调用机制 递归用于解决什么样的问题 各种数学问题如: 8 皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google 编程大赛) 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等. 将用栈解决的问题–&gt;递归代码比较简洁 递归需要遵守的重要规则 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的，不会相互影响, 比如 n 变量 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据. 递归必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowError，死龟了:) 当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 迷宫问题 package Recursion; public class MiGong { public static void main(String[] args) { // 先创建一个二维数组，模拟迷宫 // 地图 int[][] map = new int[8][7]; // 使用 1 表示墙 for (int i = 0; i &lt; 7; i++) { map[0][i] = 1; map[7][i] = 1; } // 左右全部置为 1 for (int i = 0; i &lt; 8; i++) { map[i][0] = 1; map[i][6] = 1; } //设置挡板, 1 表示 map[3][1] = 1; map[3][2] = 1; // map[1][2] = 1; // map[2][2] = 1; //输出地图 for (int[] item : map) { for (int i : item) { System.out.print(i + \" \"); } System.out.println(); } // setWay(map, 1, 1); //策略1 setWay2(map, 1, 1); //策略2 System.out.println(\"找到通路的路径：\"); for (int[] item : map) { for (int i : item) { System.out.print(i + \" \"); } System.out.println(); } } //使用递归回溯来给小球找路 // 说明 // 1. map 表示地图 // 2. i,j 表示从地图的哪个位置开始出发 (1,1) // 3. 如果小球能到 map[6][5] 位置，则说明通路找到. // 4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； // 2 表示通路可以走 ； 3 表示该点已经 走过，但是走不通 //5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯 public static boolean setWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; //走得到map[6][5]表示通路找到 } else { if (map[i][j] == 0) { //点为0，没有走过 map[i][j] = 2; //假设当前点可以走通 if (setWay(map, i + 1, j)) { //向下走 return true; //走得通 } else if (setWay(map, i, j + 1)) { //向右走 return true; } else if (setWay(map, i - 1, j)) { //向上走 return true; } else if (setWay(map, i, j - 1)) { //向左走 return true; } else { map[i][j] = 3; //走不通 return false; } } else {//map[i][j] != 0 ,点不为0，可能为1,2,3 return false; } } } //修改找路的策略，改成 上-&gt;右-&gt;下-&gt;左 public static boolean setWay2(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; //走得到map[6][5]表示通路找到 } else { if (map[i][j] == 0) { //点为0，没有走过 map[i][j] = 2; //假设当前点可以走通 if (setWay2(map, i - 1, j)) { //向上走 return true; //走得通 } else if (setWay2(map, i, j + 1)) { //向右走 return true; } else if (setWay2(map, i + 1, j)) { //向下走 return true; } else if (setWay2(map, i, j - 1)) { //向左走 return true; } else { map[i][j] = 3; //走不通 return false; } } else {//map[i][j] != 0 ,点不为0，可能为1,2,3 return false; } } } } 对迷宫问题的讨论 小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右的顺序相关 再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化 测试回溯现象 思考: 如何求出最短路径? 思路-》代码实现(通过通路路径地图获取节点为2的个数，然后比较即可) 八皇后问题八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法。 说明： 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列 package Recursion; public class Queen8 { //定义一个 max 表示共有多少个皇后 int max = 8; //定义数组 array, 保存皇后放置位置的结果,比如 arr = {0 , 4, 7, 5, 2, 6, 1, 3} int[] array = new int[max]; //下标表示行，值表示列 int num = 0;//记录方案数 int count = 0;//记录判断次数 public static void main(String[] args) { Queen8 queen8 = new Queen8(); queen8.check(0); System.out.println(\"方案次数为\" + queen8.num); System.out.println(\"判断次数为\" + queen8.count); } //编写一个方法，放置第 n 个皇后 //特别注意： check 是每一次递归时，进入到 check 中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯 private void check(int n) { if (n == max) {//n = 8 ,就是第九个皇后， 其实 8 个皇后就已然放好 num++; print(); return; } //依次放入皇后，并判断是否冲突 for (int i = 0; i &lt; max; i++) { //先把当前这个皇后 n , 放到该行的第 1 列 array[n] = i; //判断当放置第 n 个皇后到 i 列时，是否冲突 if (judge(n)) { // 不冲突 //接着放 n+1 个皇后,即开始递归 check(n+1); } //如果冲突，就继续执行 array[n] = i; 即将第 n 个皇后，放置在本行的后一个列位置 } } //查看当我们放置第 n 个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突 private boolean judge(int n) { count++; for (int i = 0; i &lt; n; i++) { // 说明 // 1. array[i] == array[n] 表示判断 第 n 个皇后是否和前面的 n-1 个皇后在同一列 // 2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第 n 个皇后是否和第 i 皇后是否在同一斜线 // Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1 //3. 判断是否在同一行, 没有必要，n 每次都在递增 if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) { return false; } } return true; } //输出皇后的摆放方案 private void print() { for (int i : array) { System.out.print(i+\" \"); } System.out.println(); } } 排序算法排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。 排序的分类： 内部排序: 指将需要处理的所有数据都加载到**内部存储器(内存)**中进行排序。 外部排序法： 数据量过大，无法全部加载到内存中，需要借助**外部存储(文件等)**进行排序。 常见的排序算法分类(见右图) 算法的时间复杂度 时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n)。 时间复杂度 一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n)表示，若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。 记作 **T(n)=Ｏ( f(n) )**，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 如：T(n)=n+1,T(n)的同数量级函数 f(n)=n，时间复杂度为O( f(n) )=O(n)。 T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同，但时间复杂度相同，都为 **O(n²)**。 计算时间复杂度的方法：  用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1  修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n²  去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²) 常见的时间复杂度 常数阶 O(1) 对数阶 O(log2n) 线性阶 O(n) 线性对数阶 O(nlog2n) 平方阶 O(n^2) 立方阶 O(n^3) 参考上面的 O(n²) 去理解就好了，O(n³)相当于三层 n 循环，其它的类似 k 次方阶 O(n^k) 指数阶 O(2^n) 常见的时间复杂度对应的图: 说明： 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜ Ο(2n) ，随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低 从图中可见，我们应该尽可能避免使用指数阶的算法 平均时间复杂度和最坏时间复杂度 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。 算法的空间复杂度简介 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例 如快速排序和归并排序算法, 基数排序就属于这种情况 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品 (redis, memcache) 和算法(基数排序)本质就是用空间换时间。 冒泡排序冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 优化： 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，再进行) 小结上面的图解过程: (1) 一共进行 数组的大小-1 次 大的循环 (2)每一趟排序的次数在逐渐的减少 (3) 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化 package Sort; import java.util.Arrays; public class BubbleSort { public static void main(String[] args) { int arr[] = {3, 9, -1, 10, 20}; boolean flag = true; //用于标识数组是否已经提前排好序 int temp = 0; //临时变量 for (int i = 0; i &lt; arr.length-1; i++) { //进行数组长度-1次排序 for (int j = 0; j &lt; arr.length - 1 - i; j++){ //每次排序的比较次数都在-1 if (arr[j] &gt; arr[j + 1]) { temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; flag = false; } } System.out.print(\"第\"+(i+1)+\"遍排序后的数组为：\"); System.out.println(Arrays.toString(arr)); if (flag) { //没有进行交换排序,也就是整个数组已经是排好序的状态 break; } else { flag = true; //排好序后重置标识 } } } } //排80000个数据用了20秒左右 选择排序选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的 选择排序思想 选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2] ~ arr[n-1]中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-1]arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。 对一个数组的选择排序再进行讲解 package Sort; import java.util.Arrays; public class SelectSort { public static void main(String[] args) { int [] arr = {101, 34, 119, 1, -1, 90, 123}; selectSort(arr); } //选择排序 public static void selectSort(int[] arr) { for (int i = 0; i &lt; arr.length - 1; i++) {//进行数组长度-1次找最小值 int minIndex = i; //用于存储最小值的下标 int min = arr[i]; //用于存储最小值 for (int j = i; j &lt; arr.length; j++) {//从第i个值比较起，最小值都排在最前面，每进行一次外循环，需要比较的个数就-1 if (min &gt; arr[j]) { //找到更小的值 minIndex = j; min = arr[j]; } }//循环结束找到最小的值 if (minIndex != i) { //最小值的下标改变，也就是找到了更小的值 arr[minIndex] = arr[i]; //进行交换，把最小值换到前面 arr[i] = min; } System.out.println(\"第\" + (i + 1) + \"遍排序：\"); System.out.println(Arrays.toString(arr)); } } } //排80000个数据用了2-3秒左右 插入排序插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。 插入排序（Insertion Sorting）的基本思想是：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 package Sort; import java.util.Arrays; public class InsertSort { public static void main(String[] args) { int[] arr = {101, 34, 119, 1, -1, 89}; insertSort(arr); } //插入排序 public static void insertSort(int[] arr) { for (int i = 1; i &lt; arr.length; i++) { int insertIndex = i - 1; //要进行排序的值的前一个下标位置 int insertVal = arr[i]; //插入的值 //要插入的值在前面排好序的数组寻找插入位置 //说明 // 1. insertIndex &gt;= 0 保证在给 insertVal 找插入位置，不越界 // 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 // 3. 就需要将 arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) { //待插入的数比排好序的数组的数据小,即排好序的数组中大的数据往后移 arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; //后移 }//循环结束时就找到插入位置，插入位置为 insertIndex+1 可以使用insertIndex = 0 时验证 if (insertIndex + 1 != i) { //要插入的位置不是自己原来的位置，所以赋值 arr[insertIndex+1] = insertVal; } System.out.println(\"第\"+i+\"轮插入\"); System.out.println(Arrays.toString(arr)); } /*第一遍排序 第 1 轮 {101, 34, 119, 1}; =&gt; {34, 101, 119, 1} int insertIndex = 1 - 1; //要进行排序的值的前一个下标位置 int insertVal = arr[1]; //插入的值 //要插入的值在前面排好序的数组寻找插入位置 //说明 // 1. insertIndex &gt;= 0 保证在给 insertVal 找插入位置，不越界 // 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 // 3. 就需要将 arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) { //待插入的数比排好序的数组的数据小,即排好序的数组中大的数据往后移 arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; //后移 }//循环结束时就找到插入位置，插入位置为 insertIndex+1 arr[insertIndex+1] = insertVal; System.out.println(\"第 1 轮插入\"); System.out.println(Arrays.toString(arr)); */ } } 希尔排序 简单插入排序存在的问题 数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1**(**最小), 这样的过程是： {2,3,4,5,6,6} {2,3,4,5,5,6} {2,3,4,4,5,6} {2,3,3,4,5,6} {2,2,3,4,5,6} {1,2,3,4,5,6} 结论:**当需要插入的数是较小的数时，后移的次数明显增多，对效率**有影响. 希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 希尔排序法基本思想 ：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止 希尔排序法应用实例 有一群小牛, 考试成绩分别是 {8,9,1,7,2,3,5,4,6,0} 请从小到大排序. 请分别使用 希尔排序时， 对有序序列在插入时采用交换法, 并测试排序速度. //80000数据 16秒左右 public class ShellSort { public static void main(String[] args) { int[] arr = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0}; shellSort(arr); } //希尔排序 // 希尔排序时， 对有序序列在插入时采用交换法 public static void shellSort(int[] arr) { int temp = 0;//中间变量 int count = 0;//记录排序次数 // 因为第 1 轮排序，是将 10 个数据分成了 5 组 for (int gap = arr.length / 2; gap &gt;= 1; gap /= 2) { for (int i = gap; i &lt; arr.length; i++) { // 遍历各组中所有的元素(共 gap 组，每组有 arr.length/gap 个元素), 步长 gap for (int j = i-gap; j &gt;= 0; j -= gap) { // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + gap]) { temp = arr[j + gap]; arr[j + gap] = arr[j]; arr[j] = temp; } } } System.out.println(\"第\"+(count++)+\"次希尔排序\"+ Arrays.toString(arr)); } /* // 因为第 1 轮排序，是将 10 个数据分成了 5 组 for (int i = 5; i &lt; arr.length; i++) { // 遍历各组中所有的元素(共 5 组，每组有 2 个元素), 步长 5 for (int j = i-5; j &gt;= 0; j -= 5) { // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + 5]) { temp = arr[j + 5]; arr[j + 5] = arr[j]; arr[j] = temp; } } } System.out.println(\"第一轮希尔排序后\"+ Arrays.toString(arr)); // 因为第 2 轮排序，是将 10 个数据分成了 5/2 = 2 组 for (int i = 2; i &lt; arr.length; i++) { // 遍历各组中所有的元素(共 2 组，每组有 5 个元素), 步长 2 for (int j = i-2; j &gt;= 0; j -= 2) { // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + 2]) { temp = arr[j + 2]; arr[j + 2] = arr[j]; arr[j] = temp; } } } System.out.println(\"第二轮希尔排序后\"+ Arrays.toString(arr)); */ } } 希尔排序时， 对有序序列在插入时采用移动法, 并测试排序速度. //80000数据 1秒左右 public class ShellSort { public static void main(String[] args) { int[] arr = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0}; shellSort(arr); System.out.println(Arrays.toString(arr)); } //对交换式的希尔排序进行优化-&gt;移位法 public static void shellSort(int[] arr) { // 增量 gap, 并逐步的缩小增量 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) { // 从第 gap 个元素，逐个对其所在的组进行直接插入排序 for (int i = gap; i &lt; arr.length; i++) { int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - gap]) {//只要插入的值比前一个步长距离的值要小就得进行排序 while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) { //只要值比要插入的值大，就往后移 //移动 arr[j] = arr[j - gap]; j -= gap; }//当退出 while 后，就给 temp 找到插入的位置 可以用 gap=1 来验证 arr[j] = temp; } } } } } 快速排序法快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 要求: 对 [-9,78,0,23,-567,70] 进行从小到大的排序，要求使用快速排序法。【测试 8w 和 800w】 说明[验证分析]: 如果取消左右递归，结果是 -9 -567 0 23 78 70 如果取消右递归,结果是 -567 -9 0 23 78 70 如果取消左递归,结果是 -9 -567 0 23 70 78 //效率比希尔快一点 package Sort; import java.util.Arrays; public class QuickSort { public static void main(String[] args) { int[] arr = {-9,78,0,23,-567,70}; System.out.println(Arrays.toString(arr)); quickSort(arr, 0, arr.length-1); } public static void quickSort(int[] arr, int left, int right) { int l = left; //左下标 int r = right; //右下标 int pivot = arr[(l + r) / 2];//中轴值 int temp = 0;//临时变量 //while循环的目的是让比pivot 值小放到左边 //比pivot 值大放到右边 while (l &lt; r) { //中轴值也可能会被进行数据位置交换 //在pivot的左边一直找,找到大于等于pivot值,才退出循环 while (arr[l] &lt; pivot) { l += 1; } //在pivot的右边一直找,找到小于等于pivot值,才退出循环 while (arr[r] &gt; pivot) { r -= 1; } //如果l &gt;= r说明pivot 的左右两边的值，已经按照左边全部是 //小于等于pivot值，右边全部是大于等于pivot值排好 if( l &gt;= r) { break; } //交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完后，发现这个arr[l] == pivot值 相等（也就是中轴值进行了位置交换） r--， 前移 if(arr[l] == pivot) { r -= 1; } //如果交换完后，发现这个arr[r] == pivot值 相等（也就是中轴值进行了位置交换） l++， 后移 if(arr[r] == pivot) { l += 1; } System.out.println(Arrays.toString(arr)); } // 如果 l == r, 必须l++, r--, 否则为出现栈溢出 if (l == r) { l += 1; r -= 1; } //向左递归 if (left &lt; r) { System.out.println(\"向左递归,末点：\"+r); quickSort(arr, left, r); } //向右递归 if (right &gt; l) { System.out.println(\"向右递归,起点：\"+l); quickSort(arr, l, right); } } } 归并排序归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将 [4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤 //效率跟快速排序差不多 package Sort; import java.util.Arrays; public class MergeSort { public static void main(String[] args) { int[] arr= { 8, 4, 5, 7, 1, 3, 6, 2 }; int[] temp = new int[arr.length + 1]; mergeSort(arr, 0, arr.length - 1, temp); System.out.println(Arrays.toString(arr)); } //分+合 public static void mergeSort(int[] arr, int left, int right, int[] temp) { if (left &lt; right) { int mid = (right + left) / 2;//中间索引 mergeSort(arr, left, mid, temp);//向左递归进行分解 mergeSort(arr, mid+1, right, temp);//向右递归进行分解 merge(arr, left, mid, right, temp);//合并 } } //合并方法 /** * * @param arr 排序的原始数组 * @param left 左边有序序列的初始索引 * @param mid 中间索引 * @param right 右边索引 * @param temp 做中转的数组 */ public static void merge(int[] arr, int left, int mid, int right, int[] temp) { int i = left; //左边有序序列的初始下标 int j = mid + 1;//右边有序序列的初始下标 int t = 0;//指向temp数组的当前索引 //(一) //先把左右两边(有序)的数据按照规则填充到temp数组 //直到左右两边的有序序列，有一边处理完毕为止 while (i &lt;= mid &amp;&amp; j &lt;= right) { //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素 //即将左边的当前元素，填充到 temp数组 //然后 t++, i++ if (arr[i] &lt; arr[j]) { temp[t] = arr[i]; i += 1; t += 1; } else { //右边的元素小于等于左边的元素 temp[t] = arr[j]; j += 1; t += 1; } } //(二) //把有剩余数据的一边的数据依次全部填充到temp while (i &lt;= mid) { //左边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[i]; t += 1; i += 1; } while (j &lt;= right) { //右边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[j]; t += 1; j += 1; } //(三) //将temp数组的元素拷贝到arr //注意，并不是每次都拷贝所有 t = 0; //重新指向temp数组的第一个元素 int tempLeft = left; System.out.println(\"tempLeft = \"+tempLeft+\" right =\"+right); //第一次合并 tempLeft = 0 , right = 1 // tempLeft = 2 right = 3 // tempLeft=0 right=3 //最后一次 tempLeft = 0 right = 7 while (tempLeft &lt;= right) { arr[tempLeft] = temp[t]; t += 1; tempLeft += 1; } } } 基数排序 基数排序(桶排序)介绍: 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 基数排序(Radix Sort)是桶排序的扩展 基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 基数排序基本思想 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤 package Sort; import java.util.Arrays; public class RadixSort { public static void main(String[] args) { int arr[] = {53, 3, 542, 748, 14, 214}; radixSort(arr); } //基数排序 public static void radixSort(int[] arr) { //得到数组中最大的数据的位数 int max = arr[0];//假设第一数就是最大数 for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &gt; max) { max = arr[i]; } } //得到最大数据位数 int maxLength = (max + \"\").length(); //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组 //说明 //1. 二维数组包含10个一维数组 //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length //3. 很明确，基数排序是使用空间换时间的经典算法 int[][] bucket = new int[10][arr.length]; //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数 //可以这里理解 //比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数 int[] bucketElementCounts = new int[10]; for (int j = 0, n = 1; j &lt; maxLength; j++, n *= 10) { //根据最大数的位数进行相对应次数的处理 for (int i = 0; i &lt; arr.length; i++) { //取出每个元素的个位值 int digitOfElement = arr[i] / n % 10; //放入到对应的桶中,第 digitOfElement 个桶，第 bucketElementCounts[digitOfElement] 个位置 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[digitOfElement]++; //对应桶数据个数加一，也就是桶下标后移 } //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for (int i = 0; i &lt; bucket.length; i++) { //遍历每个桶 if (bucketElementCounts[i] != 0) { //桶有数据 //循环该桶即第k个桶(即第k个一维数组), 放入 for (int k = 0; k &lt; bucketElementCounts[i]; k++) { //取出元素放入到arr arr[index++] = bucket[i][k]; } } //第1轮处理后，需要将每个 bucketElementCounts[i] = 0 ！！！！ //也就是把对应的桶所记录的长度为0，这样在后面的排序中可以把之前桶里的数据进行覆盖,相当于把指针前置 // bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[i] = 0; } System.out.println(\"第\"+(j+1)+\"轮，对个位的排序处理 arr =\" + Arrays.toString(arr)); } /* //第一轮 for (int i = 0; i &lt; arr.length; i++) { //取出每个元素的个位值 int digitOfElement = arr[i]/1 % 10; //放入到对应的桶中,第 digitOfElement 个桶，第 bucketElementCounts[digitOfElement] 个位置 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[digitOfElement]++; //对应桶数据个数加一，也就是桶下标后移 } //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for (int i = 0; i &lt; bucket.length; i++) { //遍历每个桶 if (bucketElementCounts[i] != 0) { //桶有数据 //循环该桶即第k个桶(即第k个一维数组), 放入 for (int k = 0; k &lt; bucketElementCounts[i]; k++) { //取出元素放入到arr arr[index++] = bucket[i][k]; } } //第1轮处理后，需要将每个 bucketElementCounts[i] = 0 ！！！！ //也就是把对应的桶所记录的长度为0，这样在后面的排序中可以把之前桶里的数据进行覆盖,相当于把指针前置 // bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[i] = 0; } System.out.println(\"第1轮，对个位的排序处理 arr =\" + Arrays.toString(arr)); //第二轮 for (int i = 0; i &lt; arr.length; i++) { //取出每个元素的十位值 int digitOfElement = arr[i]/10% 10; //放入到对应的桶中,第 digitOfElement 个桶，第 bucketElementCounts[digitOfElement] 个位置 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[digitOfElement]++; //对应桶数据个数加一，也就是桶下标后移 } //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for (int i = 0; i &lt; bucket.length; i++) { //遍历每个桶 if (bucketElementCounts[i] != 0) { //桶有数据 //循环该桶即第k个桶(即第k个一维数组), 放入 for (int k = 0; k &lt; bucketElementCounts[i]; k++) { //取出元素放入到arr arr[index++] = bucket[i][k]; } } bucketElementCounts[i] = 0; } System.out.println(\"第2轮，对十位的排序处理 arr =\" + Arrays.toString(arr)); //第三轮 for (int i = 0; i &lt; arr.length; i++) { //取出每个元素的百位值 int digitOfElement = arr[i]/100% 10; //放入到对应的桶中,第 digitOfElement 个桶，第 bucketElementCounts[digitOfElement] 个位置 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[digitOfElement]++; //对应桶数据个数加一，也就是桶下标后移 } //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for (int i = 0; i &lt; bucket.length; i++) { //遍历每个桶 if (bucketElementCounts[i] != 0) { //桶有数据 //循环该桶即第k个桶(即第k个一维数组), 放入 for (int k = 0; k &lt; bucketElementCounts[i]; k++) { //取出元素放入到arr arr[index++] = bucket[i][k]; } } bucketElementCounts[i] = 0; } System.out.println(\"第3轮，对百位的排序处理 arr =\" + Arrays.toString(arr)); */ } } 基数排序的说明: 基数排序是对传统桶排序的扩展，速度很快. 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且 r[i]在 r[j]之前，而在排序后的序列中，r[i]仍在 r[j]之前， 则称这种排序算法是稳定的；否则称为不稳定的] 有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: https://code.i-harness.com/zh-CN/q/e98fa9 常用排序算法总结和对比 相关术语解释： 稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面； 不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间。 空间复杂度：运行完一个程序所需内存的大小。 n: 数据规模 k: “桶”的个数 In-place: 不占用额外内存 Out-place: 占用额外内存 查找算法在 java 中，我们常用的查找有四种: 顺序(线性)查找 二分查找/折半查找 插值查找 斐波那契查找 线性查找有一个数列： {1,8, 10, 89, 1000, 1234} ，判断数列中是否包含此名称【顺序查找】 要求: 如果找到了，就提示找到，并给出下标值 public class SeqSearch { public static void main(String[] args) { int arr[] = { 1, 9, 11, -1, 34, 89 };// 没有顺序的数组 int index = seqSearch(arr, -11); if(index == -1) { System.out.println(\"没有找到\"); } else { System.out.println(\"找到，下标为=\" + index); } } //这里我们实现的线性查找是找到一个满足条件的值，就返回 public static int seqSearch(int[] arr, int value) { // 线性查找是逐一比对，发现有相同值，就返回下标 for (int i = 0; i &lt; arr.length; i++) { if(arr[i] == value) { return i; } } return -1; } } 二分查找请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。 package Search; import java.util.ArrayList; import java.util.List; public class BinarySearch { public static void main(String[] args) { int arr[] = { 1, 8, 10, 89,1000,1000,1000,1234}; // int index = binarySearch(arr, 0, arr.length, -1); // if (index != -1) { // System.out.println(\"在数组的第\"+(index+1)+\"位\"); // }else System.out.println(\"找不到\"); List&lt;Integer&gt; list = binarySearch2(arr, 0, arr.length - 1, 1000); System.out.println(list); } //二分查找，前提是有序数组 /** * * @param arr 要查找的数组 * @param left 左边索引 * @param right 右边索引 * @param findVal 要查找的值 * @return 返回索引，找到返回对应的下标，找不到返回-1 */ public static int binarySearch(int[] arr, int left,int right,int findVal) { if (left &gt; right||findVal&lt;arr[0]||findVal&gt;arr[arr.length-1]) { // 当 left &gt; right 时，说明递归整个数组，但是没有找到 return -1; } int mid = (left + right) / 2; //中间索引 if (findVal &gt; arr[mid]) { return binarySearch(arr, mid + 1, right, findVal);//右递归 } else if (findVal &lt; arr[mid]) { return binarySearch(arr, left, mid - 1, findVal);//左递归 } else { //找到值,findVal = arr[mid] return mid; } } //完成一个课后思考题: /* * 课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中， * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000 * * 思路分析 * 1. 在找到mid 索引值，不要马上返回 * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList * 4. 将Arraylist返回 */ public static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) { if (left &gt; right||findVal&lt;arr[0]||findVal&gt;arr[arr.length-1]) { // 当 left &gt; right 时，说明递归整个数组，但是没有找到 return new ArrayList&lt;&gt;(); //下标集合为空 } int mid = (left + right) / 2; //中间索引 if (findVal &gt; arr[mid]) { return binarySearch2(arr, mid + 1, right, findVal);//右递归 } else if (findVal &lt; arr[mid]) { return binarySearch2(arr, left, mid - 1, findVal);//左递归 } else { //找到值,findVal = arr[mid] List&lt;Integer&gt; resIndexList = new ArrayList&lt;&gt;(); //用于存放下标 int temp = mid - 1; while (true) { //扫描左边的 if (temp &lt; left || arr[temp] != findVal) { break;//扫描完左边或者值不相等，进入下次循环 } resIndexList.add(temp); temp--; //左移 } resIndexList.add(mid); temp = mid +1; while (true) { //扫描数组右边 if (temp &gt; right || arr[temp] != findVal) { break;//扫描完右边或者值不相等，进入下次循环 } resIndexList.add(temp); temp++; //右移 } return resIndexList; } } } 插值查找 插值查找原理介绍: 插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。 将折半查找中的求 mid 索引的公式 , low 表示左边索引 left, high 表示右边索引 right。 key 就是前面我们讲的 findVal int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ; //插值索引 对应前面的代码公式： int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left]) 举例说明插值查找算法 1-100 的数组 package Search; public class InsertValueSearch { public static void main(String[] args) { // int [] arr = new int[100]; // for(int i = 0; i &lt; 100; i++) { // arr[i] = i + 1; // } int arr[] = { 1, 8, 10, 89,1000,1000, 1234 }; // int index = insertValueSearch(arr, 0, arr.length - 1, 1); int index = binarySearch(arr, 0, arr.length-1, 1); System.out.println(\"index = \" + index); } //二分查找 public static int binarySearch(int[] arr, int left,int right,int findVal) { System.out.println(\"二分查找算法~~~\"); if (left &gt; right||findVal&lt;arr[0]||findVal&gt;arr[arr.length-1]) { // 当 left &gt; right 时，说明递归整个数组，但是没有找到 return -1; } int mid = (left + right) / 2; //中间索引 if (findVal &gt; arr[mid]) { return binarySearch(arr, mid + 1, right, findVal);//右递归 } else if (findVal &lt; arr[mid]) { return binarySearch(arr, left, mid - 1, findVal);//左递归 } else { //找到值,findVal = arr[mid] return mid; } } //插值查找，前提有序数组 public static int insertValueSearch(int[] arr, int left, int right, int findVal) { System.out.println(\"插值查找算法~~~\"); //注意：findVal &lt; arr[0] 和 findVal &gt; arr[arr.length - 1] 必须需要 //否则我们得到的 mid 可能越界 if (left &gt; right || findVal &gt; arr[arr.length - 1] || findVal &lt; arr[0]) { return -1; } // 求出mid, 自适应 int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; if (findVal &gt; midVal) { // 说明应该向右边递归 return insertValueSearch(arr, mid + 1, right, findVal); } else if (findVal &lt; midVal) { // 说明向左递归查找 return insertValueSearch(arr, left, mid - 1, findVal); } else { return mid; } } } 插值查找注意事项： 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快. 关键字分布不均匀的情况下，该方法不一定比折半查找要好 斐波那契(黄金分割法)查找 斐波那契(黄金分割法)查找基本介绍 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数的比例，无限接近 黄金分割值 0.618 斐波那契(黄金分割法)原理 斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位于黄金分割点附近，即 mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示  对 F(k-1)-1 的理解： 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明： 只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid=low+F(k-1)-1 类似的，每一子段也可以用相同的方式分割 但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置）， 都赋为 n 位置的值即可。 while(n&gt;fib(k)-1) k++; package Search; import java.util.Arrays; public class FibonacciSearch { public static int maxSize = 20; public static void main(String[] args) { int [] arr = {1,2,8, 10, 89, 1000, 1234,}; System.out.println(\"index=\" + fibonacciSearch(arr, 2)); } //因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列， // 因此我们需要先获取到一个斐波那契数列 //非递归方法得到一个斐波那契数列 public static int[] fib() { int[] f = new int[maxSize]; f[0] = 1; f[1] = 1; for (int i = 2; i &lt; f.length; i++) { f[i] = f[i - 1] + f[i - 2]; } return f; } //编写斐波那契查找算法 //使用非递归的方式编写算法 /** * * @param arr 被查找的数组 * @param findVal 要查找的值 * @return 找到就返回下标，没有就返回-1 */ public static int fibonacciSearch(int[] arr,int findVal) { int low = 0; int high = arr.length - 1; int k = 0; //表示斐波那契分割数值的下标 int mid = 0; //存放mid值 int f[] = fib(); //获取到斐波那契数列 //获取到斐波那契分割数值的下标,因为是下标所以-1 while (high &gt; f[k] - 1) { k++; }//在斐波那契数组中找到第一个比数组长度大的值的下标 //因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[] //不足的部分会使用0填充 int[] temp = Arrays.copyOf(arr, f[k]); //实际上需求使用a数组最后的数填充 temp //举例: //temp = {1,8, 10, 89, 1000, 1234, 0, 0} =&gt; {1,8, 10, 89, 1000, 1234, 1234, 1234,} for (int i = high + 1; i &lt; temp.length; i++) { temp[i] = arr[high]; } // 使用while来循环处理，找到我们的数 key while (low &lt;= high) { // 只要这个条件满足，就可以找 mid = low + f[k - 1] - 1; if (findVal &lt; temp[mid]) { high = mid - 1; //为什么是 k-- //说明 //1. 全部元素 = 前面的元素 + 后边元素 //2. f[k] = f[k-1] + f[k-2] //因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3] //即 在 f[k-1] 的前面继续查找 k-- //即下次循环 mid = f[k-1-1]-1 k--; } else if (findVal &gt; temp[mid]) { low = mid + 1; //为什么是k -=2 //说明 //1. 全部元素 = 前面的元素 + 后边元素 //2. f[k] = f[k-1] + f[k-2] //3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-2] = f[k-3] + f[k-4] //4. 即在f[k-2] 的前面进行查找 k -=2 //5. 即下次循环 mid = f[k - 1 - 2] - 1 k -= 2; } else {//找到 //需要确定，返回的是哪个下标 if (mid &lt;= high) { return mid; } else { return high; } } } return -1; } } 哈希表散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 google 公司的一个上机题 有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的 id 时, 要求查找到该员工的 所有信息. 要求: 不使用数据库,,速度越快越好=&gt;哈希表(散列) 添加时，保证按照 id 从低到高插入 [课后思考：如果 id 不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?] 使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息] 思路分析并画出示意图 package Hash; import java.util.Scanner; public class HashTableDemo { public static void main(String[] args) { //创建哈希表 HashTab hashTab = new HashTab(7); String key; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"add: 添加雇员\"); System.out.println(\"list: 显示雇员\"); System.out.println(\"find: 查找雇员\"); System.out.println(\"exit: 退出系统\"); key = scanner.next(); switch (key) { case \"add\": System.out.println(\"请输入雇员id\"); int id = scanner.nextInt(); System.out.println(\"请输入雇员名字\"); String name = scanner.next(); //创建 雇员 Emp emp = new Emp(id, name); hashTab.add(emp); break; case \"list\": hashTab.list(); break; case \"find\": System.out.println(\"请输入要查找的id\"); id = scanner.nextInt(); hashTab.findEmpById(id); break; case \"exit\": scanner.close(); System.exit(0); default: break; } } } } class Emp { public int id; public String name; public Emp next; //next 默认为 null public Emp(int id,String name) { this.id = id; this.name = name; } } //创建EmpLinkedList ,表示链表 class EmpLinkedList { //头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp private Emp head; //添加雇员到链表 //说明 //1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大 // 因此我们将该雇员直接加入到本链表的最后即可 public void add(Emp emp) { //如果是第一个雇员 if (head == null) { head = emp; return; } //如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后 Emp curEmp = head; while (true) { if (curEmp.next == null) {//说明到链表最后 break; } curEmp = curEmp.next; } curEmp.next = emp; } //遍历表的雇员信息 public void list(int no) { if (head == null) { System.out.println(\"第\"+(no+1)+\"条链表为空\"); return; } Emp curEmp = head; //辅助指针 System.out.print(\"第\"+(no+1)+\"条链表信息：\"); while(true) { System.out.printf(\" =&gt; id=%d name=%s\\t\", curEmp.id, curEmp.name); if(curEmp.next == null) {//说明curEmp已经是最后结点 break; } curEmp = curEmp.next; //后移，遍历 } System.out.println(); } //根据id查找雇员 //如果查找到，就返回Emp, 如果没有找到，就返回null public Emp findEmpById(int id) { if (head == null) { System.out.println(\"链表为空\"); return null; } Emp curEmp = head; while (true) { if (curEmp.id == id) {//找到 break;//这时curEmp就指向要查找的雇员 } if (curEmp.next == null) {//说明遍历当前链表没有找到该雇员 curEmp = null; break; } curEmp = curEmp.next;//后移 } return curEmp; } } //创建HashTab 管理多条链表 class HashTab { private EmpLinkedList[] empLinkedListArray; private int size; public HashTab(int size) { this.size = size; //初始化empLinkedListArray empLinkedListArray = new EmpLinkedList[size]; //？留一个坑, 这时要不要分别初始化每个链表 for (int i = 0; i &lt; size; i++) { empLinkedListArray[i] = new EmpLinkedList(); } } //添加雇员 public void add(Emp emp) { //根据员工的id ,得到该员工应当添加到哪条链表 int hashFun = hashFun(emp.id); //将emp 添加到对应的链表中 empLinkedListArray[hashFun].add(emp); } //遍历所有的链表,遍历hashtab public void list() { for(int i = 0; i &lt; size; i++) { empLinkedListArray[i].list(i); } } //编写散列函数, 使用一个简单取模法 public int hashFun(int id) { return id % size; } public void findEmpById(int id) { //使用散列函数确定到哪条链表查找 int hashFun = hashFun(id); Emp emp = empLinkedListArray[hashFun].findEmpById(id); if (emp != null) { System.out.printf(\"在第%d条链表找到雇员 id=%d\\n\",hashFun+1,id); }else{ System.out.println(\"在哈希表中，没有找到该雇员~\"); } } } 树 为什么需要树这种数据结构 数组存储方式的分析 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 [示意图] 画出操作示意图： 链式存储方式的分析 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 【示意图】 操作示意图： 树存储方式的分析 能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也 可以保证数据的插入，删除，修改的速度。【示意图,后面详讲】 案例: [7, 3, 10, 1, 5, 9, 12] 二叉树 二叉树的概念 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。 二叉树的子节点分为左节点和右节点 示意图 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二 层的叶子节点在右边连续，我们称为完全二叉树 二叉树遍历的说明 使用前序，中序和后序对下面的二叉树进行遍历. 前序遍历: 先输出父节点，再遍历左子树和右子树 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 小结: 看输出父节点的顺序，就确定是前序，中序还是后序 二叉树-查找指定节点 要求 请编写前序查找，中序查找和后序查找的方法。 并分别使用三种查找方式，查找 heroNO = 5 的节点 并分析各种查找方式，分别比较了多少次 思路分析图解 二叉树-删除节点  要求 如果删除的节点是叶子节点，则删除该节点 如果删除的节点是非叶子节点，则删除该子树. 测试，删除掉 5 号叶子节点 和 3 号子树. 完成删除思路分析 package Tree; public class BinaryTreeDemo { public static void main(String[] args) { //先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的结点 HeroNode root = new HeroNode(1, \"宋江\"); HeroNode node2 = new HeroNode(2, \"吴用\"); HeroNode node3 = new HeroNode(3, \"卢俊义\"); HeroNode node4 = new HeroNode(4, \"林冲\"); HeroNode node5 = new HeroNode(5, \"关胜\"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); //测试 // System.out.println(\"前序遍历\"); // 1,2,3,5,4 // binaryTree.preOrder(); //测试 // System.out.println(\"中序遍历\"); // binaryTree.infixOrder(); // 2,1,5,3,4 // System.out.println(\"后序遍历\"); // binaryTree.postOrder(); // 2,5,4,3,1 // HeroNode node = binaryTree.postOrderSearch(5); // if (node != null) { // System.out.printf(\"编号为%d，名字为%s\\n\", node.getNo(), node.getName()); // } else { // System.out.println(\"编号为\"+5+\"的英雄不存在\"); // } //测试删除 System.out.println(\"删除前,前序遍历\"); binaryTree.preOrder(); // 1,2,3,5,4 binaryTree.delNode(6); //binaryTree.delNode(3); System.out.println(\"删除后，前序遍历\"); binaryTree.preOrder(); // 1,2,3,4 } } //二叉树 class BinaryTree { private HeroNode root; public void setRoot(HeroNode root) { this.root = root; } //前序遍历 public void preOrder() { if (root != null) { root.preOrder(); } else { System.out.println(\"树为空\"); } } //中序遍历 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"树为空\"); } } //后序遍历 public void postOrder() { if (root != null) { root.postOrder(); } else { System.out.println(\"树为空\"); } } //前序遍历查找 public HeroNode preOrderSearch(int no) { if (root != null) { return root.preOrderSearch(no); } else { return null; } } //中序遍历查找 public HeroNode infixOrderSearch(int no) { if (root != null) { return root.infixOrderSearch(no); } else { return null; } } //后序遍历查找 public HeroNode postOrderSearch(int no) { if (root != null) { return root.postOrderSearch(no); } else { return null; } } //删除结点 public void delNode(int no) { if (root != null) { if (root.getNo() == no) { root = null; } else { root.delNode(no); } } else { System.out.println(\"空树，不能删除~\"); } } } //节点 class HeroNode { private int no; private String name; private HeroNode left; private HeroNode right; public HeroNode(int no, String name) { this.no = no; this.name = name; } @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } //前序遍历 public void preOrder() { System.out.println(this);//先输出父结点 //递归向左子树前序遍历 if (left != null) { left.preOrder(); } //递归向右子树前序遍历 if (right != null) { right.preOrder(); } } //中序遍历 public void infixOrder() { //递归向左子树中序遍历 if (left != null) { left.infixOrder(); } //输出父结点 System.out.println(this); //递归向右子树中序遍历 if (right != null) { right.infixOrder(); } } //后序遍历 public void postOrder() { if(left != null) { left.postOrder(); } if(right != null) { right.postOrder(); } System.out.println(this); } //前序遍历查找 public HeroNode preOrderSearch(int no) { System.out.println(\"进入前序遍历查找\");//输出次数就是节点查找次数 //比较当前结点是不是 if (this.no == no) { return this; } //1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找 //2.如果左递归前序查找，找到结点，则返回 HeroNode resNode = null; if (left != null) { resNode = left.preOrderSearch(no); } if (resNode != null) {//说明我们左子树找到 return resNode; } //1.左递归前序查找，找到结点，则返回，否继续判断， //2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找 if (right != null) { resNode = right.preOrderSearch(no); } return resNode; } //中序遍历查找 public HeroNode infixOrderSearch(int no) { HeroNode resNode = null; //判断当前结点的左子节点是否为空，如果不为空，则递归中序查找 if (left != null) { resNode = left.infixOrderSearch(no); } if (resNode != null) { return resNode; } System.out.println(\"进入中序遍历查找\");//输出次数就是节点查找次数 //如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点 if(this.no == no) { return this; } if (right != null) { resNode = right.infixOrderSearch(no); } return resNode; } //后序遍历查找 public HeroNode postOrderSearch(int no) { //判断当前结点的左子节点是否为空，如果不为空，则递归后序查找 HeroNode resNode = null; if(this.left != null) { resNode = this.left.postOrderSearch(no); } if(resNode != null) {//说明在左子树找到 return resNode; } //如果左子树没有找到，则向右子树递归进行后序遍历查找 if(this.right != null) { resNode = this.right.postOrderSearch(no); } if(resNode != null) { return resNode; } System.out.println(\"进入后序查找\");//输出次数就是节点查找次数 //如果左右子树都没有找到，就比较当前结点是不是 if(this.no == no) { return this; } return resNode; } //递归删除结点 //1.如果删除的节点是叶子节点，则删除该节点 //2.如果删除的节点是非叶子节点，则删除该子树 public void delNode(int no) { //思路 /* * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点. 2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) 3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除) 4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除 5. 如果第4步也没有删除结点，则应当向右子树进行递归删除. */ //2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) if (left != null &amp;&amp; left.no == no) { left = null; return; } //3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除) if (right != null &amp;&amp; right.no == no) { right = null; return; } //4.那么我们就需要向左子树进行递归删除 if (left != null) { left.delNode(no); } //5. 如果第4步也没有删除结点，则应当向右子树进行递归删除. if (right != null) { right.delNode(no); } } } 三种遍历非递归实现package com.xu; import java.util.Stack; public class Test { public static void main(String[] args) { Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); Node node4 = new Node(4); Node node5 = new Node(5); Node node6 = new Node(6); Node node7 = new Node(7); Node node8 = new Node(8); Node node9 = new Node(9); Node node10 = new Node(10); node1.setLeft(node2); node1.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setRight(node7); node3.setLeft(node6); node4.setLeft(node8); node8.setLeft(node9); node5.setRight(node10); // node5.setLeft(node10); preOrder(node1); midOrder(node1); postOrder(node1); } public static void preOrder(Node root){ if (root == null) { System.out.println(\"树为空\"); } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node temp = root; while (temp != null || !stack.isEmpty()) {//只要指针不为空或者栈不为空，遍历就没结束 while (temp!=null){ System.out.print(temp.data+\" \"); //先输出根结点 stack.push(temp);//把根结点压入栈 temp = temp.left;//遍历左子树 } temp = stack.pop();//弹出上一个根结点 temp = temp.right;//进行右子树遍历 } System.out.println(); } public static void midOrder(Node root) { if (root == null) { System.out.println(\"树为空\"); } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node temp = root; while (temp != null || !stack.isEmpty()) {//只要指针不为空或者栈不为空，遍历就没结束 while (temp!=null){ stack.push(temp);//把根结点压入栈 temp = temp.left;//遍历左子树 } temp = stack.pop();//弹出上一个根结点 System.out.print(temp.data+\" \");//输出结点 temp = temp.right;//遍历右子树 } System.out.println(); } public static void postOrder(Node root) { if (root == null) { System.out.println(\"树为空\"); } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node temp = root; while (temp != null || !stack.isEmpty()) {//只要指针不为空或者栈不为空，遍历就没结束 if (temp != null) { stack.push(temp);//把根结点压入栈 temp.flag = 1;//标记第一次入栈 temp = temp.left;//遍历左子树 } else { temp = stack.pop();//弹出上一个根结点 if (temp.flag == 1) {//如果是只入栈一次 temp.flag = 2; stack.push(temp);//标记第二次入栈 temp = temp.right;//遍历右子树 } else { //入栈过两次的就输出 System.out.print(temp.data+\" \");//输出结点 temp = null;//访问后，赋为空，确保下次循环时执行弹栈操作 } } } } } class Node{ public Node left; public Node right; public int data; public int flag; public Node(int data) { this.data = data; } public void setLeft(Node left) { this.left = left; } public void setRight(Node right) { this.right = right; } } 顺序存储二叉树 基本说明 从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组， 看下面的示意图。  要求: 右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6] 要求在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历 顺序存储二叉树的特点 顺序二叉树通常只考虑完全二叉树 第 n 个元素的左子节点为 2 * n + 1 第 n 个元素的右子节点为 2 * n + 2 第 n 个元素的父节点为 (n-1) / 2 n : 表示二叉树中的第几个元素(按 0 开始编号，为的是与数组下标符合) package Tree; public class ArrBinaryTreeDemo { public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5, 6, 7 }; //创建一个 ArrBinaryTree ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr); arrBinaryTree.preOrder(); // 1,2,4,5,3,6,7 // arrBinaryTree.infixOrder(0); } } class ArrBinaryTree { private int[] arr;//存储数据结点的数组 public ArrBinaryTree(int[] arr) { this.arr = arr; } //重载 public void preOrder() { preOrder(0); } //前序遍历 public void preOrder(int index) { if (arr == null || arr.length == 0) { System.out.println(\"数组为空，不能按照二叉树的前序遍历\"); } //输出当前这个元素 System.out.println(arr[index]); //向左递归遍历 if ((index * 2 + 1) &lt; arr.length) { preOrder(index * 2 + 1); } //向右递归遍历 if((index * 2 + 2) &lt; arr.length) { preOrder(2 * index + 2); } } //中序遍历 public void infixOrder(int index) { if (arr.length == 0 || arr == null) { System.out.println(\"数组为空，不能按照二叉树的前序遍历\"); } //向左遍历 if ((index * 2 + 1) &lt; arr.length) { infixOrder(index * 2 + 1); } //输出当前元素 System.out.println(arr[index]); //向右遍历 if ((index * 2 + 2) &lt; arr.length) { infixOrder(index*2+2); } } } 线索化二叉树 先看一个问题 将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. n+1=7 问题分析: 当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 } 但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上. 如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? 解决方案-线索二叉树 线索二叉树基本介绍 n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”） 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 一个结点的前一个结点，称为前驱结点 一个结点的后一个结点，称为后继结点 线索二叉树应用案例 应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6} 思路分析: 中序遍历的结果：{8, 3, 10, 1, 14, 6}  说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况: left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点. right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向的是后继节点 package Tree.ThreadedBinaryTree; public class ThreadedBinaryTreeDemo { public static void main(String[] args) { //测试一把中序线索二叉树的功能 HeroNode root = new HeroNode(1, \"tom\"); HeroNode node2 = new HeroNode(3, \"jack\"); HeroNode node3 = new HeroNode(6, \"smith\"); HeroNode node4 = new HeroNode(8, \"mary\"); HeroNode node5 = new HeroNode(10, \"king\"); HeroNode node6 = new HeroNode(14, \"dim\"); //二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); //测试中序线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(root); //测试: 以10号节点测试 HeroNode leftNode = node5.getLeft(); HeroNode rightNode = node5.getRight(); System.out.println(\"10号结点的前驱结点是 =\" + leftNode); //3 System.out.println(\"10号结点的后继结点是=\" + rightNode); //1 threadedBinaryTree.threadedList(); } } //定义ThreadedBinaryTree 实现了线索化功能的二叉树 class ThreadedBinaryTree { private HeroNode root; //为了实现线索化，需要创建指向当前结点的前驱结点的指针 //在递归进行线索化时，pre 总是保留前一个结点 private HeroNode pre = null; public void setRoot(HeroNode root) { this.root = root; } //编写对二叉树进行中序线索化的方法 public void threadedNodes(HeroNode node) { //如果node==null, 不能线索化 if (node == null) { return; } //(一)先线索化左子树 threadedNodes(node.getLeft()); //(二)线索化当前结点[有难度] //处理当前结点的前驱结点 //以8结点来理解 //8结点的.left = null , 8结点的.leftType = 1 if (node.getLeft() == null) { //让当前结点的左指针指向前驱结点 node.setLeft(pre); //修改当前结点的左指针的类型,指向前驱结点 node.setLeftType(1); } //处理后继结点 if (pre != null &amp;&amp; pre.getRight() == null) { //让前驱结点的右指针指向当前结点 pre.setRight(node); //修改前驱结点的右指针类型 pre.setRightType(1); } //!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点 pre = node; //(三)在线索化右子树 threadedNodes(node.getRight()); } //遍历线索化二叉树的方法 public void threadedList() { //定义一个变量，存储当前遍历的结点，从root开始 HeroNode node = root; while (node != null) { //循环的找到leftType == 1的结点，第一个找到就是8结点 //后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化 //处理后的有效结点 while (node.getLeftType() == 0) { node = node.getLeft(); } //打印当前这个结点 System.out.println(node); //如果当前结点的右指针指向的是后继结点,就一直输出 while (node.getRightType() == 1) { //获取到当前结点的后继结点 node = node.getRight(); System.out.println(node); } //替换这个遍历的结点 node = node.getRight(); } } } //先创建HeroNode 结点 class HeroNode { private int no; private String name; private HeroNode left; //默认null private HeroNode right; //默认null //说明 //1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点 //2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点 private int leftType; private int rightType; public int getLeftType() { return leftType; } public void setLeftType(int leftType) { this.leftType = leftType; } public int getRightType() { return rightType; } public void setRightType(int rightType) { this.rightType = rightType; } public HeroNode(int no, String name) { this.no = no; this.name = name; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } @Override public String toString() { return \"HeroNode [no=\" + no + \", name=\" + name + \"]\"; } } 树结构实际应用堆排序 堆排序基本介绍 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 **O(nlogn)**，它也是不稳定排序。 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 大顶堆举例说明 小顶堆举例说明 一般升序采用大顶堆，降序采用小顶堆 堆排序的基本思想是： 将待排序序列构造成一个大顶堆 此时，整个序列的最大值就是堆顶的根节点。 将其与末尾元素进行交换，此时末尾就为最大值。 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了. 堆排序步骤图解说明 步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。 原始的数组 [4, 6, 8, 5, 9] .假设给定无序序列结构如下 .此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。 .找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。 此时，我们就将一个无序序列构造成了一个大顶堆。 步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 .将堆顶元素 9 和末尾元素 4 进行交换 .重新调整结构，使其继续满足堆定义 .再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8. 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序 再简单总结下堆排序的基本思路： 1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; 2).将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 package Tree; import java.util.Arrays; public class HeapSort { public static void main(String[] args) { int arr[] = {4, 6, 8, 5, 9,10,-1,-999,89,2}; heapSort(arr); } //编写一个堆排序的方法 public static void heapSort(int[] arr) { int temp = 0; System.out.println(\"堆排序!!\"); // //分步完成 // adjustHeap(arr, 1, arr.length); // System.out.println(\"第一次\" + Arrays.toString(arr)); // 4, 9, 8, 5, 6 // // adjustHeap(arr, 0, arr.length); // System.out.println(\"第2次\" + Arrays.toString(arr)); // 9,6,8,5,4 //完成我们最终代码 //将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) { adjustHeap(arr, i, arr.length); } /* * 2).将堆顶元素与末尾元素交换，将最大元素\"沉\"到数组末端; 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 */ for (int j = arr.length - 1; j&gt;0; j--) { //交换 temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } System.out.println(\"数组=\" +Arrays.toString(arr)); } //将一个数组(二叉树), 调整成一个大顶堆 /** * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆 * 举例 int arr[] = {4, 6, 8, 5, 9}; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 {4, 9, 8, 5, 6} * 如果我们再次调用 adjustHeap 传入的是 i = 0 =&gt; 得到 {4, 9, 8, 5, 6} =&gt; {9,6,8,5, 4} * * @param arr 待调整的数组 * @param i 表示非叶子结点在数组中的索引 * @param lenght 表示对多少个元素继续调整， length 是在逐渐的减少 */ public static void adjustHeap(int arr[], int i, int lenght) { int temp = arr[i];//先取出当前元素的值，保存在临时变量 //开始调整 //说明 //1. k = i * 2 + 1 k 是 i结点的左子结点 for (int k = i * 2 + 1; k &lt; lenght; k = k * 2 + 1) { if (k + 1 &lt; lenght &amp;&amp; arr[k] &lt; arr[k + 1]) {//说明左子结点的值小于右子结点的值 k++;// k 指向右子结点 } if (arr[k] &gt; temp) {//如果子结点大于父结点 arr[i] = arr[k];//把较大的值赋给当前结点 i = k;//!!! i 指向 k,继续循环比较 } else { break; } } //当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部) arr[i] = temp;//将temp值放到调整后的位置 } } 赫夫曼树 基本介绍 给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近 赫夫曼树几个重要概念和举例说明 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为 WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。 WPL 最小的就是赫夫曼树 赫夫曼树创建思路图解 给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树. 构成赫夫曼树的步骤： 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 取出根节点权值最小的两颗二叉树 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 图解: package Tree.Huffman; import java.util.ArrayList; import java.util.Collections; public class HuffmanTree { public static void main(String[] args) { int arr[] = { 13, 7, 8, 3, 29, 6, 1 }; Node root = createHuffmanTree(arr); //测试一把 preOrder(root); // } //前序遍历哈夫曼树 public static void preOrder(Node node) { if (node != null) { node.preOrder(); } else { System.out.println(\"树为空\"); } } // 创建赫夫曼树的方法 /** * * @param arr 需要创建成哈夫曼树的数组 * @return 创建好后的赫夫曼树的root结点 */ public static Node createHuffmanTree(int[] arr) { // 第一步为了操作方便 // 1. 遍历 arr 数组 // 2. 将arr的每个元素构成成一个Node // 3. 将Node 放入到ArrayList中 ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; arr.length; i++) { nodes.add(new Node(arr[i])); } while (nodes.size() &gt; 1) { //排序 从小到大 Collections.sort(nodes); //取出根节点权值最小的两颗二叉树 //(1) 取出权值最小的结点（二叉树） Node leftNode = nodes.get(0); //(2) 取出权值第二小的结点（二叉树） Node rightNode = nodes.get(1); //(3)构建一颗新的二叉树 Node parent = new Node(leftNode.value + rightNode.value); parent.left = leftNode; parent.right = rightNode; //(4)从ArrayList删除处理过的二叉树 nodes.remove(leftNode); nodes.remove(rightNode); //(5)将parent加入到nodes nodes.add(parent); } //返回哈夫曼树的root结点 return nodes.get(0); } } // 创建结点类 // 为了让Node 对象持续排序Collections集合排序 // 让Node 实现Comparable接口 class Node implements Comparable&lt;Node&gt;{ public int value;// 结点权值 public Node left;// 指向左子结点 public Node right;// 指向右子结点 public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } @Override public int compareTo(Node o) { // 表示从小到大排序 return this.value-o.value; } //前序遍历 public void preOrder() { System.out.println(this); if (left != null) { left.preOrder(); } if (right != null) { right.preOrder(); } } } 赫夫曼编码 基本介绍 赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间 赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码 11.3.2 原理剖析  通信领域中信息的处理方式 1-定长编码  通信领域中信息的处理方式 2-变长编码  通信领域中信息的处理方式 3-赫夫曼编码 传输的字符串 i like like like java do you like a java d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值 构成赫夫曼树的步骤： ​ 1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单 的二叉树 ​ 2) 取出根节点权值最小的两颗二叉树 ​ 3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 ​ 4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列 中，所有的数据都被处理， 就得到一颗赫夫曼树 根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ， 编码 如下: o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a : 110 k: 1110 e: 1111 j: 0000 v: 0001 l: 001 : 01 按照上面的赫夫曼编码，我们的”i like like like java do you like a java” 字符串对应的编码为 (注意这里我们使用的无损压缩) 10101001101111011110100110111101111010011011110111101000011000011100110011110000110 01111000100100100110111101111011100100001100001110 通过赫夫曼编码处理 长度为 133 6） 长度为 ： 133 说明: 原来长度是 359 , 压缩了 (359-133) / 359 = 62.9% 此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性  注意事项 注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是 wpl 是一样的，都是最小的, 最后生成的赫夫曼编码的长度是一样，比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为 package Tree.Huffman.HuffmanCode; import java.io.*; import java.util.*; public class HuffmanCodeDemo { public static void main(String[] args) { // //测试压缩 // zipFile(\"c://1.txt\", \"c://1.zip\"); // System.out.println(\"压缩成功\"); // // //测试解压 // unZipFile(\"c://1.zip\",\"c://2.txt\"); // System.out.println(\"解压成功\"); String content = \"i like like like java do you like a java\"; byte[] contentBytes = content.getBytes(); System.out.println(contentBytes.length); //40 //测试一把，创建的赫夫曼树 // List&lt;Node&gt; nodes = getNodes(contentBytes); // System.out.println(nodes); // Node root = createHuffmanTree(nodes); // preOrder(root); //测试一把是否生成了对应的赫夫曼编码 // Map&lt;Byte, String&gt; huffmanCodes = getHuffmanCodes(root); // System.out.println(huffmanCodes); // byte[] bytes = zip(contentBytes, huffmanCodes); // System.out.println(Arrays.toString(bytes)); //测试编码封装方法 byte[] huffmanZip = huffmanZip(contentBytes); System.out.println(Arrays.toString(huffmanZip)); //测试解码 byte[] bytes = decode(huffmanCodes, huffmanZip); System.out.println(\"原来的字符串=\"+new String(bytes)); } //编写一个方法，完成对压缩文件的解压 /** * * @param zipFile 准备解压的文件 * @param dstFile 将文件解压到哪个路径 */ public static void unZipFile(String zipFile, String dstFile) { InputStream is = null;//定义文件输入流 ObjectInputStream ois = null;//定义一个对象输入流 OutputStream os = null;//定义文件的输出流 try { //创建文件输入流 is = new FileInputStream(zipFile); //创建一个和 is关联的对象输入流 ois = new ObjectInputStream(is); //读取byte数组 huffmanBytes byte[] huffmanBytes = (byte[]) ois.readObject(); //读取哈夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject(); //解码 byte[] bytes = decode(huffmanCodes, huffmanBytes); //将bytes 数组写入到目标文件 os = new FileOutputStream(dstFile); os.write(bytes); } catch (Exception e) { System.out.println(e.getMessage()); } finally { try { os.close(); ois.close(); is.close(); } catch (IOException e) { System.out.println(e.getMessage()); } } } //编写方法，将一个文件进行压缩 /** * @param srcFile 你传入的希望压缩的文件的全路径 * @param dstFile 我们压缩后将压缩文件放到哪个目录 */ public static void zipFile(String srcFile, String dstFile) { //文件的输入流 InputStream is = null; //文件输出流 OutputStream os = null; ObjectOutputStream oos = null; try { is = new FileInputStream(srcFile); //创建一个和源文件大小一样的byte[] byte[] bytes = new byte[is.available()]; //读取文件 is.read(bytes); //直接对源文件压缩 byte[] huffmanBytes = huffmanZip(bytes); //创建文件的输出流, 存放压缩文件 os = new FileOutputStream(dstFile); //创建一个和文件输出流关联的ObjectOutputStream oos = new ObjectOutputStream(os); //把 赫夫曼编码后的字节数组写入压缩文件 oos.writeObject(huffmanBytes); //这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用 //注意一定要把赫夫曼编码 写入压缩文件 oos.writeObject(huffmanCodes); } catch (IOException e) { System.out.println(e.getMessage()); } finally { try { oos.close(); os.close(); is.close(); } catch (IOException e) { System.out.println(e.getMessage()); } } } //完成数据的解压 //思路 //1. 将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28] // 首先先转成 赫夫曼编码对应的二进制的字符串 \"1010100010111...\" //2. 赫夫曼编码对应的二进制的字符串 \"1010100010111...\" =》 对照 赫夫曼编码 =》 \"i like like like java do you like a java\" //编写一个方法，完成对压缩数据的解码 /** * @param huffmanCodes 赫夫曼编码表 map * @param huffmanBytes 赫夫曼编码得到的字节数组 * @return 就是原来的字符串对应的数组 */ private static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) { StringBuilder stringBuilder = new StringBuilder(); //将byte数组转成二进制的字符串 for (int i = 0; i &lt; huffmanBytes.length; i++) { //判断是不是最后一个字节 boolean flag = (i == huffmanBytes.length - 1); byte b = huffmanBytes[i]; String s = byteToBitString(!flag, b);//最后一位不用补高位，无论是否为正数,因为最后一位的编码可能不够8位 stringBuilder.append(s); } //把字符串按照指定的赫夫曼编码进行解码 //把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a Map&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) { map.put(entry.getValue(), entry.getKey()); } //创建集合，存放byte ArrayList&lt;Byte&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; stringBuilder.length(); ) { int count = 1; boolean flag = true; Byte b = null; while (flag) { //1010100010111... //递增的取出 key String key = stringBuilder.substring(i, i + count);//i 不动，让count移动，指定匹配到一个字符 b = map.get(key); if (b == null) {//说明没有匹配到 count++; } else { //匹配到 flag = false; } } list.add(b); i += count;//i 直接移动到 count } //当for循环结束后，我们list中就存放了所有的字符 \"i like like like java do you like a java\" //把list 中的数据放入到byte[] 并返回 byte[] bytes = new byte[list.size()]; for (int i = 0; i &lt; list.size(); i++) { bytes[i] = list.get(i); } return bytes; } /** * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码 * * @param b 传入的 byte * @param flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位 * @return 是该 b 对应的二进制的字符串，（注意是按补码返回） */ private static String byteToBitString(boolean flag, byte b) { int temp = (int) b;//将 b 转成 int //如果是正数我们还存在补高位 if (flag) { temp |= 256; //按位或 256 1 0000 0000 | 0000 0001 =&gt; 1 0000 0001 } String binaryString = Integer.toBinaryString(temp);//返回的是temp对应的二进制的补码 if (flag) { return binaryString.substring(binaryString.length() - 8); } else { return binaryString; } } //使用一个方法，将前面的方法封装起来，便于我们的调用. /** * @param bytes 原始要处理的字节数组 * @return 哈夫曼编码后的字节数组 */ public static byte[] huffmanZip(byte[] bytes) { List&lt;Node&gt; nodes = getNodes(bytes); Node huffmanTreeRoot = createHuffmanTree(nodes); Map&lt;Byte, String&gt; huffmanCodes = getHuffmanCodes(huffmanTreeRoot); byte[] zip = zip(bytes, huffmanCodes); return zip; } //编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[] /** * @param bytes 这时原始的字符串对应的 byte[] * @param huffmanCodes 生成的赫夫曼编码map * @return 返回赫夫曼编码处理后的 byte[] * 举例： String content = \"i like like like java do you like a java\"; =》 byte[] contentBytes = content.getBytes(); * 返回的是 字符串 \"1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100\" * =&gt; 对应的 byte[] huffmanCodeBytes ，即 8位对应一个 byte,放入到 huffmanCodeBytes * huffmanCodeBytes[0] = 10101000(补码) =&gt; byte [推导 10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ] * huffmanCodeBytes[1] = -88 */ public static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) { //1.利用 huffmanCodes 将 bytes 转成 赫夫曼编码对应的字符串 StringBuilder stringBuilder = new StringBuilder(); for (byte b : bytes) { stringBuilder.append(huffmanCodes.get(b));//将对应的字符的编码取出来 } //将 \"1010100010111111110...\" 转成 byte[] //统计返回 byte[] huffmanCodeBytes 长度 //一句话 int len = (stringBuilder.length() + 7) / 8; int len; if (stringBuilder.length() % 8 == 0) { len = stringBuilder.length() / 8; } else { len = stringBuilder.length() / 8 + 1; } //创建 存储压缩后的 byte数组 byte[] huffmanCodeBytes = new byte[len]; int index = 0;//记录是第几个byte //将哈夫曼编码转换为byte数组 for (int i = 0; i &lt; stringBuilder.length(); i += 8) { String strbyte; if (i + 8 &gt; stringBuilder.length()) {//如果最后一段编码不足8个 strbyte = stringBuilder.substring(i); } else { strbyte = stringBuilder.substring(i, i + 8); } //将strByte 转成一个byte,放入到 huffmanCodeBytes huffmanCodeBytes[index] = (byte) Integer.parseInt(strbyte, 2); index++; } return huffmanCodeBytes; } //生成赫夫曼树对应的赫夫曼编码 //思路: //1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式 // 生成的赫夫曼编码表{32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011} static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;&gt;(); //2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径 static StringBuilder stringBuilder = new StringBuilder(); //为了调用方便，我们重载 getCodes public static Map&lt;Byte, String&gt; getHuffmanCodes(Node root) { if (root == null) { return null; } //处理root的左子树 getCodes(root.left, \"0\", stringBuilder); //处理root的右子树 getCodes(root.right, \"1\", stringBuilder); return huffmanCodes; } /** * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合 * * @param node 传入结点 * @param code 路径： 左子结点是 0, 右子结点 1 * @param stringBuilder 用于拼接路径 */ public static void getCodes(Node node, String code, StringBuilder stringBuilder) { StringBuilder stringBuilder2 = new StringBuilder(stringBuilder); //将code 加入到 stringBuilder2 stringBuilder2.append(code); if (node != null) {//如果node == null不处理 //判断当前node 是叶子结点还是非叶子结点 if (node.data == null) {//非叶子结点 //递归处理 //向左递归 getCodes(node.left, \"0\", stringBuilder2); //向右递归 getCodes(node.right, \"1\", stringBuilder2); } else { //叶子结点 huffmanCodes.put(node.data, stringBuilder2.toString()); } } } //前序遍历的方法 public static void preOrder(Node root) { if (root == null) { System.out.println(\"树为空\"); } else { root.preOrder(); } } //可以通过List 创建对应的赫夫曼树 public static Node createHuffmanTree(List&lt;Node&gt; nodes) { while (nodes.size() &gt; 1) { //排序, 从小到大 Collections.sort(nodes); //取出第一颗最小的二叉树 Node leftNode = nodes.get(0); //取出第二颗最小的二叉树 Node rightNode = nodes.get(1); //创建一颗新的二叉树,它的根节点 没有data, 只有权值 Node parent = new Node(leftNode.weight + rightNode.weight, null); parent.left = leftNode; parent.right = rightNode; //将已经处理的两颗二叉树从nodes删除 nodes.remove(leftNode); nodes.remove(rightNode); //将新的二叉树，加入到nodes nodes.add(parent); } //nodes 最后的结点，就是赫夫曼树的根结点 return nodes.get(0); } /** * @param bytes 接收字节数组 * @return 返回的就是 List 形式 [Node[date=97 ,weight = 5], Node[date=32,weight = 9]......], */ public static List&lt;Node&gt; getNodes(byte[] bytes) { //1创建一个ArrayList ArrayList&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); //遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value] HashMap&lt;Byte, Integer&gt; map = new HashMap&lt;Byte, Integer&gt;(); for (byte b : bytes) { Integer count = map.get(b); if (count == null) {// Map还没有这个字符数据,第一次 map.put(b, 1); } else { map.put(b, count + 1); } } for (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) { nodes.add(new Node(entry.getValue(), entry.getKey())); } return nodes; } } class Node implements Comparable&lt;Node&gt; { public int weight; //权值, 表示字符出现的次数 public Byte data;// 存放数据(字符)本身，比如'a' =&gt; 97 ' ' =&gt; 32 public Node left; public Node right; public Node(int weight, Byte data) { this.weight = weight; this.data = data; } @Override public String toString() { return \"Node{\" + \"weight=\" + weight + \", data=\" + data + '}'; } @Override public int compareTo(Node o) { return this.weight - o.weight;//从小到大排序 } //前序遍历 public void preOrder() { System.out.println(this); if (left != null) { left.preOrder(); } if (right != null) { right.preOrder(); } } } 二叉排序树 先看一个需求 给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加 解决方案分析  使用数组 数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢. 数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。  使用链式存储-链表 不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。  使用二叉排序树 二叉排序树介绍 二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。 特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点 比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为： 二叉排序树创建和遍历 一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 Array(7, 3, 10, 12, 5, 1, 9) ， 创建成对应的二叉排序树为 : 二叉排序树的删除 二叉排序树的删除情况比较复杂，有下面三种情况需要考虑 删除叶子节点 (比如：2, 5, 9, 12) 删除只有一颗子树的节点 (比如：1) 删除有两颗子树的节点. (比如：7, 3，10 ) 操作的思路分析 //对删除结点的各种情况的思路分析: 第一种情况: 删除叶子节点 (比如：2, 5, 9, 12) 思路(1) 需求先去找到要删除的结点 targetNode (2) 找到 targetNode 的 父结点 parent (3) 确定 targetNode 是 parent 的左子结点 还是右子结点 (4) 根据前面的情况来对应删除 左子结点 parent.left = null 右子结点 parent.right = null; 第二种情况: 删除只有一颗子树的节点 比如 1 思路(1) 需求先去找到要删除的结点 targetNode (2) 找到 targetNode 的 父结点 parent (3) 确定 targetNode 的子结点是左子结点还是右子结点 (4) targetNode 是 parent 的左子结点还是右子结点 (5) 如果 targetNode 有左子结点 5. 1 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.left; 5.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.left; (6) 如果 targetNode 有右子结点 6.1 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.right; 6.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right 情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 ) 思路 (1) 需求先去找到要删除的结点 targetNode (2) 找到 targetNode 的 父结点 parent (3) 从 targetNode 的右子树找到最小的结点 (4) 用一个临时变量，将 最小结点的值保存 temp = 11 (5) 删除该最小结点 (6) targetNode.value = temp package Tree.BinarySortTree; public class BinarySortTreeDemo { public static void main(String[] args) { int[] arr = {7, 3, 10, 12, 5, 1, 9, 2}; BinarySortTree binarySortTree = new BinarySortTree(); //循环的添加结点到二叉排序树 for (int i = 0; i &lt; arr.length; i++) { binarySortTree.add(new Node(arr[i])); } //中序遍历二叉排序树 System.out.println(\"中序遍历二叉排序树~\"); binarySortTree.infixOrder(); // 1,2, 3, 5, 7, 9, 10, 12 binarySortTree.delNode(1); binarySortTree.delNode(7); binarySortTree.delNode(2); System.out.println(\"删除结点后\"); binarySortTree.infixOrder(); } } //创建二叉排序树 class BinarySortTree { private Node root; //添加结点的方法 public void add(Node node) { if (root == null) { root = node;//如果root为空则直接让root指向node } else { root.add(node); } } //中序遍历 public void infixOrder() { if (root == null) { System.out.println(\"树为空\"); } else { root.infixOrder(); } } //找到要删除的结点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } //找到要删除的结点的父结点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } //编写方法: //1. 返回的 以node 为根结点的二叉排序树的最小结点的值 //2. 删除node 为根结点的二叉排序树的最小结点 /** * @param node 传入的结点(当做二叉排序树的根结点) * @return 返回的 以node 为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) { Node target = node; //循环的查找左子节点，就会找到最小值 while (target.left != null) { target = target.left; } //这时 target就指向了最小结点 //删除最小结点 delNode(target.value); return target.value; } //删除结点 public void delNode(int value) { if (root == null) { return; } //1.需求先去找到要删除的结点 targetNode Node targetNode = search(value); if (targetNode == null) { return; } //如果我们发现当前这颗二叉排序树只有一个结点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } //去找到targetNode的父结点 Node parent = searchParent(value); //如果要删除的结点是叶子结点 if (targetNode.right == null &amp;&amp; targetNode.left == null) { //判断targetNode 是父结点的左子结点，还是右子结点 if (parent.left != null &amp;&amp; parent.left.value == value) {//是左子结点 parent.left = null; } else if (parent.right != null &amp;&amp; value == parent.right.value) {//是右子节点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) {//删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal;//删除右子树最小结点，然后把最小结点值赋给targetNode } else {// 删除只有一颗子树的结点 if (targetNode.left != null) {//只有左子树 if (parent != null) { //如果 targetNode 是 parent 的左子结点，parent.left != null避免空指针异常 if (parent.left != null &amp;&amp; parent.left.value == targetNode.value) { parent.left = targetNode.left; } else {// targetNode 是 parent 的右子结点 parent.right = targetNode.left; } } else {//没有父结点,也就是树只有root结点和一个子节点 root = targetNode.left; } } else {//只有右子树 if (parent != null) { //如果 targetNode 是 parent 的左子结点 if (parent.left != null &amp;&amp; parent.left.value == targetNode.value) { parent.left = targetNode.right; } else {//如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right; } } else {//没有父结点,也就是树只有root结点和一个子节点 root = targetNode.right; } } } } } class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } //查找要删除的结点 /** * @param value 希望删除的结点的值 * @return 如果找到返回该结点，否则返回null */ public Node search(int value) { if (value == this.value) {//刚好是要找的结点 return this; } else if (value &lt; this.value) {//如果查找的值小于当前结点，向左子树递归查找 if (this.left == null) {//如果左子结点为空 return null; } return this.left.search(value); } else {//如果查找的值不小于当前结点，向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } //查找要删除结点的父结点 /** * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点，如果没有就返回null */ public Node searchParent(int value) { //如果当前结点就是要删除的结点的父结点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { //如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空 if (this.left != null &amp;&amp; value &lt; this.value) { return left.searchParent(value);//向左子树递归查找 } else if (this.right != null &amp;&amp; value &gt;= this.value) { return right.searchParent(value);//向右子树递归查找 } else {//当前结点不是要找的结点，并且左右子结点都为空 return null;// 没有找到父结点 } } } //添加节点 public void add(Node node) { if (node == null) { return; } //判断传入的结点的值，和当前子树的根结点的值关系 if (node.value &lt; this.value) { if (left == null) {//如果当前结点左子结点为null left = node; } else { //递归的向左子树添加 left.add(node); } } else {//添加的结点的值大于等于 当前结点的值 if (right == null) { right = node; } else { //递归的向右子树添加 right.add(node); } } } //中序遍历 public void infixOrder() { if (left != null) { left.infixOrder(); } System.out.println(this); if (right != null) { right.infixOrder(); } } } 平衡二叉树(AVL 树) 看一个案例(说明二叉排序树可能的问题) 给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.  左边 BST 存在的问题分析: 左子树全部为空，从形式上看，更像一个单链表. 插入速度没有影响 查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢 解决方案-平衡二叉树(AVL) 基本介绍 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。 具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 举例说明, 看看下面哪些 AVL 树, 为什么? 应用案例-单旋转(左旋转) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8} 思路分析(示意图) //左旋转方法 public void leftRotate() { //创建新的结点，以当前根结点的值 Node newNode = new Node(this.value); //把新的结点的左子树设置成当前结点的左子树 newNode.left = this.left; //把新的结点的右子树设置成根结点的右子树的左子树 newNode.right = this.right.left; //把当前结点的值替换成右子结点的值 this.value = right.value; //把当前结点的右子树设置成当前结点右子树的右子树 this.right = this.right.right; //把当前结点的左子树(左子结点)设置成新的结点 this.left = newNode; } 应用案例-单旋转(右旋转) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6} 思路分析(示意图) //右旋转 public void rightRotate() { //创建新的结点，以当前根结点的值 Node newNode = new Node(value); //把新的结点的右子树设置成当前结点的右子树 newNode.right = right; //把新的结点的左子树设置成根结点的左子树的右子树 newNode.left = left.right; //把当前结点的值设置成左子结点的值 value = left.value; //把当前结点的的左子树设置成当前结点的左子树的左子树 left = left.left; //把当前结点的右子树(右子结点)设置成新的结点 right = newNode; } 应用案例-双旋转 前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转 不能完成平衡二叉树的转换。比如数列int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树.int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL 树 问题分析 解决思路分析 当符号右旋转的条件时 如果根结点的左子树的右子树高度大于它的左子树的左子树的高度 先对当前这个根结点的左节点进行左旋转 再对当前根结点进行右旋转的操作即可 package Tree.AVL_Tree; public class AVL_TreeDemo { public static void main(String[] args) { // int[] arr = {4,3,6,5,7,8}; // int[] arr = { 10, 12, 8, 9, 7, 6 }; int[] arr = {10, 11, 7, 6, 8, 9, 22, 3, 2}; AVLTree avlTree = new AVLTree(); for (int i = 0; i &lt; arr.length; i++) { avlTree.add(new Node(arr[i])); } System.out.println(\"树的高度为\" + avlTree.getRoot().getHeight()); System.out.println(\"左子树的高度为\" + avlTree.getRoot().getLeftHeight()); System.out.println(\"右子树的高度为\" + avlTree.getRoot().getRightHeight()); avlTree.delNode(9); avlTree.delNode(11); avlTree.delNode(22); //这里树会变成不平衡 avlTree.add(new Node(4)); //加上一个节点，树就会双旋转自己平衡 System.out.println(\"树的高度为\" + avlTree.getRoot().getHeight()); System.out.println(\"左子树的高度为\" + avlTree.getRoot().getLeftHeight()); System.out.println(\"右子树的高度为\" + avlTree.getRoot().getRightHeight()); } } //创建二叉排序树 class AVLTree { private Node root; public Node getRoot() { return root; } //添加结点的方法 public void add(Node node) { if (root == null) { root = node;//如果root为空则直接让root指向node } else { root.add(node); } } //中序遍历 public void infixOrder() { if (root == null) { System.out.println(\"树为空\"); } else { root.infixOrder(); } } //找到要删除的结点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } //找到要删除的结点的父结点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } //编写方法: //1. 返回的 以node 为根结点的二叉排序树的最小结点的值 //2. 删除node 为根结点的二叉排序树的最小结点 /** * @param node 传入的结点(当做二叉排序树的根结点) * @return 返回的 以node 为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) { Node target = node; //循环的查找左子节点，就会找到最小值 while (target.left != null) { target = target.left; } //这时 target就指向了最小结点 //删除最小结点 delNode(target.value); return target.value; } //删除结点 public void delNode(int value) { if (root == null) { return; } //1.需求先去找到要删除的结点 targetNode Node targetNode = search(value); if (targetNode == null) { return; } //如果我们发现当前这颗二叉排序树只有一个结点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } //去找到targetNode的父结点 Node parent = searchParent(value); //如果要删除的结点是叶子结点 if (targetNode.right == null &amp;&amp; targetNode.left == null) { //判断targetNode 是父结点的左子结点，还是右子结点 if (parent.left != null &amp;&amp; parent.left.value == value) {//是左子结点 parent.left = null; } else if (parent.right != null &amp;&amp; value == parent.right.value) {//是右子节点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) {//删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal;//删除右子树最小结点，然后把最小结点值赋给targetNode } else {// 删除只有一颗子树的结点 if (targetNode.left != null) {//只有左子树 if (parent != null) { //如果 targetNode 是 parent 的左子结点 if (parent.left != null &amp;&amp; parent.left.value == targetNode.value) { parent.left = targetNode.left; } else {// targetNode 是 parent 的右子结点 parent.right = targetNode.left; } } else {//没有父结点,也就是树只有root结点和一个子节点 root = targetNode.left; } } else {//只有右子树 if (parent != null) { //如果 targetNode 是 parent 的左子结点 if (parent.left != null &amp;&amp; parent.left.value == targetNode.value) { parent.left = targetNode.right; } else {//如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right; } } else { root = targetNode.right; } } } } } class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } //获取左子树的高度 public int getLeftHeight() { if (left == null) { return 0; } return left.getHeight(); } //获取右子树的高度 public int getRightHeight() { if (right == null) { return 0; } return right.getHeight(); } //获取当前结点为根结点的树的高度 public int getHeight() {//每一层加一 return Math.max(left == null ? 0 : left.getHeight(), right == null ? 0 : right.getHeight()) + 1; } //左旋转方法 public void leftRotate() { //创建新的结点，以当前根结点的值 Node newNode = new Node(this.value); //把新的结点的左子树设置成当前结点的左子树 newNode.left = this.left; //把新的结点的右子树设置成根结点的右子树的左子树 newNode.right = this.right.left; //把当前结点的值替换成右子结点的值 this.value = right.value; //把当前结点的右子树设置成当前结点右子树的右子树 this.right = this.right.right; //把当前结点的左子树(左子结点)设置成新的结点 this.left = newNode; } //右旋转 public void rightRotate() { //创建新的结点，以当前根结点的值 Node newNode = new Node(value); //把新的结点的右子树设置成当前结点的右子树 newNode.right = right; //把新的结点的左子树设置成根结点的右子树的左子树 newNode.left = left.right; //把当前结点的值设置成左子结点的值 value = left.value; //把当前结点的的左子树设置成当前结点的左子树的左子树 left = left.left; //把当前结点的右子树(右子结点)设置成新的结点 right = newNode; } //查找要删除的结点 /** * @param value 希望删除的结点的值 * @return 如果找到返回该结点，否则返回null */ public Node search(int value) { if (value == this.value) {//刚好是要找的结点 return this; } else if (value &lt; this.value) {//如果查找的值小于当前结点，向左子树递归查找 if (this.left == null) {//如果左子结点为空 return null; } return this.left.search(value); } else {//如果查找的值不小于当前结点，向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } //查找要删除结点的父结点 /** * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点，如果没有就返回null */ public Node searchParent(int value) { //如果当前结点就是要删除的结点的父结点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { //如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空 if (this.left != null &amp;&amp; value &lt; this.value) { return left.searchParent(value);//向左子树递归查找 } else if (this.right != null &amp;&amp; value &gt;= this.value) { return right.searchParent(value);//向右子树递归查找 } else {//当前结点不是要找的结点，并且左右子结点都为空 return null;// 没有找到父结点 } } } //添加节点 public void add(Node node) { if (node == null) { return; } //判断传入的结点的值，和当前子树的根结点的值关系 if (node.value &lt; this.value) { if (left == null) {//如果当前结点左子结点为null left = node; } else { //递归的向左子树添加 left.add(node); } } else {//添加的结点的值大于等于 当前结点的值 if (right == null) { right = node; } else { //递归的向右子树添加 right.add(node); } } //当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转 //这里的 this 是根结点 root if (this.getRightHeight() - this.getLeftHeight() &gt; 1) { //如果它的右子树的左子树的高度大于它的右子树的右子树的高度 if (right != null &amp;&amp; right.getLeftHeight() &gt; right.getRightHeight()) { //先对右子结点进行右旋转 right.rightRotate(); //再对根结点进行左旋转 this.leftRotate(); } else {//直接进行左旋转即可 this.leftRotate(); } return; //必须要！！！，可以省略下面代码的运行，节约资源 } //当添加完一个结点后，如果: (左子树的高度-右子树的高度) &gt; 1 ,右旋转 if (getLeftHeight() - getRightHeight() &gt; 1) { //如果根结点的左子树的右子树高度大于它的左子树的左子树的高度 if (left != null &amp;&amp; left.getRightHeight() &gt; left.getLeftHeight()) { //先对左子结点进行左旋转 left.leftRotate(); //再对根结点进行右旋转 this.rightRotate(); } else { //直接进行右旋转 rightRotate(); } } } //中序遍历 public void infixOrder() { if (left != null) { left.infixOrder(); } System.out.println(this); if (right != null) { right.infixOrder(); } } } 多路查找树二叉树与 B 树 二叉树的问题分析 二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树 二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)， 就存在如下问题: 问题 1：在构建二叉树时，需要多次进行 i/o 操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时， 速度有影响 问题 2：节点海量，也会造成二叉树的高度很大，会降低操作速度 多叉树 在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree） 后面我们讲解的 2-3 树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。 举例说明(下面 2-3 树就是一颗多叉树) B 树的基本介绍 B 树通过重新组织节点，降低树的高度，并且减少 i/o 读写次数来提升效率。 如图 B 树通过重新组织节点， 降低了树的高度. 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为 4k)， 这样每个节点只需要一次 I/O 就可以完全载入 将树的度 M 设置为 1024，在 600 亿个元素中最多只需要 4 次 I/O 操作就可以读取到想要的元素, B 树(B+)广泛应用于文件存储系统以及数据库系统中 2-3 树 2-3 树是最简单的 B 树结构, 具有如下特点: 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点. 2-3 树是由二节点和三节点构成的树。 2-3 树应用案例 将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序。(演示一下构建 2-3树的过程.) 插入规则: 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面 3 个条件。 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则 其它说明 除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图: B 树、B+树和 B*树 B 树的介绍 B-tree 树即 B 树，B 即 Balanced，平衡的意思。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树是一种树，而 B 树又是另一种树。实际上，B-tree 就是指的 B 树。 前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图: 对上图的说明: B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4 B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据. 搜索有可能在非叶子结点结束 其搜索性能等价于在关键字全集内做一次二分查找 B+树的介绍 B+树是 B 树的变体，也是一种多路搜索树。 对上图的说明: B+树的搜索与 B 树也基本相同，区别是 B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。 不可能在非叶子结点命中 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层 更适合文件索引系统 B 树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然. B*树的介绍 B*树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针。  B*树的说明: B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为 2/3，而 B+树的块的最低使用率为的 1/2。 从第 1 个特点我们可以看出，B*树分配新结点的概率比 B+树要低，空间使用率更高 图 为什么要有图 前面我们学了线性表和树 线性表局限于一个直接前驱和一个直接后继的关系 树也只能有一个直接前驱也就是父节点 当我们需要表示多对多的关系时， 这里我们就用到了图。 图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为 顶点。如图： 图的常用概念 顶点(vertex) 边(edge) 路径 无向图(右图) 有向图 带权图 图的表示方式 图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。 邻接矩阵 邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1….n 个点。 邻接表 邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失. 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成 举例说明 图的快速入门案例 要求: 代码实现如下图结构 思路分析 (1) 存储顶点 String 使用 ArrayList (2) 保存矩阵 int[][] edges //添加节点 public void insertVertex(String vertex) { vertexList.add(vertex); } //添加边 /** * @param v1 表示点的下标即使第几个顶点 \"A\"-\"B\" \"A\"-&gt;0 \"B\"-&gt;1 * @param v2 第二个顶点对应的下标 * @param weight 表示 */ public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; } 深度优先遍历 图遍历介绍 所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)深度优先遍历 (2)广度优先遍历 深度优先遍历基本思想 图的深度优先搜索(Depth First Search) 。 深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解： 每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。 显然，深度优先搜索是一个递归的过程 深度优先遍历算法步骤 访问初始结点 v，并标记结点 v 为已访问。 查找结点 v 的第一个邻接结点 w。 若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续。 若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤 123）。 查找结点 v 的 w 邻接结点的下一个邻接结点，转到步骤 3。 分析图 //深度优先遍历算法 //i 第一次就是 0 public void dfs(boolean[] isVisited, int i) { //首先我们访问该结点,输出 System.out.print(getValueByIndex(i) + \"-&gt;\"); //将结点设置为已经访问 isVisited[i] = true; //查找结点i的第一个邻接结点w int w = getFirstNeighbor(i); while (w != -1) {//说明有 if (!isVisited[w]) {//如果w结点没有被访问过 dfs(isVisited, w); } //如果w结点已经被访问过，返回前一个结点查找下一个邻接点 w = getNextNeighbor(i, w); } } //对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs public void dfs() { isVisited = new boolean[vertexList.size()]; //遍历所有的结点，进行dfs[回溯] for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { dfs(isVisited, i); } } } 广度优先遍历 广度优先遍历基本思想 图的广度优先搜索(Broad First Search) 。 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点 广度优先遍历算法步骤 访问初始结点 v 并标记结点 v 为已访问。 结点 v 入队列 当队列非空时，继续执行，否则算法结束。 出队列，取得队头结点 u。 查找结点 u 的第一个邻接结点 w。 若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤： ​ 6.1 若结点 w 尚未被访问，则访问结点 w 并标记为已访问。 ​ 6.2 结点 w 入队列 ​ 6.3 查找结点 u 的继 w 邻接结点后的下一个邻接结点 w，转到步骤 6。 //广度优先遍历算法 public void bfs(boolean[] isVisited, int i) { int u;// 表示队列的头结点对应下标 int w;// 邻接结点w下标 //队列，记录结点访问的顺序 LinkedList queue = new LinkedList(); //访问结点，输出结点信息 System.out.print(getValueByIndex(i) + \"=&gt;\"); //标记为已访问 isVisited[i] = true; //将结点加入队列 queue.addLast(i); while (!queue.isEmpty()) { //取出队列的头结点下标 u = (int) queue.removeFirst(); //得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while (w != -1) {//找到 //是否访问过 if (!isVisited[w]) { System.out.print(getValueByIndex(w) + \"=&gt;\"); //标记已经访问 isVisited[w] = true; //入队 queue.addLast(w); } //以u为前驱点，找w后面的下一个邻结点 w = getNextNeighbor(u, w);//体现出我们的广度优先 } } } //遍历所有的结点，都进行广度优先搜索 public void bfs() { isVisited = new boolean[vertexList.size()]; for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { bfs(isVisited, i); } } } 图的深度优先 VS 广度优先 图的代码汇总package Graph; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; public class Graph{ private ArrayList&lt;String&gt; vertexList;//存储顶点集合 private int[][] edges;//存储图对应的邻结矩阵 private int numOfEdges; //表示边的数目 //定义给数组boolean[], 记录某个结点是否被访问 private boolean[] isVisited; public static void main(String[] args) { int n = 8; //结点的个数 // String Vertexs[] = {\"A\", \"B\", \"C\", \"D\", \"E\"}; String Vertexs[] = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; //创建图对象 Graph graph = new Graph(n); //循环的添加顶点 for(String vertex: Vertexs) { graph.insertVertex(vertex); } //添加边 //A-B A-C B-C B-D B-E // graph.insertEdge(0, 1, 1); // A-B // graph.insertEdge(0, 2, 1); // // graph.insertEdge(1, 2, 1); // // graph.insertEdge(1, 3, 1); // // graph.insertEdge(1, 4, 1); // //更新边的关系 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); //显示一把邻结矩阵 graph.showGraph(); System.out.println(\"进行深度优先遍历\"); graph.dfs(); System.out.println(); System.out.println(\"进行广度优先遍历\"); graph.bfs(); } public Graph(int n) { //初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;&gt;(n); numOfEdges = 0; } //得到第一个邻接结点的下标 w public int getFirstNeighbor(int index) { for (int j = 0; j &lt; vertexList.size(); j++) { if (edges[index][j] &gt; 0) { return j; } } return -1; } //根据前一个邻接结点的下标来获取下一个邻接结点 public int getNextNeighbor(int v1, int v2) { for (int j = v2 + 1; j &lt; vertexList.size(); j++) { if (edges[v1][j] &gt; 0) { return j; } } return -1; } //广度优先遍历算法 public void bfs(boolean[] isVisited, int i) { int u;// 表示队列的头结点对应下标 int w;// 邻接结点w下标 //队列，记录结点访问的顺序 LinkedList queue = new LinkedList(); //访问结点，输出结点信息 System.out.print(getValueByIndex(i) + \"=&gt;\"); //标记为已访问 isVisited[i] = true; //将结点加入队列 queue.addLast(i); while (!queue.isEmpty()) { //取出队列的头结点下标 u = (int) queue.removeFirst(); //得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while (w != -1) {//找到 //是否访问过 if (!isVisited[w]) { System.out.print(getValueByIndex(w) + \"=&gt;\"); //标记已经访问 isVisited[w] = true; //入队 queue.addLast(w); } //以u为前驱点，找w后面的下一个邻结点 w = getNextNeighbor(u, w);//体现出我们的广度优先 } } } //遍历所有的结点，都进行广度优先搜索 public void bfs() { isVisited = new boolean[vertexList.size()]; for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { bfs(isVisited, i); } } } //深度优先遍历算法 //i 第一次就是 0 public void dfs(boolean[] isVisited, int i) { //首先我们访问该结点,输出 System.out.print(getValueByIndex(i) + \"-&gt;\"); //将结点设置为已经访问 isVisited[i] = true; //查找结点i的第一个邻接结点w int w = getFirstNeighbor(i); while (w != -1) {//说明有 if (!isVisited[w]) {//如果w结点没有被访问过 dfs(isVisited, w); } //如果w结点已经被访问过，返回前一个结点查找下一个邻接点 w = getNextNeighbor(i, w); } } //对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs public void dfs() { isVisited = new boolean[vertexList.size()]; //遍历所有的结点，进行dfs[回溯] for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { dfs(isVisited, i); } } } //返回图的节点数目 public int getNumOfVertex() { return vertexList.size(); } //显示图对应的矩阵 public void showGraph() { for(int[] link : edges) { System.err.println(Arrays.toString(link)); } } //返回结点i(下标)对应的数据 0-&gt;\"A\" 1-&gt;\"B\" 2-&gt;\"C\" public String getValueByIndex(int i) { return vertexList.get(i); } //返回v1和v2的权值 public int getWeight(int v1, int v2) { return edges[v1][v2]; } //得到边的数目 public int getNumOfEdges() { return numOfEdges; } //添加节点 public void insertVertex(String vertex) { vertexList.add(vertex); } //添加边 /** * @param v1 表示点的下标即使第几个顶点 \"A\"-\"B\" \"A\"-&gt;0 \"B\"-&gt;1 * @param v2 第二个顶点对应的下标 * @param weight 表示 */ public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; } } 二分查找算法(非递归) 二分查找算法(非递归)介绍 前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间 O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n 步，假设从[0,99]的 队列(100 个数，即 n=100)中寻到目标数 30，则需要查找步数为㏒₂100 , 即最多需要查找 7 次( 2^6 &lt; 100 &lt; 2^7) package BinarySearchNoRecursion; public class BinarySearchNoRecursion { public static void main(String[] args) { //测试 int[] arr = {1,3, 8, 10, 11, 67, 100}; int index = binarySearch(arr, 100); System.out.println(\"index=\" + index);// 6 } //二分查找的非递归实现 /** * * @param arr 被查找的数组 * @param target 要找的值 * @return 找到的话返回下标，没有返回-1 */ public static int binarySearch(int[] arr, int target) { int left = 0; int right = arr.length - 1; while (left &lt;= right) { //说明可以继续查找 int mid = (left + right) / 2; if (arr[mid] == target) { return mid; } else if (arr[mid] &gt; target) { right = mid - 1;//需要向左边查找 } else { left = mid + 1;//需要向右边查找 } } return -1; } } 分治算法 分治算法介绍 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)…… 分治算法可以求解的一些经典问题 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 分治算法的基本步骤 分治法在每一层递归上都有三个步骤： 1) 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题 2) 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 3) 合并：将各个子问题的解合并为原问题的解。 分治算法最佳实践-汉诺塔  汉诺塔游戏的演示和思路分析: 如果是有一个盘， A-&gt;C 如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘 先把 最上面的盘 A-&gt;B 把最下边的盘 A-&gt;C 把 B 塔的所有盘 从 B-&gt;C package DivideAndConquer; public class DivideAndConquer { public static void main(String[] args) { HanoiTower(4, 'A', 'B', 'C'); } //汉诺塔的移动的方法 //使用分治算法 public static void HanoiTower(int num, char a, char b, char c) { //如果只有一个盘 if (num == 1) { System.out.println(\"第1个盘从 \" + a + \"-&gt;\" + c); } else { //如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘 //1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c HanoiTower(num - 1, a, c, b); //2. 把最下边的盘 A-&gt;C System.out.println(\"第\" + num + \"个盘从 \" + a + \"-&gt;\" + c); //3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔 HanoiTower(num - 1, b, a, c); } } } 动态规划算法 动态规划算法介绍 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 ) 动态规划可以通过填表的方式来逐步推进，得到最优解. 应用场景-背包问题 背包问题：有一个背包，容量为 4 磅 ， 现有如下物品 要求达到的目标为装入的背包的总价值最大，并且重量不超出 要求装入的物品不能重复 思路分析和图解 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分 01 背包和完全背包(完全背包指的是：每种物品都有无限件可用) 这里的问题属于 01 背包，即每个物品最多放一个。而无限背包可以转化为 01 背包。 算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w[i]和 v[i]来确定是否需要将该物品放入背包中。即对于给定的 n 个物品，设 v[i]、w[i]分别为第 i 个物品的价值和重量，C 为背包的容量。再令 v[i] [j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。则我们有下面的结果： (1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是 0 (2) 当 w[i]&gt; j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个 单元格的装入策略 (3) 当 j&gt;=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} // 当 准备加入的新增的商品的容量小于等于当前背包的容量, // 装入的方式: v[i-1][j]： 就是上一个单元格的装入的最大值 v[i] : 表示当前商品的价值 v[i-1][j-w[i]] ： 装入 i-1 商品，到剩余空间 j-w[i]的最大值 当 j&gt;=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} : 图解的分析 package Dynamic; public class KnapsackProblem { public static void main(String[] args) { int[] w = {1, 4, 3};//物品的重量 int[] val = {1500, 3000, 2000}; //物品的价值 这里val[i] 就是前面讲的v[i] int m = 4; //背包的容量 int n = val.length; //物品的个数 //创建二维数组， //v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值 int[][] v = new int[n + 1][m + 1]; //为了记录放入商品的情况，我们定一个二维数组 int[][] path = new int[n + 1][m + 1]; //初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0 for (int i = 0; i &lt; v.length; i++) { v[i][0] = 0;//将第一列设置为0 } for (int i = 0; i &lt; v[0].length; i++) { v[0][i] = 0; //将第一行设置0 } //根据前面得到公式来动态规划处理 for (int i = 1; i &lt; v.length; i++) {//不处理第一行 i是从1开始的 for (int j = 1; j &lt; v[0].length; j++) {//不处理第一列, j是从1开始的 //公式 if(w[i-1]&gt; j) { // 因为我们程序i 是从0开始的，因此原来公式中的 w[i] 修改成 w[i-1] v[i][j]=v[i-1][j]; } else { //说明: //v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} //因为我们的i 从0开始的， 因此公式需要调整成 //v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]); //为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式 if (v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]) { v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]]; //把当前的情况记录到path ,对应背包容量对应商品的最优方案 path[i][j] = 1; } else { v[i][j] = v[i - 1][j]; } } } } //输出一下v 看看目前的情况 for(int i =0; i &lt; v.length;i++) { for(int j = 0; j &lt; v[i].length;j++) { System.out.print(v[i][j] + \" \"); } System.out.println(); } System.out.println(\"============================\"); //输出最后我们是放入的哪些商品 //遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入 // for(int i = 0; i &lt; path.length; i++) { // for(int j=0; j &lt; path[i].length; j++) { // if(path[i][j] == 1) { // System.out.printf(\"第%d个商品放入到背包\\n\", i); // } // } // } int i = path.length - 1;//行的最大下标 int j = path[0].length - 1; //列的最大下标 while (i &gt;= 0 &amp;&amp; j &gt;= 0) {//从path的最后开始找 if (path[i][j] == 1) { System.out.printf(\"第%d个商品放入到背包\\n\", i); j = j - w[i - 1];//剩余的空间 } i--;//向前扫描 } } } KMP 算法 字符串匹配问题  字符串匹配问题： 有一个字符串 str1= “”硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好””，和一个子串 str2=”尚硅谷你尚硅你” 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 暴力匹配算法如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有: 如果当前字符匹配成功（即 str1[i] == str2[j]），则 i++，j++，继续匹配下一个字符 如果失配（即 str1[i]! = str2[j]），令 i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0。 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!) 暴力匹配算法实现 package KMP; public class ViolenceMatch { public static void main(String[] args) { //测试暴力匹配算法 String str1 = \"硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好\"; String str2 = \"尚硅谷你尚硅你\"; int index = violenceMatch(str1, str2); System.out.println(\"index=\" + index); } //暴力匹配算法 public static int violenceMatch(String str1, String str2) { char[] s1 = str1.toCharArray(); char[] s2 = str2.toCharArray(); int s1Len = s1.length; int s2Len = s2.length; int i = 0;// i索引指向s1 int j = 0;// j索引指向s2 while (i &lt; s1Len &amp;&amp; j &lt; s2Len) {// 保证匹配时，不越界 if (s1[i] == s2[j]) {//匹配ok,后移 i++; j++; } else {//没有匹配成功 //如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。 i = i - (j - 1); j = 0; } } //判断是否匹配成功 if (j == s2Len) { return i - j; } else { return -1; } } } KMP 算法介绍 KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法 Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法. KMP 方法算法就利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间 参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html KMP 算法最佳应用-字符串匹配问题  字符串匹配问题：： 有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=”ABCDABD” 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 要求：使用 KMP 算法完成判断，不能使用简单的暴力匹配算法  思路分析图解 举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”？ ​ 1.首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位​ 重复第一步，还是不符合，再后移 一直重复，直到 Str1 有一个字符与 Str2 的第一个字符符合为止 接着比较字符串和搜索词的下一个字符，还是符合。 遇到 Str1 有一个字符与 Str2 对应的字符不符合。 这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步。(其实是很不明智的，因为此时 BCD 已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。 KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。) 怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍 .已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分匹配值”为 2，因此按照下面的公式算出向后移动的位数： 移动位数 = 已匹配的字符数 - 对应的部分匹配值 因为 6 - 2 等于 4，所以将搜索词向后移动 4 位。 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2（”AB”），对应的”部分匹配值”为 0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移 2 位。 因为空格与 A 不匹配，继续后移一位。 逐位比较，直到发现 C 与 D 不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位。 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。 .介绍《部分匹配表》怎么产生的 先介绍前缀，后缀是什么 “部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， －”A”的前缀和后缀都为空集，共有元素的长度为 0； －”AB”的前缀为[A]，后缀为[B]，共有元素的长度为 0； －”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度 0； －”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为 0； －”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为 1； －”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为 2； －”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为 0。 ”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是 2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动 4 位（字符串长度- 部分匹配值），就可以来到第二个”AB”的位置。 到此 KMP 算法思想分析完毕! package KMP; import java.util.Arrays; public class KMPAlgorithm { public static void main(String[] args) { String str1 = \"BBC ABCDAB ABCDABCDABDE\"; String str2 = \"ABCDABD\"; //String str2 = \"BBC\"; int[] next = kmpNext(\"ABCDABD\"); //[0, 0, 0, 0, 1, 2, 0] System.out.println(\"next=\" + Arrays.toString(next)); int index = kmpSearch(str1, str2, next); System.out.println(\"index=\" + index); // 15了 } //写出我们的kmp搜索算法 /** * * @param str1 源字符串 * @param str2 子串 * @param next 部分匹配表, 是子串对应的部分匹配表 * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置 */ public static int kmpSearch(String str1, String str2, int[] next) { //遍历 for (int i = 0, j = 0; i &lt; str1.length(); i++) { //需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小 //KMP算法核心点, 可以验证... while (j &gt; 0 &amp;&amp; str1.charAt(i) != str2.charAt(j)) { j = next[j - 1]; } if (str1.charAt(i) == str2.charAt(j)) { j++; } if (j == str2.length()) {//找到了 return i - j + 1; } } return -1; } //获取到一个字符串(子串) 的部分匹配值表 public static int[] kmpNext(String dest) { //创建一个next 数组保存部分匹配值 int[] next = new int[dest.length()]; next[0] = 0;//如果字符串是长度为1 部分匹配值就是0 for (int i = 1, j = 0; i &lt; next.length; i++) { //当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j //直到我们发现 有 dest.charAt(i) == dest.charAt(j)成立才退出 //这是kmp算法的核心点 while (j &gt; 0 &amp;&amp; dest.charAt(i) != dest.charAt(j)) { j = next[j - 1]; } //当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就+1 if (dest.charAt(i) == dest.charAt(j)) { j++; } next[i] = j; } return next; } } 贪心算法 贪心算法介绍 贪婪算法(贪心算法)是指在对问题进行求解时，*在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果 贪心算法最佳应用-集合覆盖 假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号 思路分析:  如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有 n 个广播台，则广播台的组合总共有 2ⁿ -1 个,假设每秒可以计算 10 个子集， 如图:  使用贪婪算法，效率高: 目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合: 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） 将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。 重复第 1 步直到覆盖了全部的地区 分析的图解: package Greedy; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; public class GreedyAlgorithm { public static void main(String[] args) { //创建广播电台,放入到Map HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = new HashMap&lt;&gt;(); //将各个电台放入到broadcasts HashSet&lt;String&gt; hashSet1 = new HashSet&lt;String&gt;(); hashSet1.add(\"北京\"); hashSet1.add(\"上海\"); hashSet1.add(\"天津\"); HashSet&lt;String&gt; hashSet2 = new HashSet&lt;String&gt;(); hashSet2.add(\"广州\"); hashSet2.add(\"北京\"); hashSet2.add(\"深圳\"); HashSet&lt;String&gt; hashSet3 = new HashSet&lt;String&gt;(); hashSet3.add(\"成都\"); hashSet3.add(\"上海\"); hashSet3.add(\"杭州\"); HashSet&lt;String&gt; hashSet4 = new HashSet&lt;String&gt;(); hashSet4.add(\"上海\"); hashSet4.add(\"天津\"); HashSet&lt;String&gt; hashSet5 = new HashSet&lt;String&gt;(); hashSet5.add(\"杭州\"); hashSet5.add(\"大连\"); //加入到map broadcasts.put(\"K1\", hashSet1); broadcasts.put(\"K2\", hashSet2); broadcasts.put(\"K3\", hashSet3); broadcasts.put(\"K4\", hashSet4); broadcasts.put(\"K5\", hashSet5); //allAreas 存放所有的地区 ArrayList&lt;String&gt; allAreas = new ArrayList&lt;&gt;(); allAreas.add(\"北京\"); allAreas.add(\"上海\"); allAreas.add(\"天津\"); allAreas.add(\"广州\"); allAreas.add(\"深圳\"); allAreas.add(\"成都\"); allAreas.add(\"杭州\"); allAreas.add(\"大连\"); //创建ArrayList, 存放选择的电台集合 ArrayList&lt;String&gt; selects = new ArrayList&lt;&gt;(); //定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集 HashSet&lt;String&gt; tempSet = new HashSet&lt;String&gt;(); //定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key //如果maxKey 不为null , 则会加入到 selects String maxKey = null; //遍历 broadcasts, 取出对应key while (allAreas.size() &gt; 0) {// 如果allAreas 不为0, 则表示还没有覆盖到所有的地区 //每进行一次while,需要 maxKey = null; for (String key : broadcasts.keySet()) { //每进行一次for,需要 tempSet.clear(); //当前这个key能够覆盖的地区 HashSet&lt;String&gt; areas = broadcasts.get(key); tempSet.addAll(areas); //求出tempSet 和 allAreas 集合的交集, 交集会赋给 tempSet tempSet.retainAll(allAreas); //如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多 //就需要重置maxKey // tempSet.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的 if (tempSet.size() &gt; 0 &amp;&amp; (maxKey == null || tempSet.size() &gt; broadcasts.get(maxKey).size())) { maxKey = key; } } //maxKey != null, 就应该将maxKey 加入selects if (maxKey != null) { selects.add(maxKey); //将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉 allAreas.removeAll(broadcasts.get(maxKey)); } } System.out.println(\"得到的选择结果是\" + selects);//[K1,K2,K3,K5] } } 普里姆算法 应用场景-修路问题  看一个应用场景和问题： 1) 有胜利乡有 7 个村庄(A, B, C, D, E, F, G)，现在需要修路把 7 个村庄连通 2) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 3) 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短? 思路: 将 10 条边，连接即可，但是总的里程数不是最小. 正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少. 最小生成树 修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称MST。 给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 1) N 个顶点，一定有 N-1 条边 2) 包含全部顶点 3) N-1 条边都在图中 4) 举例说明(如图:) 5) 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法 普里姆算法介绍 普利姆(Prim)算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有(n-1)条边包含所有 n 个顶点的连通子图，也就是所谓的极小连通子图 普利姆的算法如下: 设 G=(V,E)是连通网，T=(U,D)是最小生成树，V,U 是顶点集合，E,D 是边的集合 若从顶点 u 开始构造最小生成树，则从集合 V 中取出顶点 u 放入集合 U 中，标记顶点 v 的 visited[u]=1 若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点 vj 加入集合 U 中，将边（ui,vj）加入集合 D 中，标记 visited[vj]=1 重复步骤②，直到 U 与 V 相等，即所有顶点都被标记为访问过，此时 D 中有 n-1 条边 提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解. 图解普利姆算法 package Prim; import java.util.Arrays; public class Prim { public static void main(String[] args) { //测试看看图是否创建ok char[] data = new char[]{'A','B','C','D','E','F','G'}; int verxs = data.length; //邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通 int [][]weight=new int[][]{ {10000,5,7,10000,10000,10000,2}, {5,10000,10000,9,10000,10000,3}, {7,10000,10000,10000,8,10000,10000}, {10000,9,10000,10000,10000,4,10000}, {10000,10000,8,10000,10000,5,4}, {10000,10000,10000,4,5,10000,6}, {2,3,10000,10000,4,6,10000}}; //创建MGraph对象 Graph graph = new Graph(verxs); //创建一个MinTree对象 MinTree minTree = new MinTree(); minTree.createGraph(graph, verxs, data, weight); //输出 minTree.showGraph(graph); //测试普利姆算法 minTree.prim(graph, 0); } } //创建最小生成树-&gt;村庄的图 class MinTree { //创建图的邻接矩阵 /** * @param graph 图对象 * @param vertex 图的顶点数 * @param data 图的各个顶点的值 * @param weight 图的邻接矩阵 */ public void createGraph(Graph graph, int vertex, char[] data, int[][] weight) { for (int i = 0; i &lt; vertex; i++) { graph.data[i] = data[i]; for (int j = 0; j &lt; vertex; j++) { graph.weight[i][j] = weight[i][j]; } } } //显示图的邻接矩阵 public void showGraph(Graph graph) { for (int[] link : graph.weight) { System.out.println(Arrays.toString(link)); } } //普利姆算法,得到最小生成树 /** * @param graph 图 * @param v 表示从图的第几个顶点开始生成'A'-&gt;0 'B'-&gt;1... */ public void prim(Graph graph, int v) { //visited[] 标记结点(顶点)是否被访问过 int[] visited = new int[graph.vertex]; //visited[] 默认元素的值都是0, 表示没有访问过 // for(int i =0; i &lt;graph.verxs; i++) { // visited[i] = 0; // } //把当前这个结点标记为已访问 visited[v] = 1; //h1 和 h2 记录两个顶点的下标 int h1 = -1; int h2 = -1; int minWeight = 10000;//将 minWeight 初始成一个大数，后面在遍历过程中，会被替换 for (int k = 1; k &lt; graph.vertex; k++) {//因为有 graph.vertex 顶点，普利姆算法结束后，有 graph.vertex-1边 //这个是确定每一次生成的子图 ，和哪个结点的距离最近 for (int i = 0; i &lt; graph.vertex; i++) {// i结点表示被访问过的结点 for (int j = 0; j &lt; graph.vertex; j++) {//j结点表示还没有访问过的结点 //无论是否访问过的结点都会被遍历 if (visited[i] == 1 &amp;&amp; visited[j] == 0 &amp;&amp; graph.weight[i][j] &lt; minWeight) { //替换minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边) minWeight = graph.weight[i][j]; h1 = i; h2 = j; } } } //找到一条边是最小 System.out.println(\"边&lt;\" + graph.data[h1] + \",\" + graph.data[h2] + \"&gt; 权值:\" + minWeight); //将当前这个结点标记为已经访问 visited[h2] = 1; //minWeight 重新设置为最大值 10000 minWeight = 10000; } } } //图 class Graph { int vertex;//表示图的节点个数 char[] data;//存放结点数据 int[][] weight;//存放边，就是我们的邻接矩阵 public Graph(int num) { this.vertex = num; data = new char[num]; weight = new int[num][num]; } } 克鲁斯卡尔算法 克鲁斯卡尔算法介绍 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 基本思想：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路 具体做法：首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止 应用场景-公交站问题 看一个应用场景和问题： 某城市新增 7 个站点(A, B, C, D, E, F, G) ，现在需要修路把 7 个站点连通 各个站点的距离用边线表示(权) ，比如 A – B 距离 12 公里 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短? 克鲁斯卡尔算法图解说明 以城市公交站问题来图解说明 克鲁斯卡尔算法的原理和步骤： 在含有 n 个顶点的连通图中选择 n-1 条边，构成一棵极小连通子图，并使该连通子图中 n-1 条边上权值之和达到最小，则称其为连通网的最小生成树。 例如，对于如上图 G4 所示的连通网可以有多棵权值总和不相同的生成树。 以上图 G4 为例，来对克鲁斯卡尔进行演示(假设，用数组 R 保存最小生成树结果)。 第 1 步：将边&lt;E,F&gt;加入 R 中。 边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果 R 中。 第 2 步：将边&lt;C,D&gt;加入 R 中。 上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果 R 中。 第 3 步：将边&lt;D,E&gt;加入 R 中。 上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果 R 中。 第 4 步：将边&lt;B,F&gt;加入 R 中。 上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果 R 中。 第 5 步：将边&lt;E,G&gt;加入 R 中。 上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果 R 中。 第 6 步：将边&lt;A,B&gt;加入 R 中。 上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果 R 中。 此时，最小生成树构造完成！它包括的边依次是：**&lt;E,F&gt;，&lt;C,D&gt;，&lt;D,E&gt;，&lt;B,F&gt;，&lt;E,G&gt;，&lt;A,B&gt;。** 克 鲁 斯 卡 尔 算 法 分 析 根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题： 问题一 对图的所有边按照权值大小进行排序。 问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。 问题一很好解决，采用排序算法进行排序即可。 问题二，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。 如 何 判 断 是 否 构 成 回 路 在将&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt;加入到最小生成树 R 中之后，这几条边的顶点就都有了终点： (01) C 的终点是 F。(02) D 的终点是 F。(03) E 的终点是 F。(04) F 的终点是 F。 关于终点的说明：（加入最小生成树后才有终点） 就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点“。 因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是 C 和 E 的终点都是 F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路。【后面有代码说明】 package Kruskal; import java.util.Arrays; public class KruskalCase { private int edgeNum;//边的个数 private char[] vertexs;//顶点数组 private int[][] matrix;//邻接矩阵 //使用 INF 表示两个顶点不能连通 private static final int INF = Integer.MAX_VALUE; public static void main(String[] args) { char[] vertexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'}; //克鲁斯卡尔算法的邻接矩阵 int matrix[][] = { /*A*//*B*//*C*//*D*//*E*//*F*//*G*/ /*A*/ { 0, 12, INF, INF, INF, 16, 14}, /*B*/ { 12, 0, 10, INF, INF, 7, INF}, /*C*/ { INF, 10, 0, 3, 5, 6, INF}, /*D*/ { INF, INF, 3, 0, 4, INF, INF}, /*E*/ { INF, INF, 5, 4, 0, 2, 8}, /*F*/ { 16, 7, 6, INF, 2, 0, 9}, /*G*/ { 14, INF, INF, INF, 8, 9, 0}}; KruskalCase kruskalCase = new KruskalCase(vertexs, matrix); kruskalCase.print(); kruskalCase.kruskal(); } public KruskalCase(char[] vertexs, int[][] matrix) { //初始化顶点数和边的个数 int vlen = vertexs.length; //初始化顶点, 复制拷贝的方式 this.vertexs = new char[vlen]; for (int i = 0; i &lt; vlen; i++) { this.vertexs[i] = vertexs[i]; } //也可以直接赋值 // this.vertexs = vertexs; //初始化边, 使用的是复制拷贝的方式 this.matrix = new int[vlen][vlen]; for(int i = 0; i &lt; vlen; i++) { for(int j= 0; j &lt; vlen; j++) { this.matrix[i][j] = matrix[i][j]; } } //统计边数 for (int i = 0; i &lt; vlen; i++) { for (int j = 1 + i; j &lt; vlen; j++) { if (this.matrix[i][j] != INF) { edgeNum++; } } } } public void kruskal() { int index = 0;//表示最后结果数组的索引 int[] ends = new int[edgeNum];//用于保存\"已有最小生成树\" 中的每个顶点在最小生成树中的终点 //创建结果数组, 保存最后的最小生成树 EData[] rets = new EData[edgeNum]; //获取图中 所有的边的集合 ， 一共有12边 EData[] edges = getEdges(); System.out.println(\"图的边的集合=\" + Arrays.toString(edges) + \" 共\"+ edges.length); //12 //按照边的权值大小进行排序(从小到大) sortEdges(edges); //遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入 for (int i = 0; i &lt; edges.length; i++) { //获取到第i条边的第一个顶点(起点) int p1 = getPosition(edges[i].start);//p1=4 //获取到第i条边的第2个顶点 int p2 = getPosition(edges[i].end);//p2 = 5 //获取p1这个顶点在已有最小生成树中的终点 int m = getEnd(ends, p1); //m = 4 //获取p2这个顶点在已有最小生成树中的终点 int n = getEnd(ends, p2); // n = 5 //是否构成回路 if (m != n) { //没有构成回路 ends[m] = n; // 设置m 在\"已有最小生成树\"中的终点 &lt;E,F&gt; [0,0,0,0,5,0,0,0,0,0,0,0] rets[index++] = edges[i];//有一条边加入到rets数组 } } //&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。 //统计并打印 \"最小生成树\", 输出 rets System.out.println(\"最小生成树为\"); for(int i = 0; i &lt; index; i++) { System.out.println(rets[i]); } } //打印邻接矩阵 public void print() { for (int i = 0; i &lt; vertexs.length; i++) { for (int j = 0; j &lt; vertexs.length; j++) { System.out.printf(\"%12d\", matrix[i][j]); } System.out.println(); } } /** * 功能：对边进行排序处理, 冒泡排序 * @param edges 边的集合 */ private void sortEdges(EData[] edges) { for (int i = 0; i &lt; edges.length-1; i++) { for (int j = 0; j &lt; edges.length - 1 - i; j++) { if (edges[j].weight &gt; edges[j + 1].weight) { EData temp = edges[j]; edges[j] = edges[j + 1]; edges[j + 1] = temp; } } } } /** * * @param ch 顶点的值，比如'A','B' * @return 返回ch顶点对应的下标，如果找不到，返回-1 */ private int getPosition(char ch) { for (int i = 0; i &lt; vertexs.length; i++) { if (vertexs[i] == ch) { return i; } } //找不到,返回-1 return -1; } /** * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组 * 是通过matrix 邻接矩阵来获取 * EData[] 形式 [['A','B', 12], ['B','F',7], .....] * @return EData[] 数组 */ public EData[] getEdges() { int index = 0; EData[] edges = new EData[edgeNum]; for (int i = 0; i &lt; vertexs.length; i++) { for (int j = i + 1; j &lt; vertexs.length; j++) { if (matrix[i][j] != INF) { edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]); } } } return edges; } /** * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同 * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成 * @param i : 表示传入的顶点对应的下标 * @return 返回的就是 下标为i 的这个顶点对应的终点的下标, 一会回头还有来理解 */ private int getEnd(int[] ends, int i) { // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0] while (ends[i] != 0) {//顶点有终点 i = ends[i]; } return i; } } //创建一个类EData ，它的对象实例就表示一条边 class EData { char start; //边的一个点 char end; //边的另外一个点 int weight; //边的权值 public EData(char start, char end, int weight) { this.start = start; this.end = end; this.weight = weight; } @Override public String toString() { return \"EData [&lt;\" + start + \", \" + end + \"&gt;= \" + weight + \"]\"; } } 迪杰斯特拉算法 迪杰斯特拉(Dijkstra)算法介绍 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 迪杰斯特拉(Dijkstra)算法过程 设置出发顶点为 v，顶点集合 V{v1,v2,vi…}，v 到 V 中各顶点的距离构成距离集合 Dis，Dis{d1,d2,di…}，Dis 集合记录着 v 到图中各顶点的距离(到自身可以看作 0，v 到 vi 距离对应为 di) 从 Dis 中选择值最小的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 v 到 vi 即为最短路径 更新 Dis 集合，更新规则为：比较 v 到 V 集合中顶点的距离值，与 v 通过 vi 到 V 集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束 迪杰斯特拉(Dijkstra)算法最佳应用-最短路径 战争时期，胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 问：如何计算出 G 村庄到 其它各个村庄的最短距离? 如果从其它点出发到各个点的最短距离又是多少? 使用图解的方式分析了迪杰斯特拉(Dijkstra)算法 思路 package Dijkstra; import java.util.Arrays; public class Dijkstra { public static void main(String[] args) { char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' }; //邻接矩阵 int[][] matrix = new int[vertex.length][vertex.length]; final int N = 65535;// 表示不可以连接 matrix[0]=new int[]{N,5,7,N,N,N,2}; matrix[1]=new int[]{5,N,N,9,N,N,3}; matrix[2]=new int[]{7,N,N,N,8,N,N}; matrix[3]=new int[]{N,9,N,N,N,4,N}; matrix[4]=new int[]{N,N,8,N,N,5,4}; matrix[5]=new int[]{N,N,N,4,5,N,6}; matrix[6]=new int[]{2,3,N,N,4,6,N}; //创建 Graph对象 Graph graph = new Graph(vertex, matrix); //测试, 看看图的邻接矩阵是否ok graph.showGraph(); graph.dsj(6); graph.showDijkstra(); } } class Graph { private int[][] matrix; // 邻接矩阵 private char[] vertex; // 顶点数组 private VisitedVertex vv; //已经访问的顶点的集合 public Graph(char[] vertex, int[][] matrix) { this.vertex = vertex; this.matrix = matrix; } public void showGraph() { for (int[] link : matrix) { System.out.println(Arrays.toString(link)); } } public void showDijkstra() { vv.show(); } //迪杰斯特拉算法实现 /** * * @param index 表示出发顶点对应的下标 */ public void dsj(int index) { vv = new VisitedVertex(vertex.length, index); update(index); for (int i = 1; i &lt; vertex.length; i++) { index = vv.updateArr(); // 选择并返回新的访问顶点 update(index);//更新index下标顶点到周围顶点的距离（从开始点的距离）和周围顶点的前驱顶点, } } //更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点, public void update(int index) { int len = 0; //根据遍历我们的邻接矩阵的 matrix[index]行 for (int i = 0; i &lt; matrix[index].length; i++) { // len 含义是 : 出发顶点到index顶点的距离 + 从index顶点到i顶点的距离的和 len = vv.getDis(index) + matrix[index][i]; // 如果j顶点没有被访问过，并且 len 小于出发顶点到i顶点的距离，就需要更新 if (!vv.in(i) &amp;&amp; len &lt; vv.getDis(i)) { vv.updateDis(i, len);//更新出发顶点到 i 顶点的距离 vv.updatePre(i, index);//更新 i 顶点的前驱为index顶点 } } } } // 已访问顶点集合 class VisitedVertex { // 记录各个顶点是否访问过 1表示访问过,0未访问,会动态更新 public int[] already_arr; // 每个下标对应的值为前一个顶点下标, 会动态更新 public int[] pre_visited; // 记录出发顶点到其他所有顶点的距离,比如G为出发顶点，就会记录G到其它顶点的距离，会动态更新，求的最短距离就会存放到dis public int[] dis; //构造器 /** * @param length :表示顶点的个数 * @param index: 出发顶点对应的下标, 比如G顶点，下标就是6 */ public VisitedVertex(int length, int index) { this.already_arr = new int[length]; this.dis = new int[length]; this.pre_visited = new int[length]; //初始化 dis数组 Arrays.fill(dis, 65535); this.already_arr[index] = 1; //设置出发顶点被访问过 this.dis[index] = 0; //设置出发顶点的访问距离为0 } /** * 功能: 判断index顶点是否被访问过 * * @param index * @return 如果访问过，就返回true, 否则访问false */ public boolean in(int index) { return already_arr[index] == 1; } /** * 功能: 更新出发顶点到index顶点的距离 * @param index * @param len */ public void updateDis(int index, int len) { dis[index] = len; } /** * 功能: 更新pre这个顶点的前驱顶点为index顶点 * @param pre * @param index */ public void updatePre(int pre, int index) { pre_visited[pre] = index; } /** * 功能:返回出发顶点到index顶点的距离 * @param index */ public int getDis(int index) { return dis[index]; } /** * 继续选择并返回新的访问顶点， 比如这里的G 完后，就是 A点作为新的访问顶点(注意不是出发顶点) * @return */ public int updateArr() { int min = 65535, index = 0; //找到可以到达的还未被访问的距离最近的顶点 i for (int i = 0; i &lt; already_arr.length; i++) { if (already_arr[i] == 0 &amp;&amp; dis[i] &lt; min) { min = dis[i]; index = i; } } //更新 index 顶点被访问过 already_arr[index] = 1; return index; } public void show() { for (int link : already_arr) { System.out.print(link+\" \"); } System.out.println(); for (int link : pre_visited) { System.out.print(link+\" \"); } System.out.println(); for (int link : dis) { System.out.print(link+\" \"); } System.out.println(); //为了好看最后的最短距离，我们处理 char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' }; int count = 0; for (int i : dis) { if (i != 65535) { System.out.print(vertex[count] + \"(\"+i+\") \"); } else { System.out.println(\"N \"); } count++; } } } 弗洛伊德算法 弗洛伊德(Floyd)算法介绍 和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。 弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。 弗洛伊德(Floyd)算法图解分析 设置顶点 vi 到顶点 vk 的最短路径已知为 Lik，顶点 vk 到 vj 的最短路径已知为 Lkj，顶点 vi 到 vj 的路径为 Lij， 则 vi 到 vj 的最短路径为：min((Lik+Lkj),Lij)，vk 的取值为图中所有顶点，则可获得 vi 到 vj 的最短路径 至于 vi 到 vk 的最短路径 Lik 或者 vk 到 vj 的最短路径 Lkj，是以同样的方式获得 弗洛伊德(Floyd)算法图解分析-举例说明 示例：求最短路径为例说明 弗洛伊德算法的步骤： 第一轮循环中，以 A(下标为：0)作为中间顶点【即把 A 作为中间顶点的所有情况都进行遍历, 就会得到更新距离表 和 前驱关系】， 距离表和前驱关系更新为： 分析如下： 以 A 顶点作为中间顶点是，B-&gt;A-&gt;C 的距离由 N-&gt;9，同理 C 到 B；C-&gt;A-&gt;G 的距离由 N-&gt;12，同理 G 到 C 更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束 弗洛伊德(Floyd)算法最佳应用-最短路径 胜利乡有 7 个村庄(A, B, C, D, E, F, G) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 问：如何计算出各村庄到 其它各村庄的最短距离? 代码实现 package Floyd; import java.util.Arrays; public class Floyd { public static void main(String[] args) { // 测试看看图是否创建成功 char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' }; //创建邻接矩阵 int[][] matrix = new int[vertex.length][vertex.length]; final int N = 65535; matrix[0] = new int[] { 0, 5, 7, N, N, N, 2 }; matrix[1] = new int[] { 5, 0, N, 9, N, N, 3 }; matrix[2] = new int[] { 7, N, 0, N, 8, N, N }; matrix[3] = new int[] { N, 9, N, 0, N, 4, N }; matrix[4] = new int[] { N, N, 8, N, 0, 5, 4 }; matrix[5] = new int[] { N, N, N, 4, 5, 0, 6 }; matrix[6] = new int[] { 2, 3, N, N, 4, 6, 0 }; //创建 Graph 对象 Graph graph = new Graph(vertex.length, matrix, vertex); graph.floyd(); graph.show(); } } class Graph { private char[] vertex;// 存放顶点的数组 private int[][] dis;// 保存，从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组 private int[][] pre;// 保存到达目标顶点的前驱顶点 // 构造器 /** * @param length 大小 * @param matrix 邻接矩阵 * @param vertex 顶点数组 */ public Graph(int length,int[][] matrix,char[] vertex) { this.vertex = vertex; this.pre = new int[length][length]; this.dis = matrix; // 对pre数组初始化, 注意存放的是前驱顶点的下标 for (int i = 0; i &lt; length; i++) { Arrays.fill(pre[i], i); } } // 显示pre数组和dis数组 public void show() { //为了显示便于阅读，我们优化一下输出 char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' }; for (int k = 0; k &lt; dis.length; k++) { for (int i = 0; i &lt; pre[k].length; i++) { System.out.print(vertex[pre[k][i]]); } System.out.println(); for (int i = 0; i &lt; dis[k].length; i++) { System.out.print(\"(\" + vertex[k] + \"到\" + vertex[i] + \"的最短路径是\" + dis[k][i] + \")\"); } System.out.println(); System.out.println(); } } //弗洛伊德算法, 比较容易理解，而且容易实现 public void floyd() { int len = 0;//变量保存距离 //对中间顶点遍历， k 就是中间顶点的下标 [A, B, C, D, E, F, G] for (int k = 0; k &lt; dis.length; k++) { //从i顶点开始出发 [A, B, C, D, E, F, G] for (int i = 0; i &lt; dis.length; i++) { //到达j顶点 // [A, B, C, D, E, F, G] for (int j = 0; j &lt; dis.length; j++) { len = dis[i][k] + dis[k][j];// =&gt; 求出从i 顶点出发，经过 k中间顶点，到达 j 顶点距离 if (len &lt; dis[i][j]) {//如果len小于 dis[i][j] dis[i][j] = len;//更新距离 pre[i][j] = pre[k][j];//更新前驱顶点 } } } } } } 马踏棋盘算法 马踏棋盘算法介绍和游戏演示 马踏棋盘算法也被称为骑士周游问题 将马随机放在国际象棋的 8×8 棋盘 Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部 64 个方格 游戏演示: http://www.4399.com/flash/146267_2.htm 马踏棋盘游戏代码实现 马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… ，思路分析+代码 实现  对第一种实现方式的思路图解 分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题. 使用前面的游戏来验证算法是否正确。 代码实现 package HorseChessboard; import java.awt.*; import java.util.ArrayList; import java.util.Comparator; public class HorseChessboard { public static int X;// 棋盘的列数 public static int Y;// 棋盘的行数 //创建一个数组，标记棋盘的各个位置是否被访问过 public static boolean[] visited; //使用一个属性，标记是否棋盘的所有位置都被访问 private static boolean finished; // 如果为true,表示成功 public static void main(String[] args) { System.out.println(\"骑士周游算法，开始运行~~\"); //测试骑士周游算法是否正确 X = 8; Y = 8; int row = 1; //马儿初始位置的行，从1开始编号 int column = 1; //马儿初始位置的列，从1开始编号 //创建棋盘 int[][] chessboard = new int[X][Y]; visited = new boolean[X * Y];//初始值都是false //测试一下耗时 long start = System.currentTimeMillis(); traversalChessboard(chessboard, row - 1, column - 1, 1); long end = System.currentTimeMillis(); System.out.println(\"共耗时: \" + (end - start) + \" 毫秒\"); //输出棋盘的最后情况 for(int[] rows : chessboard) { for(int step: rows) { System.out.print(step + \"\\t\"); } System.out.println(); } } /** * 完成骑士周游问题的算法 * @param chessboard 棋盘 * @param row 马儿当前的位置的行 从0开始 * @param column 马儿当前的位置的列 从0开始 * @param step 是第几步 ,初始位置就是第1步 */ public static void traversalChessboard(int[][] chessboard, int row, int column, int step) { chessboard[row][column] = step;//标记步数 //row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36 visited[row * X + column] = true;//标记该位置已经访问 //获取当前位置可以走的下一个位置的集合 ArrayList&lt;Point&gt; ps = next(new Point(column, row)); //对ps进行排序,排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序 sort(ps); while (!ps.isEmpty()) { Point p = ps.remove(0);//取出下一个可以走的位置 //判断该点是否已经访问过 if (!visited[p.y * X + p.x]) {//说明还没有访问过 traversalChessboard(chessboard, p.y, p.x, step + 1); } } //判断马儿是否完成了任务，使用 step 和应该走的步数比较 ， //如果没有达到数量，则表示没有完成任务，将整个棋盘置0 //说明: step &lt; X * Y 成立的情况有两种 //1. 棋盘到目前位置,仍然没有走完 //2. 棋盘处于一个回溯过程 if (step &lt; X * Y &amp;&amp; !finished) { chessboard[row][column] = 0; visited[row * X + column] = false; } else { finished = true; } } /** * 功能： 根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)，并放入到一个集合中(ArrayList), 最多有8个位置 * * @param curPoint 当前点 * @return 马儿在当前位置能走的所有点的集合 */ public static ArrayList&lt;Point&gt; next(Point curPoint) { //创建一个ArrayList ArrayList&lt;Point&gt; ps = new ArrayList&lt;Point&gt;(); //创建一个Point Point p1 = new Point(); //表示马儿可以走5这个位置 if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) { ps.add(new Point(p1)); } //判断马儿可以走6这个位置 if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) { ps.add(new Point(p1)); } //判断马儿可以走7这个位置 if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) { ps.add(new Point(p1)); } //判断马儿可以走0这个位置 if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) { ps.add(new Point(p1)); } //判断马儿可以走1这个位置 if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) { ps.add(new Point(p1)); } //判断马儿可以走2这个位置 if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) { ps.add(new Point(p1)); } //判断马儿可以走3这个位置 if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) { ps.add(new Point(p1)); } //判断马儿可以走4这个位置 if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) { ps.add(new Point(p1)); } return ps; } //根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数 public static void sort(ArrayList&lt;Point&gt; ps) { ps.sort(new Comparator&lt;Point&gt;() { @Override public int compare(Point o1, Point o2) { //获取到o1的下一步的所有位置个数 int count1 = next(o1).size(); //获取到o2的下一步的所有位置个数 int count2 = next(o2).size(); if (count1 &lt; count2) { return -1; } else if (count1 == count2) { return 0; } else { return 1; } } }); } }","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Hexo之渲染绕过","slug":"Hexo-xr","date":"2020-04-27T16:00:00.000Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"posts/17fd92ae.html","link":"","permalink":"https://gitee.com/td278121/posts/17fd92ae.html","excerpt":"","text":"0x001 Hexo 渲染 在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。因此对某个文件或者目录进行排除渲染是非常必要的。 0x002 方法一：font matterHexo新建网站页面，然后将你的代码直接写入 index.md 中 在 Front matter 中添加 layout: false，此方法适用于单一的纯HTMLCSS 页面。 --- title: tools date: 2020-04-28 00:00:00 type: \"tools\" layout: false --- 0x003 方法二：skip render在博客根目录下的 _config.yml，找到 skip_render，大概在32行左右，写入你想要的跳过渲染的路径，注意缩进和空格。 # 指定目录跳过hexo渲染 skip_render: - 'tools/*' - 'tools/**' 注释：tools/* 表示在目录 source/fireworks 下的文件全部跳过渲染，tools/** 表示在博客根目录 source/tools/ 文件夹下的文件全部跳过渲染（例如页面的 js、css 在另一个文件夹中）。 0x004 案例：webstack 导航webstack是一个纯静态的网址导航网站，内容均由viggo收集并整理。项目基于bootstrap前端框架开发。 Github：https://github.com/WebStackPage/WebStackPage.github.io 在博客根目录 source/下新建tools，然后新建index.html,将webstack网页源码全选复制粘贴到里面。 本站的webstack源码：view-source:http://luckyzmj.cn/tools/ 注意：将源码里的部分信息以及跳转链接按照你真实个人博客的环境进行修改。 然后打开博客根目录下配置文件_config.yml，找到skip_render，做如下修改： skip_render: - 'tools/*' - 'tools/**' 最后执行hexo clean和hexo s -g 本地预览，检查无误后hexo g -d部署到服务器上即可。 参考文章 https://xiabor.com/2020/04/21/hexo3/#%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87hexo%E7%9A%84%E6%B8%B2%E6%9F%93","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://gitee.com/td278121/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://gitee.com/td278121/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"https://gitee.com/td278121/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"}],"author":"luckyzmj"}],"categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://gitee.com/td278121/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Hexo","slug":"Hexo","permalink":"https://gitee.com/td278121/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"https://gitee.com/td278121/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"}]}