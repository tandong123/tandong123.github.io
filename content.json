{"meta":{"title":"TD","subtitle":"TDの博客","description":"湖南应用技术学院 | 软件技术专业 | 软件开发","author":"TD","url":"https://gitee.com/td278121","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"https://gitee.com/td278121/404.html","excerpt":"","text":""},{"title":"","date":"2021-09-14T05:00:02.323Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://gitee.com/td278121/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"https://gitee.com/td278121/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2021-09-14T05:00:24.099Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://gitee.com/td278121/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"about/index.html","permalink":"https://gitee.com/td278121/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"archives/index.html","permalink":"https://gitee.com/td278121/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"census/index.html","permalink":"https://gitee.com/td278121/census/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"categories/index.html","permalink":"https://gitee.com/td278121/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"contact/index.html","permalink":"https://gitee.com/td278121/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"friends/index.html","permalink":"https://gitee.com/td278121/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"https://gitee.com/td278121/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"tags/index.html","permalink":"https://gitee.com/td278121/tags/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"https://gitee.com/td278121/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-05-03T05:27:07.212Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/index.html","permalink":"https://gitee.com/td278121/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"https://gitee.com/td278121/List/movies/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-05-03T05:27:07.213Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://gitee.com/td278121/List/tools/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-05-03T05:27:07.214Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-05-03T05:27:07.214Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-05-03T05:27:07.213Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-05-03T05:27:07.214Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-05-03T05:27:07.216Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-05-03T05:27:07.215Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-05-03T05:27:07.217Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-05-03T05:27:07.216Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-05-03T05:27:07.217Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-05-03T05:27:07.218Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-05-03T05:27:07.218Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://gitee.com/td278121/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Linux基础","date":"2021-09-14T08:27:38.570Z","updated":"2021-09-14T08:27:38.738Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"入门概述 我们为什么要学习Linux linux诞生了这么多年，以前还喊着如何能取代windows系统，现在这个口号已经小多了，任何事物发展都有其局限性都有其天花板。就如同在国内再搞一个社交软件取代腾讯一样，想想而已基本不可能，因为用户已经习惯于使用微信交流，不是说技术上实现不了解而是老百姓已经习惯了，想让他们不用，即使他们自己不用亲戚朋友还是要用，没有办法的事情。 用习惯了windows操作系统，再让大家切换到别的操作系统基本上是不可能的事情，改变一个人已经养成的习惯太难。没有办法深入到普通老百姓的生活中，并不意味着linux就没有用武之地了。在服务器端，在开发领域linux倒是越来越受欢迎，很多程序员都觉得不懂点linux都觉得不好意思，linux在开源社区的地位依然岿然不动。 尤其是作为一个后端程序员，是必须要掌握Linux的，因为这都成为了你找工作的基础门槛了，所以不得不学习！ Linux 简介 Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux 发行版 Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。 Linux 应用领域 今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。 目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。 巴西联邦政府由于支持 Linux 而世界闻名。 有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。 印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。 中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。 在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。 葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。 法国和德国同样开始逐步采用 Linux。 Linux vs Windows 环境搭建Linux 的安装，安装步骤比较繁琐，现在其实云服务器挺普遍的，价格也便宜，如果直接不想搭建，也可以直接买一台学习用用！ 安装CentOS（虚拟机安装，耗资源） 1、可以通过镜像进行安装！ 2、可以使用我已经制作好的镜像！视频中讲解了该种方式！ 3、安装 VMware 虚拟机软件，然后打开我们的镜像即可使用！ 购买云服务器（推荐） 虚拟机安装后占用空间，也会有些卡顿，我们作为程序员其实可以选择购买一台自己的服务器，这样的话更加接近真实线上工作； 1、阿里云购买服务器：https://www.aliyun.com/minisite/goods?userCode=0phtycgr 2、购买完毕后，获取服务器的ip地址，重置服务器密码，就可以远程登录了 3、下载 xShell 工具，进行远程连接使用！连接成功效果如下： 注意事项： 如果要打开端口，需要在阿里云的安全组面板中开启对应的出入规则，不然的话会被阿里拦截！ 如果前期不好操作，可以推荐安装宝塔面板，傻瓜式管理服务器 安装教程：https://www.bt.cn/bbs/thread-19376-1-1.html 1、开启对应的端口 2、一键安装 3、安装完毕后会得到远程面板的地址，账号，密码，就可以登录了 4、登录之后就可以可视化的安装环境和部署网站！ 关于域名 如果自己的网站想要上线，就一定要购买一个域名然后进行备案； 备案的话需要一些认证和时间，备完完毕后，就可以解析到自己的网站了，这个时候就可以使用域名来进行服务器的访问！ 走近Linux系统 开机登录 开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。 开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！ 一般来说，用户的登录方式有三种： 命令行登录 ssh登录 图形界面登录 最高权限账户为 root，可以操作一切！ 关机 在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。 关机指令为：shutdown ； sync # 将数据由内存同步到硬盘中。shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机shutdown –h now # 立马关机shutdown –h 20:25 # 系统会在今天20:25关机shutdown –h +10 # 十分钟后关机shutdown –r now # 系统立马重启shutdown –r +10 # 系统十分钟后重启reboot # 就是重启，等同于 shutdown –r nowhalt # 关闭系统，等同于shutdown –h now 和 poweroff 最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。 系统目录结构 登录系统后，在当前命令窗口下输入命令： ls / 你会看到如下图所示： 树状目录结构：（Linux的一切资源都挂载在这个 / 根节点下） 以下是对这些目录的解释： /bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 /tmp：这个目录是用来存放一些临时文件的。 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin： 系统用户使用的应用程序。 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src： 内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。 目录管理 绝对路径和相对路径 我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。 其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。 在开始本教程前我们需要先知道什么是绝对路径与相对路径。 绝对路径： 路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。 相对路径： 路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！ 处理目录的常用命令 接下来我们就来看几个常见的处理目录的命令吧： ls: 列出目录 cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称 你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。 ls （列出目录） 在Linux系统当中， ls 命令可能是最常被运行的。 语法： [root@www ~]# ls [-aAdfFhilnrRSt] 目录名称 选项与参数： -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 将目录下的所有文件列出来(含属性与隐藏档) [root@www ~]# ls -al ~ cd （切换目录） cd是Change Directory的缩写，这是用来变换工作目录的命令。 语法： cd [相对路径或绝对路径] 测试： # 切换到用户目录下[root@kuangshen /]# cd home # 使用 mkdir 命令创建 kuangstudy 目录[root@kuangshen home]# mkdir kuangstudy# 进入 kuangstudy 目录[root@kuangshen home]# cd kuangstudy# 回到上一级[root@kuangshen kuangstudy]# cd ..# 回到根目录[root@kuangshen kuangstudy]# cd /# 表示回到自己的家目录，亦即是 /root 这个目录[root@kuangshen kuangstudy]# cd ~ 接下来大家多操作几次应该就可以很好的理解 cd 命令的。 pwd ( 显示目前所在的目录 ) pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。 [root@kuangshen kuangstudy]#pwd [-P] 选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。 测试： # 单纯显示出目前的工作目录[root@kuangshen ~]# pwd/root# 如果是链接，要显示真实地址，可以使用 -P参数[root@kuangshen /]# cd bin[root@kuangshen bin]# pwd -P/usr/bin mkdir （创建新目录） 如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。 mkdir [-mp] 目录名称 选项与参数： -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ 测试： # 进入我们用户目录下[root@kuangshen /]# cd /home# 创建一个 test 文件夹[root@kuangshen home]# mkdir test# 创建多层级目录[root@kuangshen home]# mkdir test1/test2/test3/test4mkdir: cannot create directory ‘test1/test2/test3/test4’:No such file or directory # &lt;== 没办法直接创建此目录啊！# 加了这个 -p 的选项，可以自行帮你创建多层目录！[root@kuangshen home]# mkdir -p test1/test2/test3/test4# 创建权限为 rwx--x--x 的目录。[root@kuangshen home]# mkdir -m 711 test2[root@kuangshen home]# ls -ldrwxr-xr-x 2 root root 4096 Mar 12 21:55 testdrwxr-xr-x 3 root root 4096 Mar 12 21:56 test1drwx--x--x 2 root root 4096 Mar 12 21:58 test2 rmdir ( 删除空的目录 ) 语法： rmdir [-p] 目录名称 选项与参数：**-p ：**连同上一级『空的』目录也一起删除 测试： # 看看有多少目录存在？[root@kuangshen home]# ls -ldrwxr-xr-x 2 root root 4096 Mar 12 21:55 testdrwxr-xr-x 3 root root 4096 Mar 12 21:56 test1drwx--x--x 2 root root 4096 Mar 12 21:58 test2# 可直接删除掉，没问题[root@kuangshen home]# rmdir test# 因为尚有内容，所以无法删除！[root@kuangshen home]# rmdir test1rmdir: failed to remove ‘test1’: Directory not empty# 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。[root@kuangshen home]# rmdir -p test1/test2/test3/test4 注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录，后面我们会将！ cp ( 复制文件或目录 ) 语法： [root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory 选项与参数： -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -r：递归持续复制，用於目录的复制行为；(常用) -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。 -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ 测试： # 找一个有文件的目录，我这里找到 root目录[root@kuangshen home]# cd /root[root@kuangshen ~]# lsinstall.sh[root@kuangshen ~]# cd /home# 复制 root目录下的install.sh 到 home目录下[root@kuangshen home]# cp /root/install.sh /home[root@kuangshen home]# lsinstall.sh# 再次复制，加上-i参数，增加覆盖询问？[root@kuangshen home]# cp -i /root/install.sh /homecp: overwrite ‘/home/install.sh’? y # n不覆盖，y为覆盖 rm ( 移除文件或目录 ) 语法： rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ 测试： # 将刚刚在 cp 的实例中创建的 install.sh删除掉！[root@kuangshen home]# rm -i install.shrm: remove regular file ‘install.sh’? y# 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！# 尽量不要在服务器上使用 rm -rf / mv ( 移动文件与目录，或修改名称 ) 语法： [root@www ~]# mv [-fiu] source destination[root@www ~]# mv [options] source1 source2 source3 .... directory 选项与参数： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 测试： # 复制一个文件到当前目录[root@kuangshen home]# cp /root/install.sh /home# 创建一个文件夹 test[root@kuangshen home]# mkdir test# 将复制过来的文件移动到我们创建的目录，并查看[root@kuangshen home]# mv install.sh test[root@kuangshen home]# lstest[root@kuangshen home]# cd test[root@kuangshen test]# lsinstall.sh# 将文件夹重命名，然后再次查看！[root@kuangshen test]# cd ..[root@kuangshen home]# mv test mvtest[root@kuangshen home]# lsmvtest 基本属性 看懂文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： 实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档 ( link file )； 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图）： 从左至右用0-9这些数字来表示。 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中： 第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限； 第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限； 第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。 修改文件属性 1、chgrp：更改文件属组 chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 2、chown：更改文件属主，也可以同时更改文件属组 chown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名 3、chmod：更改文件9个属性 chmod [-R] xyz 文件或目录 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 chmod 770 filename 可以自己下去多进行测试！ 文件内容查看 概述 Linux系统中使用以下命令来查看文件的内容： cat 由第一行开始显示文件内容 》 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。 cat 由第一行开始显示文件内容 语法： cat [-AbEnTv] 选项与参数： -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 测试： # 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/[root@kuangshen ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0BOOTPROTO=dhcpONBOOT=yes tac tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如： [root@kuangshen ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0ONBOOT=yesBOOTPROTO=dhcpDEVICE=eth0 nl 显示行号 语法： nl [-bnw] 文件 选项与参数： -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 测试： [root@kuangshen ~]# nl /etc/sysconfig/network-scripts/ifcfg-eth01DEVICE=eth02BOOTPROTO=dhcp3ONBOOT=yes more 一页一页翻动 在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 [root@kuangshen etc]# more /etc/csh.login....(中间省略)....--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令 less 一页一页翻动，以下实例输出/etc/man.config文件的内容： less运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序； [root@kuangshen etc]# more /etc/csh.login....(中间省略)....: # 这里可以等待你输入命令！ head 取出文件前面几行 语法： head [-n number] 文件 选项与参数：**-n** 后面接数字，代表显示几行的意思！ 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样： [root@kuangshen etc]# head -n 20 /etc/csh.login tail 取出文件后面几行 语法： tail [-n number] 文件 选项与参数： -n ：后面接数字，代表显示几行的意思 默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样： [root@kuangshen etc]# tail -n 20 /etc/csh.login 拓展：Linux 链接概念 Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。 情况下，ln 命令产生硬链接。 硬连接 硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 软连接 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 测试： [root@kuangshen /]# cd /home[root@kuangshen home]# touch f1 # 创建一个测试文件f1[root@kuangshen home]# lsf1[root@kuangshen home]# ln f1 f2 # 创建f1的一个硬连接文件f2[root@kuangshen home]# ln -s f1 f3 # 创建f1的一个符号连接文件f3[root@kuangshen home]# ls -li # -i参数显示文件的inode节点信息397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f1397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f2397248 lrwxrwxrwx 1 root root 2 Mar 13 00:50 f3 -&gt; f1 从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。 # echo 字符串输出 &gt;&gt; f1 输出到 f1文件[root@kuangshen home]# echo \"I am f1 file\" &gt;&gt;f1[root@kuangshen home]# cat f1I am f1 file[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3I am f1 file[root@kuangshen home]# rm -f f1[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3cat: f3: No such file or directory 通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效； 依此您可以做一些相关的测试，可以得到以下全部结论： 删除符号连接f3,对f1,f2无影响； 删除硬连接f2，对f1,f3也无影响； 删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 同时删除原文件f1,硬连接f2，整个文件会真正的被删除。 什么是Vim编辑器 Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。 vim 键盘图： 三种使用模式 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。这三种模式的作用分别是： 命令模式： 用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式： 在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 简单的说，我们可以将这三个模式想成底下的图标来表示： 上手体验一下，在home目录下测试 如果你想要使用 vi 来建立一个名为 kuangstudy.txt 的文件时，你可以这样做： [root@kuangshen home]# vim kuangstudy.txt 然后就会进入文件 按下 i 进入输入模式(也称为编辑模式)，开始编辑文字 在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！ 在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。 这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。 按下 ESC 按钮回到一般模式 好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！ 在一般模式中按下 :wq 储存后离开 vim！ OK! 这样我们就成功创建了一个 kuangstudy.txt 的文件。 Vim 按键说明 除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n&lt; space&gt; 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！(常用) n&lt; Enter&gt; n 为数字。光标向下移动 n 行(常用) 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 删除、复制与粘贴 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 第二部分：一般模式切换到编辑模式的可用的按钮说明 进入输入或取代的编辑模式 i, I 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用) a, A 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) o, O 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用) r, R 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) [Esc] 退出编辑模式，回到一般模式中(常用) 第三部分：一般模式切换到指令行模式的可用的按钮说明 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！ :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ 账号管理 简介 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个唯一的用户名和各自的口令。 用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 用户账号的管理 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。 添加账号 useradd useradd 选项 用户名 参数说明： 选项 : -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -m 使用者目录如不存在则自动建立。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名 : 指定新账号的登录名。 测试： # 此命令创建了一个用户kuangshen，其中-m选项用来为登录名kuangshen产生一个主目录 /home/kuangshen[root@kuangshen home]# useradd -m kuangshen 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。 Linux下如何切换用户 1.切换用户的命令为：su username 【username是你的用户名哦】 2.从普通用户切换到root用户，还可以使用命令：sudo su 3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令 4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】 $表示普通用户 #表示超级用户，也就是root用户 删除帐号 如果一个用户的账号不再使用，可以从系统中删除。 删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。 删除一个已有的用户账号使用userdel命令，其格式如下： userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 [root@kuangshen home]# userdel -r kuangshen 此命令删除用户kuangshen在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 修改帐号 修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 修改已有用户的信息使用usermod命令，其格式如下： usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 例如： # usermod -s /bin/ksh -d /home/z –g developer kuangshen 此命令将用户kuangshen的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。 用户口令的管理 用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。 命令的格式为： passwd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 如果默认用户名，则修改当前用户的口令。 例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令： $ passwdOld password:******New password:*******Re-enter new password:******* 如果是超级用户，可以用下列形式指定任何用户的口令： # passwd kuangshenNew password:*******Re-enter new password:******* 普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。 为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。 为用户指定空口令时，执行下列形式的命令： # passwd -d kuangshen 此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。 passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如： # passwd -l kuangshen 用户组管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 增加一个新的用户组使用groupadd命令 groupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 实例1： # groupadd group1 此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。 实例2： # groupadd -g 101 group2 此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。 如果要删除一个已有的用户组，使用groupdel命令 groupdel 用户组 例如： # groupdel group1 此命令从系统中删除组group1。 修改用户组的属性使用groupmod命令 groupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 # 此命令将组group2的组标识号修改为102。groupmod -g 102 group2# 将组group2的标识号改为10000，组名修改为group3。groupmod –g 10000 -n group3 group2 切换组 如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如： $ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。 /etc/passwd 完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。 下面分别介绍这些文件的内容。 /etc/passwd文件是用户管理工作涉及的最重要的一个文件。 Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。 这个文件对所有用户都是可读的。它的内容类似下面的例子： ＃ cat /etc/passwdroot:x:0:0:Superuser:/:daemon:x:1:1:System daemons:/etc:bin:x:2:2:Owner of system commands:/bin:sys:x:3:3:Owner of system files:/usr/sys:adm:x:4:4:System accounting:/usr/adm:uucp:x:5:5:UUCP administrator:/usr/lib/uucp:auth:x:7:21:Authentication administrator:/tcb/files/auth:cron:x:9:16:Cron daemon:/usr/spool/cron:listen:x:37:4:Network daemon:/usr/net/nls:lp:x:71:18:Printer administrator:/usr/spool/lp: 从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 1）”用户名”是代表用户账号的字符串。 通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。 为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。 2）“口令”一些系统中，存放着加密后的用户口令字。 虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。 3）“用户标识号”是一个整数，系统内部用它来标识用户。 一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。 通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。 4）“组标识号”字段记录的是用户所属的用户组。 它对应着/etc/group文件中的一条记录。 5)“注释性描述”字段记录着用户的一些个人情况。 例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。 6)“主目录”，也就是用户的起始工作目录。 它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。 7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。 Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。 系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。 用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。 利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。 8)系统中有一类用户称为伪用户（pseudo users）。 这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。 常见的伪用户如下所示： 伪 用 户 含 义bin 拥有可执行的用户命令文件sys 拥有系统文件adm 拥有帐户文件uucp UUCP使用lp lp或lpd子系统使用nobody NFS使用 /etc/shadow 1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。 由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。 2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生 它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是： 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 “登录名”是与/etc/passwd文件中的登录名相一致的用户账号 “口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。 “最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。 “最小时间间隔”指的是两次修改口令之间所需的最小天数。 “最大时间间隔”指的是口令保持有效的最大天数。 “警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。 “不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。 “失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。 /etc/group 用户组的所有信息都存放在/etc/group文件中。 将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。 每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。 当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。 用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。 用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 组名:口令:组标识号:组内用户列表 “组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 “口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。 “组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。 “组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 磁盘管理 概述 Linux磁盘管理好坏直接关系到整个系统的性能问题。 Linux磁盘管理常用命令为 df、du。 df ：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 df df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 语法： df [-ahikHTm] [目录或文件名] 选项与参数： -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； -k ：以 KBytes 的容量显示各文件系统； -m ：以 MBytes 的容量显示各文件系统； -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -H ：以 M=1000K 取代 M=1024K 的进位方式； -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出； -i ：不用硬盘容量，而以 inode 的数量来显示 测试： # 将系统内所有的文件系统列出来！# 在 Linux 底下如果 df 没有加任何选项# 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！[root@kuangshen /]# dfFilesystem 1K-blocks Used Available Use% Mounted ondevtmpfs 889100 0 889100 0% /devtmpfs 899460 704 898756 1% /dev/shmtmpfs 899460 496 898964 1% /runtmpfs 899460 0 899460 0% /sys/fs/cgroup/dev/vda1 41152812 6586736 32662368 17% /tmpfs 179896 0 179896 0% /run/user/0 # 将容量结果以易读的容量格式显示出来[root@kuangshen /]# df -hFilesystem Size Used Avail Use% Mounted ondevtmpfs 869M 0 869M 0% /devtmpfs 879M 708K 878M 1% /dev/shmtmpfs 879M 496K 878M 1% /runtmpfs 879M 0 879M 0% /sys/fs/cgroup/dev/vda1 40G 6.3G 32G 17% /tmpfs 176M 0 176M 0% /run/user/0 # 将系统内的所有特殊文件格式及名称都列出来[root@kuangshen /]# df -aTFilesystem Type 1K-blocks Used Available Use% Mounted onsysfs sysfs 0 0 0 - /sysproc proc 0 0 0 - /procdevtmpfs devtmpfs 889100 0 889100 0% /devsecurityfs securityfs 0 0 0 - /sys/kernel/securitytmpfs tmpfs 899460 708 898752 1% /dev/shmdevpts devpts 0 0 0 - /dev/ptstmpfs tmpfs 899460 496 898964 1% /runtmpfs tmpfs 899460 0 899460 0% /sys/fs/cgroupcgroup cgroup 0 0 0 - /sys/fs/cgroup/systemdpstore pstore 0 0 0 - /sys/fs/pstorecgroup cgroup 0 0 0 - /sys/fs/cgroup/freezercgroup cgroup 0 0 0 - /sys/fs/cgroup/cpusetcgroup cgroup 0 0 0 - /sys/fs/cgroup/hugetlbcgroup cgroup 0 0 0 - /sys/fs/cgroup/blkiocgroup cgroup 0 0 0 - /sys/fs/cgroup/net_cls,net_priocgroup cgroup 0 0 0 - /sys/fs/cgroup/memorycgroup cgroup 0 0 0 - /sys/fs/cgroup/pidscgroup cgroup 0 0 0 - /sys/fs/cgroup/cpu,cpuacctcgroup cgroup 0 0 0 - /sys/fs/cgroup/devicescgroup cgroup 0 0 0 - /sys/fs/cgroup/perf_eventconfigfs configfs 0 0 0 - /sys/kernel/config/dev/vda1 ext4 41152812 6586748 32662356 17% /systemd-1 - - - - - /proc/sys/fs/binfmt_miscmqueue mqueue 0 0 0 - /dev/mqueuedebugfs debugfs 0 0 0 - /sys/kernel/debughugetlbfs hugetlbfs 0 0 0 - /dev/hugepagestmpfs tmpfs 179896 0 179896 0% /run/user/0binfmt_misc binfmt_misc 0 0 0 - /proc/sys/fs/binfmt_misc # 将 /etc 底下的可用的磁盘容量以易读的容量格式显示[root@kuangshen /]# df -h /etcFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 6.3G 32G 17% / du Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。 语法： du [-ahskm] 文件或目录名称 选项与参数： -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； 测试： # 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:# 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。[root@kuangshen home]# du16./redis8./www/.oracle_jre_usage # 包括隐藏文件的目录24./www48. # 这个目录(.)所占用的总量 # 将文件的容量也列出来[root@kuangshen home]# du -a4./redis/.bash_profile4./redis/.bash_logout ....中间省略....4./kuangstudy.txt # 有文件的列表了48. # 检查根目录底下每个目录所占用的容量[root@kuangshen home]# du -sm /*0/bin146/boot.....中间省略....0/proc.....中间省略....1/tmp3026/usr # 系统初期最大就是他了啦！513/var2666/www 通配符 * 来代表每个目录。 与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。 磁盘挂载与卸除 根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载” Linux 的磁盘挂载使用mount命令，卸载使用umount命令。 磁盘挂载语法： mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 测试： # 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！[root@www ~]# mkdir /mnt/hdc6[root@www ~]# mount /dev/hdc6 /mnt/hdc6[root@www ~]# dfFilesystem 1K-blocks Used Available Use% Mounted on/dev/hdc6 1976312 42072 1833836 3% /mnt/hdc6 磁盘卸载命令 umount 语法： umount [-fn] 装置文件名或挂载点 选项与参数： -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -n ：不升级 /etc/mtab 情况下卸除。 卸载/dev/hdc6 [root@www ~]# umount /dev/hdc6 jdk安装（rpm安装）1、rpm下载地址http://www.oracle.com/technetwork/java/javase/downloads/index.html 2、如果有安装openjdk 则卸载 [root@kuangshen ~]# java -versionjava version \"1.8.0_121\"Java(TM) SE Runtime Environment (build 1.8.0_121-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)# 检查[root@kuangshen ~]# rpm -qa|grep jdkjdk1.8.0_121-1.8.0_121-fcs.x86_64# 卸载 -e --nodeps 强制删除[root@kuangshen ~]# rpm -e --nodeps jdk1.8.0_121-1.8.0_121-fcs.x86_64[root@kuangshen ~]# java -version-bash: /usr/bin/java: No such file or directory # OK 3、安装JDK # 安装java rpm[root@kuangshen kuangshen]# rpm -ivh jdk-8u221-linux-x64.rpm# 安装完成后配置环境变量 文件：/etc/profileJAVA_HOME=/usr/java/jdk1.8.0_221-amd64CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/libPATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/binexport PATH CLASSPATH JAVA_HOME# 保存退出# 让新增的环境变量生效！source /etc/profile# 测试 java -version[root@kuangshen java]# java -versionjava version \"1.8.0_221\"Java(TM) SE Runtime Environment (build 1.8.0_221-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) Tomcat安装（解压缩安装）1、安装好了Java环境后我们可以测试下Tomcat！准备好Tomcat的安装包！ 2、将文件移动到/usr/tomcat/下，并解压！ [root@kuangshen kuangshen]# mv apache-tomcat-9.0.22.tar.gz /usr[root@kuangshen kuangshen]# cd /usr[root@kuangshen usr]# lsapache-tomcat-9.0.22.tar.gz[root@kuangshen usr]# tar -zxvf apache-tomcat-9.0.22.tar.gz # 解压 3、运行Tomcat，进入bin目录，和我们以前在Windows下看的都是一样的 # 执行：startup.sh --&gt;启动tomcat# 执行：shutdown.sh --&gt;关闭tomcat./startup.sh./shutdown.sh 4、确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！ # 查看firewall服务状态systemctl status firewalld# 开启、重启、关闭、firewalld.service服务# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all # 查看全部信息firewall-cmd --list-ports # 只看端口信息# 开启端口开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent重启防火墙：systemctl restart firewalld.service命令含义：--zone #作用域--add-port=80/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效 安装Docker（yum安装） 基于 CentOS 7 安装 官网安装参考手册：https://docs.docker.com/install/linux/docker-ce/centos/ 确定你是CentOS7及以上版本 [root@192 Desktop]# cat /etc/redhat-releaseCentOS Linux release 7.2.1511 (Core) yum安装gcc相关（需要确保 虚拟机可以上外网 ） yum -y install gccyum -y install gcc-c++ 卸载旧版本 yum -y remove docker docker-common docker-selinux docker-engine# 官网版本yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装需要的软件包 yum install -y yum-utils device-mapper-persistent-data lvm2 设置stable镜像仓库 # 错误yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo## 报错[Errno 14] curl#35 - TCP connection reset by peer[Errno 12] curl#35 - Timeout# 正确推荐使用国内的yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新yum软件包索引 yum makecache fast 安装Docker CE yum -y install docker-ce docker-ce-cli containerd.io 启动docker systemctl start docker 测试 docker versiondocker run hello-worlddocker images 宝塔面板安装https://www.bilibili.com/video/av91821322","categories":[],"tags":[]},{"title":"","slug":"Java数据结构和算法","date":"2021-09-14T08:24:06.547Z","updated":"2021-09-14T08:24:06.821Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"数据结构和算法的关系 数据 data 结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以编写出更加漂亮,更加有效率的代码。 要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决. 3) 程序 = 数据结构 + 算法 数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。 数据结构包括：线性结构和非线性结构。 线性结构 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系 线性结构有两种不同的存储结构，即**顺序存储结构数组)和链式存储结构(链表)**。顺序存储的线性表称为顺序 表，顺序表中的存储元素是连续的 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地 址信息 线性结构常见的有：数组、队列、链表和栈，后面我们会详细讲解 非线性结构 非线性结构包括：二维数组，多维数组，广义表，树结构，图结构 稀疏 sparsearray 数组 基本介绍 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方法是: 记录数组一共有几行几列，有多少个不同的值 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模 第一行数组表示整个二维数组有6行7列，共有8个数据 应用实例 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等) 把稀疏数组存盘，并且可以从新恢复原来的二维数组数 整体思路分析 package sparseArray; public class SparseArray { public static void main(String[] args) { //创建一个二维数组 // 0: 表示没有棋子， 1 表示 黑子 2 表蓝子 int[][] ChessArray1 = new int[11][11]; ChessArray1[2][1] = 1; ChessArray1[3][2] = 2; //输出原数组 System.out.println(\"原始的二维数组~~~~\"); for (int[] row : ChessArray1) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); } //将二维数组 转为 稀疏数组 //先遍历二维数组 int sum =0; //统计原数组里面的数据个数 for (int i = 0; i &lt; 11; i++) { for (int j = 0; j &lt; 11; j++) { if (ChessArray1[i][j] != 0) { sum++; } } } //创建稀疏数组 int[][] sparseArray = new int[sum + 1][3]; //给稀疏数组赋值,第一行存放原二维数组的数据 sparseArray[0][0] = 11; sparseArray[0][1] = 11; sparseArray[0][2] = sum; //遍历二维数组，将非0 的数赋值给稀疏数组 int count = 0; //用于记录第几个非0 数据 for (int i = 0; i &lt; 11; i++) { for (int j = 0; j &lt; 11; j++) { if (ChessArray1[i][j] != 0) { count++; sparseArray[count][0] = i; //存放行索引 sparseArray[count][1] = j; //存放列索引 sparseArray[count][2] = ChessArray1[i][j]; //存放数值 } } } //输出稀疏数组 System.out.println(\"稀疏数组为~~~~\"); for (int[] row : sparseArray) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); } //将稀疏数组 转为 原二维数组 //1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 int[][] ChessArray2 = new int[sparseArray[0][0]][sparseArray[0][1]]; //2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可 for (int i = 1; i &lt; sparseArray.length; i++) { ChessArray2[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2]; } //输出转换后的原二维数组 System.out.println(\"转换后的原二维数组为~~~~\"); for (int[] row : ChessArray2) { for (int data : row) { System.out.printf(\"%d\\t\",data); } System.out.println(); } } } 队列 队列是一个有序列表，可以用数组或是链表来实现。 遵循先入先出的原则。即：**先存入队列的数据，要先取出。后存入的要后取出 ** 示意图：(使用数组模拟队列示意图) 数组模拟队列 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。  因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变，如图所示:  当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析 将尾指针往后移：rear+1 , 当 front == rear 【空】 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。 rear == maxSize - 1[队列满] package Array.ArrayQueue; import java.util.Scanner; public class arrayQueuedemo { public static void main(String[] args) { ArrayQueue queue = new ArrayQueue(3); boolean loop = true; char key;//接收用户输入 Scanner scanner = new Scanner(System.in); //输出一个菜单 while (loop) { System.out.println(\"s(show): 显示队列\"); System.out.println(\"e(exit): 退出程序\"); System.out.println(\"a(add): 添加数据到队列\"); System.out.println(\"g(get): 从队列取出数据\"); System.out.println(\"h(head): 查看队列头的数据\"); key = scanner.next().charAt(0); switch (key) { case 's': queue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': try { queue.addQueue(scanner.nextInt()); } catch (Exception e) { System.out.println(e.getMessage()); } break; case 'g'://取出数据 try { int head = queue.getQueue(); System.out.println(\"出列的数据为\" + head); } catch (Exception e) { System.out.println(e.getMessage()); } break; case 'h'://查看队列头的数据 try { int head = queue.headQueue(); System.out.printf(\"队列的头部数据为%d\\n\", head); } catch (Exception e) { System.out.println(e.getMessage()); } } } System.out.println(\"程序退出\"); } } // 使用数组模拟队列-编写一个 ArrayQueue 类 class ArrayQueue { private int maxSize; //队列的最大容量 private int head;//队列头 private int tail;//队列尾 private int[] arr;//存放队列数据 ArrayQueue(int maxSize) { this.maxSize = maxSize; arr = new int[maxSize]; head = -1;//指向队列头部的前一个位置 tail = -1;//指向队列最后一个数据 } //判断队列是否满 public boolean isFull() { if (tail == maxSize - 1) { return true; } return false; } //判断队列是否为空 public boolean isEmpty() { return tail == head; } //输出队列的所有数据 public void showQueue() { if (isEmpty()) { System.out.println(\"队列为空\"); return; } for (int i = head + 1; i &lt; arr.length; i++) { //因为头部指针指向头部前一个位置所以要加一 System.out.printf(\"arr[%d]=%d\\n\", i, arr[i]); } } //添加数据,进队列 public void addQueue(int data) { if (isFull()) { throw new RuntimeException(\"队列已经满了\"); } tail++; //尾部指针向后移 arr[tail] = data; } //出队列，获取头部数据 public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"队列为空，不能获取头部\"); } head++; //头部指针向后移 return arr[head]; } // 显示队列的头数据， 注意不是取出数据 public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"队列空的，没有数据~~\"); } return arr[head + 1]; } } 问题分析并优化 目前数组使用一次就不能用， 没有达到复用的效果 将这个数组使用算法，改进成一个环形的队列 取模：% 数组模拟环形队列对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)  分析说明： 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear + 1) % maxSize == front 满] rear == front [空] 分析示意图 package Array.ArrayQueue; import java.util.Scanner; public class CircleArrayQueueDemo { public static void main(String[] args) { CircleArrayQueue queue = new CircleArrayQueue(4);//实际容量只有3，因为有一个空间作为约定 boolean loop = true; char key;//接收用户输入 Scanner scanner = new Scanner(System.in); //输出一个菜单 while (loop) { System.out.println(\"s(show): 显示队列\"); System.out.println(\"e(exit): 退出程序\"); System.out.println(\"a(add): 添加数据到队列\"); System.out.println(\"g(get): 从队列取出数据\"); System.out.println(\"h(head): 查看队列头的数据\"); key = scanner.next().charAt(0); switch (key) { case 's': queue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': try { queue.addQueue(scanner.nextInt()); } catch (Exception e) { System.out.println(e.getMessage()); } break; case 'g': try { int head = queue.getQueue(); System.out.println(\"出列的数据为\" + head); } catch (Exception e) { System.out.println(e.getMessage()); } break; case 'h': try { int head = queue.headQueue(); System.out.printf(\"队列的头部数据为%d\\n\", head); } catch (Exception e) { System.out.println(e.getMessage()); } } } System.out.println(\"程序退出\"); } } class CircleArrayQueue { private int maxSize; //队列的最大容量 private int head;//队列头 private int tail;//队列尾 private int[] arr;//存放队列数据 CircleArrayQueue(int maxSize) { this.maxSize = maxSize; //环形数组队列的实际容量是参数-1，因为要留一个空间做约定 arr = new int[maxSize]; //front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 head = 0; //rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定 tail = 0; } //判断队列是否满 public boolean isFull() { return (tail + 1) % maxSize == head; } //判断队列是否为空 public boolean isEmpty() { return tail == head; } //输出队列的所有数据 public void showQueue() { if (isEmpty()) { System.out.println(\"队列为空\"); return; } for (int i = head ; i &lt; head+getsize(); i++) { System.out.printf(\"arr[%d]=%d\\n\", i%maxSize, arr[i%maxSize]); } } //添加数据,进队列 public void addQueue(int data) { if (isFull()) { throw new RuntimeException(\"队列已经满了\"); } arr[tail] = data; tail=(tail+1)%maxSize; //尾部指针向后移 } //出队列，获取头部数据 public int getQueue() { if (isEmpty()) { throw new RuntimeException(\"队列为空，不能获取头部\"); } int val = arr[head]; head=(head+1)%maxSize; //头部指针向后移 return val; } // 显示队列的头数据， 注意不是取出数据 public int headQueue() { if (isEmpty()) { throw new RuntimeException(\"队列空的，没有数据~~\"); } return arr[head]; } //获得队列的长度 public int getsize() { return (tail + maxSize - head) % maxSize; } } 链表链表是有序的列表，但是它在内存中是存储如下 小结上图: 链表是以节点的方式来存储,是链式存储 每个节点包含 data 域， next 域：指向下一个节点. 如图：发现链表的各个节点不一定是连续存储. 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 单链表 单链表(带头结点) 逻辑结构示意图如下 单链表的应用实例 使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作， 注: 删除和修改,查找 可以考虑学员独立完成，也可带学员完成 ​ 1) 第一种方法在添加英雄时，直接添加到链表的尾部 ​ 思路分析示意图: ​ 2) 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示) ​ 思路的分析示意图: ​ 3) 修改节点功能 ​ 思路 (1) 先找到该节点，通过遍历， ​ (2) temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname ​ 4) 删除节点 ​ 思路分析的示意图: package LinkedList; public class SingleLinkedListDemo { public static void main(String[] args) { SingleLinkedList singleLinkedList = new SingleLinkedList(); // //添加节点 // singleLinkedList.addHero(new HeroNode(1, \"宋江\", \"及时雨\")); // singleLinkedList.addHero(new HeroNode(2, \"吴用\", \"智多星\")); // singleLinkedList.addHero(new HeroNode(3, \"林冲\", \"豹子头\")); //按顺序排序 singleLinkedList.addHeroByOrder(new HeroNode(2, \"吴用\", \"智多星\")); singleLinkedList.addHeroByOrder(new HeroNode(1, \"宋江\", \"及时雨\")); singleLinkedList.addHeroByOrder(new HeroNode(3, \"林冲\", \"豹子头\")); singleLinkedList.addHeroByOrder(new HeroNode(1, \"宋江\", \"及时雨\")); //遍历输出 System.out.println(\"修改前\"); singleLinkedList.list(); //修改节点信息 singleLinkedList.update(new HeroNode(1, \"宋江1号\", \"及时雨来了\")); //遍历输出 System.out.println(\"修改后\"); singleLinkedList.list(); //删除3号节点 singleLinkedList.delete(3); singleLinkedList.delete(2); System.out.println(\"删除后\"); singleLinkedList.list(); } } //单向链表用来管理英雄 class SingleLinkedList { //先初始化一个头节点, 头节点不要动, 不存放具体的数据 private HeroNode headNode = new HeroNode(0, \"\", \"\"); //添加节点到单向链表 // 思路，当不考虑编号顺序时 // 1. 找到当前链表的最后节点 // 2. 将最后这个节点的 next 指向 新的节点 public void addHero(HeroNode heroNode) { //temp辅助指针 HeroNode temp = headNode; //头结点，不动，没有数据 while (temp.next != null) { temp = temp.next; //直到最后一个节点 } temp.next = heroNode; } //按编号排序添加 public void addHeroByOrder(HeroNode heroNode) { //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置 // 因为单链表，因为我们找的 temp 是位于 添加位置的前一个节点，否则插入不了 HeroNode temp = headNode; boolean flag = false; //标志添加的节点编号是否已经存在 while (true) { if (temp.next == null) {//说明 temp 已经在链表的最后 break; } if (temp.next.No &gt; heroNode.No) {//位置找到，就在 temp 的后面插入 break; } if (temp.next.No == heroNode.No) {//说明希望添加的 heroNode 的编号已然存在 flag = true; break; } temp = temp.next; //后移，遍历当前链表 } if (flag) {//为真则不能添加，说明编号存在 System.out.println(\"要添加的编号\" + heroNode.No + \"已经存在\"); return; } else { //插入到链表中, temp 的后面 heroNode.next = temp.next; temp.next = heroNode; } } //修改节点的信息, 根据 no 编号来修改，即 no 编号不能改. // 说明 // 1. 根据 newHeroNode 的 no 来修改即可 public void update(HeroNode heroNode) { if (headNode.next == null) { System.out.println(\"链表为空\"); return; } //找到需要修改的节点, 根据 no 编号 // 定义一个辅助变量，指向第一个节点，不是头结点 HeroNode temp = headNode.next; while (true) { if (temp == null) {//已经遍历完链表 System.out.println(\"没有相对应的节点\"); break; } if (temp.No == heroNode.No) { temp.Name = heroNode.Name; temp.nickName = heroNode.nickName; System.out.println(\"修改节点成功\"); break; } temp = temp.next;//temp 后移，遍历 } } //删除节点 // 1. head 不能动，因此我们需要一个 temp 辅助节点找到待删除节点的前一个节点 // 2. 说明我们在比较时，是 temp.next.no 和 需要删除的节点的 no 比较 public void delete(int no) { if (headNode.next == null) { System.out.println(\"链表为空\"); return; } HeroNode temp = headNode; while (true) { if (temp.next == null) {//已经到链表的最后 System.out.println(\"没有找到相对应的节点\"); break; } if (temp.next.No == no) {//找到的待删除节点的前一个节点 temp temp.next = temp.next.next; System.out.println(\"节点删除成功\"); break; } temp = temp.next;//temp 后移，遍历 } } //显示链表[遍历] public void list() { HeroNode temp = headNode;//头结点，不动，没有数据 while (temp.next != null) { temp = temp.next; //头结点没有数据，所以要先指向下一个 System.out.println(temp); } return; } } //定义HeroNode节点，每个HeroNode节点就是一个节点 class HeroNode { public int No; //英雄排名 public String Name; //英雄名字 public String nickName; //别名 public HeroNode next; //指向下一个节点 HeroNode(int no, String name, String nickName) { this.No = no; this.Name=name; this.nickName = nickName; } @Override public String toString() { return \"HeroNode{\" + \"No=\" + No + \", Name='\" + Name + '\\'' + \", nickName='\" + nickName + '\\'' + '}'; } } 单链表面试题(新浪、百度、腾讯)单链表的常见面试题有如下: 求单链表中有效节点的个数 /** *获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点) * @param headNode 链表头结点 * @return 返回链表节点个数 */ public static int getLength(HeroNode headNode) { if (headNode.next == null) { //链表为空 return 0; } HeroNode temp = headNode.next; //辅助指针，指向第一个节点 int length = 0; //记录链表节点个数 while (temp != null) { length++; temp = temp.next; //向后遍历 } return length; } 查找单链表中的倒数第 k 个结点 【新浪面试题】 //查找单链表中的倒数第 k 个结点 【新浪面试题】 // 思路 // 1. 编写一个方法，接收 head 节点，同时接收一个 index // 2. index 表示是倒数第 index 个节点 // 3. 先把链表从头到尾遍历，得到链表的总的长度 getLength // 4. 得到 size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到 // 5. 如果找到了，则返回该节点，否则返回 null public static HeroNode findNode(HeroNode headNode, int index) { if (headNode.next == null) { System.out.println(\"链表为空\"); return null; } int size = getLength(headNode);//第一次遍历,获取链表长度 //第二次遍历 size-index 位置，就是我们倒数的第 K 个节点 // 先做一个 index 的校验 if (index &lt;= 0 || index &gt; size) { return null; } //定义给辅助变量， for 循环定位到倒数的 index HeroNode temp = headNode.next; for (int i = 0; i &lt; size - index; i++) {//3 // 3 - 1 = 2 temp = temp.next; } return temp; } 单链表的反转【腾讯面试题，有点难度】  思路分析图解 //将单链表反转 public static void reverseList(HeroNode headNode) { //如果链表为空或者只有一个节点 if (headNode.next == null || headNode.next.next == null) { return; } HeroNode cur = headNode.next;//指向第一个节点 HeroNode next = null; //记录位置，把节点转移到反转链表后，可以找到下一个节点 HeroNode reverseNode = new HeroNode(0, \"\", \"\");//反转链表的头结点 while (cur != null) { next = cur.next; //指向下一个节点 cur.next = reverseNode.next; //把要转移的节点的下一个节点指针指向反转链表的第一个节点 reverseNode.next = cur; //把节点连接到反转链表的第一个节点位置 cur = next;//轮到下一个节点 } //全部节点移动到反转链表后，把原链表的头结点替换反转链表的头结点 headNode.next = reverseNode.next; } 从尾到头打印单链表 【百度，要求方式 1：反向遍历 。 方式 2：Stack 栈】  思路分析图解 //方式 2： // 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果 public static void reversePrint(HeroNode headNode) { if (headNode.next == null) { return;//链表为空 } HeroNode temp = headNode.next;//指向第一个节点 Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;();//创建一个栈 //将链表的所有节点压入栈 while (temp != null) { stack.push(temp); //入栈 temp = temp.next;//指针后移 } //将栈中的节点进行打印 while (stack.size() &gt; 0) { System.out.println(stack.pop());//逐个出栈 } } 双向链表使用带 head 头的双向链表实现 –水浒英雄排行榜  管理单向链表的缺点分析: 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到 temp,temp 是待删除节点的前一个节点(认真体会). 分析了双向链表如何完成遍历，添加，修改和删除的思路 对上图的说明: 分析 双向链表的遍历，添加，修改，删除的操作思路===》代码实现 遍历 和 单链表一样，只是可以向前，也可以向后查找 添加 (默认添加到双向链表的最后) ​ (1) 先找到双向链表的最后这个节点 ​ (2) temp.next = newHeroNode ​ (3) newHeroNode.pre = temp; 修改 思路和 原来的单向链表一样. 删除 ​ (1) 因为是双向链表，因此，我们可以实现自我删除某个节点 ​ (2) 直接找到要删除的这个节点，比如 temp ​ (3) temp.pre.next = temp.next ​ (4) temp.next.pre = temp.pre; package LinkedList; public class DoubleLinkedListDemo { public static void main(String[] args) { DoubleLinkedList doubleLinkedList = new DoubleLinkedList(); //添加节点 doubleLinkedList.addHeroByOrder(new HeroNode2(2, \"吴用\", \"智多星\")); doubleLinkedList.addHeroByOrder(new HeroNode2(1, \"宋江\", \"及时雨\")); doubleLinkedList.addHeroByOrder(new HeroNode2(3, \"林冲\", \"豹子头\")); doubleLinkedList.addHeroByOrder(new HeroNode2(1, \"宋江\", \"及时雨\")); doubleLinkedList.addHeroByOrder(new HeroNode2(4, \"武松\", \"捕头\")); System.out.println(\"原链表为\"); doubleLinkedList.list(); //修改节点 doubleLinkedList.update(new HeroNode2(1, \"小宋\", \"及时雨来哦\")); System.out.println(\"修改后\"); doubleLinkedList.list(); //删除 doubleLinkedList.delete(1); System.out.println(\"删除后\"); doubleLinkedList.list(); } } //双向链表用来管理英雄 class DoubleLinkedList { //先初始化一个头节点, 头节点不要动, 不存放具体的数据 private HeroNode2 headNode = new HeroNode2(0, \"\", \"\"); public HeroNode2 getHeadNode() { return headNode; } // 添加一个节点到双向链表的最后. public void addHero(HeroNode2 heroNode) { //temp辅助指针 HeroNode2 temp = headNode; //头结点，不动，没有数据 while (temp.next != null) { temp = temp.next; //直到最后一个节点 } // 当退出 while 循环时，temp 就指向了链表的最后 // 形成一个双向链表 temp.next = heroNode; heroNode.pre = temp; } //按编号排序添加 public void addHeroByOrder(HeroNode2 heroNode) { //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置 // 因为单链表，因为我们找的 temp 是位于 添加位置的前一个节点，否则插入不了 HeroNode2 temp = headNode; boolean flag = false; //标志添加的节点编号是否已经存在 while (true) { if (temp.next == null) {//说明 temp 已经在链表的最后 break; } if (temp.next.No &gt; heroNode.No) {//位置找到，就在 temp 的后面插入 break; } if (temp.next.No == heroNode.No) {//说明希望添加的 heroNode 的编号已然存在 flag = true; break; } temp = temp.next; //后移，遍历当前链表 } if (flag) {//为真则不能添加，说明编号存在 System.out.println(\"要添加的编号\" + heroNode.No + \"已经存在\"); return; } else { //插入到链表中, temp 的后面 if (temp.next != null) { // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针 temp.next.pre = heroNode; } heroNode.next = temp.next; temp.next = heroNode; heroNode.pre = temp; } } //修改节点的信息, 根据 no 编号来修改，即 no 编号不能改. // 说明 // 1. 根据 newHeroNode 的 no 来修改即可 public void update(HeroNode2 heroNode) { if (headNode.next == null) { System.out.println(\"链表为空\"); return; } //找到需要修改的节点, 根据 no 编号 // 定义一个辅助变量，指向第一个节点，不是头结点 HeroNode2 temp = headNode.next; while (true) { if (temp == null) {//已经遍历完链表 System.out.println(\"没有相对应的节点\"); break; } if (temp.No == heroNode.No) { temp.Name = heroNode.Name; temp.nickName = heroNode.nickName; System.out.println(\"修改节点成功\"); break; } temp = temp.next; } } // 从双向链表中删除一个节点, // 说明 // 1 对于双向链表，我们可以直接找到要删除的这个节点 // 2 找到后，自我删除即可 public void delete(int no) { if (headNode.next == null) { System.out.println(\"链表为空\"); return; } HeroNode2 temp = headNode.next; while (true) { if (temp == null) {//已经到链表的最后 System.out.println(\"没有找到相对应的节点\"); break; } if (temp.No == no) {//找到的待删除节点的前一个节点 temp // temp.next = temp.next.next;[单向链表] temp.pre.next = temp.next; // 这里我们的代码有问题? // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针 if (temp.next != null) { temp.next.pre = temp.pre; } System.out.println(\"节点删除成功\"); break; } temp = temp.next;//temp 后移，遍历 } } //显示链表[遍历] public void list() { HeroNode2 temp = headNode;//头结点，不动，没有数据 while (temp.next != null) { temp = temp.next; //头结点没有数据，所以要先指向下一个 System.out.println(temp); } return; } } //定义HeroNode节点，每个HeroNode节点就是一个节点 class HeroNode2 { public int No; //英雄排名 public String Name; //英雄名字 public String nickName; //别名 public HeroNode2 next; //指向下一个节点 public HeroNode2 pre; //指向上一个节点 HeroNode2(int no, String name, String nickName) { this.No = no; this.Name = name; this.nickName = nickName; } @Override public String toString() { return \"HeroNode{\" + \"No=\" + No + \", Name='\" + Name + '\\'' + \", nickName='\" + nickName + '\\'' + '}'; } } 单向环形链表Josephu(约瑟夫、约瑟夫环) 问题 Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。  约瑟夫问题的示意图  约瑟夫问题-创建环形链表的思路图解  约瑟夫问题-小孩出圈的思路分析图 package LinkedList; public class JosephuDemo { public static void main(String[] args) { CircleSingleLinkedList list = new CircleSingleLinkedList(5); list.showBoy(); list.countBoy(1, 2, 5); } } //环形单向链表 class CircleSingleLinkedList { private Boy first = null; //指向第一个节点的辅助指针 CircleSingleLinkedList(int num) { Boy curBoy = null; //辅助指针，用于指向要操作的当前节点 if (num &lt; 1) { //节点数量少于1 System.out.println(\"无法构成环形单向链表\"); return; } for (int i = 1; i &lt;= num; i++) { if (i == 1) { first = new Boy(1); //首节点不能动 curBoy = first; //当前节点，为首节点 first.setNext(first); // 构成环 } else { Boy boy = new Boy(i); curBoy.setNext(boy); //当前节点连接加入节点 boy.setNext(first); //加入节点下个节点指向首节点 curBoy = boy; //当前节点辅助指针指向加入节点 } } } //遍历环形单向链表 public void showBoy() { if (first == null) { System.out.println(\"连表为空\"); return; } // 因为 first 不能动，因此我们仍然使用一个辅助指针完成遍历 Boy curBoy = first; while (true) { System.out.println(\"小孩的编号\"+curBoy.getNo()); if (curBoy.getNext() == first) {// 说明已经遍历完毕 break; } curBoy = curBoy.getNext(); //指针后移 } } //根据用户的输入，计算出小孩出圈的顺序 /** * * @param startNo 开始报数的节点编号 * @param countNum 表示数几下 * @param num 表示圈内节点个数 */ public void countBoy(int startNo, int countNum, int num) { if (startNo &gt; num || countNum &lt; 1 || num &lt; 1) { System.out.println(\"参数输入有误\"); return; } //创建一个辅助指针helper，指向要删除节点的前一个节点 //要删除的节点用first指针指定 Boy helper = first; // 辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点 while (true) { if (helper.getNext() == first) {// 说明 helper 指向最后小孩节点 break; } helper = helper.getNext();//后移 } //将first指针指向开始数数的位置，helper指针也跟着移动 for (int i = 0; i &lt; startNo-1; i++) { first = first.getNext(); helper = helper.getNext(); } //进行报数出圈 while (true) { if (helper == first) {//只剩最后一个节点 break; } //进行报数移动,循环结束，first指向应该移除的节点 for (int i = 0; i &lt; countNum - 1; i++) { first = first.getNext(); helper = helper.getNext(); } System.out.println(\"节点\"+first.getNo()+\"出圈\"); first = first.getNext(); //first指向下一个节点 helper.setNext(first); } System.out.println(\"剩余的节点为\" + helper.getNo()); } } //节点 class Boy { private int no; //节点编号 private Boy next; //指向下一个节点 public Boy(int no) { this.no = no; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public Boy getNext() { return next; } public void setNext(Boy next) { this.next = next; } } 栈栈是一个先入后出(FILO-First In Last Out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除 图解方式说明出栈(pop)和入栈(push)的概念 栈的应用场景 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 二叉树的遍历。 图形的深度优先(depth 一 first)搜索法。 栈的快速入门 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容， 下面我们就用数组模拟栈的出栈，入栈等操作。 实现思路分析,并画出示意图 package Stack; import java.util.Scanner; public class ArrayStackDemo{ public static void main(String[] args) { ArrayStack stack = new ArrayStack(6); String key; Scanner scanner = new Scanner(System.in); boolean loops = true; while (loops) { System.out.println(\"show: 表示显示栈\"); System.out.println(\"exit: 退出程序\"); System.out.println(\"push: 表示添加数据到栈(入栈)\"); System.out.println(\"pop: 表示从栈取出数据(出栈)\"); System.out.println(\"请输入你的选择\"); key = scanner.next(); switch (key) { case \"show\": stack.showStack(); break; case \"exit\": scanner.close(); loops = false; break; case \"push\": System.out.println(\"请输入一个值\"); int val = scanner.nextInt(); stack.push(val); break; case \"pop\": try { int i = stack.pop(); System.out.println(\"出栈的值为\"+i); } catch (Exception e) { e.getMessage(); } break; default: break; } } System.out.println(\"程序退出\"); } } //栈的数组实现 class ArrayStack { private int top ; //栈顶指针 private int[] arr; //栈 private int maxSize; //栈的最大容量 ArrayStack(int num) { this.maxSize = num; this.arr = new int[maxSize]; top = -1; } //判断栈是否满 public boolean isFull() { return top == maxSize - 1; } //判断栈是否空 public boolean isEmpty() { return top == - 1; } //入栈 public void push(int val) { //先判断是否栈满 if (isFull()) { System.out.println(\"栈满\"); return; } top++; arr[top] = val; } //出栈 public int pop() { //先判断栈是否为空 if (isEmpty()) { throw new RuntimeException(\"栈空\"); } int val = arr[top]; top--; return val; } //遍历栈 public void showStack() { if (isEmpty()) { System.out.println(\"栈为空\"); return; } for (int i = top; i &gt;= 0; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, arr[i]); } } } 栈实现综合计算器(中缀表达式) 使用栈来实现综合计算器-  思路分析(图解) 代码实现[1. 先实现一位数的运算， 2. 扩展到多位数的运算] package Stack; public class Calculator { public static void main(String[] args) { String expression = \"70*200-4\"; // 15//如何处理多位数的问题？ //创建两个栈，一个数栈，一个符号栈 ArrayStack2 numStack = new ArrayStack2(10); ArrayStack2 operStack = new ArrayStack2(10); //定义需要的相关变量 int index = 0; //指针，用于扫描 int num1 ; int num2 ; int oper ; int res ; char ch ;//用于存放扫描到的字符 String SplicingNum = \"\";//用于拼接数字 //开始 while 循环的扫描 expression while (true) { //依次得到 expression 的每一个字符 ch = expression.substring(index, index + 1).charAt(0); //判断获取的字符是什么 if (operStack.isOper(ch)) {//如果是运算符 if (!operStack.isEmpty()) { //如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符, 就需要从数栈中 pop 出两个数 //在从符号栈中 pop 出一个符号，进行运算，将得到结果入数栈，然后将当前的操作符入符号栈 if (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) { num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); //把运算的结果如数栈 numStack.push(res); //然后将当前的操作符入符号栈 operStack.push(ch); } else { //如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈. operStack.push(ch); } } else { //如果为空直接入符号栈 operStack.push(ch); } } else {//如果是数，则直接入数栈 // numStack.push(ch-48); //ch 为字符，要转为int //分析思路 // 1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数 // 2. 在处理数，需要向 expression 的表达式的 index 后再看一位,如果是数就进行扫描，如果是符号才入栈 // 3. 因此我们需要定义一个变量 字符串，用于拼接 SplicingNum += ch; //如果 ch 已经是 expression 的最后一位，就直接入栈 if (index == expression.length() - 1) { numStack.push(Integer.parseInt(SplicingNum)); } else { //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈 // 注意是看后一位，不是 index++,index 没有后移 if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) { //如果后一位是运算符，则入栈 keepNum = \"1\" 或者 \"123\" numStack.push(Integer.parseInt(SplicingNum)); //重要的!!!!!!, keepNum 清空 SplicingNum = \"\"; } } } index++;//后移一位字符 if (index &gt;= expression.length()) {//扫描完 break; } } //当表达式扫描完毕，就顺序的从数栈和符号栈中 pop 出相应的数和符号，并计算 while (true) { //如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】 if (operStack.isEmpty()) { break; } num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = numStack.cal(num1, num2, oper); //把运算的结果如数栈 numStack.push(res); } System.out.println(\"表达式：\"+expression+\"计算结果为\" + numStack.pop()); } } //栈的数组实现 class ArrayStack2 { private int top ; //栈顶指针 private int[] arr; //栈 private int maxSize; //栈的最大容量 ArrayStack2(int num) { this.maxSize = num; this.arr = new int[maxSize]; top = -1; } //判断栈是否满 public boolean isFull() { return top == maxSize - 1; } //判断栈是否空 public boolean isEmpty() { return top == - 1; } //获取栈顶的值 public int peek() { return arr[top]; } //入栈 public void push(int val) { //先判断是否栈满 if (isFull()) { System.out.println(\"栈满\"); return; } top++; arr[top] = val; } //出栈 public int pop() { //先判断栈是否为空 if (isEmpty()) { throw new RuntimeException(\"栈空\"); } int val = arr[top]; top--; return val; } //遍历栈 public void showStack() { if (isEmpty()) { System.out.println(\"栈为空\"); return; } for (int i = top; i &gt;= 0; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, arr[i]); } } //返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示 // 数字越大，则优先级就越高 public int priority(int oper) { if (oper == '*' || oper == '/') { return 1; } else if (oper == '+' || oper == '-') { return 0; } else { return -1;// 假定目前的表达式只有 +, - , * , / } } //判断是否是运算符 public boolean isOper(char val) { return val == '+' || val == '-' || val == '*' || val == '/'; } //进行运算 public int cal(int num1, int num2, int oper) { int res = 0; //用于存放计算结果 switch (oper) { case '+': res = num1 + num2; break; case '-': res = num2 - num1; //注意参数顺序，不能反 break; case '*': res = num1 * num2; break; case '/': res = num2 / num1; //注意参数顺序，不能反 break; default: break; } return res; } } 逆波兰计算器我们完成一个逆波兰计算器，要求完成如下任务: 输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。 思路分析 package Stack; import java.util.ArrayList; import java.util.List; import java.util.Stack; public class NepolandNotation { public static void main(String[] args) { //说明为了方便，逆波兰表达式 的数字和符号使用空格隔开 //String suffixExpression = \"30 4 + 5 * 6 -\"; String suffixExpression = \"4 5 * 8 - 60 + 8 2 / +\"; // 76 //思路 // 1. 先将 \"3 4 + 5 × 6 - \" =&gt; 放到 ArrayList 中 // 2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算 List&lt;String&gt; list = getList(suffixExpression); int res = calculate(list); System.out.println(\"运算结果为\"+res); } //将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中 public static List&lt;String&gt; getList(String Expression) { String[] strings = Expression.split(\" \"); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String item : strings) { list.add(item); } return list; } //完成对逆波兰表达式的运算 /** * 1)从左至右扫描，将 3 和 4 压入堆栈； * 2)遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈； * 3)将 5 入栈； * 4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈； * 5)将 6 入栈； * 6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果 * */ public static int calculate(List&lt;String&gt; list) { // 创建一个栈, 只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;&gt;(); int num1; int num2; int res; //用于存放计算结果 for (String item : list) { if (item.matches(\"\\\\d+\")) { // 匹配的是多位数 stack.push(item); }else {// pop 出两个数，并运算， 再入栈 num1 = Integer.parseInt(stack.pop()); num2 = Integer.parseInt(stack.pop()); if (item.equals(\"+\")) { res = num1 + num2; }else if (item.equals(\"-\")) { res = num2 - num1; }else if (item.equals(\"*\")) { res = num1 * num2; } else if (item.equals(\"/\")) { res = num2 / num1; } else { throw new RuntimeException(\"运算符错误\"); } //把 res 入栈 stack.push(\"\" + res); } } //最后留在 stack 中的数据是运算结果 return Integer.parseInt(stack.pop()); } } 中缀表达式转换为后缀表达式大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发 中，我们需要将 中缀表达式转成后缀表达式。 具体步骤如下: 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2； 从左至右扫描中缀表达式； 遇到操作数时，将其压 s2； 遇到运算符时，比较其与 s1 栈顶运算符的优先级： ​ 1.如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； ​ 2.否则，若优先级比栈顶运算符的高，也将运算符压入 s1； ​ 3.否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较； 遇到括号时： ​ (1) 如果是左括号“(”，则直接压入 s1 ​ (2) 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃 重复步骤 2 至 5，直到表达式的最右边 将 s1 中剩余的运算符依次弹出并压入 s2 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 举例说明 将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下 因此结果为 :”1 2 3 + 4 × + 5 –” package Stack; import java.util.ArrayList; import java.util.List; import java.util.Stack; public class NepolandNotation { public static void main(String[] args) { String expression = \"1+((2+3)*4)-5+(6*6)\";//注意表达式 List&lt;String&gt; list = toInfixExpressionList(expression); System.out.println(\"中缀表达式为:\"+list); List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(list); System.out.println(\"后缀表达式为:\" + suffixExpreesionList); int result = calculate(suffixExpreesionList); System.out.println(\"计算结果为\" + result); /* //说明为了方便，逆波兰表达式 的数字和符号使用空格隔开 //String suffixExpression = \"30 4 + 5 * 6 -\"; String suffixExpression = \"4 5 * 8 - 60 + 8 2 / +\"; // 76 //思路 // 1. 先将 \"3 4 + 5 × 6 - \" =&gt; 放到 ArrayList 中 // 2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算 List&lt;String&gt; list = getList(suffixExpression); int res = calculate(list); System.out.println(\"运算结果为\" + res); */ } //将一个中缀表达式封装成list public static List&lt;String&gt; toInfixExpressionList(String s) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); int index = 0;//这是一个指针，用于遍历 中缀表达式字符串 String temp;// 对多位数的拼接 char c;// 每遍历到一个字符，就放入到 c do { //如果 c 是一个非数字，我需要加入到 ls if ((c = s.charAt(index)) &lt; 48 || (c = s.charAt(index)) &gt; 57) { list.add(\"\" + c); index++;//后移 } else {//如果是一个数，需要考虑多位数 temp = \"\"; //先将 temp 置成空 '0'[48]-&gt;'9'[57] while (index &lt; s.length() &amp;&amp; (c = s.charAt(index)) &gt;= 48 &amp;&amp; (c = s.charAt(index)) &lt;= 57) { temp += c;//拼接 index++;//后移 }//直到index指向的字符不是数字 list.add(temp); } } while (index &lt; s.length()); return list; } /////////////////////////////////////////////////////////////////////////////// //将中缀表达式转化为后缀表达式 //即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–] // 方法：将得到的中缀表达式对应的 List =&gt; 后缀表达式对应的 List public static List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; list) { //定义两个栈 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;(); // 符号栈 // 说明：因为 s2 这个栈，在整个转换过程中，没有 pop 操作，而且后面我们还需要逆序输出 // 因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2 // Stack&lt;String&gt; s2 = new Stack&lt;String&gt;();// 储存中间结果的栈 s2 List&lt;String&gt; s2 = new ArrayList&lt;String&gt;();// 储存中间结果的 Lists2 for (String item : list) { if (item.matches(\"\\\\d+\")) { s2.add(item); //遇到操作数时，将其压 s2 } else if (s1.isEmpty() || s1.peek().equals(\"(\") || item.equals(\"(\")) { s1.push(item);//如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈,如果是左括号“(”，则直接压入 s1 } else if (item.equals(\")\")) { do {//如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃 s2.add(s1.pop()); } while (!s1.peek().equals(\"(\")); s1.pop();//!!! 将 ( 弹出 s1 栈， 消除小括号 } else { //当 item 的优先级小于等于 s1 栈顶运算符, 将 s1 栈顶的运算符弹出并加入到 s2 中，再次转到(4.1) 与 s1 中新的栈顶运算符相比较 // 问题：我们缺少一个比较优先级高低的方法 while (s1.size() != 0 &amp;&amp; Operation.getValue(item) &lt;= Operation.getValue(s1.peek())) { s2.add(s1.pop()); } //直到item比栈顶运算符优先级高 s1.push(item); } } //将 s1 中剩余的运算符依次弹出并加入 s2 while (s1.size() != 0) { s2.add(s1.pop()); } return s2; //注意因为是存放到 List, 因此按顺序输出就是对应的后缀表达式对应的 List } /////////////////////////////////////////////////////////////////////////////// //将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中 public static List&lt;String&gt; getList(String Expression) { String[] strings = Expression.split(\" \"); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String item : strings) { list.add(item); } return list; } //完成对逆波兰表达式的运算 /** * 1)从左至右扫描，将 3 和 4 压入堆栈； * 2)遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈； * 3)将 5 入栈； * 4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈； * 5)将 6 入栈； * 6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果 */ public static int calculate(List&lt;String&gt; list) { // 创建一个栈, 只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;&gt;(); int num1; int num2; int res; //用于存放计算结果 for (String item : list) { if (item.matches(\"\\\\d+\")) { // 匹配的是多位数 stack.push(item); } else {// pop 出两个数，并运算， 再入栈 num1 = Integer.parseInt(stack.pop()); num2 = Integer.parseInt(stack.pop()); if (item.equals(\"+\")) { res = num1 + num2; } else if (item.equals(\"-\")) { res = num2 - num1; } else if (item.equals(\"*\")) { res = num1 * num2; } else if (item.equals(\"/\")) { res = num2 / num1; } else { throw new RuntimeException(\"运算符错误\"); } //把 res 入栈 stack.push(\"\" + res); } } //最后留在 stack 中的数据是运算结果 return Integer.parseInt(stack.pop()); } } /////////////////////////////////////////////////////////////////////////////// //编写一个类 Operation 可以返回一个运算符 对应的优先级 class Operation { private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; //写一个方法，返回对应的优先级数字 public static int getValue(String operation) { int val; switch (operation) { case \"+\": val = ADD; break; case \"-\": val = SUB; break; case \"*\": val = MUL; break; case \"/\": val = DIV; break; default: throw new RuntimeException(\"运算符有误\"); } return val; } } 递归简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁 递归调用机制 打印问题 阶乘问题 使用图解方式说明了递归的调用机制 递归用于解决什么样的问题 各种数学问题如: 8 皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google 编程大赛) 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等. 将用栈解决的问题–&gt;递归代码比较简洁 递归需要遵守的重要规则 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的，不会相互影响, 比如 n 变量 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据. 递归必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowError，死龟了:) 当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 迷宫问题 package Recursion; public class MiGong { public static void main(String[] args) { // 先创建一个二维数组，模拟迷宫 // 地图 int[][] map = new int[8][7]; // 使用 1 表示墙 for (int i = 0; i &lt; 7; i++) { map[0][i] = 1; map[7][i] = 1; } // 左右全部置为 1 for (int i = 0; i &lt; 8; i++) { map[i][0] = 1; map[i][6] = 1; } //设置挡板, 1 表示 map[3][1] = 1; map[3][2] = 1; // map[1][2] = 1; // map[2][2] = 1; //输出地图 for (int[] item : map) { for (int i : item) { System.out.print(i + \" \"); } System.out.println(); } // setWay(map, 1, 1); //策略1 setWay2(map, 1, 1); //策略2 System.out.println(\"找到通路的路径：\"); for (int[] item : map) { for (int i : item) { System.out.print(i + \" \"); } System.out.println(); } } //使用递归回溯来给小球找路 // 说明 // 1. map 表示地图 // 2. i,j 表示从地图的哪个位置开始出发 (1,1) // 3. 如果小球能到 map[6][5] 位置，则说明通路找到. // 4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； // 2 表示通路可以走 ； 3 表示该点已经 走过，但是走不通 //5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯 public static boolean setWay(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; //走得到map[6][5]表示通路找到 } else { if (map[i][j] == 0) { //点为0，没有走过 map[i][j] = 2; //假设当前点可以走通 if (setWay(map, i + 1, j)) { //向下走 return true; //走得通 } else if (setWay(map, i, j + 1)) { //向右走 return true; } else if (setWay(map, i - 1, j)) { //向上走 return true; } else if (setWay(map, i, j - 1)) { //向左走 return true; } else { map[i][j] = 3; //走不通 return false; } } else {//map[i][j] != 0 ,点不为0，可能为1,2,3 return false; } } } //修改找路的策略，改成 上-&gt;右-&gt;下-&gt;左 public static boolean setWay2(int[][] map, int i, int j) { if (map[6][5] == 2) { return true; //走得到map[6][5]表示通路找到 } else { if (map[i][j] == 0) { //点为0，没有走过 map[i][j] = 2; //假设当前点可以走通 if (setWay2(map, i - 1, j)) { //向上走 return true; //走得通 } else if (setWay2(map, i, j + 1)) { //向右走 return true; } else if (setWay2(map, i + 1, j)) { //向下走 return true; } else if (setWay2(map, i, j - 1)) { //向左走 return true; } else { map[i][j] = 3; //走不通 return false; } } else {//map[i][j] != 0 ,点不为0，可能为1,2,3 return false; } } } } 对迷宫问题的讨论 小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右的顺序相关 再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化 测试回溯现象 思考: 如何求出最短路径? 思路-》代码实现(通过通路路径地图获取节点为2的个数，然后比较即可) 八皇后问题八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法。 说明： 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列 package Recursion; public class Queen8 { //定义一个 max 表示共有多少个皇后 int max = 8; //定义数组 array, 保存皇后放置位置的结果,比如 arr = {0 , 4, 7, 5, 2, 6, 1, 3} int[] array = new int[max]; //下标表示行，值表示列 int num = 0;//记录方案数 int count = 0;//记录判断次数 public static void main(String[] args) { Queen8 queen8 = new Queen8(); queen8.check(0); System.out.println(\"方案次数为\" + queen8.num); System.out.println(\"判断次数为\" + queen8.count); } //编写一个方法，放置第 n 个皇后 //特别注意： check 是每一次递归时，进入到 check 中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯 private void check(int n) { if (n == max) {//n = 8 ,就是第九个皇后， 其实 8 个皇后就已然放好 num++; print(); return; } //依次放入皇后，并判断是否冲突 for (int i = 0; i &lt; max; i++) { //先把当前这个皇后 n , 放到该行的第 1 列 array[n] = i; //判断当放置第 n 个皇后到 i 列时，是否冲突 if (judge(n)) { // 不冲突 //接着放 n+1 个皇后,即开始递归 check(n+1); } //如果冲突，就继续执行 array[n] = i; 即将第 n 个皇后，放置在本行的后一个列位置 } } //查看当我们放置第 n 个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突 private boolean judge(int n) { count++; for (int i = 0; i &lt; n; i++) { // 说明 // 1. array[i] == array[n] 表示判断 第 n 个皇后是否和前面的 n-1 个皇后在同一列 // 2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第 n 个皇后是否和第 i 皇后是否在同一斜线 // Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1 //3. 判断是否在同一行, 没有必要，n 每次都在递增 if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) { return false; } } return true; } //输出皇后的摆放方案 private void print() { for (int i : array) { System.out.print(i+\" \"); } System.out.println(); } } 排序算法排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。 排序的分类： 内部排序: 指将需要处理的所有数据都加载到**内部存储器(内存)**中进行排序。 外部排序法： 数据量过大，无法全部加载到内存中，需要借助**外部存储(文件等)**进行排序。 常见的排序算法分类(见右图) 算法的时间复杂度 时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n)。 时间复杂度 一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n)表示，若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。 记作 **T(n)=Ｏ( f(n) )**，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 如：T(n)=n+1,T(n)的同数量级函数 f(n)=n，时间复杂度为O( f(n) )=O(n)。 T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同，但时间复杂度相同，都为 **O(n²)**。 计算时间复杂度的方法：  用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1  修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n²  去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²) 常见的时间复杂度 常数阶 O(1) 对数阶 O(log2n) 线性阶 O(n) 线性对数阶 O(nlog2n) 平方阶 O(n^2) 立方阶 O(n^3) 参考上面的 O(n²) 去理解就好了，O(n³)相当于三层 n 循环，其它的类似 k 次方阶 O(n^k) 指数阶 O(2^n) 常见的时间复杂度对应的图: 说明： 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜ Ο(2n) ，随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低 从图中可见，我们应该尽可能避免使用指数阶的算法 平均时间复杂度和最坏时间复杂度 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。 算法的空间复杂度简介 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例 如快速排序和归并排序算法, 基数排序就属于这种情况 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品 (redis, memcache) 和算法(基数排序)本质就是用空间换时间。 冒泡排序冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 优化： 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，再进行) 小结上面的图解过程: (1) 一共进行 数组的大小-1 次 大的循环 (2)每一趟排序的次数在逐渐的减少 (3) 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化 package Sort; import java.util.Arrays; public class BubbleSort { public static void main(String[] args) { int arr[] = {3, 9, -1, 10, 20}; boolean flag = true; //用于标识数组是否已经提前排好序 int temp = 0; //临时变量 for (int i = 0; i &lt; arr.length-1; i++) { //进行数组长度-1次排序 for (int j = 0; j &lt; arr.length - 1 - i; j++){ //每次排序的比较次数都在-1 if (arr[j] &gt; arr[j + 1]) { temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; flag = false; } } System.out.print(\"第\"+(i+1)+\"遍排序后的数组为：\"); System.out.println(Arrays.toString(arr)); if (flag) { //没有进行交换排序,也就是整个数组已经是排好序的状态 break; } else { flag = true; //排好序后重置标识 } } } } //排80000个数据用了20秒左右 选择排序选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的 选择排序思想 选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2] ~ arr[n-1]中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-1]arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。 对一个数组的选择排序再进行讲解 package Sort; import java.util.Arrays; public class SelectSort { public static void main(String[] args) { int [] arr = {101, 34, 119, 1, -1, 90, 123}; selectSort(arr); } //选择排序 public static void selectSort(int[] arr) { for (int i = 0; i &lt; arr.length - 1; i++) {//进行数组长度-1次找最小值 int minIndex = i; //用于存储最小值的下标 int min = arr[i]; //用于存储最小值 for (int j = i; j &lt; arr.length; j++) {//从第i个值比较起，最小值都排在最前面，每进行一次外循环，需要比较的个数就-1 if (min &gt; arr[j]) { //找到更小的值 minIndex = j; min = arr[j]; } }//循环结束找到最小的值 if (minIndex != i) { //最小值的下标改变，也就是找到了更小的值 arr[minIndex] = arr[i]; //进行交换，把最小值换到前面 arr[i] = min; } System.out.println(\"第\" + (i + 1) + \"遍排序：\"); System.out.println(Arrays.toString(arr)); } } } //排80000个数据用了2-3秒左右 插入排序插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。 插入排序（Insertion Sorting）的基本思想是：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 package Sort; import java.util.Arrays; public class InsertSort { public static void main(String[] args) { int[] arr = {101, 34, 119, 1, -1, 89}; insertSort(arr); } //插入排序 public static void insertSort(int[] arr) { for (int i = 1; i &lt; arr.length; i++) { int insertIndex = i - 1; //要进行排序的值的前一个下标位置 int insertVal = arr[i]; //插入的值 //要插入的值在前面排好序的数组寻找插入位置 //说明 // 1. insertIndex &gt;= 0 保证在给 insertVal 找插入位置，不越界 // 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 // 3. 就需要将 arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) { //待插入的数比排好序的数组的数据小,即排好序的数组中大的数据往后移 arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; //后移 }//循环结束时就找到插入位置，插入位置为 insertIndex+1 可以使用insertIndex = 0 时验证 if (insertIndex + 1 != i) { //要插入的位置不是自己原来的位置，所以赋值 arr[insertIndex+1] = insertVal; } System.out.println(\"第\"+i+\"轮插入\"); System.out.println(Arrays.toString(arr)); } /*第一遍排序 第 1 轮 {101, 34, 119, 1}; =&gt; {34, 101, 119, 1} int insertIndex = 1 - 1; //要进行排序的值的前一个下标位置 int insertVal = arr[1]; //插入的值 //要插入的值在前面排好序的数组寻找插入位置 //说明 // 1. insertIndex &gt;= 0 保证在给 insertVal 找插入位置，不越界 // 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 // 3. 就需要将 arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) { //待插入的数比排好序的数组的数据小,即排好序的数组中大的数据往后移 arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; //后移 }//循环结束时就找到插入位置，插入位置为 insertIndex+1 arr[insertIndex+1] = insertVal; System.out.println(\"第 1 轮插入\"); System.out.println(Arrays.toString(arr)); */ } } 希尔排序 简单插入排序存在的问题 数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1**(**最小), 这样的过程是： {2,3,4,5,6,6} {2,3,4,5,5,6} {2,3,4,4,5,6} {2,3,3,4,5,6} {2,2,3,4,5,6} {1,2,3,4,5,6} 结论:**当需要插入的数是较小的数时，后移的次数明显增多，对效率**有影响. 希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 希尔排序法基本思想 ：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止 希尔排序法应用实例 有一群小牛, 考试成绩分别是 {8,9,1,7,2,3,5,4,6,0} 请从小到大排序. 请分别使用 希尔排序时， 对有序序列在插入时采用交换法, 并测试排序速度. //80000数据 16秒左右 public class ShellSort { public static void main(String[] args) { int[] arr = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0}; shellSort(arr); } //希尔排序 // 希尔排序时， 对有序序列在插入时采用交换法 public static void shellSort(int[] arr) { int temp = 0;//中间变量 int count = 0;//记录排序次数 // 因为第 1 轮排序，是将 10 个数据分成了 5 组 for (int gap = arr.length / 2; gap &gt;= 1; gap /= 2) { for (int i = gap; i &lt; arr.length; i++) { // 遍历各组中所有的元素(共 gap 组，每组有 arr.length/gap 个元素), 步长 gap for (int j = i-gap; j &gt;= 0; j -= gap) { // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + gap]) { temp = arr[j + gap]; arr[j + gap] = arr[j]; arr[j] = temp; } } } System.out.println(\"第\"+(count++)+\"次希尔排序\"+ Arrays.toString(arr)); } /* // 因为第 1 轮排序，是将 10 个数据分成了 5 组 for (int i = 5; i &lt; arr.length; i++) { // 遍历各组中所有的元素(共 5 组，每组有 2 个元素), 步长 5 for (int j = i-5; j &gt;= 0; j -= 5) { // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + 5]) { temp = arr[j + 5]; arr[j + 5] = arr[j]; arr[j] = temp; } } } System.out.println(\"第一轮希尔排序后\"+ Arrays.toString(arr)); // 因为第 2 轮排序，是将 10 个数据分成了 5/2 = 2 组 for (int i = 2; i &lt; arr.length; i++) { // 遍历各组中所有的元素(共 2 组，每组有 5 个元素), 步长 2 for (int j = i-2; j &gt;= 0; j -= 2) { // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + 2]) { temp = arr[j + 2]; arr[j + 2] = arr[j]; arr[j] = temp; } } } System.out.println(\"第二轮希尔排序后\"+ Arrays.toString(arr)); */ } } 希尔排序时， 对有序序列在插入时采用移动法, 并测试排序速度. //80000数据 1秒左右 public class ShellSort { public static void main(String[] args) { int[] arr = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0}; shellSort(arr); System.out.println(Arrays.toString(arr)); } //对交换式的希尔排序进行优化-&gt;移位法 public static void shellSort(int[] arr) { // 增量 gap, 并逐步的缩小增量 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) { // 从第 gap 个元素，逐个对其所在的组进行直接插入排序 for (int i = gap; i &lt; arr.length; i++) { int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - gap]) {//只要插入的值比前一个步长距离的值要小就得进行排序 while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) { //只要值比要插入的值大，就往后移 //移动 arr[j] = arr[j - gap]; j -= gap; }//当退出 while 后，就给 temp 找到插入的位置 可以用 gap=1 来验证 arr[j] = temp; } } } } } 快速排序法快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 要求: 对 [-9,78,0,23,-567,70] 进行从小到大的排序，要求使用快速排序法。【测试 8w 和 800w】 说明[验证分析]: 如果取消左右递归，结果是 -9 -567 0 23 78 70 如果取消右递归,结果是 -567 -9 0 23 78 70 如果取消左递归,结果是 -9 -567 0 23 70 78 //效率比希尔快一点 package Sort; import java.util.Arrays; public class QuickSort { public static void main(String[] args) { int[] arr = {-9,78,0,23,-567,70}; System.out.println(Arrays.toString(arr)); quickSort(arr, 0, arr.length-1); } public static void quickSort(int[] arr, int left, int right) { int l = left; //左下标 int r = right; //右下标 int pivot = arr[(l + r) / 2];//中轴值 int temp = 0;//临时变量 //while循环的目的是让比pivot 值小放到左边 //比pivot 值大放到右边 while (l &lt; r) { //中轴值也可能会被进行数据位置交换 //在pivot的左边一直找,找到大于等于pivot值,才退出循环 while (arr[l] &lt; pivot) { l += 1; } //在pivot的右边一直找,找到小于等于pivot值,才退出循环 while (arr[r] &gt; pivot) { r -= 1; } //如果l &gt;= r说明pivot 的左右两边的值，已经按照左边全部是 //小于等于pivot值，右边全部是大于等于pivot值排好 if( l &gt;= r) { break; } //交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完后，发现这个arr[l] == pivot值 相等（也就是中轴值进行了位置交换） r--， 前移 if(arr[l] == pivot) { r -= 1; } //如果交换完后，发现这个arr[r] == pivot值 相等（也就是中轴值进行了位置交换） l++， 后移 if(arr[r] == pivot) { l += 1; } System.out.println(Arrays.toString(arr)); } // 如果 l == r, 必须l++, r--, 否则为出现栈溢出 if (l == r) { l += 1; r -= 1; } //向左递归 if (left &lt; r) { System.out.println(\"向左递归,末点：\"+r); quickSort(arr, left, r); } //向右递归 if (right &gt; l) { System.out.println(\"向右递归,起点：\"+l); quickSort(arr, l, right); } } } 归并排序归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将 [4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤 //效率跟快速排序差不多 package Sort; import java.util.Arrays; public class MergeSort { public static void main(String[] args) { int[] arr= { 8, 4, 5, 7, 1, 3, 6, 2 }; int[] temp = new int[arr.length + 1]; mergeSort(arr, 0, arr.length - 1, temp); System.out.println(Arrays.toString(arr)); } //分+合 public static void mergeSort(int[] arr, int left, int right, int[] temp) { if (left &lt; right) { int mid = (right + left) / 2;//中间索引 mergeSort(arr, left, mid, temp);//向左递归进行分解 mergeSort(arr, mid+1, right, temp);//向右递归进行分解 merge(arr, left, mid, right, temp);//合并 } } //合并方法 /** * * @param arr 排序的原始数组 * @param left 左边有序序列的初始索引 * @param mid 中间索引 * @param right 右边索引 * @param temp 做中转的数组 */ public static void merge(int[] arr, int left, int mid, int right, int[] temp) { int i = left; //左边有序序列的初始下标 int j = mid + 1;//右边有序序列的初始下标 int t = 0;//指向temp数组的当前索引 //(一) //先把左右两边(有序)的数据按照规则填充到temp数组 //直到左右两边的有序序列，有一边处理完毕为止 while (i &lt;= mid &amp;&amp; j &lt;= right) { //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素 //即将左边的当前元素，填充到 temp数组 //然后 t++, i++ if (arr[i] &lt; arr[j]) { temp[t] = arr[i]; i += 1; t += 1; } else { //右边的元素小于等于左边的元素 temp[t] = arr[j]; j += 1; t += 1; } } //(二) //把有剩余数据的一边的数据依次全部填充到temp while (i &lt;= mid) { //左边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[i]; t += 1; i += 1; } while (j &lt;= right) { //右边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[j]; t += 1; j += 1; } //(三) //将temp数组的元素拷贝到arr //注意，并不是每次都拷贝所有 t = 0; //重新指向temp数组的第一个元素 int tempLeft = left; System.out.println(\"tempLeft = \"+tempLeft+\" right =\"+right); //第一次合并 tempLeft = 0 , right = 1 // tempLeft = 2 right = 3 // tempLeft=0 right=3 //最后一次 tempLeft = 0 right = 7 while (tempLeft &lt;= right) { arr[tempLeft] = temp[t]; t += 1; tempLeft += 1; } } } 基数排序 基数排序(桶排序)介绍: 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 基数排序(Radix Sort)是桶排序的扩展 基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 基数排序基本思想 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤 package Sort; import java.util.Arrays; public class RadixSort { public static void main(String[] args) { int arr[] = {53, 3, 542, 748, 14, 214}; radixSort(arr); } //基数排序 public static void radixSort(int[] arr) { //得到数组中最大的数据的位数 int max = arr[0];//假设第一数就是最大数 for (int i = 0; i &lt; arr.length; i++) { if (arr[i] &gt; max) { max = arr[i]; } } //得到最大数据位数 int maxLength = (max + \"\").length(); //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组 //说明 //1. 二维数组包含10个一维数组 //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length //3. 很明确，基数排序是使用空间换时间的经典算法 int[][] bucket = new int[10][arr.length]; //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数 //可以这里理解 //比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数 int[] bucketElementCounts = new int[10]; for (int j = 0, n = 1; j &lt; maxLength; j++, n *= 10) { //根据最大数的位数进行相对应次数的处理 for (int i = 0; i &lt; arr.length; i++) { //取出每个元素的个位值 int digitOfElement = arr[i] / n % 10; //放入到对应的桶中,第 digitOfElement 个桶，第 bucketElementCounts[digitOfElement] 个位置 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[digitOfElement]++; //对应桶数据个数加一，也就是桶下标后移 } //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for (int i = 0; i &lt; bucket.length; i++) { //遍历每个桶 if (bucketElementCounts[i] != 0) { //桶有数据 //循环该桶即第k个桶(即第k个一维数组), 放入 for (int k = 0; k &lt; bucketElementCounts[i]; k++) { //取出元素放入到arr arr[index++] = bucket[i][k]; } } //第1轮处理后，需要将每个 bucketElementCounts[i] = 0 ！！！！ //也就是把对应的桶所记录的长度为0，这样在后面的排序中可以把之前桶里的数据进行覆盖,相当于把指针前置 // bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[i] = 0; } System.out.println(\"第\"+(j+1)+\"轮，对个位的排序处理 arr =\" + Arrays.toString(arr)); } /* //第一轮 for (int i = 0; i &lt; arr.length; i++) { //取出每个元素的个位值 int digitOfElement = arr[i]/1 % 10; //放入到对应的桶中,第 digitOfElement 个桶，第 bucketElementCounts[digitOfElement] 个位置 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[digitOfElement]++; //对应桶数据个数加一，也就是桶下标后移 } //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for (int i = 0; i &lt; bucket.length; i++) { //遍历每个桶 if (bucketElementCounts[i] != 0) { //桶有数据 //循环该桶即第k个桶(即第k个一维数组), 放入 for (int k = 0; k &lt; bucketElementCounts[i]; k++) { //取出元素放入到arr arr[index++] = bucket[i][k]; } } //第1轮处理后，需要将每个 bucketElementCounts[i] = 0 ！！！！ //也就是把对应的桶所记录的长度为0，这样在后面的排序中可以把之前桶里的数据进行覆盖,相当于把指针前置 // bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[i] = 0; } System.out.println(\"第1轮，对个位的排序处理 arr =\" + Arrays.toString(arr)); //第二轮 for (int i = 0; i &lt; arr.length; i++) { //取出每个元素的十位值 int digitOfElement = arr[i]/10% 10; //放入到对应的桶中,第 digitOfElement 个桶，第 bucketElementCounts[digitOfElement] 个位置 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[digitOfElement]++; //对应桶数据个数加一，也就是桶下标后移 } //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for (int i = 0; i &lt; bucket.length; i++) { //遍历每个桶 if (bucketElementCounts[i] != 0) { //桶有数据 //循环该桶即第k个桶(即第k个一维数组), 放入 for (int k = 0; k &lt; bucketElementCounts[i]; k++) { //取出元素放入到arr arr[index++] = bucket[i][k]; } } bucketElementCounts[i] = 0; } System.out.println(\"第2轮，对十位的排序处理 arr =\" + Arrays.toString(arr)); //第三轮 for (int i = 0; i &lt; arr.length; i++) { //取出每个元素的百位值 int digitOfElement = arr[i]/100% 10; //放入到对应的桶中,第 digitOfElement 个桶，第 bucketElementCounts[digitOfElement] 个位置 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[i]; bucketElementCounts[digitOfElement]++; //对应桶数据个数加一，也就是桶下标后移 } //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for (int i = 0; i &lt; bucket.length; i++) { //遍历每个桶 if (bucketElementCounts[i] != 0) { //桶有数据 //循环该桶即第k个桶(即第k个一维数组), 放入 for (int k = 0; k &lt; bucketElementCounts[i]; k++) { //取出元素放入到arr arr[index++] = bucket[i][k]; } } bucketElementCounts[i] = 0; } System.out.println(\"第3轮，对百位的排序处理 arr =\" + Arrays.toString(arr)); */ } } 基数排序的说明: 基数排序是对传统桶排序的扩展，速度很快. 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且 r[i]在 r[j]之前，而在排序后的序列中，r[i]仍在 r[j]之前， 则称这种排序算法是稳定的；否则称为不稳定的] 有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: https://code.i-harness.com/zh-CN/q/e98fa9 常用排序算法总结和对比 相关术语解释： 稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面； 不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度： 一个算法执行所耗费的时间。 空间复杂度：运行完一个程序所需内存的大小。 n: 数据规模 k: “桶”的个数 In-place: 不占用额外内存 Out-place: 占用额外内存 查找算法在 java 中，我们常用的查找有四种: 顺序(线性)查找 二分查找/折半查找 插值查找 斐波那契查找 线性查找有一个数列： {1,8, 10, 89, 1000, 1234} ，判断数列中是否包含此名称【顺序查找】 要求: 如果找到了，就提示找到，并给出下标值 public class SeqSearch { public static void main(String[] args) { int arr[] = { 1, 9, 11, -1, 34, 89 };// 没有顺序的数组 int index = seqSearch(arr, -11); if(index == -1) { System.out.println(\"没有找到\"); } else { System.out.println(\"找到，下标为=\" + index); } } //这里我们实现的线性查找是找到一个满足条件的值，就返回 public static int seqSearch(int[] arr, int value) { // 线性查找是逐一比对，发现有相同值，就返回下标 for (int i = 0; i &lt; arr.length; i++) { if(arr[i] == value) { return i; } } return -1; } } 二分查找请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。 package Search; import java.util.ArrayList; import java.util.List; public class BinarySearch { public static void main(String[] args) { int arr[] = { 1, 8, 10, 89,1000,1000,1000,1234}; // int index = binarySearch(arr, 0, arr.length, -1); // if (index != -1) { // System.out.println(\"在数组的第\"+(index+1)+\"位\"); // }else System.out.println(\"找不到\"); List&lt;Integer&gt; list = binarySearch2(arr, 0, arr.length - 1, 1000); System.out.println(list); } //二分查找，前提是有序数组 /** * * @param arr 要查找的数组 * @param left 左边索引 * @param right 右边索引 * @param findVal 要查找的值 * @return 返回索引，找到返回对应的下标，找不到返回-1 */ public static int binarySearch(int[] arr, int left,int right,int findVal) { if (left &gt; right||findVal&lt;arr[0]||findVal&gt;arr[arr.length-1]) { // 当 left &gt; right 时，说明递归整个数组，但是没有找到 return -1; } int mid = (left + right) / 2; //中间索引 if (findVal &gt; arr[mid]) { return binarySearch(arr, mid + 1, right, findVal);//右递归 } else if (findVal &lt; arr[mid]) { return binarySearch(arr, left, mid - 1, findVal);//左递归 } else { //找到值,findVal = arr[mid] return mid; } } //完成一个课后思考题: /* * 课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中， * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000 * * 思路分析 * 1. 在找到mid 索引值，不要马上返回 * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList * 4. 将Arraylist返回 */ public static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) { if (left &gt; right||findVal&lt;arr[0]||findVal&gt;arr[arr.length-1]) { // 当 left &gt; right 时，说明递归整个数组，但是没有找到 return new ArrayList&lt;&gt;(); //下标集合为空 } int mid = (left + right) / 2; //中间索引 if (findVal &gt; arr[mid]) { return binarySearch2(arr, mid + 1, right, findVal);//右递归 } else if (findVal &lt; arr[mid]) { return binarySearch2(arr, left, mid - 1, findVal);//左递归 } else { //找到值,findVal = arr[mid] List&lt;Integer&gt; resIndexList = new ArrayList&lt;&gt;(); //用于存放下标 int temp = mid - 1; while (true) { //扫描左边的 if (temp &lt; left || arr[temp] != findVal) { break;//扫描完左边或者值不相等，进入下次循环 } resIndexList.add(temp); temp--; //左移 } resIndexList.add(mid); temp = mid +1; while (true) { //扫描数组右边 if (temp &gt; right || arr[temp] != findVal) { break;//扫描完右边或者值不相等，进入下次循环 } resIndexList.add(temp); temp++; //右移 } return resIndexList; } } } 插值查找 插值查找原理介绍: 插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。 将折半查找中的求 mid 索引的公式 , low 表示左边索引 left, high 表示右边索引 right。 key 就是前面我们讲的 findVal int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ; //插值索引 对应前面的代码公式： int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left]) 举例说明插值查找算法 1-100 的数组 package Search; public class InsertValueSearch { public static void main(String[] args) { // int [] arr = new int[100]; // for(int i = 0; i &lt; 100; i++) { // arr[i] = i + 1; // } int arr[] = { 1, 8, 10, 89,1000,1000, 1234 }; // int index = insertValueSearch(arr, 0, arr.length - 1, 1); int index = binarySearch(arr, 0, arr.length-1, 1); System.out.println(\"index = \" + index); } //二分查找 public static int binarySearch(int[] arr, int left,int right,int findVal) { System.out.println(\"二分查找算法~~~\"); if (left &gt; right||findVal&lt;arr[0]||findVal&gt;arr[arr.length-1]) { // 当 left &gt; right 时，说明递归整个数组，但是没有找到 return -1; } int mid = (left + right) / 2; //中间索引 if (findVal &gt; arr[mid]) { return binarySearch(arr, mid + 1, right, findVal);//右递归 } else if (findVal &lt; arr[mid]) { return binarySearch(arr, left, mid - 1, findVal);//左递归 } else { //找到值,findVal = arr[mid] return mid; } } //插值查找，前提有序数组 public static int insertValueSearch(int[] arr, int left, int right, int findVal) { System.out.println(\"插值查找算法~~~\"); //注意：findVal &lt; arr[0] 和 findVal &gt; arr[arr.length - 1] 必须需要 //否则我们得到的 mid 可能越界 if (left &gt; right || findVal &gt; arr[arr.length - 1] || findVal &lt; arr[0]) { return -1; } // 求出mid, 自适应 int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; if (findVal &gt; midVal) { // 说明应该向右边递归 return insertValueSearch(arr, mid + 1, right, findVal); } else if (findVal &lt; midVal) { // 说明向左递归查找 return insertValueSearch(arr, left, mid - 1, findVal); } else { return mid; } } } 插值查找注意事项： 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快. 关键字分布不均匀的情况下，该方法不一定比折半查找要好 斐波那契(黄金分割法)查找 斐波那契(黄金分割法)查找基本介绍 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数的比例，无限接近 黄金分割值 0.618 斐波那契(黄金分割法)原理 斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位于黄金分割点附近，即 mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示  对 F(k-1)-1 的理解： 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明： 只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid=low+F(k-1)-1 类似的，每一子段也可以用相同的方式分割 但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置）， 都赋为 n 位置的值即可。 while(n&gt;fib(k)-1) k++; package Search; import java.util.Arrays; public class FibonacciSearch { public static int maxSize = 20; public static void main(String[] args) { int [] arr = {1,2,8, 10, 89, 1000, 1234,}; System.out.println(\"index=\" + fibonacciSearch(arr, 2)); } //因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列， // 因此我们需要先获取到一个斐波那契数列 //非递归方法得到一个斐波那契数列 public static int[] fib() { int[] f = new int[maxSize]; f[0] = 1; f[1] = 1; for (int i = 2; i &lt; f.length; i++) { f[i] = f[i - 1] + f[i - 2]; } return f; } //编写斐波那契查找算法 //使用非递归的方式编写算法 /** * * @param arr 被查找的数组 * @param findVal 要查找的值 * @return 找到就返回下标，没有就返回-1 */ public static int fibonacciSearch(int[] arr,int findVal) { int low = 0; int high = arr.length - 1; int k = 0; //表示斐波那契分割数值的下标 int mid = 0; //存放mid值 int f[] = fib(); //获取到斐波那契数列 //获取到斐波那契分割数值的下标,因为是下标所以-1 while (high &gt; f[k] - 1) { k++; }//在斐波那契数组中找到第一个比数组长度大的值的下标 //因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[] //不足的部分会使用0填充 int[] temp = Arrays.copyOf(arr, f[k]); //实际上需求使用a数组最后的数填充 temp //举例: //temp = {1,8, 10, 89, 1000, 1234, 0, 0} =&gt; {1,8, 10, 89, 1000, 1234, 1234, 1234,} for (int i = high + 1; i &lt; temp.length; i++) { temp[i] = arr[high]; } // 使用while来循环处理，找到我们的数 key while (low &lt;= high) { // 只要这个条件满足，就可以找 mid = low + f[k - 1] - 1; if (findVal &lt; temp[mid]) { high = mid - 1; //为什么是 k-- //说明 //1. 全部元素 = 前面的元素 + 后边元素 //2. f[k] = f[k-1] + f[k-2] //因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3] //即 在 f[k-1] 的前面继续查找 k-- //即下次循环 mid = f[k-1-1]-1 k--; } else if (findVal &gt; temp[mid]) { low = mid + 1; //为什么是k -=2 //说明 //1. 全部元素 = 前面的元素 + 后边元素 //2. f[k] = f[k-1] + f[k-2] //3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-2] = f[k-3] + f[k-4] //4. 即在f[k-2] 的前面进行查找 k -=2 //5. 即下次循环 mid = f[k - 1 - 2] - 1 k -= 2; } else {//找到 //需要确定，返回的是哪个下标 if (mid &lt;= high) { return mid; } else { return high; } } } return -1; } } 哈希表散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 google 公司的一个上机题 有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的 id 时, 要求查找到该员工的 所有信息. 要求: 不使用数据库,,速度越快越好=&gt;哈希表(散列) 添加时，保证按照 id 从低到高插入 [课后思考：如果 id 不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?] 使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息] 思路分析并画出示意图 package Hash; import java.util.Scanner; public class HashTableDemo { public static void main(String[] args) { //创建哈希表 HashTab hashTab = new HashTab(7); String key; Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"add: 添加雇员\"); System.out.println(\"list: 显示雇员\"); System.out.println(\"find: 查找雇员\"); System.out.println(\"exit: 退出系统\"); key = scanner.next(); switch (key) { case \"add\": System.out.println(\"请输入雇员id\"); int id = scanner.nextInt(); System.out.println(\"请输入雇员名字\"); String name = scanner.next(); //创建 雇员 Emp emp = new Emp(id, name); hashTab.add(emp); break; case \"list\": hashTab.list(); break; case \"find\": System.out.println(\"请输入要查找的id\"); id = scanner.nextInt(); hashTab.findEmpById(id); break; case \"exit\": scanner.close(); System.exit(0); default: break; } } } } class Emp { public int id; public String name; public Emp next; //next 默认为 null public Emp(int id,String name) { this.id = id; this.name = name; } } //创建EmpLinkedList ,表示链表 class EmpLinkedList { //头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp private Emp head; //添加雇员到链表 //说明 //1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大 // 因此我们将该雇员直接加入到本链表的最后即可 public void add(Emp emp) { //如果是第一个雇员 if (head == null) { head = emp; return; } //如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后 Emp curEmp = head; while (true) { if (curEmp.next == null) {//说明到链表最后 break; } curEmp = curEmp.next; } curEmp.next = emp; } //遍历表的雇员信息 public void list(int no) { if (head == null) { System.out.println(\"第\"+(no+1)+\"条链表为空\"); return; } Emp curEmp = head; //辅助指针 System.out.print(\"第\"+(no+1)+\"条链表信息：\"); while(true) { System.out.printf(\" =&gt; id=%d name=%s\\t\", curEmp.id, curEmp.name); if(curEmp.next == null) {//说明curEmp已经是最后结点 break; } curEmp = curEmp.next; //后移，遍历 } System.out.println(); } //根据id查找雇员 //如果查找到，就返回Emp, 如果没有找到，就返回null public Emp findEmpById(int id) { if (head == null) { System.out.println(\"链表为空\"); return null; } Emp curEmp = head; while (true) { if (curEmp.id == id) {//找到 break;//这时curEmp就指向要查找的雇员 } if (curEmp.next == null) {//说明遍历当前链表没有找到该雇员 curEmp = null; break; } curEmp = curEmp.next;//后移 } return curEmp; } } //创建HashTab 管理多条链表 class HashTab { private EmpLinkedList[] empLinkedListArray; private int size; public HashTab(int size) { this.size = size; //初始化empLinkedListArray empLinkedListArray = new EmpLinkedList[size]; //？留一个坑, 这时要不要分别初始化每个链表 for (int i = 0; i &lt; size; i++) { empLinkedListArray[i] = new EmpLinkedList(); } } //添加雇员 public void add(Emp emp) { //根据员工的id ,得到该员工应当添加到哪条链表 int hashFun = hashFun(emp.id); //将emp 添加到对应的链表中 empLinkedListArray[hashFun].add(emp); } //遍历所有的链表,遍历hashtab public void list() { for(int i = 0; i &lt; size; i++) { empLinkedListArray[i].list(i); } } //编写散列函数, 使用一个简单取模法 public int hashFun(int id) { return id % size; } public void findEmpById(int id) { //使用散列函数确定到哪条链表查找 int hashFun = hashFun(id); Emp emp = empLinkedListArray[hashFun].findEmpById(id); if (emp != null) { System.out.printf(\"在第%d条链表找到雇员 id=%d\\n\",hashFun+1,id); }else{ System.out.println(\"在哈希表中，没有找到该雇员~\"); } } } 树 为什么需要树这种数据结构 数组存储方式的分析 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 [示意图] 画出操作示意图： 链式存储方式的分析 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 【示意图】 操作示意图： 树存储方式的分析 能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也 可以保证数据的插入，删除，修改的速度。【示意图,后面详讲】 案例: [7, 3, 10, 1, 5, 9, 12] 二叉树 二叉树的概念 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。 二叉树的子节点分为左节点和右节点 示意图 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二 层的叶子节点在右边连续，我们称为完全二叉树 二叉树遍历的说明 使用前序，中序和后序对下面的二叉树进行遍历. 前序遍历: 先输出父节点，再遍历左子树和右子树 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 小结: 看输出父节点的顺序，就确定是前序，中序还是后序 二叉树-查找指定节点 要求 请编写前序查找，中序查找和后序查找的方法。 并分别使用三种查找方式，查找 heroNO = 5 的节点 并分析各种查找方式，分别比较了多少次 思路分析图解 二叉树-删除节点  要求 如果删除的节点是叶子节点，则删除该节点 如果删除的节点是非叶子节点，则删除该子树. 测试，删除掉 5 号叶子节点 和 3 号子树. 完成删除思路分析 package Tree; public class BinaryTreeDemo { public static void main(String[] args) { //先需要创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); //创建需要的结点 HeroNode root = new HeroNode(1, \"宋江\"); HeroNode node2 = new HeroNode(2, \"吴用\"); HeroNode node3 = new HeroNode(3, \"卢俊义\"); HeroNode node4 = new HeroNode(4, \"林冲\"); HeroNode node5 = new HeroNode(5, \"关胜\"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); //测试 // System.out.println(\"前序遍历\"); // 1,2,3,5,4 // binaryTree.preOrder(); //测试 // System.out.println(\"中序遍历\"); // binaryTree.infixOrder(); // 2,1,5,3,4 // System.out.println(\"后序遍历\"); // binaryTree.postOrder(); // 2,5,4,3,1 // HeroNode node = binaryTree.postOrderSearch(5); // if (node != null) { // System.out.printf(\"编号为%d，名字为%s\\n\", node.getNo(), node.getName()); // } else { // System.out.println(\"编号为\"+5+\"的英雄不存在\"); // } //测试删除 System.out.println(\"删除前,前序遍历\"); binaryTree.preOrder(); // 1,2,3,5,4 binaryTree.delNode(6); //binaryTree.delNode(3); System.out.println(\"删除后，前序遍历\"); binaryTree.preOrder(); // 1,2,3,4 } } //二叉树 class BinaryTree { private HeroNode root; public void setRoot(HeroNode root) { this.root = root; } //前序遍历 public void preOrder() { if (root != null) { root.preOrder(); } else { System.out.println(\"树为空\"); } } //中序遍历 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"树为空\"); } } //后序遍历 public void postOrder() { if (root != null) { root.postOrder(); } else { System.out.println(\"树为空\"); } } //前序遍历查找 public HeroNode preOrderSearch(int no) { if (root != null) { return root.preOrderSearch(no); } else { return null; } } //中序遍历查找 public HeroNode infixOrderSearch(int no) { if (root != null) { return root.infixOrderSearch(no); } else { return null; } } //后序遍历查找 public HeroNode postOrderSearch(int no) { if (root != null) { return root.postOrderSearch(no); } else { return null; } } //删除结点 public void delNode(int no) { if (root != null) { if (root.getNo() == no) { root = null; } else { root.delNode(no); } } else { System.out.println(\"空树，不能删除~\"); } } } //节点 class HeroNode { private int no; private String name; private HeroNode left; private HeroNode right; public HeroNode(int no, String name) { this.no = no; this.name = name; } @Override public String toString() { return \"HeroNode{\" + \"no=\" + no + \", name='\" + name + '\\'' + '}'; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } //前序遍历 public void preOrder() { System.out.println(this);//先输出父结点 //递归向左子树前序遍历 if (left != null) { left.preOrder(); } //递归向右子树前序遍历 if (right != null) { right.preOrder(); } } //中序遍历 public void infixOrder() { //递归向左子树中序遍历 if (left != null) { left.infixOrder(); } //输出父结点 System.out.println(this); //递归向右子树中序遍历 if (right != null) { right.infixOrder(); } } //后序遍历 public void postOrder() { if(left != null) { left.postOrder(); } if(right != null) { right.postOrder(); } System.out.println(this); } //前序遍历查找 public HeroNode preOrderSearch(int no) { System.out.println(\"进入前序遍历查找\");//输出次数就是节点查找次数 //比较当前结点是不是 if (this.no == no) { return this; } //1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找 //2.如果左递归前序查找，找到结点，则返回 HeroNode resNode = null; if (left != null) { resNode = left.preOrderSearch(no); } if (resNode != null) {//说明我们左子树找到 return resNode; } //1.左递归前序查找，找到结点，则返回，否继续判断， //2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找 if (right != null) { resNode = right.preOrderSearch(no); } return resNode; } //中序遍历查找 public HeroNode infixOrderSearch(int no) { HeroNode resNode = null; //判断当前结点的左子节点是否为空，如果不为空，则递归中序查找 if (left != null) { resNode = left.infixOrderSearch(no); } if (resNode != null) { return resNode; } System.out.println(\"进入中序遍历查找\");//输出次数就是节点查找次数 //如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点 if(this.no == no) { return this; } if (right != null) { resNode = right.infixOrderSearch(no); } return resNode; } //后序遍历查找 public HeroNode postOrderSearch(int no) { //判断当前结点的左子节点是否为空，如果不为空，则递归后序查找 HeroNode resNode = null; if(this.left != null) { resNode = this.left.postOrderSearch(no); } if(resNode != null) {//说明在左子树找到 return resNode; } //如果左子树没有找到，则向右子树递归进行后序遍历查找 if(this.right != null) { resNode = this.right.postOrderSearch(no); } if(resNode != null) { return resNode; } System.out.println(\"进入后序查找\");//输出次数就是节点查找次数 //如果左右子树都没有找到，就比较当前结点是不是 if(this.no == no) { return this; } return resNode; } //递归删除结点 //1.如果删除的节点是叶子节点，则删除该节点 //2.如果删除的节点是非叶子节点，则删除该子树 public void delNode(int no) { //思路 /* * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点. 2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) 3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除) 4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除 5. 如果第4步也没有删除结点，则应当向右子树进行递归删除. */ //2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) if (left != null &amp;&amp; left.no == no) { left = null; return; } //3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除) if (right != null &amp;&amp; right.no == no) { right = null; return; } //4.那么我们就需要向左子树进行递归删除 if (left != null) { left.delNode(no); } //5. 如果第4步也没有删除结点，则应当向右子树进行递归删除. if (right != null) { right.delNode(no); } } } 三种遍历非递归实现package com.xu; import java.util.Stack; public class Test { public static void main(String[] args) { Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); Node node4 = new Node(4); Node node5 = new Node(5); Node node6 = new Node(6); Node node7 = new Node(7); Node node8 = new Node(8); Node node9 = new Node(9); Node node10 = new Node(10); node1.setLeft(node2); node1.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setRight(node7); node3.setLeft(node6); node4.setLeft(node8); node8.setLeft(node9); node5.setRight(node10); // node5.setLeft(node10); preOrder(node1); midOrder(node1); postOrder(node1); } public static void preOrder(Node root){ if (root == null) { System.out.println(\"树为空\"); } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node temp = root; while (temp != null || !stack.isEmpty()) {//只要指针不为空或者栈不为空，遍历就没结束 while (temp!=null){ System.out.print(temp.data+\" \"); //先输出根结点 stack.push(temp);//把根结点压入栈 temp = temp.left;//遍历左子树 } temp = stack.pop();//弹出上一个根结点 temp = temp.right;//进行右子树遍历 } System.out.println(); } public static void midOrder(Node root) { if (root == null) { System.out.println(\"树为空\"); } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node temp = root; while (temp != null || !stack.isEmpty()) {//只要指针不为空或者栈不为空，遍历就没结束 while (temp!=null){ stack.push(temp);//把根结点压入栈 temp = temp.left;//遍历左子树 } temp = stack.pop();//弹出上一个根结点 System.out.print(temp.data+\" \");//输出结点 temp = temp.right;//遍历右子树 } System.out.println(); } public static void postOrder(Node root) { if (root == null) { System.out.println(\"树为空\"); } Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node temp = root; while (temp != null || !stack.isEmpty()) {//只要指针不为空或者栈不为空，遍历就没结束 if (temp != null) { stack.push(temp);//把根结点压入栈 temp.flag = 1;//标记第一次入栈 temp = temp.left;//遍历左子树 } else { temp = stack.pop();//弹出上一个根结点 if (temp.flag == 1) {//如果是只入栈一次 temp.flag = 2; stack.push(temp);//标记第二次入栈 temp = temp.right;//遍历右子树 } else { //入栈过两次的就输出 System.out.print(temp.data+\" \");//输出结点 temp = null;//访问后，赋为空，确保下次循环时执行弹栈操作 } } } } } class Node{ public Node left; public Node right; public int data; public int flag; public Node(int data) { this.data = data; } public void setLeft(Node left) { this.left = left; } public void setRight(Node right) { this.right = right; } } 顺序存储二叉树 基本说明 从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组， 看下面的示意图。  要求: 右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6] 要求在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历 顺序存储二叉树的特点 顺序二叉树通常只考虑完全二叉树 第 n 个元素的左子节点为 2 * n + 1 第 n 个元素的右子节点为 2 * n + 2 第 n 个元素的父节点为 (n-1) / 2 n : 表示二叉树中的第几个元素(按 0 开始编号，为的是与数组下标符合) package Tree; public class ArrBinaryTreeDemo { public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5, 6, 7 }; //创建一个 ArrBinaryTree ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr); arrBinaryTree.preOrder(); // 1,2,4,5,3,6,7 // arrBinaryTree.infixOrder(0); } } class ArrBinaryTree { private int[] arr;//存储数据结点的数组 public ArrBinaryTree(int[] arr) { this.arr = arr; } //重载 public void preOrder() { preOrder(0); } //前序遍历 public void preOrder(int index) { if (arr == null || arr.length == 0) { System.out.println(\"数组为空，不能按照二叉树的前序遍历\"); } //输出当前这个元素 System.out.println(arr[index]); //向左递归遍历 if ((index * 2 + 1) &lt; arr.length) { preOrder(index * 2 + 1); } //向右递归遍历 if((index * 2 + 2) &lt; arr.length) { preOrder(2 * index + 2); } } //中序遍历 public void infixOrder(int index) { if (arr.length == 0 || arr == null) { System.out.println(\"数组为空，不能按照二叉树的前序遍历\"); } //向左遍历 if ((index * 2 + 1) &lt; arr.length) { infixOrder(index * 2 + 1); } //输出当前元素 System.out.println(arr[index]); //向右遍历 if ((index * 2 + 2) &lt; arr.length) { infixOrder(index*2+2); } } } 线索化二叉树 先看一个问题 将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. n+1=7 问题分析: 当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 } 但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上. 如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? 解决方案-线索二叉树 线索二叉树基本介绍 n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”） 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 一个结点的前一个结点，称为前驱结点 一个结点的后一个结点，称为后继结点 线索二叉树应用案例 应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6} 思路分析: 中序遍历的结果：{8, 3, 10, 1, 14, 6}  说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况: left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点. right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向的是后继节点 package Tree.ThreadedBinaryTree; public class ThreadedBinaryTreeDemo { public static void main(String[] args) { //测试一把中序线索二叉树的功能 HeroNode root = new HeroNode(1, \"tom\"); HeroNode node2 = new HeroNode(3, \"jack\"); HeroNode node3 = new HeroNode(6, \"smith\"); HeroNode node4 = new HeroNode(8, \"mary\"); HeroNode node5 = new HeroNode(10, \"king\"); HeroNode node6 = new HeroNode(14, \"dim\"); //二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); //测试中序线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(root); //测试: 以10号节点测试 HeroNode leftNode = node5.getLeft(); HeroNode rightNode = node5.getRight(); System.out.println(\"10号结点的前驱结点是 =\" + leftNode); //3 System.out.println(\"10号结点的后继结点是=\" + rightNode); //1 threadedBinaryTree.threadedList(); } } //定义ThreadedBinaryTree 实现了线索化功能的二叉树 class ThreadedBinaryTree { private HeroNode root; //为了实现线索化，需要创建指向当前结点的前驱结点的指针 //在递归进行线索化时，pre 总是保留前一个结点 private HeroNode pre = null; public void setRoot(HeroNode root) { this.root = root; } //编写对二叉树进行中序线索化的方法 public void threadedNodes(HeroNode node) { //如果node==null, 不能线索化 if (node == null) { return; } //(一)先线索化左子树 threadedNodes(node.getLeft()); //(二)线索化当前结点[有难度] //处理当前结点的前驱结点 //以8结点来理解 //8结点的.left = null , 8结点的.leftType = 1 if (node.getLeft() == null) { //让当前结点的左指针指向前驱结点 node.setLeft(pre); //修改当前结点的左指针的类型,指向前驱结点 node.setLeftType(1); } //处理后继结点 if (pre != null &amp;&amp; pre.getRight() == null) { //让前驱结点的右指针指向当前结点 pre.setRight(node); //修改前驱结点的右指针类型 pre.setRightType(1); } //!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点 pre = node; //(三)在线索化右子树 threadedNodes(node.getRight()); } //遍历线索化二叉树的方法 public void threadedList() { //定义一个变量，存储当前遍历的结点，从root开始 HeroNode node = root; while (node != null) { //循环的找到leftType == 1的结点，第一个找到就是8结点 //后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化 //处理后的有效结点 while (node.getLeftType() == 0) { node = node.getLeft(); } //打印当前这个结点 System.out.println(node); //如果当前结点的右指针指向的是后继结点,就一直输出 while (node.getRightType() == 1) { //获取到当前结点的后继结点 node = node.getRight(); System.out.println(node); } //替换这个遍历的结点 node = node.getRight(); } } } //先创建HeroNode 结点 class HeroNode { private int no; private String name; private HeroNode left; //默认null private HeroNode right; //默认null //说明 //1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点 //2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点 private int leftType; private int rightType; public int getLeftType() { return leftType; } public void setLeftType(int leftType) { this.leftType = leftType; } public int getRightType() { return rightType; } public void setRightType(int rightType) { this.rightType = rightType; } public HeroNode(int no, String name) { this.no = no; this.name = name; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public HeroNode getLeft() { return left; } public void setLeft(HeroNode left) { this.left = left; } public HeroNode getRight() { return right; } public void setRight(HeroNode right) { this.right = right; } @Override public String toString() { return \"HeroNode [no=\" + no + \", name=\" + name + \"]\"; } } 树结构实际应用堆排序 堆排序基本介绍 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 **O(nlogn)**，它也是不稳定排序。 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 大顶堆举例说明 小顶堆举例说明 一般升序采用大顶堆，降序采用小顶堆 堆排序的基本思想是： 将待排序序列构造成一个大顶堆 此时，整个序列的最大值就是堆顶的根节点。 将其与末尾元素进行交换，此时末尾就为最大值。 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了. 堆排序步骤图解说明 步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。 原始的数组 [4, 6, 8, 5, 9] .假设给定无序序列结构如下 .此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。 .找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。 此时，我们就将一个无序序列构造成了一个大顶堆。 步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 .将堆顶元素 9 和末尾元素 4 进行交换 .重新调整结构，使其继续满足堆定义 .再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8. 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序 再简单总结下堆排序的基本思路： 1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; 2).将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 package Tree; import java.util.Arrays; public class HeapSort { public static void main(String[] args) { int arr[] = {4, 6, 8, 5, 9,10,-1,-999,89,2}; heapSort(arr); } //编写一个堆排序的方法 public static void heapSort(int[] arr) { int temp = 0; System.out.println(\"堆排序!!\"); // //分步完成 // adjustHeap(arr, 1, arr.length); // System.out.println(\"第一次\" + Arrays.toString(arr)); // 4, 9, 8, 5, 6 // // adjustHeap(arr, 0, arr.length); // System.out.println(\"第2次\" + Arrays.toString(arr)); // 9,6,8,5,4 //完成我们最终代码 //将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) { adjustHeap(arr, i, arr.length); } /* * 2).将堆顶元素与末尾元素交换，将最大元素\"沉\"到数组末端; 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 */ for (int j = arr.length - 1; j&gt;0; j--) { //交换 temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } System.out.println(\"数组=\" +Arrays.toString(arr)); } //将一个数组(二叉树), 调整成一个大顶堆 /** * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆 * 举例 int arr[] = {4, 6, 8, 5, 9}; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 {4, 9, 8, 5, 6} * 如果我们再次调用 adjustHeap 传入的是 i = 0 =&gt; 得到 {4, 9, 8, 5, 6} =&gt; {9,6,8,5, 4} * * @param arr 待调整的数组 * @param i 表示非叶子结点在数组中的索引 * @param lenght 表示对多少个元素继续调整， length 是在逐渐的减少 */ public static void adjustHeap(int arr[], int i, int lenght) { int temp = arr[i];//先取出当前元素的值，保存在临时变量 //开始调整 //说明 //1. k = i * 2 + 1 k 是 i结点的左子结点 for (int k = i * 2 + 1; k &lt; lenght; k = k * 2 + 1) { if (k + 1 &lt; lenght &amp;&amp; arr[k] &lt; arr[k + 1]) {//说明左子结点的值小于右子结点的值 k++;// k 指向右子结点 } if (arr[k] &gt; temp) {//如果子结点大于父结点 arr[i] = arr[k];//把较大的值赋给当前结点 i = k;//!!! i 指向 k,继续循环比较 } else { break; } } //当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部) arr[i] = temp;//将temp值放到调整后的位置 } } 赫夫曼树 基本介绍 给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近 赫夫曼树几个重要概念和举例说明 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为 WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。 WPL 最小的就是赫夫曼树 赫夫曼树创建思路图解 给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树. 构成赫夫曼树的步骤： 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 取出根节点权值最小的两颗二叉树 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 图解: package Tree.Huffman; import java.util.ArrayList; import java.util.Collections; public class HuffmanTree { public static void main(String[] args) { int arr[] = { 13, 7, 8, 3, 29, 6, 1 }; Node root = createHuffmanTree(arr); //测试一把 preOrder(root); // } //前序遍历哈夫曼树 public static void preOrder(Node node) { if (node != null) { node.preOrder(); } else { System.out.println(\"树为空\"); } } // 创建赫夫曼树的方法 /** * * @param arr 需要创建成哈夫曼树的数组 * @return 创建好后的赫夫曼树的root结点 */ public static Node createHuffmanTree(int[] arr) { // 第一步为了操作方便 // 1. 遍历 arr 数组 // 2. 将arr的每个元素构成成一个Node // 3. 将Node 放入到ArrayList中 ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; arr.length; i++) { nodes.add(new Node(arr[i])); } while (nodes.size() &gt; 1) { //排序 从小到大 Collections.sort(nodes); //取出根节点权值最小的两颗二叉树 //(1) 取出权值最小的结点（二叉树） Node leftNode = nodes.get(0); //(2) 取出权值第二小的结点（二叉树） Node rightNode = nodes.get(1); //(3)构建一颗新的二叉树 Node parent = new Node(leftNode.value + rightNode.value); parent.left = leftNode; parent.right = rightNode; //(4)从ArrayList删除处理过的二叉树 nodes.remove(leftNode); nodes.remove(rightNode); //(5)将parent加入到nodes nodes.add(parent); } //返回哈夫曼树的root结点 return nodes.get(0); } } // 创建结点类 // 为了让Node 对象持续排序Collections集合排序 // 让Node 实现Comparable接口 class Node implements Comparable&lt;Node&gt;{ public int value;// 结点权值 public Node left;// 指向左子结点 public Node right;// 指向右子结点 public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } @Override public int compareTo(Node o) { // 表示从小到大排序 return this.value-o.value; } //前序遍历 public void preOrder() { System.out.println(this); if (left != null) { left.preOrder(); } if (right != null) { right.preOrder(); } } } 赫夫曼编码 基本介绍 赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间 赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码 11.3.2 原理剖析  通信领域中信息的处理方式 1-定长编码  通信领域中信息的处理方式 2-变长编码  通信领域中信息的处理方式 3-赫夫曼编码 传输的字符串 i like like like java do you like a java d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值 构成赫夫曼树的步骤： ​ 1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单 的二叉树 ​ 2) 取出根节点权值最小的两颗二叉树 ​ 3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 ​ 4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列 中，所有的数据都被处理， 就得到一颗赫夫曼树 根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ， 编码 如下: o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a : 110 k: 1110 e: 1111 j: 0000 v: 0001 l: 001 : 01 按照上面的赫夫曼编码，我们的”i like like like java do you like a java” 字符串对应的编码为 (注意这里我们使用的无损压缩) 10101001101111011110100110111101111010011011110111101000011000011100110011110000110 01111000100100100110111101111011100100001100001110 通过赫夫曼编码处理 长度为 133 6） 长度为 ： 133 说明: 原来长度是 359 , 压缩了 (359-133) / 359 = 62.9% 此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性  注意事项 注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是 wpl 是一样的，都是最小的, 最后生成的赫夫曼编码的长度是一样，比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为 package Tree.Huffman.HuffmanCode; import java.io.*; import java.util.*; public class HuffmanCodeDemo { public static void main(String[] args) { // //测试压缩 // zipFile(\"c://1.txt\", \"c://1.zip\"); // System.out.println(\"压缩成功\"); // // //测试解压 // unZipFile(\"c://1.zip\",\"c://2.txt\"); // System.out.println(\"解压成功\"); String content = \"i like like like java do you like a java\"; byte[] contentBytes = content.getBytes(); System.out.println(contentBytes.length); //40 //测试一把，创建的赫夫曼树 // List&lt;Node&gt; nodes = getNodes(contentBytes); // System.out.println(nodes); // Node root = createHuffmanTree(nodes); // preOrder(root); //测试一把是否生成了对应的赫夫曼编码 // Map&lt;Byte, String&gt; huffmanCodes = getHuffmanCodes(root); // System.out.println(huffmanCodes); // byte[] bytes = zip(contentBytes, huffmanCodes); // System.out.println(Arrays.toString(bytes)); //测试编码封装方法 byte[] huffmanZip = huffmanZip(contentBytes); System.out.println(Arrays.toString(huffmanZip)); //测试解码 byte[] bytes = decode(huffmanCodes, huffmanZip); System.out.println(\"原来的字符串=\"+new String(bytes)); } //编写一个方法，完成对压缩文件的解压 /** * * @param zipFile 准备解压的文件 * @param dstFile 将文件解压到哪个路径 */ public static void unZipFile(String zipFile, String dstFile) { InputStream is = null;//定义文件输入流 ObjectInputStream ois = null;//定义一个对象输入流 OutputStream os = null;//定义文件的输出流 try { //创建文件输入流 is = new FileInputStream(zipFile); //创建一个和 is关联的对象输入流 ois = new ObjectInputStream(is); //读取byte数组 huffmanBytes byte[] huffmanBytes = (byte[]) ois.readObject(); //读取哈夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject(); //解码 byte[] bytes = decode(huffmanCodes, huffmanBytes); //将bytes 数组写入到目标文件 os = new FileOutputStream(dstFile); os.write(bytes); } catch (Exception e) { System.out.println(e.getMessage()); } finally { try { os.close(); ois.close(); is.close(); } catch (IOException e) { System.out.println(e.getMessage()); } } } //编写方法，将一个文件进行压缩 /** * @param srcFile 你传入的希望压缩的文件的全路径 * @param dstFile 我们压缩后将压缩文件放到哪个目录 */ public static void zipFile(String srcFile, String dstFile) { //文件的输入流 InputStream is = null; //文件输出流 OutputStream os = null; ObjectOutputStream oos = null; try { is = new FileInputStream(srcFile); //创建一个和源文件大小一样的byte[] byte[] bytes = new byte[is.available()]; //读取文件 is.read(bytes); //直接对源文件压缩 byte[] huffmanBytes = huffmanZip(bytes); //创建文件的输出流, 存放压缩文件 os = new FileOutputStream(dstFile); //创建一个和文件输出流关联的ObjectOutputStream oos = new ObjectOutputStream(os); //把 赫夫曼编码后的字节数组写入压缩文件 oos.writeObject(huffmanBytes); //这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用 //注意一定要把赫夫曼编码 写入压缩文件 oos.writeObject(huffmanCodes); } catch (IOException e) { System.out.println(e.getMessage()); } finally { try { oos.close(); os.close(); is.close(); } catch (IOException e) { System.out.println(e.getMessage()); } } } //完成数据的解压 //思路 //1. 将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28] // 首先先转成 赫夫曼编码对应的二进制的字符串 \"1010100010111...\" //2. 赫夫曼编码对应的二进制的字符串 \"1010100010111...\" =》 对照 赫夫曼编码 =》 \"i like like like java do you like a java\" //编写一个方法，完成对压缩数据的解码 /** * @param huffmanCodes 赫夫曼编码表 map * @param huffmanBytes 赫夫曼编码得到的字节数组 * @return 就是原来的字符串对应的数组 */ private static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) { StringBuilder stringBuilder = new StringBuilder(); //将byte数组转成二进制的字符串 for (int i = 0; i &lt; huffmanBytes.length; i++) { //判断是不是最后一个字节 boolean flag = (i == huffmanBytes.length - 1); byte b = huffmanBytes[i]; String s = byteToBitString(!flag, b);//最后一位不用补高位，无论是否为正数,因为最后一位的编码可能不够8位 stringBuilder.append(s); } //把字符串按照指定的赫夫曼编码进行解码 //把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a Map&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) { map.put(entry.getValue(), entry.getKey()); } //创建集合，存放byte ArrayList&lt;Byte&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; stringBuilder.length(); ) { int count = 1; boolean flag = true; Byte b = null; while (flag) { //1010100010111... //递增的取出 key String key = stringBuilder.substring(i, i + count);//i 不动，让count移动，指定匹配到一个字符 b = map.get(key); if (b == null) {//说明没有匹配到 count++; } else { //匹配到 flag = false; } } list.add(b); i += count;//i 直接移动到 count } //当for循环结束后，我们list中就存放了所有的字符 \"i like like like java do you like a java\" //把list 中的数据放入到byte[] 并返回 byte[] bytes = new byte[list.size()]; for (int i = 0; i &lt; list.size(); i++) { bytes[i] = list.get(i); } return bytes; } /** * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码 * * @param b 传入的 byte * @param flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位 * @return 是该 b 对应的二进制的字符串，（注意是按补码返回） */ private static String byteToBitString(boolean flag, byte b) { int temp = (int) b;//将 b 转成 int //如果是正数我们还存在补高位 if (flag) { temp |= 256; //按位或 256 1 0000 0000 | 0000 0001 =&gt; 1 0000 0001 } String binaryString = Integer.toBinaryString(temp);//返回的是temp对应的二进制的补码 if (flag) { return binaryString.substring(binaryString.length() - 8); } else { return binaryString; } } //使用一个方法，将前面的方法封装起来，便于我们的调用. /** * @param bytes 原始要处理的字节数组 * @return 哈夫曼编码后的字节数组 */ public static byte[] huffmanZip(byte[] bytes) { List&lt;Node&gt; nodes = getNodes(bytes); Node huffmanTreeRoot = createHuffmanTree(nodes); Map&lt;Byte, String&gt; huffmanCodes = getHuffmanCodes(huffmanTreeRoot); byte[] zip = zip(bytes, huffmanCodes); return zip; } //编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[] /** * @param bytes 这时原始的字符串对应的 byte[] * @param huffmanCodes 生成的赫夫曼编码map * @return 返回赫夫曼编码处理后的 byte[] * 举例： String content = \"i like like like java do you like a java\"; =》 byte[] contentBytes = content.getBytes(); * 返回的是 字符串 \"1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100\" * =&gt; 对应的 byte[] huffmanCodeBytes ，即 8位对应一个 byte,放入到 huffmanCodeBytes * huffmanCodeBytes[0] = 10101000(补码) =&gt; byte [推导 10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ] * huffmanCodeBytes[1] = -88 */ public static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) { //1.利用 huffmanCodes 将 bytes 转成 赫夫曼编码对应的字符串 StringBuilder stringBuilder = new StringBuilder(); for (byte b : bytes) { stringBuilder.append(huffmanCodes.get(b));//将对应的字符的编码取出来 } //将 \"1010100010111111110...\" 转成 byte[] //统计返回 byte[] huffmanCodeBytes 长度 //一句话 int len = (stringBuilder.length() + 7) / 8; int len; if (stringBuilder.length() % 8 == 0) { len = stringBuilder.length() / 8; } else { len = stringBuilder.length() / 8 + 1; } //创建 存储压缩后的 byte数组 byte[] huffmanCodeBytes = new byte[len]; int index = 0;//记录是第几个byte //将哈夫曼编码转换为byte数组 for (int i = 0; i &lt; stringBuilder.length(); i += 8) { String strbyte; if (i + 8 &gt; stringBuilder.length()) {//如果最后一段编码不足8个 strbyte = stringBuilder.substring(i); } else { strbyte = stringBuilder.substring(i, i + 8); } //将strByte 转成一个byte,放入到 huffmanCodeBytes huffmanCodeBytes[index] = (byte) Integer.parseInt(strbyte, 2); index++; } return huffmanCodeBytes; } //生成赫夫曼树对应的赫夫曼编码 //思路: //1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式 // 生成的赫夫曼编码表{32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011} static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;&gt;(); //2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径 static StringBuilder stringBuilder = new StringBuilder(); //为了调用方便，我们重载 getCodes public static Map&lt;Byte, String&gt; getHuffmanCodes(Node root) { if (root == null) { return null; } //处理root的左子树 getCodes(root.left, \"0\", stringBuilder); //处理root的右子树 getCodes(root.right, \"1\", stringBuilder); return huffmanCodes; } /** * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合 * * @param node 传入结点 * @param code 路径： 左子结点是 0, 右子结点 1 * @param stringBuilder 用于拼接路径 */ public static void getCodes(Node node, String code, StringBuilder stringBuilder) { StringBuilder stringBuilder2 = new StringBuilder(stringBuilder); //将code 加入到 stringBuilder2 stringBuilder2.append(code); if (node != null) {//如果node == null不处理 //判断当前node 是叶子结点还是非叶子结点 if (node.data == null) {//非叶子结点 //递归处理 //向左递归 getCodes(node.left, \"0\", stringBuilder2); //向右递归 getCodes(node.right, \"1\", stringBuilder2); } else { //叶子结点 huffmanCodes.put(node.data, stringBuilder2.toString()); } } } //前序遍历的方法 public static void preOrder(Node root) { if (root == null) { System.out.println(\"树为空\"); } else { root.preOrder(); } } //可以通过List 创建对应的赫夫曼树 public static Node createHuffmanTree(List&lt;Node&gt; nodes) { while (nodes.size() &gt; 1) { //排序, 从小到大 Collections.sort(nodes); //取出第一颗最小的二叉树 Node leftNode = nodes.get(0); //取出第二颗最小的二叉树 Node rightNode = nodes.get(1); //创建一颗新的二叉树,它的根节点 没有data, 只有权值 Node parent = new Node(leftNode.weight + rightNode.weight, null); parent.left = leftNode; parent.right = rightNode; //将已经处理的两颗二叉树从nodes删除 nodes.remove(leftNode); nodes.remove(rightNode); //将新的二叉树，加入到nodes nodes.add(parent); } //nodes 最后的结点，就是赫夫曼树的根结点 return nodes.get(0); } /** * @param bytes 接收字节数组 * @return 返回的就是 List 形式 [Node[date=97 ,weight = 5], Node[date=32,weight = 9]......], */ public static List&lt;Node&gt; getNodes(byte[] bytes) { //1创建一个ArrayList ArrayList&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); //遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value] HashMap&lt;Byte, Integer&gt; map = new HashMap&lt;Byte, Integer&gt;(); for (byte b : bytes) { Integer count = map.get(b); if (count == null) {// Map还没有这个字符数据,第一次 map.put(b, 1); } else { map.put(b, count + 1); } } for (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) { nodes.add(new Node(entry.getValue(), entry.getKey())); } return nodes; } } class Node implements Comparable&lt;Node&gt; { public int weight; //权值, 表示字符出现的次数 public Byte data;// 存放数据(字符)本身，比如'a' =&gt; 97 ' ' =&gt; 32 public Node left; public Node right; public Node(int weight, Byte data) { this.weight = weight; this.data = data; } @Override public String toString() { return \"Node{\" + \"weight=\" + weight + \", data=\" + data + '}'; } @Override public int compareTo(Node o) { return this.weight - o.weight;//从小到大排序 } //前序遍历 public void preOrder() { System.out.println(this); if (left != null) { left.preOrder(); } if (right != null) { right.preOrder(); } } } 二叉排序树 先看一个需求 给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加 解决方案分析  使用数组 数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢. 数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。  使用链式存储-链表 不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。  使用二叉排序树 二叉排序树介绍 二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。 特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点 比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为： 二叉排序树创建和遍历 一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 Array(7, 3, 10, 12, 5, 1, 9) ， 创建成对应的二叉排序树为 : 二叉排序树的删除 二叉排序树的删除情况比较复杂，有下面三种情况需要考虑 删除叶子节点 (比如：2, 5, 9, 12) 删除只有一颗子树的节点 (比如：1) 删除有两颗子树的节点. (比如：7, 3，10 ) 操作的思路分析 //对删除结点的各种情况的思路分析: 第一种情况: 删除叶子节点 (比如：2, 5, 9, 12) 思路(1) 需求先去找到要删除的结点 targetNode (2) 找到 targetNode 的 父结点 parent (3) 确定 targetNode 是 parent 的左子结点 还是右子结点 (4) 根据前面的情况来对应删除 左子结点 parent.left = null 右子结点 parent.right = null; 第二种情况: 删除只有一颗子树的节点 比如 1 思路(1) 需求先去找到要删除的结点 targetNode (2) 找到 targetNode 的 父结点 parent (3) 确定 targetNode 的子结点是左子结点还是右子结点 (4) targetNode 是 parent 的左子结点还是右子结点 (5) 如果 targetNode 有左子结点 5. 1 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.left; 5.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.left; (6) 如果 targetNode 有右子结点 6.1 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.right; 6.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right 情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 ) 思路 (1) 需求先去找到要删除的结点 targetNode (2) 找到 targetNode 的 父结点 parent (3) 从 targetNode 的右子树找到最小的结点 (4) 用一个临时变量，将 最小结点的值保存 temp = 11 (5) 删除该最小结点 (6) targetNode.value = temp package Tree.BinarySortTree; public class BinarySortTreeDemo { public static void main(String[] args) { int[] arr = {7, 3, 10, 12, 5, 1, 9, 2}; BinarySortTree binarySortTree = new BinarySortTree(); //循环的添加结点到二叉排序树 for (int i = 0; i &lt; arr.length; i++) { binarySortTree.add(new Node(arr[i])); } //中序遍历二叉排序树 System.out.println(\"中序遍历二叉排序树~\"); binarySortTree.infixOrder(); // 1,2, 3, 5, 7, 9, 10, 12 binarySortTree.delNode(1); binarySortTree.delNode(7); binarySortTree.delNode(2); System.out.println(\"删除结点后\"); binarySortTree.infixOrder(); } } //创建二叉排序树 class BinarySortTree { private Node root; //添加结点的方法 public void add(Node node) { if (root == null) { root = node;//如果root为空则直接让root指向node } else { root.add(node); } } //中序遍历 public void infixOrder() { if (root == null) { System.out.println(\"树为空\"); } else { root.infixOrder(); } } //找到要删除的结点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } //找到要删除的结点的父结点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } //编写方法: //1. 返回的 以node 为根结点的二叉排序树的最小结点的值 //2. 删除node 为根结点的二叉排序树的最小结点 /** * @param node 传入的结点(当做二叉排序树的根结点) * @return 返回的 以node 为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) { Node target = node; //循环的查找左子节点，就会找到最小值 while (target.left != null) { target = target.left; } //这时 target就指向了最小结点 //删除最小结点 delNode(target.value); return target.value; } //删除结点 public void delNode(int value) { if (root == null) { return; } //1.需求先去找到要删除的结点 targetNode Node targetNode = search(value); if (targetNode == null) { return; } //如果我们发现当前这颗二叉排序树只有一个结点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } //去找到targetNode的父结点 Node parent = searchParent(value); //如果要删除的结点是叶子结点 if (targetNode.right == null &amp;&amp; targetNode.left == null) { //判断targetNode 是父结点的左子结点，还是右子结点 if (parent.left != null &amp;&amp; parent.left.value == value) {//是左子结点 parent.left = null; } else if (parent.right != null &amp;&amp; value == parent.right.value) {//是右子节点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) {//删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal;//删除右子树最小结点，然后把最小结点值赋给targetNode } else {// 删除只有一颗子树的结点 if (targetNode.left != null) {//只有左子树 if (parent != null) { //如果 targetNode 是 parent 的左子结点，parent.left != null避免空指针异常 if (parent.left != null &amp;&amp; parent.left.value == targetNode.value) { parent.left = targetNode.left; } else {// targetNode 是 parent 的右子结点 parent.right = targetNode.left; } } else {//没有父结点,也就是树只有root结点和一个子节点 root = targetNode.left; } } else {//只有右子树 if (parent != null) { //如果 targetNode 是 parent 的左子结点 if (parent.left != null &amp;&amp; parent.left.value == targetNode.value) { parent.left = targetNode.right; } else {//如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right; } } else {//没有父结点,也就是树只有root结点和一个子节点 root = targetNode.right; } } } } } class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } //查找要删除的结点 /** * @param value 希望删除的结点的值 * @return 如果找到返回该结点，否则返回null */ public Node search(int value) { if (value == this.value) {//刚好是要找的结点 return this; } else if (value &lt; this.value) {//如果查找的值小于当前结点，向左子树递归查找 if (this.left == null) {//如果左子结点为空 return null; } return this.left.search(value); } else {//如果查找的值不小于当前结点，向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } //查找要删除结点的父结点 /** * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点，如果没有就返回null */ public Node searchParent(int value) { //如果当前结点就是要删除的结点的父结点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { //如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空 if (this.left != null &amp;&amp; value &lt; this.value) { return left.searchParent(value);//向左子树递归查找 } else if (this.right != null &amp;&amp; value &gt;= this.value) { return right.searchParent(value);//向右子树递归查找 } else {//当前结点不是要找的结点，并且左右子结点都为空 return null;// 没有找到父结点 } } } //添加节点 public void add(Node node) { if (node == null) { return; } //判断传入的结点的值，和当前子树的根结点的值关系 if (node.value &lt; this.value) { if (left == null) {//如果当前结点左子结点为null left = node; } else { //递归的向左子树添加 left.add(node); } } else {//添加的结点的值大于等于 当前结点的值 if (right == null) { right = node; } else { //递归的向右子树添加 right.add(node); } } } //中序遍历 public void infixOrder() { if (left != null) { left.infixOrder(); } System.out.println(this); if (right != null) { right.infixOrder(); } } } 平衡二叉树(AVL 树) 看一个案例(说明二叉排序树可能的问题) 给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.  左边 BST 存在的问题分析: 左子树全部为空，从形式上看，更像一个单链表. 插入速度没有影响 查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢 解决方案-平衡二叉树(AVL) 基本介绍 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。 具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 举例说明, 看看下面哪些 AVL 树, 为什么? 应用案例-单旋转(左旋转) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8} 思路分析(示意图) //左旋转方法 public void leftRotate() { //创建新的结点，以当前根结点的值 Node newNode = new Node(this.value); //把新的结点的左子树设置成当前结点的左子树 newNode.left = this.left; //把新的结点的右子树设置成根结点的右子树的左子树 newNode.right = this.right.left; //把当前结点的值替换成右子结点的值 this.value = right.value; //把当前结点的右子树设置成当前结点右子树的右子树 this.right = this.right.right; //把当前结点的左子树(左子结点)设置成新的结点 this.left = newNode; } 应用案例-单旋转(右旋转) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6} 思路分析(示意图) //右旋转 public void rightRotate() { //创建新的结点，以当前根结点的值 Node newNode = new Node(value); //把新的结点的右子树设置成当前结点的右子树 newNode.right = right; //把新的结点的左子树设置成根结点的左子树的右子树 newNode.left = left.right; //把当前结点的值设置成左子结点的值 value = left.value; //把当前结点的的左子树设置成当前结点的左子树的左子树 left = left.left; //把当前结点的右子树(右子结点)设置成新的结点 right = newNode; } 应用案例-双旋转 前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转 不能完成平衡二叉树的转换。比如数列int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树.int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL 树 问题分析 解决思路分析 当符号右旋转的条件时 如果根结点的左子树的右子树高度大于它的左子树的左子树的高度 先对当前这个根结点的左节点进行左旋转 再对当前根结点进行右旋转的操作即可 package Tree.AVL_Tree; public class AVL_TreeDemo { public static void main(String[] args) { // int[] arr = {4,3,6,5,7,8}; // int[] arr = { 10, 12, 8, 9, 7, 6 }; int[] arr = {10, 11, 7, 6, 8, 9, 22, 3, 2}; AVLTree avlTree = new AVLTree(); for (int i = 0; i &lt; arr.length; i++) { avlTree.add(new Node(arr[i])); } System.out.println(\"树的高度为\" + avlTree.getRoot().getHeight()); System.out.println(\"左子树的高度为\" + avlTree.getRoot().getLeftHeight()); System.out.println(\"右子树的高度为\" + avlTree.getRoot().getRightHeight()); avlTree.delNode(9); avlTree.delNode(11); avlTree.delNode(22); //这里树会变成不平衡 avlTree.add(new Node(4)); //加上一个节点，树就会双旋转自己平衡 System.out.println(\"树的高度为\" + avlTree.getRoot().getHeight()); System.out.println(\"左子树的高度为\" + avlTree.getRoot().getLeftHeight()); System.out.println(\"右子树的高度为\" + avlTree.getRoot().getRightHeight()); } } //创建二叉排序树 class AVLTree { private Node root; public Node getRoot() { return root; } //添加结点的方法 public void add(Node node) { if (root == null) { root = node;//如果root为空则直接让root指向node } else { root.add(node); } } //中序遍历 public void infixOrder() { if (root == null) { System.out.println(\"树为空\"); } else { root.infixOrder(); } } //找到要删除的结点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } //找到要删除的结点的父结点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } //编写方法: //1. 返回的 以node 为根结点的二叉排序树的最小结点的值 //2. 删除node 为根结点的二叉排序树的最小结点 /** * @param node 传入的结点(当做二叉排序树的根结点) * @return 返回的 以node 为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) { Node target = node; //循环的查找左子节点，就会找到最小值 while (target.left != null) { target = target.left; } //这时 target就指向了最小结点 //删除最小结点 delNode(target.value); return target.value; } //删除结点 public void delNode(int value) { if (root == null) { return; } //1.需求先去找到要删除的结点 targetNode Node targetNode = search(value); if (targetNode == null) { return; } //如果我们发现当前这颗二叉排序树只有一个结点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } //去找到targetNode的父结点 Node parent = searchParent(value); //如果要删除的结点是叶子结点 if (targetNode.right == null &amp;&amp; targetNode.left == null) { //判断targetNode 是父结点的左子结点，还是右子结点 if (parent.left != null &amp;&amp; parent.left.value == value) {//是左子结点 parent.left = null; } else if (parent.right != null &amp;&amp; value == parent.right.value) {//是右子节点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) {//删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal;//删除右子树最小结点，然后把最小结点值赋给targetNode } else {// 删除只有一颗子树的结点 if (targetNode.left != null) {//只有左子树 if (parent != null) { //如果 targetNode 是 parent 的左子结点 if (parent.left != null &amp;&amp; parent.left.value == targetNode.value) { parent.left = targetNode.left; } else {// targetNode 是 parent 的右子结点 parent.right = targetNode.left; } } else {//没有父结点,也就是树只有root结点和一个子节点 root = targetNode.left; } } else {//只有右子树 if (parent != null) { //如果 targetNode 是 parent 的左子结点 if (parent.left != null &amp;&amp; parent.left.value == targetNode.value) { parent.left = targetNode.right; } else {//如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right; } } else { root = targetNode.right; } } } } } class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } @Override public String toString() { return \"Node{\" + \"value=\" + value + '}'; } //获取左子树的高度 public int getLeftHeight() { if (left == null) { return 0; } return left.getHeight(); } //获取右子树的高度 public int getRightHeight() { if (right == null) { return 0; } return right.getHeight(); } //获取当前结点为根结点的树的高度 public int getHeight() {//每一层加一 return Math.max(left == null ? 0 : left.getHeight(), right == null ? 0 : right.getHeight()) + 1; } //左旋转方法 public void leftRotate() { //创建新的结点，以当前根结点的值 Node newNode = new Node(this.value); //把新的结点的左子树设置成当前结点的左子树 newNode.left = this.left; //把新的结点的右子树设置成根结点的右子树的左子树 newNode.right = this.right.left; //把当前结点的值替换成右子结点的值 this.value = right.value; //把当前结点的右子树设置成当前结点右子树的右子树 this.right = this.right.right; //把当前结点的左子树(左子结点)设置成新的结点 this.left = newNode; } //右旋转 public void rightRotate() { //创建新的结点，以当前根结点的值 Node newNode = new Node(value); //把新的结点的右子树设置成当前结点的右子树 newNode.right = right; //把新的结点的左子树设置成根结点的右子树的左子树 newNode.left = left.right; //把当前结点的值设置成左子结点的值 value = left.value; //把当前结点的的左子树设置成当前结点的左子树的左子树 left = left.left; //把当前结点的右子树(右子结点)设置成新的结点 right = newNode; } //查找要删除的结点 /** * @param value 希望删除的结点的值 * @return 如果找到返回该结点，否则返回null */ public Node search(int value) { if (value == this.value) {//刚好是要找的结点 return this; } else if (value &lt; this.value) {//如果查找的值小于当前结点，向左子树递归查找 if (this.left == null) {//如果左子结点为空 return null; } return this.left.search(value); } else {//如果查找的值不小于当前结点，向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } //查找要删除结点的父结点 /** * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点，如果没有就返回null */ public Node searchParent(int value) { //如果当前结点就是要删除的结点的父结点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { //如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空 if (this.left != null &amp;&amp; value &lt; this.value) { return left.searchParent(value);//向左子树递归查找 } else if (this.right != null &amp;&amp; value &gt;= this.value) { return right.searchParent(value);//向右子树递归查找 } else {//当前结点不是要找的结点，并且左右子结点都为空 return null;// 没有找到父结点 } } } //添加节点 public void add(Node node) { if (node == null) { return; } //判断传入的结点的值，和当前子树的根结点的值关系 if (node.value &lt; this.value) { if (left == null) {//如果当前结点左子结点为null left = node; } else { //递归的向左子树添加 left.add(node); } } else {//添加的结点的值大于等于 当前结点的值 if (right == null) { right = node; } else { //递归的向右子树添加 right.add(node); } } //当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转 //这里的 this 是根结点 root if (this.getRightHeight() - this.getLeftHeight() &gt; 1) { //如果它的右子树的左子树的高度大于它的右子树的右子树的高度 if (right != null &amp;&amp; right.getLeftHeight() &gt; right.getRightHeight()) { //先对右子结点进行右旋转 right.rightRotate(); //再对根结点进行左旋转 this.leftRotate(); } else {//直接进行左旋转即可 this.leftRotate(); } return; //必须要！！！，可以省略下面代码的运行，节约资源 } //当添加完一个结点后，如果: (左子树的高度-右子树的高度) &gt; 1 ,右旋转 if (getLeftHeight() - getRightHeight() &gt; 1) { //如果根结点的左子树的右子树高度大于它的左子树的左子树的高度 if (left != null &amp;&amp; left.getRightHeight() &gt; left.getLeftHeight()) { //先对左子结点进行左旋转 left.leftRotate(); //再对根结点进行右旋转 this.rightRotate(); } else { //直接进行右旋转 rightRotate(); } } } //中序遍历 public void infixOrder() { if (left != null) { left.infixOrder(); } System.out.println(this); if (right != null) { right.infixOrder(); } } } 多路查找树二叉树与 B 树 二叉树的问题分析 二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树 二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)， 就存在如下问题: 问题 1：在构建二叉树时，需要多次进行 i/o 操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时， 速度有影响 问题 2：节点海量，也会造成二叉树的高度很大，会降低操作速度 多叉树 在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree） 后面我们讲解的 2-3 树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。 举例说明(下面 2-3 树就是一颗多叉树) B 树的基本介绍 B 树通过重新组织节点，降低树的高度，并且减少 i/o 读写次数来提升效率。 如图 B 树通过重新组织节点， 降低了树的高度. 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为 4k)， 这样每个节点只需要一次 I/O 就可以完全载入 将树的度 M 设置为 1024，在 600 亿个元素中最多只需要 4 次 I/O 操作就可以读取到想要的元素, B 树(B+)广泛应用于文件存储系统以及数据库系统中 2-3 树 2-3 树是最简单的 B 树结构, 具有如下特点: 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点. 2-3 树是由二节点和三节点构成的树。 2-3 树应用案例 将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序。(演示一下构建 2-3树的过程.) 插入规则: 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面 3 个条件。 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则 其它说明 除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图: B 树、B+树和 B*树 B 树的介绍 B-tree 树即 B 树，B 即 Balanced，平衡的意思。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树是一种树，而 B 树又是另一种树。实际上，B-tree 就是指的 B 树。 前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图: 对上图的说明: B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4 B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据. 搜索有可能在非叶子结点结束 其搜索性能等价于在关键字全集内做一次二分查找 B+树的介绍 B+树是 B 树的变体，也是一种多路搜索树。 对上图的说明: B+树的搜索与 B 树也基本相同，区别是 B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。 不可能在非叶子结点命中 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层 更适合文件索引系统 B 树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然. B*树的介绍 B*树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针。  B*树的说明: B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为 2/3，而 B+树的块的最低使用率为的 1/2。 从第 1 个特点我们可以看出，B*树分配新结点的概率比 B+树要低，空间使用率更高 图 为什么要有图 前面我们学了线性表和树 线性表局限于一个直接前驱和一个直接后继的关系 树也只能有一个直接前驱也就是父节点 当我们需要表示多对多的关系时， 这里我们就用到了图。 图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为 顶点。如图： 图的常用概念 顶点(vertex) 边(edge) 路径 无向图(右图) 有向图 带权图 图的表示方式 图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。 邻接矩阵 邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1….n 个点。 邻接表 邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失. 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成 举例说明 图的快速入门案例 要求: 代码实现如下图结构 思路分析 (1) 存储顶点 String 使用 ArrayList (2) 保存矩阵 int[][] edges //添加节点 public void insertVertex(String vertex) { vertexList.add(vertex); } //添加边 /** * @param v1 表示点的下标即使第几个顶点 \"A\"-\"B\" \"A\"-&gt;0 \"B\"-&gt;1 * @param v2 第二个顶点对应的下标 * @param weight 表示 */ public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; } 深度优先遍历 图遍历介绍 所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)深度优先遍历 (2)广度优先遍历 深度优先遍历基本思想 图的深度优先搜索(Depth First Search) 。 深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解： 每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。 显然，深度优先搜索是一个递归的过程 深度优先遍历算法步骤 访问初始结点 v，并标记结点 v 为已访问。 查找结点 v 的第一个邻接结点 w。 若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续。 若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤 123）。 查找结点 v 的 w 邻接结点的下一个邻接结点，转到步骤 3。 分析图 //深度优先遍历算法 //i 第一次就是 0 public void dfs(boolean[] isVisited, int i) { //首先我们访问该结点,输出 System.out.print(getValueByIndex(i) + \"-&gt;\"); //将结点设置为已经访问 isVisited[i] = true; //查找结点i的第一个邻接结点w int w = getFirstNeighbor(i); while (w != -1) {//说明有 if (!isVisited[w]) {//如果w结点没有被访问过 dfs(isVisited, w); } //如果w结点已经被访问过，返回前一个结点查找下一个邻接点 w = getNextNeighbor(i, w); } } //对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs public void dfs() { isVisited = new boolean[vertexList.size()]; //遍历所有的结点，进行dfs[回溯] for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { dfs(isVisited, i); } } } 广度优先遍历 广度优先遍历基本思想 图的广度优先搜索(Broad First Search) 。 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点 广度优先遍历算法步骤 访问初始结点 v 并标记结点 v 为已访问。 结点 v 入队列 当队列非空时，继续执行，否则算法结束。 出队列，取得队头结点 u。 查找结点 u 的第一个邻接结点 w。 若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤： ​ 6.1 若结点 w 尚未被访问，则访问结点 w 并标记为已访问。 ​ 6.2 结点 w 入队列 ​ 6.3 查找结点 u 的继 w 邻接结点后的下一个邻接结点 w，转到步骤 6。 //广度优先遍历算法 public void bfs(boolean[] isVisited, int i) { int u;// 表示队列的头结点对应下标 int w;// 邻接结点w下标 //队列，记录结点访问的顺序 LinkedList queue = new LinkedList(); //访问结点，输出结点信息 System.out.print(getValueByIndex(i) + \"=&gt;\"); //标记为已访问 isVisited[i] = true; //将结点加入队列 queue.addLast(i); while (!queue.isEmpty()) { //取出队列的头结点下标 u = (int) queue.removeFirst(); //得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while (w != -1) {//找到 //是否访问过 if (!isVisited[w]) { System.out.print(getValueByIndex(w) + \"=&gt;\"); //标记已经访问 isVisited[w] = true; //入队 queue.addLast(w); } //以u为前驱点，找w后面的下一个邻结点 w = getNextNeighbor(u, w);//体现出我们的广度优先 } } } //遍历所有的结点，都进行广度优先搜索 public void bfs() { isVisited = new boolean[vertexList.size()]; for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { bfs(isVisited, i); } } } 图的深度优先 VS 广度优先 图的代码汇总package Graph; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; public class Graph{ private ArrayList&lt;String&gt; vertexList;//存储顶点集合 private int[][] edges;//存储图对应的邻结矩阵 private int numOfEdges; //表示边的数目 //定义给数组boolean[], 记录某个结点是否被访问 private boolean[] isVisited; public static void main(String[] args) { int n = 8; //结点的个数 // String Vertexs[] = {\"A\", \"B\", \"C\", \"D\", \"E\"}; String Vertexs[] = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; //创建图对象 Graph graph = new Graph(n); //循环的添加顶点 for(String vertex: Vertexs) { graph.insertVertex(vertex); } //添加边 //A-B A-C B-C B-D B-E // graph.insertEdge(0, 1, 1); // A-B // graph.insertEdge(0, 2, 1); // // graph.insertEdge(1, 2, 1); // // graph.insertEdge(1, 3, 1); // // graph.insertEdge(1, 4, 1); // //更新边的关系 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); //显示一把邻结矩阵 graph.showGraph(); System.out.println(\"进行深度优先遍历\"); graph.dfs(); System.out.println(); System.out.println(\"进行广度优先遍历\"); graph.bfs(); } public Graph(int n) { //初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;&gt;(n); numOfEdges = 0; } //得到第一个邻接结点的下标 w public int getFirstNeighbor(int index) { for (int j = 0; j &lt; vertexList.size(); j++) { if (edges[index][j] &gt; 0) { return j; } } return -1; } //根据前一个邻接结点的下标来获取下一个邻接结点 public int getNextNeighbor(int v1, int v2) { for (int j = v2 + 1; j &lt; vertexList.size(); j++) { if (edges[v1][j] &gt; 0) { return j; } } return -1; } //广度优先遍历算法 public void bfs(boolean[] isVisited, int i) { int u;// 表示队列的头结点对应下标 int w;// 邻接结点w下标 //队列，记录结点访问的顺序 LinkedList queue = new LinkedList(); //访问结点，输出结点信息 System.out.print(getValueByIndex(i) + \"=&gt;\"); //标记为已访问 isVisited[i] = true; //将结点加入队列 queue.addLast(i); while (!queue.isEmpty()) { //取出队列的头结点下标 u = (int) queue.removeFirst(); //得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while (w != -1) {//找到 //是否访问过 if (!isVisited[w]) { System.out.print(getValueByIndex(w) + \"=&gt;\"); //标记已经访问 isVisited[w] = true; //入队 queue.addLast(w); } //以u为前驱点，找w后面的下一个邻结点 w = getNextNeighbor(u, w);//体现出我们的广度优先 } } } //遍历所有的结点，都进行广度优先搜索 public void bfs() { isVisited = new boolean[vertexList.size()]; for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { bfs(isVisited, i); } } } //深度优先遍历算法 //i 第一次就是 0 public void dfs(boolean[] isVisited, int i) { //首先我们访问该结点,输出 System.out.print(getValueByIndex(i) + \"-&gt;\"); //将结点设置为已经访问 isVisited[i] = true; //查找结点i的第一个邻接结点w int w = getFirstNeighbor(i); while (w != -1) {//说明有 if (!isVisited[w]) {//如果w结点没有被访问过 dfs(isVisited, w); } //如果w结点已经被访问过，返回前一个结点查找下一个邻接点 w = getNextNeighbor(i, w); } } //对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs public void dfs() { isVisited = new boolean[vertexList.size()]; //遍历所有的结点，进行dfs[回溯] for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { dfs(isVisited, i); } } } //返回图的节点数目 public int getNumOfVertex() { return vertexList.size(); } //显示图对应的矩阵 public void showGraph() { for(int[] link : edges) { System.err.println(Arrays.toString(link)); } } //返回结点i(下标)对应的数据 0-&gt;\"A\" 1-&gt;\"B\" 2-&gt;\"C\" public String getValueByIndex(int i) { return vertexList.get(i); } //返回v1和v2的权值 public int getWeight(int v1, int v2) { return edges[v1][v2]; } //得到边的数目 public int getNumOfEdges() { return numOfEdges; } //添加节点 public void insertVertex(String vertex) { vertexList.add(vertex); } //添加边 /** * @param v1 表示点的下标即使第几个顶点 \"A\"-\"B\" \"A\"-&gt;0 \"B\"-&gt;1 * @param v2 第二个顶点对应的下标 * @param weight 表示 */ public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; } } 二分查找算法(非递归) 二分查找算法(非递归)介绍 前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间 O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n 步，假设从[0,99]的 队列(100 个数，即 n=100)中寻到目标数 30，则需要查找步数为㏒₂100 , 即最多需要查找 7 次( 2^6 &lt; 100 &lt; 2^7) package BinarySearchNoRecursion; public class BinarySearchNoRecursion { public static void main(String[] args) { //测试 int[] arr = {1,3, 8, 10, 11, 67, 100}; int index = binarySearch(arr, 100); System.out.println(\"index=\" + index);// 6 } //二分查找的非递归实现 /** * * @param arr 被查找的数组 * @param target 要找的值 * @return 找到的话返回下标，没有返回-1 */ public static int binarySearch(int[] arr, int target) { int left = 0; int right = arr.length - 1; while (left &lt;= right) { //说明可以继续查找 int mid = (left + right) / 2; if (arr[mid] == target) { return mid; } else if (arr[mid] &gt; target) { right = mid - 1;//需要向左边查找 } else { left = mid + 1;//需要向右边查找 } } return -1; } } 分治算法 分治算法介绍 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)…… 分治算法可以求解的一些经典问题 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 分治算法的基本步骤 分治法在每一层递归上都有三个步骤： 1) 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题 2) 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 3) 合并：将各个子问题的解合并为原问题的解。 分治算法最佳实践-汉诺塔  汉诺塔游戏的演示和思路分析: 如果是有一个盘， A-&gt;C 如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘 先把 最上面的盘 A-&gt;B 把最下边的盘 A-&gt;C 把 B 塔的所有盘 从 B-&gt;C package DivideAndConquer; public class DivideAndConquer { public static void main(String[] args) { HanoiTower(4, 'A', 'B', 'C'); } //汉诺塔的移动的方法 //使用分治算法 public static void HanoiTower(int num, char a, char b, char c) { //如果只有一个盘 if (num == 1) { System.out.println(\"第1个盘从 \" + a + \"-&gt;\" + c); } else { //如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘 //1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c HanoiTower(num - 1, a, c, b); //2. 把最下边的盘 A-&gt;C System.out.println(\"第\" + num + \"个盘从 \" + a + \"-&gt;\" + c); //3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔 HanoiTower(num - 1, b, a, c); } } } 动态规划算法 动态规划算法介绍 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 ) 动态规划可以通过填表的方式来逐步推进，得到最优解. 应用场景-背包问题 背包问题：有一个背包，容量为 4 磅 ， 现有如下物品 要求达到的目标为装入的背包的总价值最大，并且重量不超出 要求装入的物品不能重复 思路分析和图解 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分 01 背包和完全背包(完全背包指的是：每种物品都有无限件可用) 这里的问题属于 01 背包，即每个物品最多放一个。而无限背包可以转化为 01 背包。 算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w[i]和 v[i]来确定是否需要将该物品放入背包中。即对于给定的 n 个物品，设 v[i]、w[i]分别为第 i 个物品的价值和重量，C 为背包的容量。再令 v[i] [j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。则我们有下面的结果： (1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是 0 (2) 当 w[i]&gt; j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个 单元格的装入策略 (3) 当 j&gt;=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} // 当 准备加入的新增的商品的容量小于等于当前背包的容量, // 装入的方式: v[i-1][j]： 就是上一个单元格的装入的最大值 v[i] : 表示当前商品的价值 v[i-1][j-w[i]] ： 装入 i-1 商品，到剩余空间 j-w[i]的最大值 当 j&gt;=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} : 图解的分析 package Dynamic; public class KnapsackProblem { public static void main(String[] args) { int[] w = {1, 4, 3};//物品的重量 int[] val = {1500, 3000, 2000}; //物品的价值 这里val[i] 就是前面讲的v[i] int m = 4; //背包的容量 int n = val.length; //物品的个数 //创建二维数组， //v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值 int[][] v = new int[n + 1][m + 1]; //为了记录放入商品的情况，我们定一个二维数组 int[][] path = new int[n + 1][m + 1]; //初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0 for (int i = 0; i &lt; v.length; i++) { v[i][0] = 0;//将第一列设置为0 } for (int i = 0; i &lt; v[0].length; i++) { v[0][i] = 0; //将第一行设置0 } //根据前面得到公式来动态规划处理 for (int i = 1; i &lt; v.length; i++) {//不处理第一行 i是从1开始的 for (int j = 1; j &lt; v[0].length; j++) {//不处理第一列, j是从1开始的 //公式 if(w[i-1]&gt; j) { // 因为我们程序i 是从0开始的，因此原来公式中的 w[i] 修改成 w[i-1] v[i][j]=v[i-1][j]; } else { //说明: //v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} //因为我们的i 从0开始的， 因此公式需要调整成 //v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]); //为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式 if (v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]) { v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]]; //把当前的情况记录到path ,对应背包容量对应商品的最优方案 path[i][j] = 1; } else { v[i][j] = v[i - 1][j]; } } } } //输出一下v 看看目前的情况 for(int i =0; i &lt; v.length;i++) { for(int j = 0; j &lt; v[i].length;j++) { System.out.print(v[i][j] + \" \"); } System.out.println(); } System.out.println(\"============================\"); //输出最后我们是放入的哪些商品 //遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入 // for(int i = 0; i &lt; path.length; i++) { // for(int j=0; j &lt; path[i].length; j++) { // if(path[i][j] == 1) { // System.out.printf(\"第%d个商品放入到背包\\n\", i); // } // } // } int i = path.length - 1;//行的最大下标 int j = path[0].length - 1; //列的最大下标 while (i &gt;= 0 &amp;&amp; j &gt;= 0) {//从path的最后开始找 if (path[i][j] == 1) { System.out.printf(\"第%d个商品放入到背包\\n\", i); j = j - w[i - 1];//剩余的空间 } i--;//向前扫描 } } } KMP 算法 字符串匹配问题  字符串匹配问题： 有一个字符串 str1= “”硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好””，和一个子串 str2=”尚硅谷你尚硅你” 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 暴力匹配算法如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有: 如果当前字符匹配成功（即 str1[i] == str2[j]），则 i++，j++，继续匹配下一个字符 如果失配（即 str1[i]! = str2[j]），令 i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0。 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!) 暴力匹配算法实现 package KMP; public class ViolenceMatch { public static void main(String[] args) { //测试暴力匹配算法 String str1 = \"硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好\"; String str2 = \"尚硅谷你尚硅你\"; int index = violenceMatch(str1, str2); System.out.println(\"index=\" + index); } //暴力匹配算法 public static int violenceMatch(String str1, String str2) { char[] s1 = str1.toCharArray(); char[] s2 = str2.toCharArray(); int s1Len = s1.length; int s2Len = s2.length; int i = 0;// i索引指向s1 int j = 0;// j索引指向s2 while (i &lt; s1Len &amp;&amp; j &lt; s2Len) {// 保证匹配时，不越界 if (s1[i] == s2[j]) {//匹配ok,后移 i++; j++; } else {//没有匹配成功 //如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。 i = i - (j - 1); j = 0; } } //判断是否匹配成功 if (j == s2Len) { return i - j; } else { return -1; } } } KMP 算法介绍 KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法 Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法. KMP 方法算法就利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间 参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html KMP 算法最佳应用-字符串匹配问题  字符串匹配问题：： 有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=”ABCDABD” 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 要求：使用 KMP 算法完成判断，不能使用简单的暴力匹配算法  思路分析图解 举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”？ ​ 1.首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位​ 重复第一步，还是不符合，再后移 一直重复，直到 Str1 有一个字符与 Str2 的第一个字符符合为止 接着比较字符串和搜索词的下一个字符，还是符合。 遇到 Str1 有一个字符与 Str2 对应的字符不符合。 这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步。(其实是很不明智的，因为此时 BCD 已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。 KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。) 怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍 .已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分匹配值”为 2，因此按照下面的公式算出向后移动的位数： 移动位数 = 已匹配的字符数 - 对应的部分匹配值 因为 6 - 2 等于 4，所以将搜索词向后移动 4 位。 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2（”AB”），对应的”部分匹配值”为 0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移 2 位。 因为空格与 A 不匹配，继续后移一位。 逐位比较，直到发现 C 与 D 不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位。 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。 .介绍《部分匹配表》怎么产生的 先介绍前缀，后缀是什么 “部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， －”A”的前缀和后缀都为空集，共有元素的长度为 0； －”AB”的前缀为[A]，后缀为[B]，共有元素的长度为 0； －”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度 0； －”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为 0； －”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为 1； －”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为 2； －”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为 0。 ”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是 2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动 4 位（字符串长度- 部分匹配值），就可以来到第二个”AB”的位置。 到此 KMP 算法思想分析完毕! package KMP; import java.util.Arrays; public class KMPAlgorithm { public static void main(String[] args) { String str1 = \"BBC ABCDAB ABCDABCDABDE\"; String str2 = \"ABCDABD\"; //String str2 = \"BBC\"; int[] next = kmpNext(\"ABCDABD\"); //[0, 0, 0, 0, 1, 2, 0] System.out.println(\"next=\" + Arrays.toString(next)); int index = kmpSearch(str1, str2, next); System.out.println(\"index=\" + index); // 15了 } //写出我们的kmp搜索算法 /** * * @param str1 源字符串 * @param str2 子串 * @param next 部分匹配表, 是子串对应的部分匹配表 * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置 */ public static int kmpSearch(String str1, String str2, int[] next) { //遍历 for (int i = 0, j = 0; i &lt; str1.length(); i++) { //需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小 //KMP算法核心点, 可以验证... while (j &gt; 0 &amp;&amp; str1.charAt(i) != str2.charAt(j)) { j = next[j - 1]; } if (str1.charAt(i) == str2.charAt(j)) { j++; } if (j == str2.length()) {//找到了 return i - j + 1; } } return -1; } //获取到一个字符串(子串) 的部分匹配值表 public static int[] kmpNext(String dest) { //创建一个next 数组保存部分匹配值 int[] next = new int[dest.length()]; next[0] = 0;//如果字符串是长度为1 部分匹配值就是0 for (int i = 1, j = 0; i &lt; next.length; i++) { //当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j //直到我们发现 有 dest.charAt(i) == dest.charAt(j)成立才退出 //这是kmp算法的核心点 while (j &gt; 0 &amp;&amp; dest.charAt(i) != dest.charAt(j)) { j = next[j - 1]; } //当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就+1 if (dest.charAt(i) == dest.charAt(j)) { j++; } next[i] = j; } return next; } } 贪心算法 贪心算法介绍 贪婪算法(贪心算法)是指在对问题进行求解时，*在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果 贪心算法最佳应用-集合覆盖 假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号 思路分析:  如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有 n 个广播台，则广播台的组合总共有 2ⁿ -1 个,假设每秒可以计算 10 个子集， 如图:  使用贪婪算法，效率高: 目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合: 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） 将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。 重复第 1 步直到覆盖了全部的地区 分析的图解: package Greedy; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; public class GreedyAlgorithm { public static void main(String[] args) { //创建广播电台,放入到Map HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = new HashMap&lt;&gt;(); //将各个电台放入到broadcasts HashSet&lt;String&gt; hashSet1 = new HashSet&lt;String&gt;(); hashSet1.add(\"北京\"); hashSet1.add(\"上海\"); hashSet1.add(\"天津\"); HashSet&lt;String&gt; hashSet2 = new HashSet&lt;String&gt;(); hashSet2.add(\"广州\"); hashSet2.add(\"北京\"); hashSet2.add(\"深圳\"); HashSet&lt;String&gt; hashSet3 = new HashSet&lt;String&gt;(); hashSet3.add(\"成都\"); hashSet3.add(\"上海\"); hashSet3.add(\"杭州\"); HashSet&lt;String&gt; hashSet4 = new HashSet&lt;String&gt;(); hashSet4.add(\"上海\"); hashSet4.add(\"天津\"); HashSet&lt;String&gt; hashSet5 = new HashSet&lt;String&gt;(); hashSet5.add(\"杭州\"); hashSet5.add(\"大连\"); //加入到map broadcasts.put(\"K1\", hashSet1); broadcasts.put(\"K2\", hashSet2); broadcasts.put(\"K3\", hashSet3); broadcasts.put(\"K4\", hashSet4); broadcasts.put(\"K5\", hashSet5); //allAreas 存放所有的地区 ArrayList&lt;String&gt; allAreas = new ArrayList&lt;&gt;(); allAreas.add(\"北京\"); allAreas.add(\"上海\"); allAreas.add(\"天津\"); allAreas.add(\"广州\"); allAreas.add(\"深圳\"); allAreas.add(\"成都\"); allAreas.add(\"杭州\"); allAreas.add(\"大连\"); //创建ArrayList, 存放选择的电台集合 ArrayList&lt;String&gt; selects = new ArrayList&lt;&gt;(); //定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集 HashSet&lt;String&gt; tempSet = new HashSet&lt;String&gt;(); //定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key //如果maxKey 不为null , 则会加入到 selects String maxKey = null; //遍历 broadcasts, 取出对应key while (allAreas.size() &gt; 0) {// 如果allAreas 不为0, 则表示还没有覆盖到所有的地区 //每进行一次while,需要 maxKey = null; for (String key : broadcasts.keySet()) { //每进行一次for,需要 tempSet.clear(); //当前这个key能够覆盖的地区 HashSet&lt;String&gt; areas = broadcasts.get(key); tempSet.addAll(areas); //求出tempSet 和 allAreas 集合的交集, 交集会赋给 tempSet tempSet.retainAll(allAreas); //如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多 //就需要重置maxKey // tempSet.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的 if (tempSet.size() &gt; 0 &amp;&amp; (maxKey == null || tempSet.size() &gt; broadcasts.get(maxKey).size())) { maxKey = key; } } //maxKey != null, 就应该将maxKey 加入selects if (maxKey != null) { selects.add(maxKey); //将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉 allAreas.removeAll(broadcasts.get(maxKey)); } } System.out.println(\"得到的选择结果是\" + selects);//[K1,K2,K3,K5] } } 普里姆算法 应用场景-修路问题  看一个应用场景和问题： 1) 有胜利乡有 7 个村庄(A, B, C, D, E, F, G)，现在需要修路把 7 个村庄连通 2) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 3) 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短? 思路: 将 10 条边，连接即可，但是总的里程数不是最小. 正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少. 最小生成树 修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称MST。 给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 1) N 个顶点，一定有 N-1 条边 2) 包含全部顶点 3) N-1 条边都在图中 4) 举例说明(如图:) 5) 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法 普里姆算法介绍 普利姆(Prim)算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有(n-1)条边包含所有 n 个顶点的连通子图，也就是所谓的极小连通子图 普利姆的算法如下: 设 G=(V,E)是连通网，T=(U,D)是最小生成树，V,U 是顶点集合，E,D 是边的集合 若从顶点 u 开始构造最小生成树，则从集合 V 中取出顶点 u 放入集合 U 中，标记顶点 v 的 visited[u]=1 若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点 vj 加入集合 U 中，将边（ui,vj）加入集合 D 中，标记 visited[vj]=1 重复步骤②，直到 U 与 V 相等，即所有顶点都被标记为访问过，此时 D 中有 n-1 条边 提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解. 图解普利姆算法 package Prim; import java.util.Arrays; public class Prim { public static void main(String[] args) { //测试看看图是否创建ok char[] data = new char[]{'A','B','C','D','E','F','G'}; int verxs = data.length; //邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通 int [][]weight=new int[][]{ {10000,5,7,10000,10000,10000,2}, {5,10000,10000,9,10000,10000,3}, {7,10000,10000,10000,8,10000,10000}, {10000,9,10000,10000,10000,4,10000}, {10000,10000,8,10000,10000,5,4}, {10000,10000,10000,4,5,10000,6}, {2,3,10000,10000,4,6,10000}}; //创建MGraph对象 Graph graph = new Graph(verxs); //创建一个MinTree对象 MinTree minTree = new MinTree(); minTree.createGraph(graph, verxs, data, weight); //输出 minTree.showGraph(graph); //测试普利姆算法 minTree.prim(graph, 0); } } //创建最小生成树-&gt;村庄的图 class MinTree { //创建图的邻接矩阵 /** * @param graph 图对象 * @param vertex 图的顶点数 * @param data 图的各个顶点的值 * @param weight 图的邻接矩阵 */ public void createGraph(Graph graph, int vertex, char[] data, int[][] weight) { for (int i = 0; i &lt; vertex; i++) { graph.data[i] = data[i]; for (int j = 0; j &lt; vertex; j++) { graph.weight[i][j] = weight[i][j]; } } } //显示图的邻接矩阵 public void showGraph(Graph graph) { for (int[] link : graph.weight) { System.out.println(Arrays.toString(link)); } } //普利姆算法,得到最小生成树 /** * @param graph 图 * @param v 表示从图的第几个顶点开始生成'A'-&gt;0 'B'-&gt;1... */ public void prim(Graph graph, int v) { //visited[] 标记结点(顶点)是否被访问过 int[] visited = new int[graph.vertex]; //visited[] 默认元素的值都是0, 表示没有访问过 // for(int i =0; i &lt;graph.verxs; i++) { // visited[i] = 0; // } //把当前这个结点标记为已访问 visited[v] = 1; //h1 和 h2 记录两个顶点的下标 int h1 = -1; int h2 = -1; int minWeight = 10000;//将 minWeight 初始成一个大数，后面在遍历过程中，会被替换 for (int k = 1; k &lt; graph.vertex; k++) {//因为有 graph.vertex 顶点，普利姆算法结束后，有 graph.vertex-1边 //这个是确定每一次生成的子图 ，和哪个结点的距离最近 for (int i = 0; i &lt; graph.vertex; i++) {// i结点表示被访问过的结点 for (int j = 0; j &lt; graph.vertex; j++) {//j结点表示还没有访问过的结点 //无论是否访问过的结点都会被遍历 if (visited[i] == 1 &amp;&amp; visited[j] == 0 &amp;&amp; graph.weight[i][j] &lt; minWeight) { //替换minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边) minWeight = graph.weight[i][j]; h1 = i; h2 = j; } } } //找到一条边是最小 System.out.println(\"边&lt;\" + graph.data[h1] + \",\" + graph.data[h2] + \"&gt; 权值:\" + minWeight); //将当前这个结点标记为已经访问 visited[h2] = 1; //minWeight 重新设置为最大值 10000 minWeight = 10000; } } } //图 class Graph { int vertex;//表示图的节点个数 char[] data;//存放结点数据 int[][] weight;//存放边，就是我们的邻接矩阵 public Graph(int num) { this.vertex = num; data = new char[num]; weight = new int[num][num]; } } 克鲁斯卡尔算法 克鲁斯卡尔算法介绍 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 基本思想：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路 具体做法：首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止 应用场景-公交站问题 看一个应用场景和问题： 某城市新增 7 个站点(A, B, C, D, E, F, G) ，现在需要修路把 7 个站点连通 各个站点的距离用边线表示(权) ，比如 A – B 距离 12 公里 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短? 克鲁斯卡尔算法图解说明 以城市公交站问题来图解说明 克鲁斯卡尔算法的原理和步骤： 在含有 n 个顶点的连通图中选择 n-1 条边，构成一棵极小连通子图，并使该连通子图中 n-1 条边上权值之和达到最小，则称其为连通网的最小生成树。 例如，对于如上图 G4 所示的连通网可以有多棵权值总和不相同的生成树。 以上图 G4 为例，来对克鲁斯卡尔进行演示(假设，用数组 R 保存最小生成树结果)。 第 1 步：将边&lt;E,F&gt;加入 R 中。 边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果 R 中。 第 2 步：将边&lt;C,D&gt;加入 R 中。 上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果 R 中。 第 3 步：将边&lt;D,E&gt;加入 R 中。 上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果 R 中。 第 4 步：将边&lt;B,F&gt;加入 R 中。 上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果 R 中。 第 5 步：将边&lt;E,G&gt;加入 R 中。 上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果 R 中。 第 6 步：将边&lt;A,B&gt;加入 R 中。 上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果 R 中。 此时，最小生成树构造完成！它包括的边依次是：**&lt;E,F&gt;，&lt;C,D&gt;，&lt;D,E&gt;，&lt;B,F&gt;，&lt;E,G&gt;，&lt;A,B&gt;。** 克 鲁 斯 卡 尔 算 法 分 析 根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题： 问题一 对图的所有边按照权值大小进行排序。 问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。 问题一很好解决，采用排序算法进行排序即可。 问题二，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。 如 何 判 断 是 否 构 成 回 路 在将&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt;加入到最小生成树 R 中之后，这几条边的顶点就都有了终点： (01) C 的终点是 F。(02) D 的终点是 F。(03) E 的终点是 F。(04) F 的终点是 F。 关于终点的说明：（加入最小生成树后才有终点） 就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点“。 因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是 C 和 E 的终点都是 F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路。【后面有代码说明】 package Kruskal; import java.util.Arrays; public class KruskalCase { private int edgeNum;//边的个数 private char[] vertexs;//顶点数组 private int[][] matrix;//邻接矩阵 //使用 INF 表示两个顶点不能连通 private static final int INF = Integer.MAX_VALUE; public static void main(String[] args) { char[] vertexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'}; //克鲁斯卡尔算法的邻接矩阵 int matrix[][] = { /*A*//*B*//*C*//*D*//*E*//*F*//*G*/ /*A*/ { 0, 12, INF, INF, INF, 16, 14}, /*B*/ { 12, 0, 10, INF, INF, 7, INF}, /*C*/ { INF, 10, 0, 3, 5, 6, INF}, /*D*/ { INF, INF, 3, 0, 4, INF, INF}, /*E*/ { INF, INF, 5, 4, 0, 2, 8}, /*F*/ { 16, 7, 6, INF, 2, 0, 9}, /*G*/ { 14, INF, INF, INF, 8, 9, 0}}; KruskalCase kruskalCase = new KruskalCase(vertexs, matrix); kruskalCase.print(); kruskalCase.kruskal(); } public KruskalCase(char[] vertexs, int[][] matrix) { //初始化顶点数和边的个数 int vlen = vertexs.length; //初始化顶点, 复制拷贝的方式 this.vertexs = new char[vlen]; for (int i = 0; i &lt; vlen; i++) { this.vertexs[i] = vertexs[i]; } //也可以直接赋值 // this.vertexs = vertexs; //初始化边, 使用的是复制拷贝的方式 this.matrix = new int[vlen][vlen]; for(int i = 0; i &lt; vlen; i++) { for(int j= 0; j &lt; vlen; j++) { this.matrix[i][j] = matrix[i][j]; } } //统计边数 for (int i = 0; i &lt; vlen; i++) { for (int j = 1 + i; j &lt; vlen; j++) { if (this.matrix[i][j] != INF) { edgeNum++; } } } } public void kruskal() { int index = 0;//表示最后结果数组的索引 int[] ends = new int[edgeNum];//用于保存\"已有最小生成树\" 中的每个顶点在最小生成树中的终点 //创建结果数组, 保存最后的最小生成树 EData[] rets = new EData[edgeNum]; //获取图中 所有的边的集合 ， 一共有12边 EData[] edges = getEdges(); System.out.println(\"图的边的集合=\" + Arrays.toString(edges) + \" 共\"+ edges.length); //12 //按照边的权值大小进行排序(从小到大) sortEdges(edges); //遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入 for (int i = 0; i &lt; edges.length; i++) { //获取到第i条边的第一个顶点(起点) int p1 = getPosition(edges[i].start);//p1=4 //获取到第i条边的第2个顶点 int p2 = getPosition(edges[i].end);//p2 = 5 //获取p1这个顶点在已有最小生成树中的终点 int m = getEnd(ends, p1); //m = 4 //获取p2这个顶点在已有最小生成树中的终点 int n = getEnd(ends, p2); // n = 5 //是否构成回路 if (m != n) { //没有构成回路 ends[m] = n; // 设置m 在\"已有最小生成树\"中的终点 &lt;E,F&gt; [0,0,0,0,5,0,0,0,0,0,0,0] rets[index++] = edges[i];//有一条边加入到rets数组 } } //&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。 //统计并打印 \"最小生成树\", 输出 rets System.out.println(\"最小生成树为\"); for(int i = 0; i &lt; index; i++) { System.out.println(rets[i]); } } //打印邻接矩阵 public void print() { for (int i = 0; i &lt; vertexs.length; i++) { for (int j = 0; j &lt; vertexs.length; j++) { System.out.printf(\"%12d\", matrix[i][j]); } System.out.println(); } } /** * 功能：对边进行排序处理, 冒泡排序 * @param edges 边的集合 */ private void sortEdges(EData[] edges) { for (int i = 0; i &lt; edges.length-1; i++) { for (int j = 0; j &lt; edges.length - 1 - i; j++) { if (edges[j].weight &gt; edges[j + 1].weight) { EData temp = edges[j]; edges[j] = edges[j + 1]; edges[j + 1] = temp; } } } } /** * * @param ch 顶点的值，比如'A','B' * @return 返回ch顶点对应的下标，如果找不到，返回-1 */ private int getPosition(char ch) { for (int i = 0; i &lt; vertexs.length; i++) { if (vertexs[i] == ch) { return i; } } //找不到,返回-1 return -1; } /** * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组 * 是通过matrix 邻接矩阵来获取 * EData[] 形式 [['A','B', 12], ['B','F',7], .....] * @return EData[] 数组 */ public EData[] getEdges() { int index = 0; EData[] edges = new EData[edgeNum]; for (int i = 0; i &lt; vertexs.length; i++) { for (int j = i + 1; j &lt; vertexs.length; j++) { if (matrix[i][j] != INF) { edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]); } } } return edges; } /** * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同 * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成 * @param i : 表示传入的顶点对应的下标 * @return 返回的就是 下标为i 的这个顶点对应的终点的下标, 一会回头还有来理解 */ private int getEnd(int[] ends, int i) { // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0] while (ends[i] != 0) {//顶点有终点 i = ends[i]; } return i; } } //创建一个类EData ，它的对象实例就表示一条边 class EData { char start; //边的一个点 char end; //边的另外一个点 int weight; //边的权值 public EData(char start, char end, int weight) { this.start = start; this.end = end; this.weight = weight; } @Override public String toString() { return \"EData [&lt;\" + start + \", \" + end + \"&gt;= \" + weight + \"]\"; } } 迪杰斯特拉算法 迪杰斯特拉(Dijkstra)算法介绍 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 迪杰斯特拉(Dijkstra)算法过程 设置出发顶点为 v，顶点集合 V{v1,v2,vi…}，v 到 V 中各顶点的距离构成距离集合 Dis，Dis{d1,d2,di…}，Dis 集合记录着 v 到图中各顶点的距离(到自身可以看作 0，v 到 vi 距离对应为 di) 从 Dis 中选择值最小的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 v 到 vi 即为最短路径 更新 Dis 集合，更新规则为：比较 v 到 V 集合中顶点的距离值，与 v 通过 vi 到 V 集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束 迪杰斯特拉(Dijkstra)算法最佳应用-最短路径 战争时期，胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 问：如何计算出 G 村庄到 其它各个村庄的最短距离? 如果从其它点出发到各个点的最短距离又是多少? 使用图解的方式分析了迪杰斯特拉(Dijkstra)算法 思路 package Dijkstra; import java.util.Arrays; public class Dijkstra { public static void main(String[] args) { char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' }; //邻接矩阵 int[][] matrix = new int[vertex.length][vertex.length]; final int N = 65535;// 表示不可以连接 matrix[0]=new int[]{N,5,7,N,N,N,2}; matrix[1]=new int[]{5,N,N,9,N,N,3}; matrix[2]=new int[]{7,N,N,N,8,N,N}; matrix[3]=new int[]{N,9,N,N,N,4,N}; matrix[4]=new int[]{N,N,8,N,N,5,4}; matrix[5]=new int[]{N,N,N,4,5,N,6}; matrix[6]=new int[]{2,3,N,N,4,6,N}; //创建 Graph对象 Graph graph = new Graph(vertex, matrix); //测试, 看看图的邻接矩阵是否ok graph.showGraph(); graph.dsj(6); graph.showDijkstra(); } } class Graph { private int[][] matrix; // 邻接矩阵 private char[] vertex; // 顶点数组 private VisitedVertex vv; //已经访问的顶点的集合 public Graph(char[] vertex, int[][] matrix) { this.vertex = vertex; this.matrix = matrix; } public void showGraph() { for (int[] link : matrix) { System.out.println(Arrays.toString(link)); } } public void showDijkstra() { vv.show(); } //迪杰斯特拉算法实现 /** * * @param index 表示出发顶点对应的下标 */ public void dsj(int index) { vv = new VisitedVertex(vertex.length, index); update(index); for (int i = 1; i &lt; vertex.length; i++) { index = vv.updateArr(); // 选择并返回新的访问顶点 update(index);//更新index下标顶点到周围顶点的距离（从开始点的距离）和周围顶点的前驱顶点, } } //更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点, public void update(int index) { int len = 0; //根据遍历我们的邻接矩阵的 matrix[index]行 for (int i = 0; i &lt; matrix[index].length; i++) { // len 含义是 : 出发顶点到index顶点的距离 + 从index顶点到i顶点的距离的和 len = vv.getDis(index) + matrix[index][i]; // 如果j顶点没有被访问过，并且 len 小于出发顶点到i顶点的距离，就需要更新 if (!vv.in(i) &amp;&amp; len &lt; vv.getDis(i)) { vv.updateDis(i, len);//更新出发顶点到 i 顶点的距离 vv.updatePre(i, index);//更新 i 顶点的前驱为index顶点 } } } } // 已访问顶点集合 class VisitedVertex { // 记录各个顶点是否访问过 1表示访问过,0未访问,会动态更新 public int[] already_arr; // 每个下标对应的值为前一个顶点下标, 会动态更新 public int[] pre_visited; // 记录出发顶点到其他所有顶点的距离,比如G为出发顶点，就会记录G到其它顶点的距离，会动态更新，求的最短距离就会存放到dis public int[] dis; //构造器 /** * @param length :表示顶点的个数 * @param index: 出发顶点对应的下标, 比如G顶点，下标就是6 */ public VisitedVertex(int length, int index) { this.already_arr = new int[length]; this.dis = new int[length]; this.pre_visited = new int[length]; //初始化 dis数组 Arrays.fill(dis, 65535); this.already_arr[index] = 1; //设置出发顶点被访问过 this.dis[index] = 0; //设置出发顶点的访问距离为0 } /** * 功能: 判断index顶点是否被访问过 * * @param index * @return 如果访问过，就返回true, 否则访问false */ public boolean in(int index) { return already_arr[index] == 1; } /** * 功能: 更新出发顶点到index顶点的距离 * @param index * @param len */ public void updateDis(int index, int len) { dis[index] = len; } /** * 功能: 更新pre这个顶点的前驱顶点为index顶点 * @param pre * @param index */ public void updatePre(int pre, int index) { pre_visited[pre] = index; } /** * 功能:返回出发顶点到index顶点的距离 * @param index */ public int getDis(int index) { return dis[index]; } /** * 继续选择并返回新的访问顶点， 比如这里的G 完后，就是 A点作为新的访问顶点(注意不是出发顶点) * @return */ public int updateArr() { int min = 65535, index = 0; //找到可以到达的还未被访问的距离最近的顶点 i for (int i = 0; i &lt; already_arr.length; i++) { if (already_arr[i] == 0 &amp;&amp; dis[i] &lt; min) { min = dis[i]; index = i; } } //更新 index 顶点被访问过 already_arr[index] = 1; return index; } public void show() { for (int link : already_arr) { System.out.print(link+\" \"); } System.out.println(); for (int link : pre_visited) { System.out.print(link+\" \"); } System.out.println(); for (int link : dis) { System.out.print(link+\" \"); } System.out.println(); //为了好看最后的最短距离，我们处理 char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' }; int count = 0; for (int i : dis) { if (i != 65535) { System.out.print(vertex[count] + \"(\"+i+\") \"); } else { System.out.println(\"N \"); } count++; } } } 弗洛伊德算法 弗洛伊德(Floyd)算法介绍 和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。 弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。 弗洛伊德(Floyd)算法图解分析 设置顶点 vi 到顶点 vk 的最短路径已知为 Lik，顶点 vk 到 vj 的最短路径已知为 Lkj，顶点 vi 到 vj 的路径为 Lij， 则 vi 到 vj 的最短路径为：min((Lik+Lkj),Lij)，vk 的取值为图中所有顶点，则可获得 vi 到 vj 的最短路径 至于 vi 到 vk 的最短路径 Lik 或者 vk 到 vj 的最短路径 Lkj，是以同样的方式获得 弗洛伊德(Floyd)算法图解分析-举例说明 示例：求最短路径为例说明 弗洛伊德算法的步骤： 第一轮循环中，以 A(下标为：0)作为中间顶点【即把 A 作为中间顶点的所有情况都进行遍历, 就会得到更新距离表 和 前驱关系】， 距离表和前驱关系更新为： 分析如下： 以 A 顶点作为中间顶点是，B-&gt;A-&gt;C 的距离由 N-&gt;9，同理 C 到 B；C-&gt;A-&gt;G 的距离由 N-&gt;12，同理 G 到 C 更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束 弗洛伊德(Floyd)算法最佳应用-最短路径 胜利乡有 7 个村庄(A, B, C, D, E, F, G) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 问：如何计算出各村庄到 其它各村庄的最短距离? 代码实现 package Floyd; import java.util.Arrays; public class Floyd { public static void main(String[] args) { // 测试看看图是否创建成功 char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' }; //创建邻接矩阵 int[][] matrix = new int[vertex.length][vertex.length]; final int N = 65535; matrix[0] = new int[] { 0, 5, 7, N, N, N, 2 }; matrix[1] = new int[] { 5, 0, N, 9, N, N, 3 }; matrix[2] = new int[] { 7, N, 0, N, 8, N, N }; matrix[3] = new int[] { N, 9, N, 0, N, 4, N }; matrix[4] = new int[] { N, N, 8, N, 0, 5, 4 }; matrix[5] = new int[] { N, N, N, 4, 5, 0, 6 }; matrix[6] = new int[] { 2, 3, N, N, 4, 6, 0 }; //创建 Graph 对象 Graph graph = new Graph(vertex.length, matrix, vertex); graph.floyd(); graph.show(); } } class Graph { private char[] vertex;// 存放顶点的数组 private int[][] dis;// 保存，从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组 private int[][] pre;// 保存到达目标顶点的前驱顶点 // 构造器 /** * @param length 大小 * @param matrix 邻接矩阵 * @param vertex 顶点数组 */ public Graph(int length,int[][] matrix,char[] vertex) { this.vertex = vertex; this.pre = new int[length][length]; this.dis = matrix; // 对pre数组初始化, 注意存放的是前驱顶点的下标 for (int i = 0; i &lt; length; i++) { Arrays.fill(pre[i], i); } } // 显示pre数组和dis数组 public void show() { //为了显示便于阅读，我们优化一下输出 char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' }; for (int k = 0; k &lt; dis.length; k++) { for (int i = 0; i &lt; pre[k].length; i++) { System.out.print(vertex[pre[k][i]]); } System.out.println(); for (int i = 0; i &lt; dis[k].length; i++) { System.out.print(\"(\" + vertex[k] + \"到\" + vertex[i] + \"的最短路径是\" + dis[k][i] + \")\"); } System.out.println(); System.out.println(); } } //弗洛伊德算法, 比较容易理解，而且容易实现 public void floyd() { int len = 0;//变量保存距离 //对中间顶点遍历， k 就是中间顶点的下标 [A, B, C, D, E, F, G] for (int k = 0; k &lt; dis.length; k++) { //从i顶点开始出发 [A, B, C, D, E, F, G] for (int i = 0; i &lt; dis.length; i++) { //到达j顶点 // [A, B, C, D, E, F, G] for (int j = 0; j &lt; dis.length; j++) { len = dis[i][k] + dis[k][j];// =&gt; 求出从i 顶点出发，经过 k中间顶点，到达 j 顶点距离 if (len &lt; dis[i][j]) {//如果len小于 dis[i][j] dis[i][j] = len;//更新距离 pre[i][j] = pre[k][j];//更新前驱顶点 } } } } } } 马踏棋盘算法 马踏棋盘算法介绍和游戏演示 马踏棋盘算法也被称为骑士周游问题 将马随机放在国际象棋的 8×8 棋盘 Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部 64 个方格 游戏演示: http://www.4399.com/flash/146267_2.htm 马踏棋盘游戏代码实现 马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… ，思路分析+代码 实现  对第一种实现方式的思路图解 分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题. 使用前面的游戏来验证算法是否正确。 代码实现 package HorseChessboard; import java.awt.*; import java.util.ArrayList; import java.util.Comparator; public class HorseChessboard { public static int X;// 棋盘的列数 public static int Y;// 棋盘的行数 //创建一个数组，标记棋盘的各个位置是否被访问过 public static boolean[] visited; //使用一个属性，标记是否棋盘的所有位置都被访问 private static boolean finished; // 如果为true,表示成功 public static void main(String[] args) { System.out.println(\"骑士周游算法，开始运行~~\"); //测试骑士周游算法是否正确 X = 8; Y = 8; int row = 1; //马儿初始位置的行，从1开始编号 int column = 1; //马儿初始位置的列，从1开始编号 //创建棋盘 int[][] chessboard = new int[X][Y]; visited = new boolean[X * Y];//初始值都是false //测试一下耗时 long start = System.currentTimeMillis(); traversalChessboard(chessboard, row - 1, column - 1, 1); long end = System.currentTimeMillis(); System.out.println(\"共耗时: \" + (end - start) + \" 毫秒\"); //输出棋盘的最后情况 for(int[] rows : chessboard) { for(int step: rows) { System.out.print(step + \"\\t\"); } System.out.println(); } } /** * 完成骑士周游问题的算法 * @param chessboard 棋盘 * @param row 马儿当前的位置的行 从0开始 * @param column 马儿当前的位置的列 从0开始 * @param step 是第几步 ,初始位置就是第1步 */ public static void traversalChessboard(int[][] chessboard, int row, int column, int step) { chessboard[row][column] = step;//标记步数 //row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36 visited[row * X + column] = true;//标记该位置已经访问 //获取当前位置可以走的下一个位置的集合 ArrayList&lt;Point&gt; ps = next(new Point(column, row)); //对ps进行排序,排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序 sort(ps); while (!ps.isEmpty()) { Point p = ps.remove(0);//取出下一个可以走的位置 //判断该点是否已经访问过 if (!visited[p.y * X + p.x]) {//说明还没有访问过 traversalChessboard(chessboard, p.y, p.x, step + 1); } } //判断马儿是否完成了任务，使用 step 和应该走的步数比较 ， //如果没有达到数量，则表示没有完成任务，将整个棋盘置0 //说明: step &lt; X * Y 成立的情况有两种 //1. 棋盘到目前位置,仍然没有走完 //2. 棋盘处于一个回溯过程 if (step &lt; X * Y &amp;&amp; !finished) { chessboard[row][column] = 0; visited[row * X + column] = false; } else { finished = true; } } /** * 功能： 根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)，并放入到一个集合中(ArrayList), 最多有8个位置 * * @param curPoint 当前点 * @return 马儿在当前位置能走的所有点的集合 */ public static ArrayList&lt;Point&gt; next(Point curPoint) { //创建一个ArrayList ArrayList&lt;Point&gt; ps = new ArrayList&lt;Point&gt;(); //创建一个Point Point p1 = new Point(); //表示马儿可以走5这个位置 if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) { ps.add(new Point(p1)); } //判断马儿可以走6这个位置 if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) { ps.add(new Point(p1)); } //判断马儿可以走7这个位置 if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) { ps.add(new Point(p1)); } //判断马儿可以走0这个位置 if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) { ps.add(new Point(p1)); } //判断马儿可以走1这个位置 if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) { ps.add(new Point(p1)); } //判断马儿可以走2这个位置 if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) { ps.add(new Point(p1)); } //判断马儿可以走3这个位置 if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) { ps.add(new Point(p1)); } //判断马儿可以走4这个位置 if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) { ps.add(new Point(p1)); } return ps; } //根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数 public static void sort(ArrayList&lt;Point&gt; ps) { ps.sort(new Comparator&lt;Point&gt;() { @Override public int compare(Point o1, Point o2) { //获取到o1的下一步的所有位置个数 int count1 = next(o1).size(); //获取到o2的下一步的所有位置个数 int count2 = next(o2).size(); if (count1 &lt; count2) { return -1; } else if (count1 == count2) { return 0; } else { return 1; } } }); } }","categories":[],"tags":[]},{"title":"","slug":"JSON","date":"2021-09-14T08:23:41.622Z","updated":"2021-09-14T08:23:42.954Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"QinJiang\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试1、新建一个module ，springmvc-05-json ， 添加web的支持 2、在web目录下新建一个 json-1.html ， 编写测试内容 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSON_秦疆&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; //编写一个js的对象 var user = { name:\"秦疆\", age:3, sex:\"男\" }; //将js对象转换成json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象 var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3、在IDEA中使用浏览器打开，查看控制台输出！ Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; 配置SpringMVC需要的配置 web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; springmvc-servlet.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； package com.kuang.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; //需要导入lombok @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； @Controller public class UserController { @RequestMapping(\"/json1\") @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 配置Tomcat ， 启动测试一下！ http://localhost:8080/json1 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMaping的produces属性来实现，修改下代码 //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\") 再次测试， http://localhost:8080/json1 ， 乱码问题OK！ 【注意：使用json记得处理乱码问题】 代码优化 乱码统一解决上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 返回json字符串统一解决在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ @RestController public class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\") public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 启动tomcat测试，结果都正常输出！ 测试集合输出 增加一个新的方法 @RequestMapping(\"/json2\") public String json2() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str; } 运行结果 : 十分完美，没有任何问题！ 输出时间对象 增加一个新的方法 @RequestMapping(\"/json3\") public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str; } 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 @RequestMapping(\"/json4\") public String json4() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str; } 运行结果 : 成功的输出了时间！ 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 package com.kuang.utils; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import java.text.SimpleDateFormat; public class JsonUtils { public static String getJson(Object object) { return getJson(object,\"yyyy-MM-dd HH:mm:ss\"); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 我们使用工具类，代码就更加简洁了！ @RequestMapping(\"/json5\") public String json5() throws JsonProcessingException { Date date = new Date(); String json = JsonUtils.getJson(date); return json; } 大功告成！完美！ FastJsonfastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt; &lt;/dependency&gt; fastjson 三个主要的类： JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组 内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 package com.kuang.controller; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.kuang.pojo.User; import java.util.ArrayList; import java.util.List; public class FastJsonDemo { public static void main(String[] args) { //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\"*******Java对象 转 JSON字符串*******\"); String str1 = JSON.toJSONString(list); System.out.println(\"JSON.toJSONString(list)==&gt;\"+str1); String str2 = JSON.toJSONString(user1); System.out.println(\"JSON.toJSONString(user1)==&gt;\"+str2); System.out.println(\"\\n****** JSON字符串 转 Java对象*******\"); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\"JSON.parseObject(str2,User.class)==&gt;\"+jp_user1); System.out.println(\"\\n****** Java对象 转 JSON对象 ******\"); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\"(JSONObject) JSON.toJSON(user2)==&gt;\"+jsonObject1.getString(\"name\")); System.out.println(\"\\n****** JSON对象 转 Java对象 ******\"); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\"JSON.toJavaObject(jsonObject1, User.class)==&gt;\"+to_java_user); } } 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！","categories":[],"tags":[]},{"title":"","slug":"JavaScript","date":"2021-09-14T08:23:41.603Z","updated":"2021-09-14T08:23:42.953Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"JavaScriptJavaScript 作者只用了10天就开出来 行为层（JavaScript）JavaScript是一门弱类型的脚本语言，其源代码在发往客户端之前不需要经过编译，而是将文本格式的字符代码发送给浏览器，由浏览器解释运行 Native 原生 JS 开发 原生 JS 开发，也就是让我们按照【ECMAScript】标准开发方式，简称 ES ，特点是所有浏览器都支持。 TypeScript 微软标准 TypeScript 是一种由微软开发和开源的编程语言，他是JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。 UI框架 Ant-Design：阿里出品，基于React的UI框架 ElementUI. iview、ice：饿了么出品，基于Vue的UI框架 BootStrap：Twitter推出的一个用于前端开发的开源工具包 AmazeUI：又叫”妹子UI“，一款HTML5跨屏的前端框架 JavaScript 构建工具 Babel：JS编译工具，主要用于浏览器不支持的ES新特性 WebPack：模块打包器，主要作用是打包、压缩、合并和按序加载 1、什么是JavaScript1.1、概述JavaScript是一门世界上最流行的脚本语言 一个合格的后端人员，必须要精通javaScript 1.2、历史ECMAScript可以理解为是JavaScript的一个标准。 最新版本已经到了ES6版本 但是大部分浏览器还只停留在支持ES5代码上 开发环境–先上环境，版本不一致 2、快速入门2.1、引入JavaScriptscript标签内不用显示定义type，也默认就是JavaScript 2.1.1、内部标签&lt;script&gt; alert('hello world'); &lt;/script&gt; 2.1.2、外部引入abs.js alert('hello world'); test.html &lt;!--注意script必须成对出现--&gt; &lt;script src=\"abc.js\"&gt;&lt;/script&gt; 测试代码 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--script标签内写JavaScript代码--&gt; &lt;!--&lt;script&gt;--&gt; &lt;!-- alert('hello world');--&gt; &lt;!--&lt;/script&gt;--&gt; &lt;!--外部引入--&gt; &lt;!--注意script必须成对出现，如果&lt;script&gt;标签中使用src属性，那么该标签中封装的 javascript代码不会被执行。--&gt; &lt;script src=\"js/qj.js\"&gt;&lt;/script&gt; &lt;!--不用显示定义type，也默认就是JavaScript--&gt; &lt;script type=\"javascript\"&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--这里也可以存放--&gt; &lt;/body&gt; &lt;/html&gt; 2.2、基本语法入门&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--javaScript严格区分大小写--&gt; &lt;script&gt; // 1.定义变量 var score=70; // 2.条件控制 if (score&gt;60&amp;&amp;score&lt;70){ alert(\"60~70\"); }else if(score&gt;70&amp;&amp;score&lt;80){ alert(\"70~80\") }else{ alert(\"other\"); } //console.log(score) 在浏览器的控制台打印变量，相当于System.out.println() /* * dasdasda */ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 浏览器必备调试须知： 2.3、数据类型数值、文本、图形、音频、视频… 变量 var 变量名='变量值'; 不能以数字开头！ number js不区分小数跟整数，统一用number 123 //整数 123.1 //浮点数 1.23e3 //科学技术法 -99 //负数 NaN //not a number Infinity //表示无限大 字符串 'abc' \"abc\" 布尔值 true false 算术运算符 + 、- 、* 、/ 、% 、++ 、-- 赋值运算符 = 、 += 、-= 、 *= 、 /= 、 %= 逻辑运算符 &amp;&amp; //两个都为真，结果为真 || //一个为真，结果为真 ! //真即假，假即真 比较运算符 &gt; 、&lt;、 &gt;=、 &lt;=、 != = //赋值 == //等于（类型不一样，值一样，也会判断为true） === //绝对等于（类型一样，值一样，结果为true） 这是一个js缺陷，坚持不要使用== 须知： NaN===NaN,这个与所有的数值都不相等，包括自己 只能通过isNaN(NaN)来判断这个数值是否为NaN 位运算符 &amp; 、 | 、 ^ 、 &gt;&gt; 、 &lt;&lt; 、 &gt;&gt;&gt; /* 左移几位就是该数据乘以2的几次方（左移运算符&lt;&lt;）（右移相反&gt;&gt;:除以，高位空缺的位高位是什么就补什么）； 无符号右移&gt;&gt;&gt;：数据进行右移时，高位出现空缺，无论高位是什么都补0。 */ 三元运算符 ? : 浮点数问题： console.log((1/3)===(1-2/3)); //输出 false 尽量避免使用浮点数进行计算，存在精度问题 console.log(Math.abs(1/3-(1-2/3))&lt;0.000000001); //输出 true null和undefined null 空 undefined 未定义，其实它就是一个常量。 var xx; alert(xx); // undefined alert(xx==undefined); //true 其他一些注意点 alert(\"12\"-1);//11 alert(\"12\"+1);//121 alert(true+1);//2 ，因为在js中false就是0，或者null，非0、非null就是true。默认用1表示。 alert(\"a=\"+a/1000*1000);//a=3710;进行除运算不会进行取整 数组 java的数组必须是一系列相同类型的对象，js中不需要这样 //保证代码的可读性，尽量使用[] var arr = [1, 2, 3, 4, 5, \"hello\", null, true]; new Array(1, 2, 3, 4, 5, \"hello\"); 取数组下标，如果越界了，就会undefined 对象 对象是{}，数组是[] 每个属性之间使用逗号隔开，最后一个不需要 var person={ name:'lisi', age:3, tags:['js','java','web'] } 取对象的值 2.4、严格检查模式 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--前提：IDEA需要设置支持使用ES6语法 'use strict';严格检查模式，预防JavaScript的随意性导致产生的一些问题，必须写在JavaScript的第一行 局部变量建议使用let定义 --&gt; &lt;script&gt; //严格检查模式 'use strict'; //全局变量 var i=1; //ES6 中局部变量使用let定义 let j=1; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 3、数据类型3.1、字符串 1、正常字符串使用单引号或者双引号包裹 2、注意转义字符 \\ \\' \\n \\t \\u4e2d \\u#### Unicode字符 \\x41 Ascll字符 3、多行字符串编写 //tab 上面的那个piao~ var msg=` helloworld 你好 你好呀 `; console.log(msg); 4、模板字符串 var name=\"lisi\"; var age=3; var msg=`你好，${name}`; console.log(msg); 5、字符串长度 str.length 6、字符串的可变性,不可变 7、大小写转换 //转大写，注意这里是方法，不是属性 str.toUpperCase(); //转小写 str.toLowerCase(); 8、输出指定字符的位置 str.indexOf(\"t\"); 9、substring从第x个字符截取到第y个字符，包含第一个，不包含最后一个 str.substring(x,y); 3.2、数组Array可以包含任意类型的数据 var arr=[1,2,3,4,5,6];//通过下标取值和赋值 arr[0]; arr[0]=1; 1、长度 arr.length; 注意：假如给arr.length赋值，数组大小就会发生变化，如果赋值过小，元素就会丢失 2、indexOf，通过元素获得下表索引 arr.indexOf(2); 字符串的1和数字1是不同的 3、slice() 截取Array的一部分，返回一个新的数组，类似于String中的subString 4、push()、pop() push:压入到尾部 pop:弹出尾部的一个元素 5、unshift()，shift() unshift:压入到头部 shift:弹出头部的一个元素 6、排序用sort() 7、元素反转 reverse() 8、concat() 注意：concat()并没有修改数组，只是返回了一个新的数组 9、连接符 join 打印拼接数组，使用特定的字符串连接 &gt;&gt; arr.join(\"-\"); &lt;- \"c-b-a\" 10、多维数组 &gt;&gt; arr=[[1,2],[3,4],[5,6]]; &gt;&gt; arr[1][1] &lt;- 4 数组：存储数据（如何存，如何取，方法都可以自己实现！） js中的数组定义的两种方式： // 1、直接定义 var arr = []; var arr = [3,1,5,8]; // 2、使用了javascript中的Array对象来完成的定义。 var arr = new Array(); //var arr = []; var arr1 = new Array(5); //数组定义并长度是5. var arr2 = new Array(5,6,7); //定义一个数组，元素是5,6,7 alert(typeof(arr));//对象类型是Object 3.3、对象若干个键值对 var 对象名 = { 属性名 : 属性值, .... , 属性名 : 属性值 }; //定义了一个person对象，他有四个属性 var person = { name: 'lisi', age: 3, email: '123456@qq.com', score: 0 }; js中的对象，{…}表示一个对象，键值对描述属性xxx:xxx，多个属性之间使用逗号隔开，最后一个属性不加逗号。 JavaScript中所有的键都是字符串，值是任意对象！ 1、对象赋值问题 &gt;&gt; person.name='wangwu'; &lt;- \"wangwu\" &gt;&gt; person &lt;- Object { name: \"wangwu\", age: 3, email: \"123456@qq.com\", score: 0 } 2、使用一个不存在的对象属性不会报错 undefined &gt;&gt; person.haha &lt;- undefined 3、动态的删减属性，通过delete来删除对象的属性 &gt;&gt; delete person.name &lt;- true &gt;&gt; person &lt;- Object { age: 3, email: \"123456@qq.com\", score: 0 } 4、动态的添加属性，直接给新的属性添加值即可 &gt;&gt; person.haha='hahah' &lt;- \"hahah\" &gt;&gt; person &lt;- Object { age: 3, email: \"123456@qq.com\", score: 0, haha: \"hahah\" } 5、判断属性值是否在这个对象中，xxx in xxx &gt;&gt; 'age' in person &lt;- true //继承 &gt;&gt; 'toString' in person &lt;- true 6、判断一个属性是否是自身拥有的 hasOwnProperty &gt;&gt; person.hasOwnProperty('toString'); &lt;- false &gt;&gt; person.hasOwnProperty('age'); &lt;- true 3.4、流程控制 if判断 let age=3; if(age&lt;=3){ alert('haha'); }else if(age&gt;3&amp;&amp;age&lt;5){ alert('kua'); }else{ alert('lili'); } 循环 while循环，尽量避免程序死循环 while(age&lt;100){ age=age+1; console.log(age); } do{ age=age+1; console.log(age); }while(age&lt;100) for循环 var age=[12,35,26,45,38]; for (let i=0;i&lt;age.length;i++){ console.log(age[i]); } for (let number of age) { console.log(number); } forEach循环 ES5.1引入的 var age=[12,35,26,45,38]; //函数 age.forEach(function (value) { console.log(value) }) for…in var age=[12,35,26,45,38]; //索引 for(let index in object){} for (let number in age) { console.log(age[number]); } 3.5、Map和Set ES6的新特性 Map: //SE6 //学生的成绩，学生的名字 let map=new Map([['tom',100],['jack',90],['haha',88]]); let name = map.get('tom');//通过key获得value map.set('admin',60); //新增或修改 map.delete('tom'); //删除 console.log(map); Set:无序不重复的集合 let set=new Set([3,1,1,1,1]);//set可以去重 set.add(2); //添加 set.delete(3); //删除 console.log(set.has(1));//判断是否包含 console.log(set); 3.6、iterator ES6的新特性 遍历迭代Map和Set 遍历数组 let arr=[9,6,7,2]; for (let number of arr) { console.log(number); } 遍历Map let map=new Map([['tom',100],['jack',90],['haha',88]]); for (let mapElement of map) { console.log(mapElement); } 遍历Set let set=new Set([3,1,1,2,6]);//set可以去重 for (let number of set) { console.log(number); } 4、函数及面向对象4.1、定义函数 定义方式一 绝对值函数 function abs(x){ if(x&gt;=0){ return x; }else{ return -x; } } 一旦执行return，代表函数结束，返回结果 如果没有执行return，函数执行完也会返回结果，结果为undefined。 定义方式二 var abs=function(x){ if(x&gt;=0){ return x; }else{ return -x; } } function(x){…}这是一个匿名函数，但是可以把结果赋值给abs，通过abs就可以调用 两种方法等价 调用函数 abs(10) //10 abs(-10) //10 var sum = getSum; //getSum本身是一个函数名，而函数本身在js中就是一个对象。getSum就是这个函数对象的引用.将getSum这个引用的地址赋值给sum。这时sum也指向了这个函数对象。相当于这个函数对象有两个函数名称。 参数问题： JavaScript可以传任意个参数，也可以不传参数 参数进来是否存在的问题？假设不存在参数，如何规避 var abs=function(x){ //手动抛出异常 if(typeof x!=='number'){ throw 'Not a number'; } if(x&gt;=0){ return x; }else{ return -x; } } arguments arguments是JS免费赠送的关键字 代表传进来的所有的参数是一个数组 var abs=function(x){ console.log(\"x==&gt;\",x); for (let i = 0; i &lt; arguments.length; i++) { console.log(arguments[i]); } if(x&gt;=0){ return x; }else{ return -x; } } 问题：arguments包含所有的参数，有时候想用多余的参数来进行附加操作，需要排除已有参数 rest 以前： if(arguments.length&gt;2){ for(let i=2;i&lt;arguments.length;i++){ //... } } ES6引入的新特性，获取除了已经定义的参数之外的所有参数 …rest function a(a,b,...rest){ console.log(\"a===&gt;\",a); console.log(\"b===&gt;\",b); console.log(rest); } rest参数只能写在最后面，必须用…标识 4.2、变量作用域在JavaScript中，var定义的变量实际是有作用域的 假设在函数体中声明，则在函数体外不可以使用（非要实现，可以使用闭包） `use strict`; function f() { var x=1; x=x+1; } x=x+2;//ReferenceError: x is not defined 如果两个函数使用了相同的变量名，只要在函数内部，不冲突 `use strict`; function f() { var x=1; x=x+1; } function f1() { var x=2; } 内部函数可以访问外部函数的成员，反之，则不行 function f() { var x=1; //内部函数可以访问外部函数的成员，反之，则不行 function f1() { var y=x+1; } var z=y+1;//ReferenceError: y is not defined } 假设内部函数变量和外部函数变量重名， function f() { var x=1; //内部函数可以访问外部函数的成员，反之，则不行 function f1() { var x='A'; console.log('inner==&gt;'+x);//inner==&gt;A } console.log('outer==&gt;'+x);//outer==&gt;1 f1(); } f(); 在JavaScript中，函数查找变量从自身函数开始，由“内”向“外”查找，假设外部存在这个同名的函数变量，则内部函数会屏蔽外部函数的变量。 提升变量的作用域 function f() { var x='x'+y; console.log(x); var y='y'; } 结果：xundefined 输出x和undefined拼接 说明js执行引擎自动提升了y的声明，不会提升y的赋值，等价于 function f2() { var y; var x='x'+y; console.log(x); y='y'; } 全局函数 //全局变量 x=1; function f() { console.log(x); } f(); console.log(x); 全局对象window var x='xxx'; alert(x); alert(window.x);//默认所有的全局变量都会自动绑定在window对象下 alert()这个函数本身也是一个window变量 var x='xxx'; window.alert(x); var old_alert=window.alert; //old_alert(x); window.alert=function () { }; //发现alert失效了 window.alert(123); //恢复 window.alert=old_alert; window.alert(456); JavaScript实际上只有一个全局作用域，任何变量（函数也可视为变量），假设没有在函数作用范围内找到，就会向外查找，如果在全局作用域都没有找到，就会报ReferenceError 规范 由于所有的全局变量都会绑定到Windows上，如果不同的js使用了相同的全局变量，冲突-&gt;如何减少冲突？ //唯一全局变量，用来装自己定义的全局变量 var Mapp={}; //定义全局变量 Mapp.name='lisi'; Mapp.add=function(a,b){ return a+b; } 把自己的代码全部放入自己定义的唯一空间名字中，降低全局命名冲突问题 局部作用域 let 使用var定义 function aaa() { for (var i = 0; i &lt; 100; i++) { console.log(i); } console.log(i+1);//i出了作用域还可以使用 } ES6使用let关键字，解决局部作用域冲突问题 function aaa() { for (let i = 0; i &lt; 100; i++) { console.log(i); } console.log(i+1);//ReferenceError: i is not defined } 建议大家都使用let去定义局部作用域的变量 ​ 常量const 在ES6之前定义常量：只要用全部大写字母命名的变量就是常量，建议不要修改这样的值 var PI=3.14; console.log(PI); PI='213';//可以改变这个值 console.log(PI); 在ES6引入了常量关键字const const PI=3.14;//只读变量 console.log(PI); PI=354;// TypeError: invalid assignment to const `PI' ，失败 4.3、方法 定义方法 方法就是把函数放在对象里面，队形只有两个东西：属性跟方法 var a = { name: 'lisi', birth: 2000, //方法 age: function () { //今年-出生年月 let year = new Date().getFullYear(); return year - this.birth; } } //属性 a.name //方法，一定要带（） a.age() this代表什么？拆开上面的代码看看 function getAge() { //今年-出生年月 let year = new Date().getFullYear(); return year - this.birth; } var a = { name: 'lisi', birth: 2000, //方法 age: getAge }; //a.age() ok //getAge() NaN window 这个this是无法指向的，默认指向调用他的那个对象 apply 在js中可以控制this的指向 function getAge() { //今年-出生年月 let year = new Date().getFullYear(); return year - this.birth; } var a2 = { name: 'lisi', birth: 2000, //方法 age: getAge }; getAge.apply(a2,[]);//this指向了a2这个对象，参数为空 想要获取谁就指向谁 5、内部对象 标准对象 &gt;&gt; typeof 123 &lt;- \"number\" &gt;&gt; typeof '123' &lt;- \"string\" &gt;&gt; typeof true &lt;- \"boolean\" &gt;&gt; typeof NaN &lt;- \"number\" &gt;&gt; typeof [] &lt;- \"object\" &gt;&gt; typeof {} &lt;- \"object\" &gt;&gt; typeof Math.abs &lt;- \"function\" &gt;&gt; typeof undefined &lt;- \"undefined\" 5.1、Date 基本使用 let date = new Date();//Date Tue Jun 09 2020 10:49:38 GMT+0800 (中国标准时间) console.log(date); date.getFullYear();//年 date.getMonth();//月 0-11 代表月 date.getDate();//日 date.getDay();//星期 date.getHours();//时 date.getMinutes();//分 date.getSeconds();//秒 date.getMilliseconds();//毫秒 date.getTime();//时间戳 全世界统一 1970.1.1 00:00:00 毫秒数 console.log(new Date(1591671532754));//时间戳转时间 转换 &gt;&gt; var now=new Date(1591671532754); &gt;&gt; console.log(now); &lt;- Date Tue Jun 09 2020 10:58:52 GMT+0800 (中国标准时间) &gt;&gt; now.toLocaleString()//注意调用是一个方法，不是属性 &lt;- \"2020/6/9 上午10:58:52\" &gt;&gt; now.toGMTString() &lt;- \"Tue, 09 Jun 2020 02:58:52 GMT\" 5.2、Math /* * 演示Math对象。该对象的中的方法都是静态的。不需要new，直接Math调用即 可。 */ var num1 = Math.ceil(12.34);//返回大于等于指定参数的最小整数。 var num2 = Math.floor(12.34);//返回小于等于指定数据的最大整数。 var num3 = Math.round(12.54);//四舍五入 var num4 = Math.pow(10,2); //平方 5.3、Json Json是什么 早期，所有的数据传输习惯使用xml文件 JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在JavaScript中，一切皆为对象，任何js支持的类型都可以用 JSON 来表示 格式： 对象都用 {} 数组都用 [] 所有的键值对都使用 key:value JSON 字符串和 JavaScript 对象的转换 var user={ name:'lisi', age:3, sex:'男' }; //对象转换为JSON let jsonUser = JSON.stringify(user);//{\"name\":\"lisi\",\"age\":3,\"sex\":\"男\"} //JSON字符串转换为对象,参数为JSON字符串 let object = JSON.parse(jsonUser);//Object { name: \"lisi\", age: 3, sex: \"男\" } 很多人搞不清楚，JSON 和 JS 对象的区别 var object={a:'hello',b:'hellob'}; var json='{\"a\":\"hello\",\"b\":\"hellob\"}'; 5.4、Ajax 原生的js写法：xhr 异步请求 jQuery封装好的方法 $(“#name”).ajax(“”) axios 请求 6、面向对象编程 原型对象 JavaScript、java、c#…面向对象；JavaScript有一些区别 类：模板 原型 对象：具体的实例 在JavaScript中，这个需要换一下思维方式 原型： var Student={ name:'lisi', age:3, sex:'男', run:function () { console.log(this.name+' run...'); } }; var xiaoming={ name:'xiaoming' }; //xiaoming的原型是Student xiaoming.__proto__=Student; var bird={ fly:function(){ console.log(this.name+' fly...'); } }; //xiaoming的原型是bird xiaoming.__proto__=bird; class 继承 以前： function student(name) { this.name=name; } //给student新增一个方法 student.prototype.hello=function () { alert('hello'); }; class关键字是在ES6引入的 1、定义一个类，属性，方法 //ES6之后 //定义一个类 class Student{ constructor(name) { this.name=name; } hello(){ alert('hello'); } } var xiaoming=new Student(\"小明\"); var xiaohong=new Student(\"小红\"); xiaoming.hello(); 2、继承 class Student{ constructor(name) { this.name=name; } hello(){ alert('hello'); } } class XiaoStudent extends Student{ constructor(name,grade) { super(name); this.grade=grade; } myGrade(){ alert('我是一个小学生'); } } var xiaoming=new Student(\"小明\"); var xiaohong=new XiaoStudent(\"小红\",1); 本质：查看对向原型 原型链 __ proto __: 7、操作Bom元素BOM：Browser Object Model（浏览器对象模型） 浏览器介绍 JavaScript和浏览器关系：JavaScript诞生就是为了让他在浏览器中运行 浏览器内核： IE 6-11 Chrome Safari FireFox 三方 QQ浏览器 360浏览器 7.1、window（重要） window代表浏览器窗口 &gt;&gt; window.innerHeight &lt;- 244 &gt;&gt; window.innerWidth &lt;- 1536 &gt;&gt; window.outerHeight &lt;- 848 &gt;&gt; window.outerWidth &lt;- 1550 //可以调整浏览器窗口大小试试 7.2、Navigator Navigator封装了浏览器的信息 &gt;&gt; navigator.appName &lt;- \"Netscape\" &gt;&gt; navigator.appVersion &lt;- \"5.0 (Windows)\" &gt;&gt; navigator.userAgent &lt;- \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0\" &gt;&gt; navigator.platform &lt;- \"Win32 大多数时候不会使用navigator对象，因为会被人为修改，建议使用这些属性来判断和编写代码 7.3、screen 代表屏幕的尺寸（像素px） &gt;&gt; screen.width &lt;- 1536 &gt;&gt; screen.height &lt;- 864 7.4、location（重要） 代表当前页面的URL信息 host: \"www.baidu.com\" //主机 href: \"https://www.baidu.com/\" //地址 protocol: \"https:\" //协议 reload: function reload() //重新加载 //设置新的地址 &gt;&gt; location.assign(\"https://www.csdn.net/\") 7.5、Document Document代表当前页面 HTML DOM文档树 &gt;&gt; document.title &lt;- \"百度一下，你就知道\" &gt;&gt; document.title=\"hahah\" &lt;- \"hahah\" 获取具体的文档树节点 &lt;dl id=\"app\"&gt; &lt;dt&gt;Java&lt;/dt&gt; &lt;dd&gt;JavaEE&lt;/dd&gt; &lt;dd&gt;JavaSE&lt;/dd&gt; &lt;/dl&gt; &lt;script&gt; let dl = document.getElementById('app'); console.log(dl); &lt;/script&gt; 获取cookie &gt;&gt; document.cookie &lt;- \"BAIDUID=4ABFE152F04D1B1C0AA7208BF816637D:FG=1; BIDUPSID=4ABFE152F04D1B1C0AA7208BF816637D; PSTM=1589766046; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; BD_HOME=1; H_PS_PSSID=31724_1461_31325_21082_31780_31271_30823_31848_22160; BD_UPN=13314752; ORIGIN=1; ISSW=1; ISSW=1\" 劫持cookie原理 &lt;script src=\"aaa.js\"&gt;&lt;/script&gt; &lt;!--恶意人员获取用户的cookie，上传到他的服务器--&gt; 服务器端可以设置cookie：httpOnly，防止 cookie 泄露 7.6、History（不建议使用） 代表浏览器的历史记录 history.forward();//前进 history.back();//后退 7.7、Window 对象的一些方法&lt;script type=\"text/javascript\"&gt; var timeid；//全局变量，如果写在某个方法的话别的方法就不能使用 function windowMethodDemo(){ var b = confirm(\"你真的确定要点击吗？\"); //这里的方法都省略了window. alert(\"b=\"+b); //上面confirm方法会弹出一个窗口，点击按钮会返回值 setTimeout(\"alert('time out run')\",4000); //设置多少毫秒弹出 timeid = setInterval(\"alert('interval run')\",3000); //返回的Integer对象clearInterval方法用，该方法的作用是每多少毫秒就弹出 } function stopTime(){ clearInterval(timeid); //取消setInterval方法的调用 } function windowMove(){ // moveBy(10,10); 窗口移动多少像素 // moveTo(40,40); 窗口移动到哪个坐标 for (var x = 0; x &lt; 700; x++){ //该代码段就是抖动窗口的功能 moveBy(20, 0); moveBy(0, 20); moveBy(-20,0); moveBy(0,-20); } } function windowOpen(){ open(\"ad.html\",\"_blank\",\"height=400,width=400,status（状态栏）=no,toolbar（工具栏）=no,menubar（菜单栏）=no,location（地址栏）=no\"); //第一个参数是打开的链接，第二个参数窗口target属性，第三个参数设置窗口的其他属性 // close(); 弹出窗口后关闭该窗口 } &lt;/script&gt; &lt;input type=\"button\" value=\"演示window对象的方法\" onclick=\"windowOpen()\"/&gt; &lt;input type=\"button\" value=\"停止\" onclick=\"stopTime()\"/&gt; 7.8、Window 对象的一些事件&lt;script type=\"text/javascript\"&gt; /* onunload = function(){ //窗口关闭后弹出 alert(\"onunload run\"); } onload = function(){ //窗口加载后弹出 alert(\"onload run\"); } onbeforeunload = function(){ //窗口关闭时弹出 alert(\"onbeforeunload run\"); } 已过时？ */ onload = function(){ window.status = \"啊！，加载完毕啦\"; //设置窗口加载后状态栏的信息 } &lt;/script&gt; 8、操作Dom对象（重点）DOM：Document Object Model（文档对象模型） DOM用来将标记型文档封装成对象，并将标记型文档中的所有的内容(标签，文本，属性等)都封装成对象。封装成对象的目的是为了更为方便的操作这些文档以及文档中的所有内容。因为对象的出现就可以有属性和行为被调用。文档对象模型 文档：标记型文档。 对象：封装了属性和行为的实例，可以被直接调用。 模型：所有标记型文档都具备一些共性特征的一个体现。标记型文档(标签，属性，标签中封装的数据)，只要是标记型文档，DOM这种技术都可以对其进行操作。常见的标记型文档：html xml DOM技术的解析方式：将标记型文档解析一棵DOM树，并将树中的内容都封装成节点对象。注意：这个DOM解析方式的好处：可以对树中的节点进行任意操作，比如：增删改查。弊端：这种解析需要将整个标记型文档加载进内存。意味着如果标记型文档的体积很大，较为浪费内存空间。 简介另一种解析方式：SAX：是由一些组织定义的一种民间常用的解析方式，并不是w3c标准，而DOM是W3C的标准。SAX解析的方式：基于事件驱动的解析。获取数据的速度很快，但是不能对标记进行增删改。 DOM模型有三种： DOM level 1：将html文档封装成对象。 DOM level 2：在leve 1基础上加入了新功能，比如解析名称空间。 DOM level 3：将xml文档封装成了对象。 DHTML:动态的HTML。不是一门语言：是多项技术综合体的简称.其中包含了HTML,CSS,DOM,JavaScript。 这四个技术在动态html页面效果定义时，都处于什么样角色呢？负责什么样的职责呢？ HTML:负责提供标签，对数据进行封装，目的是便于对该标签中的数据进行操作。简单说：用标签封装数据。 CSS:负责提供样式属性，对标签中的数据进行样式的定义。 简单说：对数据进行样式定义 DOM:负责将标签型文档以及文档中的所有内容进行解析，并封装成对象，在对象中定义了更多的属性和行为，便于对对象操作。简单说：将文档和标签以及其他内容变成对象。 JS:负责提供程序设计语言，对页面中的对象进行逻辑操作。简单说：负责页面的行为定义。就是页面的动态效果。 所以javascript是动态效果的主力编程语言。 DHTML+XMLhttpRequest = AJAX 8.1、核心浏览器网页就是一个Dom树形结构 更新：更新Dom节点 遍历：得到Dom节点 删除：删除Dom节点 添加：添加一个新的Dom节点 要操作一个Dom节点，就要先获得这个Dom节点 8.2、获得Dom节点/* 获取节点的方法： 1，getElementById():通过标签的id属性值获取该标签节点。返回该标签节点。一般容器型节点都有ID属性，所以就用这个获取。 2，getElementsByName(): 通过标签的name属性获取节点，因为name有相同，所以返回的一个数组。 3，getElementsByTagName(): 通过标签名获取节点。因为标签名会重复，所以返回的是一个数组。 */ //对应CSS选择器 let byTagName = document.getElementsByTagName(\"h1\"); console.log(byTagName); let byId = document.getElementById('p1'); console.log(byId); let byClassName = document.getElementsByClassName('p2'); console.log(byClassName); let father = document.getElementById('father'); let children = father.children;//获取父节点下的所有子节点 let child=father.children[index];//获取第index个子节点 let firstChild = father.firstChild;//第一个子节点 let lastChild = father.lastChild;//最后一个子节点 这是原生代码，之后我们都尽量使用jQuery 8.3、更新Dom&lt;div id=\"id1\"&gt;&lt;/div&gt; &lt;script&gt; let id1 = document.getElementById('id1'); &lt;/script&gt; 操作文本 id1.innerText='456';修改文本的值 id1.innerHTML='123';可以解析HTML文本标签 操作css &gt;&gt; id1.style.color='red' //属性使用字符串 &lt;- \"red\" &gt;&gt; id1.style.fontSize='100px' //下划线转驼峰命名问题 &lt;- \"100px\" &gt;&gt; id1.style.padding='2em' &lt;- \"2em\" 8.4、删除Dom删除节点的步骤：先获取父节点，再通过父节点删除自己 &lt;div id=\"father\"&gt; &lt;h1&gt;标题1&lt;/h1&gt; &lt;p id=\"p1\"&gt;p1&lt;/p&gt; &lt;p class=\"p2\"&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let self = document.getElementById('p1'); let father = self.parentElement; father.removeChild(self); //删除是一个动态的过程 father.removeChildren(father.children[0]); &lt;/script&gt; 注意：删除多个节点的时候，children的位置是时刻变化的。 8.5、插入Dom当获得了某个Dom节点，假设这个Dom节点是空的，通过innerHTML就可以增加一个元素，但是如果这个Dom节点已经存在元素了，就不能这么干，会覆盖。 将已有的标签追加到后面 &lt;p id=\"js\"&gt;JavaScript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let js = document.getElementById('js'); let list = document.getElementById('list'); list.append(js);//追加到后面 &lt;/script&gt; 效果： 创建一个新的标签，实现插入 &lt;p id=\"js\"&gt;JavaScript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let js = document.getElementById('js');//已存在的节点 let list = document.getElementById('list'); list.append(js); //通过js创建一个节点 let newP = document.createElement('p');//创建一个p标签 newP.id='newP'; newP.innerText='hello'; list.append(newP); //创建一个标签节点 let myScript = document.createElement('script'); myScript.setAttribute('type','text/javascript'); list.appendChild(myScript); //可以创建一个style标签 let myStyle = document.createElement('style');//创建了一个空style标签 myStyle.setAttribute(\"type\",'text/css');//设置type为text/css myStyle.innerHTML='body{background: antiquewhite;}';//设置标签内容 let head = document.getElementsByTagName('head');//将style追加到头部 head[0].appendChild(myStyle);//head的第0个才是head &lt;/script&gt; 效果： 插入到前面 insertBefore //insertBefore(newNode,targetNode) let js = document.getElementById('js');//新的节点 let list = document.getElementById('list');//包含的父节点 let ee = document.getElementById('ee');//目标节点 list.insertBefore(js,ee); 9、操作表单（验证）9.1、表单是什么 文本框 text 下拉框 &lt; select &gt; 单选框 radio 多选框 checkbox 隐藏域 hidden 密码框 password …. 表单的目的：提交信息 9.2、获得要提交的信息&lt;form action=\"\" method=\"post\"&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;input type=\"text\" id=\"username\"&gt; &lt;!--多选框的值就是value的值--&gt; &lt;p&gt; &lt;span&gt;性别&lt;/span&gt; &lt;input type=\"radio\" name=\"sex\" value=\"man\" id=\"boy\"&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"women\" id=\"girl\"&gt;女 &lt;/p&gt; &lt;/form&gt; &lt;script&gt; let username = document.getElementById('username'); let boy = document.getElementById('boy'); let girl = document.getElementById('girl'); //得到输入框的值 username.value; //修改输入框的值 username.value = '123'; //对于单选框，多选框等固定的值，用.value只能取到当前的值 boy.value; boy.checked;//查看返回的结果是否为true，如果为true，则为选中 boy.checked=true;//赋值 &lt;/script&gt; 9.3、提交表单 md5加密密码 md5在线cdn：https://www.bootcdn.cn/blueimp-md5/ &lt;!--表单绑定提交事件 onsubmit 绑定一个提交检测函数 true false 将这个结果返回表单，使用onsubmit接收 onsubmit=\"return check()\"--&gt; &lt;form action=\"https://www.baidu.com/\" method=\"post\" onsubmit=\"return check()\"&gt; &lt;p&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码&lt;/span&gt; &lt;input type=\"password\" id=\"input-password\"&gt; &lt;!--隐藏域作用:如果直接把input-password加密，在提交表单的一瞬间密码会变长，因 为进行了加密，加隐藏域可以保持密码长度不变，服务器获取的数据也应该是id为 md5-password的数据，id为input-password只是过渡作用--&gt; &lt;input type=\"hidden\" id=\"md5-password\" name=\"password\"&gt; &lt;/p&gt; &lt;!--绑定事件 onclick 被点击--&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; function check() { let username = document.getElementById('username'); let input_password = document.getElementById('input-password'); let md5_password = document.getElementById('md5-password'); // MD5算法 md5_password.value=md5(input_password.value); //可以检验表单内容，true通过，false阻止 return true; } &lt;/script&gt; 10、jQueryJavaScript jQuery库，里面存在大量的JavaScript函数 引入jQuery （官网：https://jquery.com/） （文档：https://jquery.cuishifeng.cn/index.html） （在线cdn：https://www.bootcdn.cn/jquery/） 10.1、初识jQuery公式：$(选择器).事件函数() &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--cdn引入--&gt; &lt;!--&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js\"&gt;&lt;/script&gt;--&gt; &lt;script src=\"lib/jquery-3.5.1.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 公式：$(selector).action() --&gt; &lt;a href=\"\" id=\"test-jquery\"&gt;点我&lt;/a&gt; &lt;script&gt; //选择器就是css选择器 $('#test-jquery').click(function () { alert('hello jquery'); }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 10.2、选择器文档工具站：https://jquery.cuishifeng.cn/index.html //原生js，选择器少，麻烦不好记 //标签 document.getElementsByTagName(); //id document.getElementById(); //类 document.getElementsByClassName(); //jquery css中的选择器，他都能用 $('p').click();//标签选择器 $('#id1').click();//id选择器 $('.class1').click();//类选择器 10.3、事件鼠标事件，键盘事件，其他事件 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"lib/jquery-3.5.1.js\"&gt;&lt;/script&gt; &lt;style&gt; #divMove{ width: 500px; height: 500px; border: red solid 1px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--获取鼠标当前的坐标--&gt; mouse：&lt;span id=\"mouseMove\"&gt;&lt;/span&gt; &lt;div id=\"divMove\"&gt; 在这里移动鼠标试试 &lt;/div&gt; &lt;script&gt; //当网页元素加载完毕之后响应事件 $(function () { $('#divMove').mousemove(function (e) { $('#mouseMove').text('x:'+e.pageX+\" y:\"+e.pageY); }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 10.4、操作DOM 文本节点操作 &lt;ul id=\"test-ul\"&gt; &lt;li class=\"js\"&gt;javascript&lt;/li&gt; &lt;li name=\"python\"&gt;python&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $('#test-ul li[name=python]').text();//获得值 $('#test-ul li[name=python]').text(\"123\");//设置值 $('#test-ul').html();//获得值 $('#test-ul').html(\"&lt;strong&gt;123&lt;/strong&gt;\");//设置值 &lt;/script&gt; css操作 $('#test-ul li[name=python]').css({'color':'red','fontSize':'30px'}); 元素的显示和隐藏 本质：display:none $('#test-ul li[name=python]').hide();//隐藏 $('#test-ul li[name=python]').show();//显示 $('#test-ul li[name=python]').toggle();//隐藏显示轮换，调用一次换一次 娱乐测试 $(window).width();//浏览器窗口 $(window).height(); 小技巧 1、如何巩固 JS 看jQuery框架源码 看游戏源码 2、巩固HTML、CSS 扒网站，全部down下来，然后对应修改，看效果","categories":[],"tags":[]},{"title":"","slug":"CSS3","date":"2021-09-14T08:23:41.394Z","updated":"2021-09-14T08:23:41.583Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"CSS3HTML+CSS+JavaScript 结构+表项+交互 如何学习？ CSS是什么 CSS怎么用（快速入门） CSS选择器（重点+难点） 美化网页（文字、阴影、超链接、列表、渐变…） 盒子模型 浮动 定位 网页动画（特效效果） 1、初识CSS1.1、什么是CSSCascading Style Sheet（层叠样式表） CSS：表现（美化网页） 字体、颜色、边距、高度、宽度、背景图片、网页定位、网页浮动… 1.2、发展史CSS1.0CSS2.0 DIV（块）+CSS，HTML与CSS结构分离，网页变得简单，利于SEOCSS2.1 浮动和定位CSS3.0 圆角边框、阴影、动画…. 浏览器兼容性 1.3、快速入门 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 规范 &lt;style&gt;&lt;/style&gt;内可以编写html代码,每一个声明最好以分号结尾 语法： 选择器{ 声明1: ; 声明2: ; 声明3: ; } --&gt; &lt;style&gt; h1{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是标题&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 建议使用这种规范 CSS优势： 内容和表现分离 网页结构表现统一，可以实现复用 样式十分丰富 建议使用独立于HTML的css文件 利于SEO，容易被搜索引擎收录 1.4、css的三种导入方式&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--2.内部样式表--&gt; &lt;style&gt; h1{ color:green; } &lt;/style&gt; &lt;!--3.外部样式--&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;!--优先级：就近原则--&gt; &lt;!--1.行内样式：在标签元素中编写一个style属性，编写样式即可--&gt; &lt;h1 style=\"color: red;\"&gt;我是标题&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 拓展：外部样式两种写法： 链接式： &lt;!--外部样式--&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt; 导入式： @import是CSS2.1特有的 &lt;!--导入式--&gt; &lt;style&gt; @import url(\"style.css\"); &lt;/style&gt; 2、选择器 作用：选择页面上的某一种元素或者某一类元素 2.1、基本选择器2.1.1、标签选择器选择一类标签 语法： ​ 标签名{ ​ 声明1：xx； ​ 声明2：xx； ​ } &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*标签选择器会选中页面上的所有这个标签*/ h1{ color: #dcff4f; background: deepskyblue; border-radius: 14px; } p{ font-size: 80px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;学Java&lt;/h1&gt; &lt;h1&gt;学Java&lt;/h1&gt; &lt;p&gt;狂神说&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 2.1.2、类选择器 class选中所有class属性一致的标签，可以跨标签 语法： ​ . 类名{ ​ 声明1：； ​ 声明2：； ​ } &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*类选择器格式：.class的名称{} 好处：可以多个标签归类，是同一个class，可以复用 */ .one{ color:wheat; } .two{ color:red; } .three{ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=\"one\"&gt;标题1&lt;/h1&gt; &lt;h1 class=\"two\"&gt;标题2&lt;/h1&gt; &lt;h1 class=\"three\"&gt;标题3&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 2.1.3、id选择器全局唯一 语法： ​ #id名{ ​ 声明1：； ​ 声明2：； ​ } &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*id选择器格式：#id名称{} id必须保证全局唯一 不遵循就近原则，固定的优先级：id选择器&gt;类选择器&gt;标签选择器 */ #one{ color: aquamarine; } .style1{ color:red; } h1{ color: #dcff4f; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id=\"one\" class=\"style1\"&gt;标题1&lt;/h1&gt; &lt;h1 class=\"style1\"&gt;标题2&lt;/h1&gt; &lt;h1 class=\"style1\"&gt;标题3&lt;/h1&gt; &lt;h1&gt;标题4&lt;/h1&gt; &lt;h1&gt;标题5&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 优先级：不遵循就近原则，固定的：id选择器&gt;类选择器&gt;标签选择器 使用！important 可以打破这个规定 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*id选择类型的后代选择器*/ #div1 div{ color: #222222; /*黑色*/ } .t1{ color: #00fda2; /*青色*/ } .t2{ color: #cb1919 !important; /*红色*/ } &lt;/style&gt; &lt;body&gt; &lt;div id=\"div1\" test=\"\"&gt; &lt;div class=\"t1\"&gt;未使用important&lt;/div&gt; &lt;div class=\"t2\"&gt;使用important&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2.2、层次选择器 HTML &lt;body&gt; &lt;p&gt;p0&lt;/p&gt; &lt;p class=\"active\"&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p4&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;p5&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;p6&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; 2.2.1、后代选择器在某个元素的后面 ：祖爷爷 爷爷 爸爸 我（所有同类标签） /*后代选择器*/ body p{ background: red; } 2.2.2、子选择器选择当前选择元素的下一代 /*子选择器*/ body &gt; p{ background: blueviolet; } 2.2.3、相邻兄弟选择器同辈（同级） （相邻）向下，只有一个 /*相邻兄弟选择器*/ .active + p{ background: cadetblue; } 2.2.4、通用选择器当前选中元素的（同级）向下的所有元素 /*通用兄弟选择器*/ .active ~ p{ background: green; } 2.3、结构伪类选择器伪类： 标签：条件{ 声明：xx； } &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--避免使用class和id选择器--&gt; &lt;style&gt; /*ul的第一个子元素*/ ul li:first-child{ background: #dcff4f; } /*ul的第最后一个子元素*/ ul li:last-child{ background: blueviolet; } /*选中p1:定位到父元素，选中当前的第一个子元素 选中当前元素的父级元素，选中父级元素的第n个子元素（把不同类的子标签也算进去），但第n个子元素必须是当前同类元素，否则选不中 */ p:nth-child(3){ background: cadetblue; } /*先选中当前元素的父级元素，然后选中父级元素的第n个和当前元素同类型的子元素*/ p:nth-of-type(3){ background: wheat; } /*鼠标移动到上面会发生变化*/ a:hover{ background: black; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a&gt;12231&lt;/a&gt; &lt;h1&gt;h1&lt;/h1&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt;li1&lt;/li&gt; &lt;li&gt;li2&lt;/li&gt; &lt;li&gt;li3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 2.4、属性选择器（常用）css标签可以自定义属性，可以随便添加属性，主要用于属性选择器的选择。 class+id结合 属性名 属性名 = 属性值（正则） **= 绝对等于 ** *= 包含 ^= 以…开头 $= 以…结尾 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .demo a{ float: left; display: block; height: 50px; width: 50px; border-radius: 10px; background: blue; text-align: center; color: gainsboro; text-decoration: none; margin-right: 5px; font: bold 20px/50px Arial; } /* 1.属性名 2.属性名=属性值（正则） 3. = 是绝对等于 *= 是包含 4. ^= 以...开头 5. $= 以...结尾 */ /*选中存在id属性的元素 a[]{} */ a[id]{ background: #2be24e; } /*选中存在test属性的元素 a[]{} test属性是自定义的*/ a[test]{ } /*选中id=first*/ a[id=first]{ background: #ff0b2f; } /*class中有link的*/ a[class *= \"link\"]{ background: cadetblue; } /*选中href中以http开头的*/ a[href^=http]{ background: #ff0b2f; } /* 选中href中以pdf结尾的*/ a[href$=pdf]{ background: #2be24e; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"demo\"&gt; &lt;a href=\"http://www.baidu.com/\" class=\"link item first\" id=\"first\"&gt;1&lt;/a&gt; &lt;a href=\"\" class=\"links item active\" target=\"_blank\" title=\"test\"&gt;2&lt;/a&gt; &lt;a href=\"images/123.html\" class=\"link item\"&gt;3&lt;/a&gt; &lt;a href=\"images/123.png\" class=\"link item\"&gt;4&lt;/a&gt; &lt;a href=\"images/123.jpg\" class=\"link item\"&gt;5&lt;/a&gt; &lt;a href=\"abc\" class=\"link item\"&gt;6&lt;/a&gt; &lt;a href=\"/a.pdf\" class=\"link item\"&gt;7&lt;/a&gt; &lt;a href=\"/abc.pdf\" class=\"link item\"&gt;8&lt;/a&gt; &lt;a href=\"abc.doc\" class=\"link item\"&gt;9&lt;/a&gt; &lt;a href=\"abcd.doc\" class=\"link item last\"&gt;10&lt;/a&gt; &lt;a href=\"abcd.doc\" test=\"\"&gt;11&lt;/a&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 3、美化网页元素3.1、为什么要美化网页 有效的传递页面信息 美化网页，页面漂亮才能吸引用户 凸显页面主题 提高用户体验 span标签：重点要突出的字，使用span套起来 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #title1{ font-size: 50px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; 欢迎学习&lt;span id=\"title1\"&gt;java&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 3.2、字体样式 &lt;!-- font-family: 字体 font-size: 字体大小 font-weight: 字体粗细 color: 字体颜色 --&gt; &lt;style&gt; body{ font-family: \"Arial Black\", 楷体; } h1{ font-size: 50px; color: #ff0b2f; } .p1{ font-weight: bold; } &lt;/style&gt; &lt;!--font：字体风格 字体粗细 字体大小 字体种类 --&gt; &lt;style&gt; p{ font: oblique bolder 16px \"楷体\" ; } &lt;/style&gt; 3.3、文本样式 颜色 color:RGB/RGBA/单词; 对齐方式 text-align: center;水平居中 首行缩进 text-indent: 2em;段首缩进 行高 height: 300px;块高 ​ line-height: 300px;行高 ​ 行高和块高度一致，就可以实现单行文本上下居中 装饰划线 text-decoration: 文本图片水平对齐 vertical-align: middle; &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- 颜色： 单词 RGB：0~F RGBA ：A：0~1 透明度 text-align: center;排版 水平居中 text-indent: 2em;段落首行缩进 height: 300px; line-height: 300px;行高和块高度一致，就可以上下居中 --&gt; &lt;style&gt; h1{ color: rgba(0,255,255,0.9); text-align: center;/*文本居中*/ } .p1{ text-indent: 2em; } .p3{ background: blue; height: 300px; line-height: 300px; } /*下划线*/ .l1{ text-decoration: underline; } /*中划线*/ .l2{ text-decoration: line-through; } /*上划线*/ .l3{ text-decoration: overline; } /*超链接去下划线*/ a{ text-decoration: none; } /*水平对齐 需要参照物：a和b a，b{ 声明：xxxx； } */ img,span{ vertical-align: middle; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"\"&gt;123&lt;/a&gt; &lt;p class=\"l1\"&gt;123123&lt;/p&gt; &lt;p class=\"l2\"&gt;123123&lt;/p&gt; &lt;p class=\"l3\"&gt;123123&lt;/p&gt; &lt;h1&gt;《魁拔》&lt;/h1&gt; &lt;p class=\"p1\"&gt; 是2008年北京青青树动漫科技有限公司以系列动画电影的第一部《魁拔之十万火急》为基础，重新剪辑而成的TV动画。 由王川执导，田博、马华等编剧，刘婧荦，竹内顺子等配音。 &lt;/p&gt; &lt;p class=\"p3\"&gt; TV版完整保留了电影的世界观、人物设定、故事内容和情节主线，但重制了片头曲。 《魁拔妖侠传》是魁拔系列电影的前传，主要讲述的是有关卡拉肖克潘家族的故事，与电影关系并不大。 目前大家所说的魁拔通常指魁拔系列动画电影。 &lt;/p&gt; &lt;p&gt; &lt;img src=\"a.png\" alt=\"\"&gt; &lt;span&gt;jdlajsdajldjalsjd&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 3.4、超链接伪类和阴影&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; /*默认颜色*/ a{ text-decoration: none; color: black; } /*鼠标悬浮的状态*/ a:hover{ color: orange; font-size: 20px; } /*鼠标按住未释放状态*/ a:active{ color: #2be24e; } /*text-shadow:阴影颜色 水平偏移 垂直偏移 阴影半径*/ #price{ text-shadow: cadetblue 5px 5px 1px; } p:hover{ background: blueviolet; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"#\"&gt; &lt;img src=\"images/1.jpg\" alt=\"\"&gt; &lt;/a&gt; &lt;p&gt; &lt;a href=\"#\"&gt;码出高效：Java开发手册&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;a href=\"#\"&gt;作者：孤尽老师&lt;/a&gt; &lt;/p&gt; &lt;p id=\"price\"&gt;￥99&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 3.5、列表#nav{ width: 300px; background: darkgrey; } .title{ font-size: 18px; font-weight: bold; text-indent: 1em; line-height: 35px; background: #ff0b2f; } /* list-style: none;去掉圆点 circle；空心圆 decimal：数字 square：正方形 */ /*ul{*/ /* background: darkgrey;*/ /*}*/ ul li{ height: 30px; list-style: none; text-indent: 1em; } a{ text-decoration: none; font-size: 14px; color: black; } a:hover{ color: orange; text-decoration: underline; } 3.6、背景图像背景颜色 背景图片 div{ width: 1400px; height: 700px; border: 1px solid red; background-image: url(\"images/1.jpg\"); /*默认平铺 repeat*/ } .div1{ background-repeat: repeat-x;/*水平平铺*/ } .div2{ background-repeat: repeat-y;/*竖直平铺*/ } .div3{ background-repeat: no-repeat;/*不平铺*/ } /* background：颜色 图片链接 位置 平铺方式 background: red url(\"images/a.jpg\") 270px 10px no-repeat */ 3.7、渐变推荐网站：https://www.grabient.com/ background-color: #FFFFFF; background-image: linear-gradient(124deg, #FFFFFF 0%, #6284FF 50%, #FF0000 100%); 4、盒子模型 4.1、什么是盒子 margan：外边距 padding：内边距 border：边框 4.2、边框 边框的粗细 边框的样式 边框的颜色 /*body总有一个默认的外边距margin：8dp*/ body{ margin: 0; } #app{ width: 300px; border: 1px solid red;/*粗细 样式 颜色*/ } h2{ font-size: 16px; background: cadetblue; line-height: 30px; margin: 0; color: #FFFFFF; } form{ background: cadetblue; } /* 设置第一个input，因为大的div下没有input标签，所以就找了小的div的input标签 */ div:nth-of-type(1)&gt;input{ border: 3px solid black; } div:nth-of-type(2)&gt;input{ border: 3px dashed #be0be2; } div:nth-of-type(2)&gt;input{ border: 2px dashed #2be24e; } 4.3、内外边距&lt;!--外边距可以使居中--&gt; &lt;style&gt; /*body总有一个默认的外边距margin：8dp*/ body{ margin: 0; } /* margin:0;一个参数为上下左右 margin: 0 auto;上下为0，左右自动，实现水平居中 margin:0 1px 2px 3px;四个参数为上右下左，顺时针 */ #app{ width: 300px; border: 1px solid red;/*粗细 样式 颜色*/ margin: 0 auto; } h2{ font-size: 16px; background: cadetblue; line-height: 30px; margin: 0; color: #FFFFFF; } form{ background: cadetblue; } input{ border: 1px solid black; } div:nth-of-type(1){ padding: 10px; } 盒子的计算方式：这个元素到底多大？ ​ 元素大小：margin+border+padding+内容宽度 4.4、圆角边框&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- border-radius: 50px 20px; 左上右下 右上左下--&gt; &lt;!-- border-radius: 100px 100px 0 0; 左上 右上 右下 左下--&gt; &lt;!--圆圈：圆角 = 半径 --&gt; &lt;style&gt; div{ width: 100px; height: 50px; border: 10px solid red; border-radius: 100px 100px 0 0; } img{ border-radius: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;img src=\"images/1.jpg\" alt=\"\"&gt; &lt;/body&gt; &lt;/html&gt; 4.5、盒子阴影&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- margin：0 auto;居中要求：外面是一个块元素，块元素有固定的宽度，body有无限宽度 一般和text-align：center 配合使用 --&gt; &lt;style&gt; div{ width: 1000px; height: 500px; text-align: center; } img{ border-radius: 100px; box-shadow: 10px 10px 100px yellow; margin: 0 auto; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;img src=\"images/1.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 回到顶部 5、浮动5.1、标准文档流块级元素：独占一行 h1~h6 p div 列表... 行内元素：不独占一行 span a img strong... 行内元素可以被包含在块级元素中，反之则不可以 5.2、display&lt;!--display: block;块元素 inline;行内元素 inline-block;是块元素，但是可以内联，在同一行 none;不显示 --&gt; &lt;style&gt; div{ width: 100px; height: 100px; border: red solid 1px; display: inline; } span{ width: 100px; height: 100px; border: red solid 1px; display: inline-block; } &lt;/style&gt; 这个也是一种能够实现行内元素排列的方式，但是我们很多情况都使用float 5.3、float左右浮动 div{ margin: 10px; padding: 5px; } #father{ border: 1px solid red; } .layer01{ border: 1px dashed black; display: inline-block; float: left; } .layer02{ border: 1px dashed green; display: inline-block; float: left; } .layer03{ border: 1px dashed blue; display: inline-block; float: left; } .layer04{ border: 1px dashed paleturquoise; font-size: 12px; line-height: 23px; display: inline-block; float: left; clear: both; } 5.4、父级边框塌陷问题clear clear: right; 右侧不允许有浮动元素 left; 左侧不允许有浮动元素 both;两侧都不允许有浮动元素 解决方案： 设置父级元素高度 #father{ border: 1px solid red; height: 800px; } 增加一个空的div子标签，清除浮动 &lt;div class=\"clear\"&gt;&lt;/div&gt; .clear{ clear: both; margin: 0; padding: 0; } overflow 在父级元素中增加一个 overflow: hidden; 父类添加一个伪类 after #father:after{ content: ''; display: block; clear: both; } 小结： 浮动元素后面增加空的div 简单，代码中尽量避免空的div 设置父元素的高度 简单，元素假设有了固定的高度，就会被限制 overflow 简单，下拉的一些场景避免使用 父类添加一个伪类：after（推荐） 写法稍微复杂一点，但是没有副作用，推荐使用 5.5、对比 display 方向不可控制 float 浮动起来会脱离标准文档流，所以要解决父级塌陷的问题 6、定位6.1、相对定位相对定位：position: relative; 相对于原来的位置，进行指定的偏移,相对定位的话，它仍然在标准文档流中，原来的位置会被保留 top: -20px; left: 20px; bottom: -10px; right: 20px; &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!--相对定位：相对于自己原来的位置进行定位--&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body{ padding: 20px; } div{ margin: 10px; padding: 5px; font-size: 12px; line-height: 15px; } #father{ border: 1px solid red; padding: 0; } #first{ background-color: #23ff66; border: 1px dashed #23ff98; position: relative;/*相对定位：上下左右*/ top: -20px; left: 20px; } #second{ background-color: #34cedd; border: 1px dashed #34ceff; } #third{ background-color: #ff8299; border: 1px dashed #ff82fc; position: relative; bottom: -10px; right: 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"father\"&gt; &lt;div id=\"first\"&gt;第一个盒子&lt;/div&gt; &lt;div id=\"second\"&gt;第二个盒子&lt;/div&gt; &lt;div id=\"third\"&gt;第三个盒子&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 练习：方块定位 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #box{ width: 300px; height: 300px; border: red 1px solid; padding: 10px; } a{ width: 100px; height: 100px; text-decoration: none; background: pink; line-height: 100px; text-align: center; color: #FFFFFF; display: block; } a:hover{ background: #6284FF; } .a2,.a4{ position: relative; left: 200px; top: -100px; } .a5{ position: relative; top: -300px; right: -100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"box\"&gt; &lt;a href=\"#\" class=\"a1\"&gt;链接1&lt;/a&gt; &lt;a href=\"#\" class=\"a2\"&gt;链接2&lt;/a&gt; &lt;a href=\"#\" class=\"a3\"&gt;链接3&lt;/a&gt; &lt;a href=\"#\" class=\"a4\"&gt;链接4&lt;/a&gt; &lt;a href=\"#\" class=\"a5\"&gt;链接5&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 6.2、绝对定位定位：基于xxx定位，上下左右 没有父级元素定位的前提下，相对于浏览器定位 假设父级元素存在定位，通常相对于父级元素进行偏移 在父级元素范围内移动 相对于父级或者浏览器的位置，进行指定的偏移,绝对定位的话，它不在在标准文档流中，原来的位置不会被保留 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div{ margin: 10px; padding: 5px; font-size: 12px; line-height: 15px; } #father{ border: 1px solid red; padding: 0; position: relative; } #first{ background-color: #23ff66; border: 1px dashed #23ff98; } #second{ background-color: #34cedd; border: 1px dashed #34ceff; position: absolute; right: 30px; } #third{ background-color: #ff8299; border: 1px dashed #ff82fc; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"father\"&gt; &lt;div id=\"first\"&gt;第一个盒子&lt;/div&gt; &lt;div id=\"second\"&gt;第二个盒子&lt;/div&gt; &lt;div id=\"third\"&gt;第三个盒子&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 6.3、固定定位 fixed&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body{ height: 1000px; } div:nth-of-type(1){ /*绝对定位，相对于浏览器初始位置*/ width: 100px; height: 100px; background: #6284FF; position: absolute; right: 0; bottom: 0; } div:nth-of-type(2){/*fixed,固定定位，一直定在那*/ width: 50px; height: 50px; background: #2be24e; position: fixed; right: 0; bottom: 0; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div1&lt;/div&gt; &lt;div&gt;div2&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 6.4、z-index图层~ z-index：默认是0，最高无限制 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li class=\"tipText\"&gt;大家好&lt;/li&gt; &lt;li class=\"tipBg\"&gt;&lt;/li&gt; &lt;li&gt;时间：2099-1-1&lt;/li&gt; &lt;li&gt;地点：月球一号基地&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; opacity: 0.5; /*背景透明度*/ #content{ width: 380px; padding: 0; margin: 0; overflow: hidden; font-size: 12px; line-height: 25px; border: 1px solid red; } ul,li{ margin: 0; padding: 0; list-style: none; } /*父级元素相对定位*/ #content ul{ position: relative; } .tipText,.tipBg{ position: absolute; width: 380px; height: 25px; top: 200px; } .tipBg{ background: #05e29b; opacity: 0.5;/*背景透明度*/ } .tipText{ z-index: 999; } 7、变形在CSS3中，可以利用transform功能来实现文字或图像的旋转、缩放、倾斜、移动这四种类型的变形处理，本文将对此做详细介绍。 7.1、旋转 rotate用法：transform: rotate(45deg); 共一个参数“角度”，单位deg为度的意思，正数为顺时针旋转，负数为逆时针旋转，上述代码作用是顺时针旋转45度。 7.2、缩放 scale用法：transform: scale(0.5) 或者 transform: scale(0.5, 2); 参数表示缩放倍数； 一个参数时：表示水平和垂直同时缩放该倍率 两个参数时：第一个参数指定水平方向的缩放倍率，第二个参数指定垂直方向的缩放倍率。 7.3、倾斜 skew用法：transform: skew(30deg) 或者 transform: skew(30deg, 30deg); 参数表示倾斜角度，单位deg 一个参数时：表示水平方向的倾斜角度； 两个参数时：第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度。 关于skew倾斜角度的计算方式表面上看并不是那么直观，这里借鉴某大拿绘制的图举例说明一下： 首先需要说明的是skew的默认原点transform-origin是这个物件的中心点 skewX(30deg) 如下图： skewY(10deg) 如下图： skew(30deg, 10deg) 如下图： 我当初就是看到此图瞬间理解的。 7.4、移动 translate用法：transform: translate(45px) 或者 transform: translate(45px, 150px); 参数表示移动距离，单位px， 一个参数时：表示水平方向的移动距离； 两个参数时：第一个参数表示水平方向的移动距离，第二个参数表示垂直方向的移动距离。 7.5、基准点 transform-origin在使用transform方法进行文字或图像的变形时，是以元素的中心点为基准点进行的。使用transform-origin属性，可以改变变形的基准点。 用法：transform-origin: 10px 10px; 共两个参数，表示相对左上角原点的距离，单位px，第一个参数表示相对左上角原点水平方向的距离，第二个参数表示相对左上角原点垂直方向的距离； 两个参数除了可以设置为具体的像素值，其中第一个参数可以指定为left、center、right，第二个参数可以指定为top、center、bottom。 7.6、多方法组合变形上面我们介绍了使用transform对元素进行旋转、缩放、倾斜、移动的方法，这里讲介绍综合使用这几个方法来对一个元素进行多重变形。 用法：transform: rotate(45deg) scale(0.5) skew(30deg, 30deg) translate(100px, 100px); 这四种变形方法顺序可以随意，但不同的顺序导致变形结果不同，原因是变形的顺序是从左到右依次进行，这个用法中的执行顺序为1.rotate 2.scalse 3.skew 4.translate 8、总结","categories":[],"tags":[]},{"title":"","slug":"AJAX","date":"2021-09-14T08:23:41.379Z","updated":"2021-09-14T08:23:41.584Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 伪造Ajax我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function(){ var myDate = new Date(); document.getElementById('currentTime').innerText = myDate.getTime(); }; function LoadPage(){ var targetUrl = document.getElementById('url').value; console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; } &lt;/script&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" value=\"https://www.baidu.com/\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage()\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3、使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 ….等等 jQuery.ajax纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;beanclass=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 2、编写一个AjaxController @Controller public class AjaxController { @RequestMapping(\"/a1\") public void ajax1(String name , HttpServletResponse response) throwsIOException { if (\"admin\".equals(name)){ response.getWriter().print(\"true\"); }else{ response.getWriter().print(\"false\"); } } } 3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入 &lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; 4、编写index.jsp测试 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt;--%&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ &lt;%-- 这里的$是jQuery的缩写--%&gt; $.post({ url:\"${pageContext.request.contextPath}/a1\", data:{'name':$(\"#txtName\").val()}, success:function (data,status) { &lt;%-- 这里的data是后台controller返回的数据--%&gt; alert(data); alert(status); } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;%--onblur：失去焦点触发事件--%&gt; 用户名:&lt;input type=\"text\" id=\"txtName\" onblur=\"a1()\"/&gt; &lt;/body&gt; &lt;/html&gt; 5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ Springmvc实现实体类user @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 我们来获取一个集合对象，展示到前端页面 @RequestMapping(\"/a2\") public List&lt;User&gt; ajax2(){ List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(\"秦疆1号\",3,\"男\")); list.add(new User(\"秦疆2号\",3,\"男\")); list.add(new User(\"秦疆3号\",3,\"男\")); return list; //由于@RestController注解，将list转成json格式返回 } 前端页面 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" id=\"btn\" value=\"获取数据\"/&gt; &lt;table width=\"80%\" align=\"center\"&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;tbody id=\"content\"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () { $(\"#btn\").click(function () { $.post(\"${pageContext.request.contextPath}/a2\",function (data) { console.log(data) var html=\"\"; for (var i = 0; i &lt;data.length ; i++) { html+= \"&lt;tr&gt;\" + \"&lt;td&gt;\" + data[i].name + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].age + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].sex + \"&lt;/td&gt;\" + \"&lt;/tr&gt;\" } $(\"#content\").html(html); }); }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 成功实现了数据回显！可以体会一下Ajax的好处！ 注册提示效果我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化 我们写一个Controller @RequestMapping(\"/a3\") public String ajax3(String name,String pwd){ String msg = \"\"; //模拟数据库中存在数据 if (name!=null){ if (\"admin\".equals(name)){ msg = \"OK\"; }else { msg = \"用户名输入错误\"; } } if (pwd!=null){ if (\"123456\".equals(pwd)){ msg = \"OK\"; }else { msg = \"密码输入有误\"; } } return msg; //由于@RestController注解，将msg转成json格式返回 } 前端页面 login.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ $.post({ url:\"${pageContext.request.contextPath}/a3\", data:{'name':$(\"#name\").val()}, success:function (data) { if (data.toString()=='OK'){ $(\"#userInfo\").css(\"color\",\"green\"); }else { $(\"#userInfo\").css(\"color\",\"red\"); } $(\"#userInfo\").html(data); } }); } function a2(){ $.post({ url:\"${pageContext.request.contextPath}/a3\", data:{'pwd':$(\"#pwd\").val()}, success:function (data) { if (data.toString()=='OK'){ $(\"#pwdInfo\").css(\"color\",\"green\"); }else { $(\"#pwdInfo\").css(\"color\",\"red\"); } $(\"#pwdInfo\").html(data); } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 用户名:&lt;input type=\"text\" id=\"name\" onblur=\"a1()\"/&gt; &lt;span id=\"userInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 密码:&lt;input type=\"text\" id=\"pwd\" onblur=\"a2()\"/&gt; &lt;span id=\"pwdInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 【记得处理json乱码问题】 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 测试一下效果，动态请求响应，局部刷新，就是如此！ 获取baidu接口Demo&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;JSONP百度搜索&lt;/title&gt; &lt;style&gt; #q{ width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; } #ul{ width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; } #ul li{ line-height: 30px; padding: 0 10px; } #ul li:hover{ background-color: #f60; color: #fff; } &lt;/style&gt; &lt;script&gt; // 2.步骤二 // 定义demo函数 (分析接口、数据) function demo(data){ var Ul = document.getElementById('ul'); var html = ''; // 如果搜索数据存在 把内容添加进去 if (data.s.length) { // 隐藏掉的ul显示出来 Ul.style.display = 'block'; // 搜索到的数据循环追加到li里 for(var i = 0;i&lt;data.s.length;i++){ html += '&lt;li&gt;'+data.s[i]+'&lt;/li&gt;'; } // 循环的li写入ul Ul.innerHTML = html; } } // 1.步骤一 window.onload = function(){ // 获取输入框和ul var Q = document.getElementById('q'); var Ul = document.getElementById('ul'); // 事件鼠标抬起时候 Q.onkeyup = function(){ // 如果输入框不等于空 if (this.value != '') { // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ // 创建标签 var script = document.createElement('script'); //给定要跨域的地址 赋值给src //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src ='https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='+this.value+'&amp;cb=demo'; // 将组合好的带src的script标签追加到body里 document.body.appendChild(script); } } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" id=\"q\" /&gt; &lt;ul id=\"ul\"&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; Ajax在我们开发中十分重要，一定要学会使用！","categories":[],"tags":[]},{"title":"","slug":"ElasticSearch","date":"2021-09-14T08:23:18.100Z","updated":"2021-09-14T08:23:18.267Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"ElasticSearch概述Lucene 和 ElasticSearch 关系： ElasticSearch 是基于 Lucene 做了一些封装和增强 Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别（大数据时代）的数据。es也使用 Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。 使用 维基百科，类似百度百科，全文检索，高亮，搜索推荐/2 （权重，百度！） The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜） Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和 回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案 GitHub（开源代码管理），搜索上千亿行代码 电商网站，检索商品 日志数据分析，logstash采集日志，ES进行复杂的数据分析，ELK技术（ elasticsearch+logstash+kibana） 商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如 说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买。 BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近 3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，**区，最近3年，每年消费 金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘， Kibana进行数据可视化 国内：站内搜索（电商，招聘，门户，等等），IT系统搜索（OA，CRM，ERP，等等），数据分析 （ES热门 的一个使用场景） ES和Solr的差别Elasticsearch简介Elasticsearch是一个实时分布式搜索和分析引擎。它让你以前所未有的速度处理大数据成为可能。它用于全文搜索、结构化搜索、分析以及将这三者混合使用：维基百科使用Elasticsearch提供全文搜索并高亮关键字，以及输入实时搜索(search-asyou-type)和搜索纠错(did-you-mean)等搜索建议功能。英国卫报使用Elasticsearch结合用户日志和社交网络数据提供给他们的编辑以实时的反馈，以便及时了解公众对新发表的文章的回应。StackOverflow结合全文搜索与地理位置查询，以及more-like-this功能来找到相关的问题和答案。Github使用Elasticsearch检索1300亿行的代码。 但是Elasticsearch不仅用于大型企业，它还让像DataDog以及Klout这样的创业公司将最初的想法变成可扩展的解决方案。Elasticsearch可以在你的笔记本上运行，也可以在数以百计的服务器上处理PB级别的数据 。 Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。 但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 Solr简介Solr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化 Solr可以独立运行，运行在Jetty、Tomcat等这些Servlet容器中，Solr 索引的实现方法很简单，用 POST方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。Solr不提供构建UI的功能，Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。 solr是基于lucene开发企业级搜索服务器，实际上就是封装了lucene。 Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的文件，生成索引；也可以通过提出查找请求，并得到返回结果。 Lucene简介Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具 包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引 引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单 易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索 引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提 供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。人们 经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。 Lucene是一个全文检索引擎的架构。那什么是全文搜索引擎？ 全文搜索引擎是名副其实的搜索引擎，国外具代表性的有Google、Fast/AllTheWeb、AltaVista、 Inktomi、Teoma、WiseNut等，国内著名的有百度（Baidu）。它们都是通过从互联网上提取的各个网 站的信息（以网页文字为主）而建立的数据库中，检索与用户查询条件匹配的相关记录，然后按一定的 排列顺序将结果返回给用户，因此他们是真正的搜索引擎。 从搜索结果来源的角度，全文搜索引擎又可细分为两种，一种是拥有自己的检索程序（Indexer），俗称 “蜘蛛”（Spider）程序或“机器人”（Robot）程序，并自建网页数据库，搜索结果直接从自身的数据库中 调用，如上面提到的7家引擎；另一种则是租用其他引擎的数据库，并按自定的格式排列搜索结果，如 Lycos引擎。 Elasticsearch和Solr比较 比较总结 1、es基本是开箱即用（解压就可以用 ! ），非常简单。Solr安装略微复杂一丢丢！ 2、Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。 3、Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持 json文件格式。 4、Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提 供，例如图形化界面需要kibana友好支撑~! 5、Solr 查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用； ES建立索引快（即查询慢），即实时性查询快，用于facebook新浪等搜索。 Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。 6、Solr比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而 Elasticsearch相对开发维护者较少，更新太快，学习使用成本较高。（趋势！） ElasticSearch安装声明：JDK1.8 ，最低要求！ ElasticSearch 客户端，界面工具！ Java开发，ElasticSearch 的版本和我们之后对应的 Java 的核心jar包！ 版本对应！JDK 环境是正常！ 下载 官网：https://www.elastic.co/ 下载地址：https://www.elastic.co/cn/downloads/elasticsearch window 下安装！ 解压就可以使用了！ 熟悉目录！ bin 启动文件 config 配置文件 log4j2 日志配置文件 jvm.options java 虚拟机相关的配置 elasticsearch.yml elasticsearch 的配置文件！ 默认 9200 端口！ 跨域！ lib 相关jar包 logs 日志！ modules 功能模块 plugins 插件！ 启动，访问9200； 启动不起来在elasticsearch.yml末尾添加 xpack.ml.enabled: false 访问测试！ 安装可视化界面 es head的插件 需要node.js环境 下载地址：https://github.com/mobz/elasticsearch-head/ 启动 npm install npm run start 连接测试发现，存在跨域问题：配置 es 的 yml 配置文件 http.cors.enabled: true http.cors.allow-origin: \"*\" 重启es服务器，然后再次连接 初学，就把es当做一个数据库！ （可以建立索引（库），文档（库中的数据！）） 这个head我们就把它当做数据展示工具！我们后面所有的查询，Kibana！ 了解 ELK ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。市面上也被成为ElasticStack。其中Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为 es。Logstash是ELK的中央数据流引擎，用于从不同目标（文件/数据存储/MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件/MQ/redis/elasticsearch/kafka等）。Kibana可以将Elasticsearch 的数据通过友好的页面展示出来，提供实时分析的功能。 市面上很多开发只要提到ELK能够一致说出它是一个日志分析架构技术栈总称，但实际上ELK不仅仅适用于日志分析，它还可以支持其它任何数据分析和收集的场景，日志分析和收集只是更具有代表性。并非唯一性。 安装Kibana Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测 官网：https://www.elastic.co/cn/kibana Kibana 版本要和 Es 一致！ 启动测试： 解压后端的目录 启动 访问测试 开发工具！ （Post、curl、head、谷歌浏览器插件测试！） 汉化！自己修改kibana配置即可！ zh-CN！ kibaba.yml文件末尾添加 i18n.locale: \"zn-CH\" ES核心概念 索引 字段类型（mapping） 文档（documents） 概述 在前面的学习中，我们已经掌握了es是什么，同时也把es的服务已经安装启动，那么es是如何去存储数据，数据结构是什么，又是如何实现搜索的呢？我们先来聊聊ElasticSearch的相关概念吧！ 集群，节点，索引，类型，文档，分片，映射是什么？ elasticsearch是面向文档，关系型数据库 和 elasticsearch 客观的对比！一切都是JSON！ Relational DB Elasticsearch 数据库(database) 索引(indices) 表(tables) types 行(rows) documents 字段(columns) fields elasticsearch(集群)中可以包含多个索引(数据库)，每个索引中可以包含多个类型(表)，每个类型下又包含多个文档(行)，每个文档中又包含多个字段(列)。 物理设计： elasticsearch 在后台把每个索引划分成多个分片，每个分片可以在集群中的不同服务器间迁移 一个人就是一个集群！默认的集群名称就是 elaticsearh 逻辑设计： 一个索引类型中，包含多个文档，比如说文档1，文档2。 当我们索引一篇文档时，可以通过这样的顺序找到 它: 索引 ▷ 类型 ▷ 文档ID ，通过这个组合我们就能索引到某个具体的文档。 注意:ID不必是整数，实际上它是个字符串。 文档 就是我们的一条条数据 user 1 zhangsan 18 2 kuangshen 3 之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch中，文档有几个 重要属性 : 自我包含，一篇文档同时包含字段和对应的值，也就是同时包含 key:value！ 可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的！ {就是一个json对象！fastjson进行自动转换！} 灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。 尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型。 类型 类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。 类型中对于字段的定义称为映射，比如 name 映射为字符串类型。 我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch会认为它是整形。 但是elasticsearch也可能猜不对， 所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别整什么幺蛾子。 索引 就是数据库！ 索引是映射类型的容器，elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。 然后它们被存储到了各个分片上了。 我们来研究下分片是如何工作的。 物理设计 ：节点和分片 如何工作 一个集群至少有一个节点，而一个节点就是一个elasricsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片 ( primary shard ,又称主分片 ) 构成的，每一个主分片会有一个副本 ( replica shard ,又称复制分片 ) 上图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内，这样有利于某个节点挂掉 了，数据也不至于丢失。 实际上，一个分片是一个Lucene索引，一个包含倒排索引的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。 不过倒排索引是什么? 倒排索引 elasticsearch使用的是一种称为倒排索引的结构，采用Lucene倒排索作为底层。这种结构适用于快速的全文搜索， 一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。 例如，现在有两个文档， 每个文档包含如下内容： Study every day, good good up to forever # 文档1包含的内容 To forever, study every day, good good up # 文档2包含的内容 为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens)，然后创建一个包含所有不重复的词条的排序列表，然后列出每个词条出现在哪个文档 : term doc_1 doc_2 Study √ x To x x every √ √ forever √ √ day √ √ study x √ good √ √ every √ √ to √ x up √ √ 现在，我们试图搜索 to forever，只需要查看包含每个词条的文档 score term doc_1 doc_2 to √ × forever √ √ total 2 1 两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，现在，这两个包含关键字的文档都将返回。 再来看一个示例，比如我们通过博客标签来搜索博客文章。那么倒排索引列表就是这样的一个结构 : 如果要搜索含有 python 标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要 查看标签这一栏，然后获取相关的文章ID即可。完全过滤掉无关的所有数据，提高效率！ elasticsearch的索引和Lucene的索引对比 在elasticsearch中， 索引 （库）这个词被频繁使用，这就是术语的使用。 在elasticsearch中，索引被分为多个分片，每份分片是一个Lucene的索引。所以一个elasticsearch索引是由多个Lucene索引组成的。别问为什么，谁让elasticsearch使用Lucene作为底层呢! 如无特指，说起索引都是指elasticsearch的索引。 IK分词器插件 什么是IK分词器？ 分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，比如 “我爱狂神” 会被分为”我”,”爱”,”狂”,”神”，这显然是不符合要求的，所以我们需要安装中文分词器ik来解决这个问题。 如果要使用中文，建议使用ik分词器！ IK提供了两个分词算法：ik_smart 和 ik_max_word，其中 ik_smart 为最少切分，ik_max_word为最细粒度划分！ 安装 https://github.com/medcl/elasticsearch-analysis-ik 下载完毕之后，放入到我们的elasticsearch 插件即可！ 重启观察ES，可以看到ik分词器被加载了！ elasticsearch-plugin 可以通过这个命令来查看加载进来的插件 使用kibana测试！ 查看不同的分词效果 其中 ik_smart 为最少切分 ik_max_word为最细粒度划分！穷尽词库的可能！字典！ 我们输入 超级喜欢狂神说Java 发现问题：狂神说被拆开了！ 这种自己需要的词，需要自己加到我们的分词器的字典中！ ik 分词器增加自己的配置！ 重启es，看细节！ 再次测试一下狂神说，看下效果！ Rest风格说明一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 基本Rest命令说明： method url地址 描述 PUT localhost:9200/索引名称/类型名称/文档id 创建文档（指定文档id） POST localhost:9200/索引名称/类型名称 创建文档（随机文档id） POST localhost:9200/索引名称/类型名称/文档id/_update 修改文档 DELETE localhost:9200/索引名称/类型名称/文档id 删除文档 GET localhost:9200/索引名称/类型名称/文档id 查询文档通过文档id POST localhost:9200/索引名称/类型名称/_search 查询所有数据 关于索引的基本操作创建一个索引PUT /索引名/~类型名~/文档id { 请求体 } 完成了自动增加了索引！数据也成功的添加了，这就是我说大家在初期可以把它当做数据库学习的原因！ 那么 name 这个字段用不用指定类型呢。毕竟我们关系型数据库 是需要指定类型的啊 ! 字符串类型 text 、 keyword 数值类型 long, integer, short, byte, double, float, half_float, scaled_float 日期类型 date 布尔值类型 boolean 二进制类型 binary 等等….. 指定字段的类型 获得这个规则！ 可以通过 GET 请求获取具体的信息！ 查看默认的信息 如果自己的文档字段没有指定，那么es 就会给我们默认配置字段类型！ 扩展： 通过命令 elasticsearch 索引情况！ 通过GET _cat/ 可以获得es的当前的很多信息！ 修改索引曾经是用PUT，如果字段写不全（少写字段就会被丢弃）也就是覆盖原来的数据！ 现在的方法用POST，相应请求后面要加 _update ，只会更新提交的字段！ 删除索引通过DELETE 命令实现删除、 根据你的请求来判断是删除索引还是删除文档记录！ 使用RESTFUL 风格是ES推荐大家使用的！ 关于文档的基本操作（重点）基本操作添加数据PUT /kuangshen/user/1 { \"name\": \"狂神说\", \"age\": 23, \"desc\": \"一顿操作猛如虎，一看工资2500\", \"tags\": [\"技术宅\",\"温暖\",\"直男\"] } 获取数据 GET 更新数据 PUT Post _update , 推荐使用这种更新方式！ 使用 POST 后面没有加 _update 其他没有被提交的字段会被置空，然后新添加了doc.name字段 使用 POST 后面加 _update 提交的字段值被更新了，没有被提交的字段还是原来的值 简单地搜索GET kuangshen/user/1 简答的条件查询，可以根据默认的映射规则，产生基本的查询！ 复杂操作搜索select ( 排序，分页，高亮，模糊查询，精准查询！) 输出结果，不想要那么多！ 我们之后使用Java操作es ，所有的方法和对象就是这里面的 key！ 排序！ 分页查询！ 数据下标还是从0开始的，和学的所有数据结构是一样的！ /search/{current}/{pagesize} 布尔值查询 must （and），所有的条件都要符合 where id = 1 and name = xxx should（or），所有的条件都要符合 where id = 1 or name = xxx must_not （not） 过滤器 filter gt 大于 gte 大于等于 lt 小于 lte 小于等于！ 匹配多个条件！ 精确查询！ term 查询是直接通过倒排索引指定的词条进程精确查找的！ 关于分词： term ，直接查询精确的 match，会使用分词器解析！（先分析文档，然后在通过分析的文档进行查询！） 两个类型 text keyword (text类型的会被分词，keyword类型的不会被分词) 多个值匹配精确查询 高亮查询！ 集成SpringBoot 找官方文档！ 找到原生的依赖 &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.6.2&lt;/version&gt; &lt;/dependency&gt; 找对象 分析这个类中的方法即可！ 配置基本的项目 问题：一定要保证 我们的导入的依赖和我们的 es 版本一致 源码中提供对象！ 虽然这里导入3个类，静态内部类，核心类就一个！ /** * Elasticsearch rest client infrastructure configurations. * * @author Brian Clozel * @author Stephane Nicoll */ class RestClientConfigurations { @Configuration(proxyBeanMethods = false) static class RestClientBuilderConfiguration { // RestClientBuilder @Bean @ConditionalOnMissingBean RestClientBuilder elasticsearchRestClientBuilder(RestClientProperties properties, ObjectProvider&lt;RestClientBuilderCustomizer&gt; builderCustomizers) { HttpHost[] hosts = properties.getUris().stream().map(HttpHost::create).toArray(HttpHost[]::new); RestClientBuilder builder = RestClient.builder(hosts); PropertyMapper map = PropertyMapper.get(); map.from(properties::getUsername).whenHasText().to((username) -&gt; { CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); Credentials credentials = new UsernamePasswordCredentials(properties.getUsername(), properties.getPassword()); credentialsProvider.setCredentials(AuthScope.ANY, credentials); builder.setHttpClientConfigCallback( (httpClientBuilder) -&gt; httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider)); }); builder.setRequestConfigCallback((requestConfigBuilder) -&gt; { map.from(properties::getConnectionTimeout).whenNonNull().asInt(Duration::toMill is) .to(requestConfigBuilder::setConnectTimeout); map.from(properties::getReadTimeout).whenNonNull().asInt(Duration::toMillis) .to(requestConfigBuilder::setSocketTimeout); return requestConfigBuilder; }); builderCustomizers.orderedStream().forEach((customizer) -&gt; customizer.customize(builder)); return builder; } } @Configuration(proxyBeanMethods = false) @ConditionalOnClass(RestHighLevelClient.class) static class RestHighLevelClientConfiguration { // RestHighLevelClient 高级客户端，也是我们这里要讲，后面项目会用到的客户端 @Bean @ConditionalOnMissingBean RestHighLevelClient elasticsearchRestHighLevelClient(RestClientBuilder restClientBuilder) { return new RestHighLevelClient(restClientBuilder); } @Bean @ConditionalOnMissingBean RestClient elasticsearchRestClient(RestClientBuilder builder, ObjectProvider&lt;RestHighLevelClient&gt; restHighLevelClient) { RestHighLevelClient client = restHighLevelClient.getIfUnique(); if (client != null) { return client.getLowLevelClient(); } return builder.build(); } } @Configuration(proxyBeanMethods = false) static class RestClientFallbackConfiguration { // RestClient 普通的客户端！ @Bean @ConditionalOnMissingBean RestClient elasticsearchRestClient(RestClientBuilder builder) { return builder.build(); } } } 具体的Api测试！ 创建索引 判断索引是否存在 删除索引 创建文档 crud文档！ 配置类 @Configuration public class RestHighLevelClientConfiguration { @Bean public RestHighLevelClient restHighLevelClient() { RestHighLevelClient client = new RestHighLevelClient( RestClient.builder( new HttpHost(\"localhost\", 9200, \"http\"))); return client; } } 测试类 @SpringBootTest class KuangshenEsApiApplicationTests { // 面向对象来操作 @Autowired @Qualifier(\"restHighLevelClient\") private RestHighLevelClient client; // 测试索引的创建 Request PUT kuang_index @Test void testCreateIndex() throws IOException { // 1、创建索引请求 CreateIndexRequest request = new CreateIndexRequest(\"kuang_index\"); // 2、客户端执行请求 IndicesClient,请求后获得响应 CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT); System.out.println(createIndexResponse); } // 测试获取索引,判断其是否存在 @Test void testExistIndex() throws IOException { GetIndexRequest request = new GetIndexRequest(\"kuang_index2\"); boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); System.out.println(exists); } // 测试删除索引 @Test void testDeleteIndex() throws IOException { DeleteIndexRequest request = new DeleteIndexRequest(\"kuang_index\"); // 删除 AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT); System.out.println(delete.isAcknowledged()); } // 测试添加文档 @Test void testAddDocument() throws IOException { // 创建对象 User user = new User(\"狂神说\", 3); // 创建请求 IndexRequest request = new IndexRequest(\"kuang_index\"); // 规则 put /kuang_index/_doc/1 request.id(\"1\"); request.timeout(TimeValue.timeValueSeconds(1)); request.timeout(\"1s\"); // 将我们的数据放入请求 json request.source(JSON.toJSONString(user), XContentType.JSON); // 客户端发送请求 , 获取响应的结果 IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT); System.out.println(indexResponse.toString()); // System.out.println(indexResponse.status()); // 对应我们命令返回的状态CREATED } // 获取文档，判断是否存在 get /index/doc/1 @Test void testIsExists() throws IOException { GetRequest getRequest = new GetRequest(\"kuang_index\", \"1\"); // 不获取返回的 _source 的上下文了 getRequest.fetchSourceContext(new FetchSourceContext(false)); getRequest.storedFields(\"_none_\"); boolean exists = client.exists(getRequest, RequestOptions.DEFAULT); System.out.println(exists); } // 获得文档的信息 @Test void testGetDocument() throws IOException { GetRequest getRequest = new GetRequest(\"kuang_index\", \"1\"); GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT); System.out.println(getResponse.getSourceAsString()); // 打印文档的内容 System.out.println(getResponse); // 返回的全部内容和命令式一样的 } // 更新文档的信息 @Test void testUpdateRequest() throws IOException { UpdateRequest updateRequest = new UpdateRequest(\"kuang_index\",\"1\"); updateRequest.timeout(\"1s\"); User user = new User(\"狂神说Java\", 18); updateRequest.doc(JSON.toJSONString(user),XContentType.JSON); UpdateResponse updateResponse = client.update(updateRequest, RequestOptions.DEFAULT); System.out.println(updateResponse.status()); } // 删除文档记录 @Test void testDeleteRequest() throws IOException { DeleteRequest request = new DeleteRequest(\"kuang_index\",\"1\"); request.timeout(\"1s\"); DeleteResponse deleteResponse = client.delete(request, RequestOptions.DEFAULT); System.out.println(deleteResponse.status()); } // 特殊的，真的项目一般都会批量插入数据！ @Test void testBulkRequest() throws IOException { BulkRequest bulkRequest = new BulkRequest(); bulkRequest.timeout(\"10s\"); ArrayList&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(\"kuangshen1\",3)); userList.add(new User(\"kuangshen2\",3)); userList.add(new User(\"kuangshen3\",3)); userList.add(new User(\"qinjiang1\",3)); userList.add(new User(\"qinjiang1\",3)); userList.add(new User(\"qinjiang1\",3)); // 批处理请求 for (int i = 0; i &lt; userList.size() ; i++) { // 批量更新和批量删除，就在这里修改对应的请求就可以了 bulkRequest.add( new IndexRequest(\"kuang_index\") .id(\"\"+(i+1)) .source(JSON.toJSONString(userList.get(i)),XContentType.JSON)); } BulkResponse bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT); System.out.println(bulkResponse.hasFailures()); // 是否失败，返回 false 代表成功！ } // 查询 // SearchRequest 搜索请求 // SearchSourceBuilder 条件构造 // HighlightBuilder 构建高亮 // TermQueryBuilder 精确查询 // MatchAllQueryBuilder // xxx QueryBuilder 对应我们刚才看到的命令！ @Test void testSearch() throws IOException { SearchRequest searchRequest = new SearchRequest(\"kuang_index\"); // 构建搜索条件 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); sourceBuilder.highlighter() // 查询条件，我们可以使用 QueryBuilders 工具来实现 // QueryBuilders.termQuery 精确 // QueryBuilders.matchAllQuery() 匹配所有 TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(\"name\", \"qinjiang1\"); // MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery(); sourceBuilder.query(termQueryBuilder); sourceBuilder.timeout(new TimeValue(60,TimeUnit.SECONDS)); searchRequest.source(sourceBuilder); SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT); System.out.println(JSON.toJSONString(searchResponse.getHits())); System.out.println(\"=================================\"); for (SearchHit documentFields : searchResponse.getHits().getHits()) { System.out.println(documentFields.getSourceAsMap()); } } } 爬虫1、导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.11.2&lt;/version&gt; &lt;/dependency&gt; 2、编写工具类 package com.xu.utils; import com.xu.pojo.Content; import org.jsoup.Jsoup; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element; import org.jsoup.select.Elements; import org.springframework.stereotype.Component; import java.net.URL; import java.util.ArrayList; @Component public class JsoupUtils { public static void main(String[] args) throws Exception { new JsoupUtils().getContent(\"心理学\").forEach(System.out::println); } public ArrayList&lt;Content&gt; getContent(String keyword) throws Exception{ //请求url https://search.jd.com/Search?keyword=java String url = \"https://search.jd.com/Search?keyword=\"+keyword+\"&amp;enc=utf-8\"; //返回的就是浏览器document对象 Document document = Jsoup.parse(new URL(url), 30000); //获取一个大的div Element element = document.getElementById(\"J_goodsList\"); //获取div里的所有li Elements elements = element.getElementsByTag(\"li\"); // System.out.println(elements.html()); ArrayList&lt;Content&gt; list = new ArrayList&lt;&gt;(); for (Element el : elements) { String img = el.getElementsByTag(\"img\").get(0).attr(\"data-lazy-img\"); String price = el.getElementsByClass(\"p-price\").get(0).text(); String title = el.getElementsByClass(\"p-name\").get(0).text(); Content content = new Content(title, price, img); list.add(content); } return list; } } 3、业务编写 package com.xu.service; import com.alibaba.fastjson.JSON; import com.xu.pojo.Content; import com.xu.utils.JsoupUtils; import org.elasticsearch.action.bulk.BulkRequest; import org.elasticsearch.action.bulk.BulkResponse; import org.elasticsearch.action.index.IndexRequest; import org.elasticsearch.action.search.SearchRequest; import org.elasticsearch.action.search.SearchResponse; import org.elasticsearch.client.RequestOptions; import org.elasticsearch.client.RestHighLevelClient; import org.elasticsearch.common.text.Text; import org.elasticsearch.common.unit.TimeValue; import org.elasticsearch.common.xcontent.XContentType; import org.elasticsearch.index.query.QueryBuilders; import org.elasticsearch.index.query.TermQueryBuilder; import org.elasticsearch.search.SearchHit; import org.elasticsearch.search.builder.SearchSourceBuilder; import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder; import org.elasticsearch.search.fetch.subphase.highlight.HighlightField; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.concurrent.TimeUnit; //业务编写 @Service public class ContentService { @Autowired private RestHighLevelClient restHighLevelClient; //解析数据放入 es 索引中 public boolean parseContent(String keyword) throws Exception { ArrayList&lt;Content&gt; contents = new JsoupUtils().getContent(keyword); //把查询的数据放入es中 BulkRequest bulkRequest = new BulkRequest(); bulkRequest.timeout(new TimeValue(60, TimeUnit.SECONDS)); for (int i = 0; i &lt; contents.size(); i++) { bulkRequest.add(new IndexRequest(\"jd_index\").source(JSON.toJSONString(contents.get(i)), XContentType.JSON)); } BulkResponse bulkResponse = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT); return !bulkResponse.hasFailures(); } //获取es里数据实现，实现搜索功能 public List&lt;Map&lt;String, Object&gt;&gt; searchPage(String keyword, int pageNo, int pageSize) throws IOException { if (pageNo&lt;=0){ pageNo = 1; } //条件搜索 SearchRequest searchRequest = new SearchRequest(\"jd_index\"); SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); //分页 sourceBuilder.from((pageNo - 1) * pageSize); sourceBuilder.size(pageSize); //精确查找 TermQueryBuilder termQuery = QueryBuilders.termQuery(\"title\", keyword); sourceBuilder.query(termQuery); sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); //高亮 HighlightBuilder highlightBuilder = new HighlightBuilder(); highlightBuilder.field(\"title\"); highlightBuilder.requireFieldMatch(false);//false 多个高亮开启 默认就是false highlightBuilder.preTags(\"&lt;span style='color:red'&gt;\"); highlightBuilder.postTags(\"&lt;/span&gt;\"); sourceBuilder.highlighter(highlightBuilder); //执行搜索 searchRequest.source(sourceBuilder); SearchResponse response = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT); //解析结果 ArrayList&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;(); for (SearchHit hit : response.getHits().getHits()) { Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields(); HighlightField title = highlightFields.get(\"title\"); Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();//原来的数据 //解析高亮字段,将原来的字段换为高亮字段 if (title != null) { Text[] texts = title.getFragments(); String newTitle = \"\"; for (Text text : texts) { newTitle += text; } sourceAsMap.put(\"title\", newTitle); } list.add(sourceAsMap); } return list; } }","categories":[],"tags":[]},{"title":"","slug":"SSM笔记 狂神","date":"2021-09-14T08:22:56.383Z","updated":"2021-09-14T08:22:56.539Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"整合SSM数据库环境创建一个存放书籍数据的数据库表 CREATE DATABASE `ssmbuild`; USE `ssmbuild`; DROP TABLE IF EXISTS `books`; CREATE TABLE `books` ( `bookId` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id', `bookName` VARCHAR(100) NOT NULL COMMENT '书名', `bookCounts` INT(11) NOT NULL COMMENT '数量', `detail` VARCHAR(200) NOT NULL COMMENT '描述', KEY `bookId` (`bookId`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `books`(`bookId`,`bookName`,`bookCounts`,`detail`)VALUES (1,'Java',1,'从入门到放弃'), (2,'MySQL',10,'从删库到跑路'), (3,'Linux',5,'从进门到进牢'); 基本环境搭建1、新建一Maven项目！ssmbuild ， 添加web的支持 2、导入相关的pom依赖！ &lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop切入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、Maven资源过滤设置 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 4、建立基本结构和配置框架！ com.kuang.pojo com.kuang.dao com.kuang.service com.kuang.controller mybatis-config.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;/configuration&gt; applicationContext.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; Mybatis层编写1、数据库配置文件 database.properties jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT jdbc.username=root jdbc.password=admin 2、IDEA关联数据库 3、编写MyBatis的核心配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name=\"com.xu.pojo\"/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper class=\"com.xu.mapper.BookMapper\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 4、编写数据库对应的实体类 com.kuang.pojo.Books 使用lombok插件！ package com.kuang.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class Books { private int bookID; private String bookName; private int bookCounts; private String detail; } 5、编写Dao层的 Mapper接口！ package com.xu.mapper; import com.xu.pojo.Books; import org.apache.ibatis.annotations.Param; import java.util.List; public interface BookMapper { //增加一本书 int addBook(Books book); //根据id删除一本书 int deleteBook(@Param(\"id\") int bookId); //更新一本书 int updateBook(Books book); //根据id查询书 Books findBookById(@Param(\"id\") int bookId); //查询所有书 List&lt;Books&gt; findAllBook(); //按书籍名称查询 Books queryBookByName(@Param(\"bookName\") String bookName); } 6、编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包； &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.xu.mapper.BookMapper\"&gt; &lt;insert id=\"addBook\" parameterType=\"Books\"&gt; insert into books (bookId,bookName,bookCounts,detail) values (#{bookId},#{bookName},#{bookCounts},#{detail}); &lt;/insert&gt; &lt;delete id=\"deleteBook\" parameterType=\"int\"&gt; delete from books where bookId=#{id} &lt;/delete&gt; &lt;update id=\"updateBook\" parameterType=\"Books\"&gt; update books set bookName = #{bookName},bookCounts = #{bookCounts},detail = #{detail} where bookId = #{bookId} &lt;/update&gt; &lt;select id=\"findBookById\" resultType=\"Books\"&gt; select * from ssmbuild.books where bookId = #{id} &lt;/select&gt; &lt;select id=\"findAllBook\" resultType=\"Books\"&gt; SELECT * from ssmbuild.books &lt;/select&gt; &lt;select id=\"queryBookByName\" resultType=\"Books\"&gt; select * from books where bookName=#{bookName}; &lt;/select&gt; &lt;/mapper&gt; 7、编写Service层的接口和实现类 接口： package com.kuang.service; import com.kuang.pojo.Books; import java.util.List; //BookService:底下需要去实现,调用dao层 public interface BookService { //增加一本书 int addBook(Books book); //根据id删除一本书 int deleteBook(int bookId); //更新一本书 int updateBook(Books book); //根据id查询书 Books findBookById(int bookId); //查询所有书 List&lt;Books&gt; findAllBook(); //按书籍名称查询 Books queryBookByName( String bookName); } 实现类： package com.kuang.service; import com.kuang.dao.BookMapper; import com.kuang.pojo.Books; import java.util.List; public class BookServiceImpl implements BookService { //调用dao层的操作，设置一个set接口，方便Spring管理 private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } @Override public int addBook(Books book) { return bookMapper.addBook(book); } @Override public int deleteBook(int bookId) { return bookMapper.deleteBook(bookId); } @Override public int updateBook(Books book) { return bookMapper.updateBook(book); } @Override public Books findBookById(int bookId) { return bookMapper.findBookById(bookId); } @Override public List&lt;Books&gt; findAllBook() { return bookMapper.findAllBook(); } @Override public Books queryBookByName(String bookName) { return bookMapper.queryBookByName(bookName); } } OK，到此，底层需求操作编写完毕！ Spring层1、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池； 2、我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1.关联数据库文件 --&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=\"driverClass\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"jdbcUrl\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"user\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=\"maxPoolSize\" value=\"30\"/&gt; &lt;property name=\"minPoolSize\" value=\"10\"/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=\"autoCommitOnClose\" value=\"false\"/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=\"checkoutTimeout\" value=\"10000\"/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=\"acquireRetryAttempts\" value=\"2\"/&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt; &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=\"basePackage\" value=\"com.xu.mapper\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 3、Spring整合service层 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 扫描service相关的bean --&gt; &lt;context:component-scan base-package=\"com.xu.service\" /&gt; &lt;!--BookServiceImpl注入到IOC容器中--&gt; &lt;bean id=\"BookServiceImpl\" class=\"com.xu.service.BookServiceImpl\"&gt; &lt;property name=\"bookMapper\" ref=\"bookMapper\"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\"class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- aop事务织入--&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id=\"interceptor\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务切入 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.xu.mapper.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"interceptor\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！ SpringMVC层1、web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--encodingFilter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;/web-app&gt; 2、spring-mvc.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" /&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=\"com.xu.controller\" /&gt; &lt;/beans&gt; 3、Spring配置整合文件，applicationContext.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"spring-dao.xml\"/&gt; &lt;import resource=\"spring-service.xml\"/&gt; &lt;import resource=\"spring-mvc.xml\"/&gt; &lt;/beans&gt; Controller 和 视图层编写1、BookController 类编写 ， 方法一：查询全部书籍 @Controller @RequestMapping(\"/book\") public class BookController { @Autowired @Qualifier(\"BookServiceImpl\") private Bookservice bookservice; //向上转型 @RequestMapping(\"/findAll\") public String findAllBook(Model model) { List&lt;Books&gt; booksList = bookservice.findAllBook(); model.addAttribute(\"booksList\", booksList); return \"findAllBook\"; } } 2、编写首页 index.jsp &lt;%-- User: win10 Date: 2020/6/24 Time: 15:51 --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;style type=\"text/css\"&gt; h3 { width: 150px; height: 40px; margin: 100px auto; text-align: center; text-decoration: none; background-color: burlywood; border-radius: 8px; line-height: 40px; } a { text-decoration: none; color: black; font-size: 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt; &lt;a href=\"${pageContext.request.contextPath}/book/findAll\"&gt;查找所有书籍&lt;/a&gt; &lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 3、书籍列表页面 findAllBook.jsp &lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;%-- User: win10 Date: 2020/6/24 Time: 16:52 --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;书籍列表&lt;/title&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 column\"&gt; &lt;a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/book/toAddBook\"&gt;新增书籍&lt;/a&gt; &lt;a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/book/findAll\"&gt;查询所有书籍&lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-md-8 column\"&gt; &lt;form action=\"${pageContext.request.contextPath}/book/queryBookByName\" method=\"post\" style=\"float: right\" class=\"form-inline\"&gt; &lt;span style=\"color: red;font-weight: bold\" &gt;${msg}&lt;/span&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" name=\"bookName\" placeholder=\"输入书籍名称查询\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;table class=\"table table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;/th&gt; &lt;th&gt;书籍名字&lt;/th&gt; &lt;th&gt;书籍数量&lt;/th&gt; &lt;th&gt;书籍详情&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach var=\"book\" items=\"${booksList}\"&gt; &lt;tr&gt; &lt;th&gt;${book.bookId}&lt;/th&gt; &lt;th&gt;${book.bookName}&lt;/th&gt; &lt;th&gt;${book.bookCounts}&lt;/th&gt; &lt;th&gt;${book.detail}&lt;/th&gt; &lt;th&gt;&lt;a href=\"${pageContext.request.contextPath}/book/toUpdatePage?bookId=${book.bookId}\"&gt;修改&lt;/a&gt; | &lt;a href=\"${pageContext.request.contextPath}/book/deleteBook/${book.bookId}\"&gt;删除&lt;/a&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 4、BookController 类编写 ， 方法二：添加书籍 @RequestMapping(\"/toAddBook\") public String toAddBookPage() { return \"addBook\"; } @RequestMapping(\"/addBook\") public String addBook(Books book) { System.out.println(\"------addBook------\"); System.out.println(book); bookservice.addBook(book); return \"redirect:/book/findAll\"; } 5、添加书籍页面：addBook.jsp &lt;%-- User: win10 Date: 2020/6/24 Time: 22:33 --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;添加书籍&lt;/title&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;增加书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=\"/book/addBook\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍名称：&lt;/label&gt; &lt;input type=\"text\" name=\"bookName\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍数量：&lt;/label&gt; &lt;input type=\"text\" name=\"bookCounts\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍详情：&lt;/label&gt; &lt;input type=\"text\" name=\"detail\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"submit\" value=\"添加\" class=\"form-control\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 6、BookController 类编写 ， 方法三：修改书籍 @RequestMapping(\"/toUpdatePage\") public String toUpdatePage(int bookId, Model model) { Books book = bookservice.findBookById(bookId); model.addAttribute(\"QBook\", book); return \"updateBook\"; } @RequestMapping(\"/updateBook\") public String updateBook(Books book) { System.out.println(\"updatebook=&gt;\" + book); int i = bookservice.updateBook(book); if (i &gt; 0) { System.out.println(\"updateBook 成功\" + book); } return \"redirect:/book/findAll\"; } 7、修改书籍页面 updateBook.jsp &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; &lt;%-- User: win10 Date: 2020/6/25 Time: 9:22 --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;修改书籍&lt;/title&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;修改书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=\"${pageContext.request.contextPath}/book/updateBook\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"bookId\" value=\"${QBook.bookId}\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍名称：&lt;/label&gt; &lt;input type=\"text\" name=\"bookName\" class=\"form-control\" required value=\"${QBook.bookName}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍数量：&lt;/label&gt; &lt;input type=\"text\" name=\"bookCounts\" class=\"form-control\" required value=\"${QBook.bookCounts}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;书籍详情：&lt;/label&gt; &lt;input type=\"text\" name=\"detail\" class=\"form-control\" required value=\"${QBook.detail}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"submit\" value=\"修改\" class=\"form-control\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 8、BookController 类编写 ， 方法四：删除书籍 @RequestMapping(\"/deleteBook/{bookId}\") public String deleteBook(@PathVariable(\"bookId\") int bookId) { bookservice.deleteBook(bookId); return \"redirect:/book/findAll\"; } 9、BookController 类编写 ， 方法五：按书籍名称查询书籍（mapper 和 service 层都要进行添加方法） @RequestMapping(\"/queryBookByName\") public String queryBookByName(String bookName, Model model) { Books book = bookservice.queryBookByName(bookName); System.err.println(book); List&lt;Books&gt; list = new ArrayList&lt;Books&gt;(); list.add(book); if (book == null) { list = bookservice.findAllBook(); model.addAttribute(\"msg\", \"未找到匹配书籍\"); } model.addAttribute(\"booksList\", list); return \"findAllBook\"; } 配置Tomcat，进行运行！ 到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，大家需要保证，不看任何东西，自己也可以完整的实现出来！ 项目结构图","categories":[],"tags":[]},{"title":"","slug":"Spring MVC笔记","date":"2021-09-14T08:22:46.108Z","updated":"2021-09-14T08:22:48.206Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"Spring MVCSpring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。Spring MVC 是目前主流的实现 MVC 设计模式的企业级开发框架，Spring 框架的一个子模块，无需整合，开发起来更加便捷。 WEB-INF 下的资源用户不能直接访问，只能通过 servlet 和 controller 访问。 什么是 MVC 设计模式？将应用程序分为 Controller、Model、View 三层，Controller 接收客户端请求，调用 Model 生成业务数据，传递给 View。 MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 回顾Servlet 新建一个Maven工程当做父工程！pom依赖！ &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！ 导入servlet 和 jsp 的 jar 依赖 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; 编写一个Servlet类，用来处理用户的请求 package com.kuang.servlet; //实现Servlet接口 public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throwsServletException, IOException { //取得参数 String method = req.getParameter(\"method\"); if (method.equals(\"add\")){ req.getSession().setAttribute(\"msg\",\"执行了add方法\"); } if (method.equals(\"delete\")){ req.getSession().setAttribute(\"msg\",\"执行了delete方法\"); } //业务逻辑 //视图跳转 req.getRequestDispatcher(\"/WEB-INF/jsp/hello.jsp\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throwsServletException, IOException { doGet(req,resp); } } 编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 在web.xml中注册Servlet &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- 路径拦截映射，/user 路径由该 HelloServlet 处理 --&gt; &lt;url-pattern&gt;/user&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 会话超时设置 --&gt; &lt;session-config&gt; &lt;session-timeout&gt;&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!-- 默认启动页面 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 配置Tomcat，并启动测试 localhost:8080/user?method=add localhost:8080/user?method=delete MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： ​ 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. Hello，SpringMVC 第一个 SpringMVC 程序 配置版1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ 2、确定导入了SpringMVC 的依赖！ 3、配置web.xml ， 注册DispatcherServlet &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; 5、添加 处理映射器 &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; 6、添加 处理器适配器 &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; 7、添加 视图解析器 &lt;!--视图解析器:DispatcherServlet给他的ModelAndView 1、获取ModelAndView的数据 2、解析ModelAndView的视图名字 3、拼接视图名字，找到对应的视图 /WEB-INF/jsp/xx.jsp--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; 8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； package com.kuang.controller; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; //注意：这里我们先导入Controller接口 public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(\"msg\",\"HelloSpringMVC!\"); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(\"hello\"); //: /WEB-INF/jsp/hello.jsp return mv; } } 9、将自己的类交给SpringIOC容器，注册bean &lt;!--Handler，这里加“/”是因为用的处理映射器是--&gt; &lt;bean id=\"/hello\" class=\"com.kuang.controller.HelloController\"/&gt; 10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 11、配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布 Artifacts 中，在 WEB-INF 文件夹下添加lib 文件夹，然后添加 lib 依赖！ 重启Tomcat 即可解决！ 小结：看这个估计大部分同学都能理解其中的原理了，但是我们实际开发才不会这么写，不然就疯了，还学这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。 注解版1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 2、由于Maven可能存在资源过滤的问题，我们将配置完善 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 4、配置web.xml 注意点： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求，即.jsp 不会进入spring的 DispatcherServlet类 ,直接就进入jsp页面。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现视图解析器返回 jsp视图时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 5、添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!--视图解析器:DispatcherServlet给他的ModelAndView 1、获取ModelAndView的数据 2、解析ModelAndView的视图名字 3、拼接视图名字，找到对应的视图 /WEB-INF/jsp/xx.jsp--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 让IOC的注解生效 静态资源过滤 ：HTML 、 JS 、 CSS 、 图片 、 视频 ….. MVC的注解驱动 配置视图解析器 6、创建Controller 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/HelloController\") public class HelloController { //真实访问地址 : 项目名/HelloController/hello @RequestMapping(\"/hello\") public String sayHello(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值 //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(\"msg\",\"hello,SpringMVC\"); //web-inf/jsp/hello.jsp return \"hello\"; } } @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射URL请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 7、创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;SpringMVC&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 8、配置Tomcat运行 配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！ OK，运行成功！ 小结实现步骤其实非常的简单： 新建一个web项目 导入相关jar包 编写web.xml , 注册DispatcherServlet 编写springmvc配置文件 接下来就是去创建对应的控制类 , controller 最后完善前端视图和controller之间的对应 测试运行调试. 使用springMVC必须配置的三大件： 处理器映射器、处理器适配器、视图解析器 通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置 Spring MVC 的核心组件 DispatcherServlet：前置控制器，是整个流程控制的核心，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。 Handler：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。 HandlerMapping：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。 HandlerInterceptor：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。 HandlerExecutionChain：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。 HandlerAdapter：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。 ModelAndView：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。 ViewResolver：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。 中心控制器 DispatcherServlet​ Spring 的web框架围绕 DispatcherServlet 设计。DispatcherServlet 的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的 @controller 声明方式。 ​ Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。 SpringMVC的原理如下图所示： ​ 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 Spring MVC 的工作流程 客户端请求被 DisptacherServlet 接收。 根据 HandlerMapping 映射到 Handler。 生成 Handler 和 HandlerInterceptor。 Handler 和 HandlerInterceptor 以 HandlerExecutionChain 的形式一并返回给 DisptacherServlet。 DispatcherServlet 通过 HandlerAdapter 调用 Handler 的方法完成业务逻辑处理。 Handler 返回一个 ModelAndView 给 DispatcherServlet。 DispatcherServlet 将获取的 ModelAndView 对象传给 ViewResolver 视图解析器，将逻辑视图解析为物理视图 View。 ViewResovler 返回一个 View 给 DispatcherServlet。 DispatcherServlet 根据 View 进行视图渲染（将模型数据 Model 填充到视图 View 中）。 DispatcherServlet 将渲染后的结果响应给客户端。 Spring MVC 流程非常复杂，实际开发中很简单，因为大部分的组件不需要开发者创建、管理，只需要通过配置文件的方式完成配置即可，真正需要开发者进行处理的只有 Handler 、View。 控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； //实现该接口的类获得控制器功能 public interface Controller { //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponsevar2) throws Exception; } 测试 新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 //定义控制器 //注意点：不要导错包，实现Controller接口，重写方法； public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"Test1Controller\"); mv.setViewName(\"test\"); return mv; } } 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 &lt;bean name=\"/t1\" class=\"com.kuang.controller.ControllerTest1\"/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${msg} &lt;/body&gt; &lt;/html&gt; 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; 增加一个ControllerTest2类，使用注解实现； //@Controller注解的类会自动添加到Spring上下文中 @Controller public class ControllerTest2{ //映射访问路径 @RequestMapping(\"/t2\") public String index(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"ControllerTest2\"); //返回视图位置 return \"test\"; } } 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！ @RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面 @Controller public class TestController { @RequestMapping(\"/h1\") public String test(){ return \"test\"; } } 访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法 @Controller @RequestMapping(\"/admin\") public class TestController { @RequestMapping(\"/h1\") public String test(){ return \"test\"; } } 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； 使用method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 我们来测试一下： 增加一个方法 //映射访问路径,必须是POST请求 @RequestMapping(value = \"/hello\",method = {RequestMethod.POST}) public String index2(Model model){ model.addAttribute(\"msg\", \"hello!\"); return \"test\"; } 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； //映射访问路径,必须是Get请求 @RequestMapping(value = \"/hello\",method = {RequestMethod.GET}) public String index2(Model model){ model.addAttribute(\"msg\", \"hello!\"); return \"test\"; } 小结： Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 使用params：指定请求中必须包含某些参数，否则无法调用该方法。 @RequestMapping(value = \"/index\",method = RequestMethod.GET,params = {\"name\",\"id=10\"}) public String index(){ System.out.println(\"执行了index...\"); return \"index\"; } 上述代码表示请求中必须包含 name 和 id 两个参数，同时 id 的值必须是 10。 关于参数绑定，在形参列表中通过添加 @RequestParam 注解完成 HTTP 请求参数与业务方法形参的映射。 @RequestMapping(value = \"/index\",method = RequestMethod.GET,params = {\"name\",\"id=10\"}) public String index(@RequestParam(\"name\") String str,@RequestParam(\"id\") int age){ System.out.println(str); System.out.println(age); System.out.println(\"执行了index...\"); return \"index\"; } 上述代码表示将请求的参数 name 和 id 分别赋给了形参 str 和 age ，同时自动完成了数据类型转换，将 “10” 转为了 int 类型的 10，再赋给 age，这些工作都是由 HandlerAdapter 来完成的。 RestFul 风格概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 REST：Representational State Transfer，资源表现层状态转换，是目前比较主流的一种互联网软件架构，它结构清晰、标准规范、易于理解、便于扩展。 资源（Resource） 网络上的一个实体，或者说网络中存在的一个具体信息，一段文本、一张图片、一首歌曲、一段视频等等，总之就是一个具体的存在。可以用一个 URI（统一资源标识符）指向它，每个资源都有对应的一个特定的 URI，要获取该资源时，只需要访问对应的 URI 即可。 表现层（Representation） 资源具体呈现出来的形式，比如文本可以用 txt 格式表示，也可以用 HTML、XML、JSON等格式来表示。 状态转换（State Transfer） 客户端如果希望操作服务器中的某个资源，就需要通过某种方式让服务端发生状态转换，而这种转换是建立在表现层之上的，所以叫做”表现层状态转换”。 特点 URL 更加简洁。 有利于不同系统之间的资源共享，只需要遵守一定的规范，不需要进行其他配置即可实现资源共享。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get ​ http://127.0.0.1/item/queryItem.action?id=1 查询,GET ​ http://127.0.0.1/item/saveItem.action 新增,POST ​ http://127.0.0.1/item/updateItem.action 更新,POST ​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ ​ http://127.0.0.1/item/1 查询,GET ​ http://127.0.0.1/item 新增,POST ​ http://127.0.0.1/item 更新,PUT（根据请求方法类型来与上面区别） ​ http://127.0.0.1/item/1 删除,DELETE 学习测试 在新建一个类 RestFulController @Controller public class RestFulController { } 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 @Controller public class RestFulController { //映射访问路径 @RequestMapping(\"/commit/{p1}/{p2}\") public String index(@PathVariable int p1, @PathVariable int p2, Model model){ int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; } } 我们来测试请求查看下 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 ![img](https://gitee.com/xudongyin/img/raw/master/img/20200719181343) 我们来修改下对应的参数类型，再次测试 //映射访问路径 @RequestMapping(\"/commit/{p1}/{p2}\") public String index(@PathVariable int p1, @PathVariable String p2, Model model){ String result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; } 结果跳转方式ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : {视图解析器前缀} + viewName +{视图解析器后缀} &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; 对应的controller类 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; } } ServletAPI通过设置ServletAPI , 不需要视图解析器 . 1、通过HttpServletResponse进行输出 2、通过HttpServletResponse实现重定向 3、通过HttpServletResponse实现转发 @Controller public class ResultGo { @RequestMapping(\"/result/t1\") public void test1(HttpServletRequest req, HttpServletResponse rsp) throwsIOException { rsp.getWriter().println(\"Hello,Spring BY servlet API\"); } @RequestMapping(\"/result/t2\") public void test2(HttpServletRequest req, HttpServletResponse rsp) throwsIOException { rsp.sendRedirect(\"/index.jsp\"); } @RequestMapping(\"/result/t3\") public void test3(HttpServletRequest req, HttpServletResponse rsp) throwsException { //转发 req.setAttribute(\"msg\",\"/result/t3\"); req.getRequestDispatcher(\"/WEB-INF/jsp/test.jsp\").forward(req,rsp); } } SpringMVC通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉 @Controller public class ResultSpringMVC { @RequestMapping(\"/rsm/t1\") public String test1(){ //转发 return \"/index.jsp\"; } @RequestMapping(\"/rsm/t2\") public String test2(){ //转发二 return \"forward:/index.jsp\"; } @RequestMapping(\"/rsm/t3\") public String test3(){ //重定向 return \"redirect:/index.jsp\"; } } 通过SpringMVC来实现转发和重定向 - 有视图解析器； 重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题. 可以重定向到另外一个请求实现 . @Controller public class ResultSpringMVC2 { @RequestMapping(\"/rsm2/t1\") public String test1(){ //转发 return \"test\"; } @RequestMapping(\"/rsm2/t2\") public String test2(){ //重定向 //return \"redirect:/index.jsp\"; return \"redirect:/hello\"; //hello为另一个请求路径/ } } 数据处理处理提交数据1、提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/hello?name=kuangshen 处理方法 : @RequestMapping(\"/hello\") public String hello(String name){ System.out.println(name); return \"hello\"; } 后台输出 : kuangshen 2、提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=kuangshen 处理方法 : //@RequestParam(\"username\") : username提交的域的名称 . @RequestMapping(\"/hello\") public String hello(@RequestParam(\"username\") String name){ System.out.println(name); return \"hello\"; } 后台输出 : kuangshen 3、提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 1、实体类 public class User { private int id; private String name; private int age; //构造 //get/set //tostring() } 2、提交数据 : http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15 3、处理方法 : @RequestMapping(\"/user\") public String user(User user){ System.out.println(user); return \"hello\"; } 后台输出 : User { id=1, name=’kuangshen’, age=15 } 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。 数据显示到前端第一种 : 通过ModelAndView 实现controller接口 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"ControllerTest1\"); mv.setViewName(\"test\"); return mv; } } 第二种 : 通过ModelMap ModelMap @RequestMapping(\"/hello\") public String hello(@RequestParam(\"username\") String name, ModelMap model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"name\",name); System.out.println(name); return \"hello\"; } 第三种 : 通过Model Model @RequestMapping(\"/ct2/hello\") public String hello(@RequestParam(\"username\") String name, Model model){ //封装要显示到视图中的数据 //相当于req.setAttribute(\"name\",name); model.addAttribute(\"msg\",name); System.out.println(name); return \"test\"; } 对比就对于新手而言简单来说使用区别就是： Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 乱码问题测试步骤： 1、我们可以在首页编写一个提交的表单 &lt;form action=\"/e/t\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; 2、后台编写对应的处理类 @Controller public class Encoding { @RequestMapping(\"/e/t\") public String test(Model model,String name){ model.addAttribute(\"msg\",name); //获取表单提交的值 return \"test\"; //跳转到test页面显示输入的值 } } 3、输入中文测试，发现乱码 不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！ 以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;&lt;!-- 自定义 --&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 对所有请求生效 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;&lt;!-- 跟上面自定义的名字对应 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 但是我们发现 , 有些极端情况下，这个过滤器对get的支持不好 . 处理方法 : 1、修改tomcat配置文件 ：设置编码！ &lt;Connector URIEncoding=\"utf-8\" port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 2、自定义过滤器 package com.kuang.filter; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.Map; /** * 解决get和post请求 全部乱码的过滤器 */ public class GenericEncodingFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChainchain) throws IOException, ServletException { //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(\"text/html;charset=UTF-8\"); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); } @Override public void init(FilterConfig filterConfig) throws ServletException { } } //自定义request对象，HttpServletRequest的包装类 class MyRequest extends HttpServletRequestWrapper { private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) { super(request);// super必须写 this.request = request; } // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() { // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(\"post\")) { // post请求 try { // 处理post乱码 request.setCharacterEncoding(\"utf-8\"); return request.getParameterMap(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } else if (method.equalsIgnoreCase(\"get\")) { // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) { // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) { String[] values = parameterMap.get(parameterName); if (values != null) { for (int i = 0; i &lt; values.length; i++) { try { // 处理get乱码 values[i] = new String(values[i] .getBytes(\"ISO-8859-1\"), \"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } } hasEncode = true; } return parameterMap; } return super.getParameterMap(); } //取一个值 @Override public String getParameter(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) { return null; } return values[0]; // 取回参数的第一个值 } //取所有值 @Override public String[] getParameterValues(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; } } 这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！ 然后在web.xml中配置这个过滤器即可！ 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！ 什么是JSON？ JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"QinJiang\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JavaScript 对象互转要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试1、新建一个module ，springmvc-05-json ， 添加web的支持 2、在web目录下新建一个 json-1.html ， 编写测试内容 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;JSON_秦疆&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; //编写一个js的对象 var user = { name:\"秦疆\", age:3, sex:\"男\" }; //将js对象转换成json字符串，let与var一样 let s = JSON.stringify(usr); console.log(s); //将json字符串转换为js对象，let与var一样 let parse = JSON.parse(s); console.log(parse); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3、在IDEA中使用浏览器打开，查看控制台输出！ Controller返回JSON数据 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; 配置SpringMVC需要的配置 web.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; springmvc-servlet.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； package com.kuang.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; //需要导入lombok @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法 编写一个Controller； @Controller public class UserController { @RequestMapping(\"/json1\") @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 配置Tomcat ， 启动测试一下！ http://localhost:8080/json1 发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型； 通过@RequestMapping 的 produces 属性来实现，修改下代码 //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\",produces = \"application/json;charset=utf-8\") 再次测试， http://localhost:8080/json1 ， 乱码问题OK！ 【注意：使用json记得处理乱码问题】 代码优化 乱码统一解决上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 返回json字符串统一解决在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不会进行视图解析，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ @RestController public class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = \"/json1\") public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(\"秦疆1号\", 3, \"男\"); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 启动tomcat测试，结果都正常输出！ 测试集合输出 增加一个新的方法 @RequestMapping(\"/json2\") public String json2() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str; } 运行结果 : 十分完美，没有任何问题！ 输出时间对象 增加一个新的方法 @RequestMapping(\"/json3\") public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str; } 运行结果 : 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 @RequestMapping(\"/json4\") public String json4() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str; } 运行结果 : 成功的输出了时间！ 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 package com.kuang.utils; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import java.text.SimpleDateFormat; public class JsonUtils { public static String getJson(Object object) { return getJson(object,\"yyyy-MM-dd HH:mm:ss\"); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 我们使用工具类，代码就更加简洁了！ @RequestMapping(\"/json5\") public String json5() throws JsonProcessingException { Date date = new Date(); String json = JsonUtils.getJson(date); return json; } 大功告成！完美！ FastJsonfastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 fastjson 的 pom依赖！ &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt; &lt;/dependency&gt; fastjson 三个主要的类： JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组 内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。 代码测试，我们新建一个FastJsonDemo 类 package com.kuang.controller; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.kuang.pojo.User; import java.util.ArrayList; import java.util.List; public class FastJsonDemo { public static void main(String[] args) { //创建一个对象 User user1 = new User(\"秦疆1号\", 3, \"男\"); User user2 = new User(\"秦疆2号\", 3, \"男\"); User user3 = new User(\"秦疆3号\", 3, \"男\"); User user4 = new User(\"秦疆4号\", 3, \"男\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(\"*******Java对象 转 JSON字符串*******\"); String str1 = JSON.toJSONString(list); System.out.println(\"JSON.toJSONString(list)==&gt;\"+str1); String str2 = JSON.toJSONString(user1); System.out.println(\"JSON.toJSONString(user1)==&gt;\"+str2); System.out.println(\"\\n****** JSON字符串 转 Java对象*******\"); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(\"JSON.parseObject(str2,User.class)==&gt;\"+jp_user1); System.out.println(\"\\n****** Java对象 转 JSON对象 ******\"); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(\"(JSONObject) JSON.toJSON(user2)==&gt;\"+jsonObject1.getString(\"name\")); System.out.println(\"\\n****** JSON对象 转 Java对象 ******\"); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(\"JSON.toJavaObject(jsonObject1, User.class)==&gt;\"+to_java_user); } } 这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！ AJAX简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 伪造Ajax我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function(){ var myDate = new Date(); document.getElementById('currentTime').innerText = myDate.getTime(); }; function LoadPage(){ var targetUrl = document.getElementById('url').value; console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; } &lt;/script&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" value=\"https://www.baidu.com/\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage()\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3、使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 ….等等 jQuery.ajax纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!--静态资源过滤--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;beanclass=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 2、编写一个AjaxController @Controller public class AjaxController { @RequestMapping(\"/a1\") public void ajax1(String name , HttpServletResponse response) throwsIOException { if (\"admin\".equals(name)){ response.getWriter().print(\"true\"); }else{ response.getWriter().print(\"false\"); } } } 3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入 &lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; 4、编写index.jsp测试 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt;--%&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ &lt;%-- $ 是 jQuery 的缩写--%&gt; $.post({ url:\"${pageContext.request.contextPath}/a1\", data:{'name':$(\"#txtName\").val()}, success:function (data,status) { &lt;%-- 这里的data是后台controller返回的数据--%&gt; alert(data); alert(status); } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;%--onblur：失去焦点触发事件--%&gt; 用户名:&lt;input type=\"text\" id=\"txtName\" onblur=\"a1()\"/&gt; &lt;/body&gt; &lt;/html&gt; 5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ SpringMVC实现实体类user @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 我们来获取一个集合对象，展示到前端页面 @RequestMapping(\"/a2\") public List&lt;User&gt; ajax2(){ List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(\"秦疆1号\",3,\"男\")); list.add(new User(\"秦疆2号\",3,\"男\")); list.add(new User(\"秦疆3号\",3,\"男\")); return list; //由于@RestController注解，将list转成json格式返回 } 前端页面 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" id=\"btn\" value=\"获取数据\"/&gt; &lt;table width=\"80%\" align=\"center\"&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;tbody id=\"content\"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () { &lt;%-- 没有外面这层function嵌套的话，点击事件不能正常运行， 点击事件在这里不是一个函数--%&gt; $(\"#btn\").click(function () { &lt;%-- 缩写形式 $.post(url , param[可以省略], success)--%&gt; $.post(\"${pageContext.request.contextPath}/a2\",function (data) { console.log(data) var html=\"\"; for (var i = 0; i &lt;data.length ; i++) { html+= \"&lt;tr&gt;\" + \"&lt;td&gt;\" + data[i].name + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].age + \"&lt;/td&gt;\" + \"&lt;td&gt;\" + data[i].sex + \"&lt;/td&gt;\" + \"&lt;/tr&gt;\" } $(\"#content\").html(html); }); }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 成功实现了数据回显！可以体会一下Ajax的好处！ 注册提示效果我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化 我们写一个Controller @RequestMapping(\"/a3\") public String ajax3(String name,String pwd){ String msg = \"\"; //模拟数据库中存在数据 if (name!=null){ if (\"admin\".equals(name)){ msg = \"OK\"; }else { msg = \"用户名输入错误\"; } } if (pwd!=null){ if (\"123456\".equals(pwd)){ msg = \"OK\"; }else { msg = \"密码输入有误\"; } } return msg; //由于@RestController注解，将msg转成json格式返回 } 前端页面 login.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1(){ $.post({ url:\"${pageContext.request.contextPath}/a3\", data:{'name':$(\"#name\").val()}, success:function (data) { if (data.toString()=='OK'){ $(\"#userInfo\").css(\"color\",\"green\"); }else { $(\"#userInfo\").css(\"color\",\"red\"); } $(\"#userInfo\").html(data); } }); } function a2(){ $.post({ url:\"${pageContext.request.contextPath}/a3\", data:{'pwd':$(\"#pwd\").val()}, success:function (data) { if (data.toString()=='OK'){ $(\"#pwdInfo\").css(\"color\",\"green\"); }else { $(\"#pwdInfo\").css(\"color\",\"red\"); } $(\"#pwdInfo\").html(data); } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 用户名:&lt;input type=\"text\" id=\"name\" onblur=\"a1()\"/&gt; &lt;span id=\"userInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 密码:&lt;input type=\"text\" id=\"pwd\" onblur=\"a2()\"/&gt; &lt;span id=\"pwdInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 【记得处理json乱码问题】 我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 测试一下效果，动态请求响应，局部刷新，就是如此！ 获取baidu接口Demo&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;JSONP百度搜索&lt;/title&gt; &lt;style&gt; #q{ width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; } #ul{ width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; } #ul li{ line-height: 30px; padding: 0 10px; } #ul li:hover{ background-color: #f60; color: #fff; } &lt;/style&gt; &lt;script&gt; // 2.步骤二 // 定义demo函数 (分析接口、数据) function demo(data){ var Ul = document.getElementById('ul'); var html = ''; // 如果搜索数据存在 把内容添加进去 if (data.s.length) { // 隐藏掉的ul显示出来 Ul.style.display = 'block'; // 搜索到的数据循环追加到li里 for(var i = 0;i&lt;data.s.length;i++){ html += '&lt;li&gt;'+data.s[i]+'&lt;/li&gt;'; } // 循环的li写入ul Ul.innerHTML = html; } } // 1.步骤一 window.onload = function(){ // 获取输入框和ul var Q = document.getElementById('q'); var Ul = document.getElementById('ul'); // 事件鼠标抬起时候 Q.onkeyup = function(){ // 如果输入框不等于空 if (this.value != '') { // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ // 创建标签 var script = document.createElement('script'); //给定要跨域的地址 赋值给src //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src ='https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='+this.value+'&amp;cb=demo'; // 将组合好的带src的script标签追加到body里 document.body.appendChild(script); } } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" id=\"q\" /&gt; &lt;ul id=\"ul\"&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; Ajax在我们开发中十分重要，一定要学会使用！ 拦截器 概述 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 自定义拦截器 那如何实现拦截器呢？ 想要自定义拦截器，必须实现 HandlerInterceptor 接口。 1、新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持 2、配置web.xml 和 springmvc-servlet.xml 文件 3、编写一个拦截器 package com.kuang.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 public boolean preHandle(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse, Object o) throws Exception { System.out.println(\"------------处理前------------\"); return true; } //在请求处理方法执行之后执行 public void postHandle(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)throws Exception { System.out.println(\"------------处理后------------\"); } //在dispatcherServlet处理后执行,做清理工作. public void afterCompletion(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { System.out.println(\"------------清理------------\"); } } 4、在springmvc的配置文件中配置拦截器 &lt;!--关于拦截器的配置--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;!--/admin/** 拦截的是/admin/下的所有--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=\"com.kuang.interceptor.MyInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 5、编写一个Controller，接收请求 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; //测试拦截器的控制器 @Controller public class InterceptorController { @RequestMapping(\"/interceptor\") @ResponseBody public String testFunction() { System.out.println(\"控制器中的方法执行了\"); return \"hello\"; } } 6、前端 index.jsp &lt;a href=\"${pageContext.request.contextPath}/interceptor\"&gt;拦截器测试&lt;/a&gt; 7、启动tomcat 测试一下！ 验证用户是否登录 (认证用户) 实现思路 1、有一个登陆页面，需要写一个controller访问页面。 2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。 3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面 测试： 1、编写一个登陆页面 login.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;h1&gt;登录页面&lt;/h1&gt; &lt;hr&gt; &lt;body&gt; &lt;form action=\"${pageContext.request.contextPath}/user/login\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码：&lt;input type=\"password\" name=\"pwd\"&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 2、编写一个Controller处理请求 package com.kuang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpSession; @Controller @RequestMapping(\"/user\") public class UserController { //跳转到登陆页面 @RequestMapping(\"/jumplogin\") public String jumpLogin() throws Exception { return \"login\"; } //跳转到成功页面 @RequestMapping(\"/jumpSuccess\") public String jumpSuccess() throws Exception { return \"success\"; } //登陆提交 @RequestMapping(\"/login\") public String login(HttpSession session, String username, String pwd) throwsException { // 向session记录用户身份信息 System.out.println(\"接收前端===\"+username); session.setAttribute(\"user\", username); return \"success\"; } //退出登陆 @RequestMapping(\"logout\") public String logout(HttpSession session) throws Exception { // session 过期 session.invalidate(); //移除节点数据 //session.removeAttribute(\"user\"); return \"login\"; } } 3、编写一个登陆成功的页面 success.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;登录成功页面&lt;/h1&gt; &lt;hr&gt; ${user} &lt;a href=\"${pageContext.request.contextPath}/user/logout\"&gt;注销&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！ &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;hr&gt; &lt;%--登录--%&gt; &lt;a href=\"${pageContext.request.contextPath}/user/jumplogin\"&gt;登录&lt;/a&gt; &lt;a href=\"${pageContext.request.contextPath}/user/jumpSuccess\"&gt;成功页面&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 5、编写用户登录拦截器 package com.kuang.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; public class LoginInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws ServletException, IOException { // 如果是登陆页面则放行 System.out.println(\"uri: \" + request.getRequestURI()); if (request.getRequestURI().contains(\"login\")) { return true; } HttpSession session = request.getSession(); // 如果用户已登陆也放行 if(session.getAttribute(\"user\") != null) { return true; } // 用户没有登陆跳转到登陆页面 request.getRequestDispatcher(\"/WEB-INF/jsp/login.jsp\").forward(request,response); return false; } public void postHandle(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)throws Exception { } public void afterCompletion(HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { } } 6、在Springmvc的配置文件中注册拦截器 &lt;!--关于拦截器的配置--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean id=\"loginInterceptor\" class=\"com.kuang.interceptor.LoginInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 7、再次重启Tomcat测试！ OK，测试登录拦截功能无误. Spring MVC 数据绑定数据绑定：在后端的业务方法中直接获取客户端 HTTP 请求中的参数，将请求参数映射到业务方法的形参中，Spring MVC 中数据绑定的工作是由 HandlerAdapter 来完成的。 基本数据类型 @RequestMapping(\"/baseType\") @ResponseBody public String baseType(int id){ return id+\"\"; } @ResponseBody 表示 Spring MVC 会直接将业务方法的返回值响应给客户端，如果不加 @ResponseBody 注解，Spring MVC 会将业务方法的放回值传递给 DispatcherServlet，再由 DisptacherServlet 调用 ViewResolver 对返回值进行解析，映射到一个 JSP 资源。（这里没有指定JSP，所以去掉的话就会找不到页面） 包装类 @RequestMapping(\"/packageType\") @ResponseBody public String packageType(@RequestParam(value = \"num\",required = false,defaultValue = \"0\") Integer id){ return id+\"\"; } 包装类可以接收 null，当 HTTP 请求没有参数时，使用包装类定义形参的数据类型，程序不会抛出异常。 @RequestParam value = “num”：将 HTTP 请求中名为 num 的参数赋给形参 id。 requried：设置 num 是否为必填项，true 表示必填，false 表示非必填，可省略。 defaultValue = “0”：如果 HTTP 请求中没有 num 参数，默认值为0. 数组 @RestController @RequestMapping(\"/data\") public class DataBindHandler { @RequestMapping(\"/array\") public String array(String[] name){ String str = Arrays.toString(name); return str; } } @RestController 表示该控制器会直接将业务方法的返回值响应给客户端，不进行视图解析。 @Controller 表示该控制器的每一个业务方法的返回值都会交给视图解析器进行解析，如果只需要将数据响应给客户端，而不需要进行视图解析，则需要在对应的业务方法定义处添加 @ResponseBody。 @RestController @RequestMapping(\"/data\") public class DataBindHandler { @RequestMapping(\"/array\") public String array(String[] name){ String str = Arrays.toString(name); return str; } } 等同于 @Controller @RequestMapping(\"/data\") public class DataBindHandler { @RequestMapping(\"/array\") @ResponseBody public String array(String[] name){ String str = Arrays.toString(name); return str; } } List Spring MVC 不支持 List 类型的直接转换，需要对 List 集合进行包装。 集合封装类 package com.southwind.entity; import lombok.Data; import java.util.List; @Data public class UserList { private List&lt;User&gt; users; } JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 09:12 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/data/list\" method=\"post\"&gt; 用户1编号：&lt;input type=\"text\" name=\"users[0].id\"/&gt;&lt;br/&gt; 用户1名称：&lt;input type=\"text\" name=\"users[0].name\"/&gt;&lt;br/&gt; 用户2编号：&lt;input type=\"text\" name=\"users[1].id\"/&gt;&lt;br/&gt; 用户2名称：&lt;input type=\"text\" name=\"users[1].name\"/&gt;&lt;br/&gt; 用户3编号：&lt;input type=\"text\" name=\"users[2].id\"/&gt;&lt;br/&gt; 用户3名称：&lt;input type=\"text\" name=\"users[2].name\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 业务方法 @RequestMapping(\"/list\") public String list(UserList userList){ StringBuffer str = new StringBuffer(); for(User user:userList.getUsers()){ str.append(user); } return str.toString(); } 处理 @ResponseBody 中文乱码，在 springmvc.xml 中配置消息转换器。 &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; ==register-defaults=”Boolean” 是否添加其他默认的HttpMessageConverter注册，消息转化器默认总共有七个== Map 自定义封装类 package com.southwind.entity; import lombok.Data; import java.util.Map; @Data public class UserMap { private Map&lt;String,User&gt; users; } 业务方法 @RequestMapping(\"/map\") public String map(UserMap userMap){ StringBuffer str = new StringBuffer(); for(String key:userMap.getUsers().keySet()){ User user = userMap.getUsers().get(key); str.append(user); } return str.toString(); } JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 09:12 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/data/map\" method=\"post\"&gt; 用户1编号：&lt;input type=\"text\" name=\"users['a'].id\"/&gt;&lt;br/&gt; 用户1名称：&lt;input type=\"text\" name=\"users['a'].name\"/&gt;&lt;br/&gt; 用户2编号：&lt;input type=\"text\" name=\"users['b'].id\"/&gt;&lt;br/&gt; 用户2名称：&lt;input type=\"text\" name=\"users['b'].name\"/&gt;&lt;br/&gt; 用户3编号：&lt;input type=\"text\" name=\"users['c'].id\"/&gt;&lt;br/&gt; 用户3名称：&lt;input type=\"text\" name=\"users['c'].name\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; JSON 客户端发生 JSON 格式的数据，直接通过 Spring MVC 绑定到业务方法的形参中。 处理 Spring MVC 无法加载静态资源的问题(被 ==dispatcherServlet== 拦截)，在 web.xml 中添加配置即可。 &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 10:35 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;!--这里引用了jquery文件，需要自己去找下载--&gt; &lt;script type=\"text/javascript\"&gt; $(function(){ var user = { \"id\":1, \"name\":\"张三\" }; $.ajax({ url:\"/data/json\", data:JSON.stringify(user), &lt;这里进入到handler里的业务方法&gt; type:\"POST\", contentType:\"application/json;charset=UTF-8\", dataType:\"JSON\", success:function(data){ alert(data.id+\"---\"+data.name); } }) }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 业务方法 @RequestMapping(\"/json\") public User json(@RequestBody User user){ System.out.println(user); user.setId(6); user.setName(\"张六\"); return user; } Spring MVC 中的 JSON 和 JavaBean 的转换需要借助于 fastjson，pom.xml 引入相关依赖。 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.32&lt;/version&gt; &lt;/dependency&gt; springmvc.xml 添加 fastjson 配置。 &lt;mvc:annotation-driven&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\" value=\"text/html;charset=UTF-8\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置fastjson --&gt; &lt;bean class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4\"&gt;&lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; Spring MVC 模型数据解析JSP 四大作用域对应的内置对象：pageContext、request、session、application。 模型数据的绑定是由 ViewResolver 来完成的，实际开发中，我们需要先添加模型数据，再交给 ViewResolver 来绑定。 Spring MVC 提供了以下几种方式添加模型数据： Map Model ModelAndView HttpServletRequest @SessionAttribute @ModelAttribute 将模式数据绑定到 request 对象。 1、Map @RequestMapping(\"/map\") public String map(Map&lt;String,User&gt; map){ User user = new User(); user.setId(1L); user.setName(\"张三\"); map.put(\"a\",user); //这里把key值改为“1”的话，jsp调用的时候不能调用，只能是字符串 return \"view\"; } JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 11:36 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${requestScope.a} //这里requestScope. 后面只能是字符串，不能是数字 &lt;/body&gt; &lt;/html&gt; ==&lt;%@ page isELIgnored=”false” %&gt;== 不写这行代码，浏览器会将 ${requestScope.user} 作为文本输出，而不会解析 2、Model pom.xml &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; Handler @RequestMapping(\"/model\") public String model(Model model){ User user = new User(); user.setId(1L); user.setName(\"张三\"); model.addAttribute(\"user\",user); return \"view\"; } 3、ModelAndView @RequestMapping(\"/modelAndView\") public ModelAndView modelAndView(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"user\",user); modelAndView.setViewName(\"view\"); return modelAndView; } @RequestMapping(\"/modelAndView2\") public ModelAndView modelAndView2(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"user\",user); View view = new InternalResourceView(\"/view.jsp\"); modelAndView.setView(view); return modelAndView; } @RequestMapping(\"/modelAndView3\") public ModelAndView modelAndView3(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView = new ModelAndView(\"view\"); modelAndView.addObject(\"user\",user); return modelAndView; } @RequestMapping(\"/modelAndView4\") public ModelAndView modelAndView4(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); View view = new InternalResourceView(\"/view.jsp\"); ModelAndView modelAndView = new ModelAndView(view); modelAndView.addObject(\"user\",user); return modelAndView; } @RequestMapping(\"/modelAndView5\") public ModelAndView modelAndView5(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); Map&lt;String,User&gt; map = new HashMap&lt;&gt;(); map.put(\"user\",user); ModelAndView modelAndView = new ModelAndView(\"view\",map); return modelAndView; } @RequestMapping(\"/modelAndView6\") public ModelAndView modelAndView6(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); Map&lt;String,User&gt; map = new HashMap&lt;&gt;(); map.put(\"user\",user); View view = new InternalResourceView(\"/view.jsp\"); ModelAndView modelAndView = new ModelAndView(view,map); return modelAndView; } @RequestMapping(\"/modelAndView7\") public ModelAndView modelAndView7(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView = new ModelAndView(\"view\",\"user\",user); return modelAndView; } @RequestMapping(\"/modelAndView8\") public ModelAndView modelAndView8(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); View view = new InternalResourceView(\"/view.jsp\"); ModelAndView modelAndView = new ModelAndView(view,\"user\",user); return modelAndView; } 4、HttpServletRequest @RequestMapping(\"/request\") public String request(HttpServletRequest request){ User user = new User(); user.setId(1L); user.setName(\"张三\"); request.setAttribute(\"user\",user); return \"view\"; } 5、@ModelAttribute 定义一个方法，该方法专门用来返回要填充到模型数据中的对象。 @ModelAttribute //返回一个user对象，交给框架自己去处理 public User getUser(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); return user; } @ModelAttribute //把对象装map里，也就是自己处理，不用返回对象 public void getUser(Map&lt;String,User&gt; map){ User user = new User(); user.setId(1L); user.setName(\"张三\"); map.put(\"user\",user); } @ModelAttribute //把对象装model里，也就是自己处理，不用返回对象 public void getUser(Model model){ User user = new User(); user.setId(1L); user.setName(\"张三\"); model.addAttribute(\"user\",user); } 业务方法中无需再处理模型数据，只需返回视图即可。 @RequestMapping(\"/modelAttribute\") public String modelAttribute(){ return \"view\"; } 将模型数据绑定到 session 对象 1、直接使用原生的 Servlet API。 @RequestMapping(\"/session\") public String session(HttpServletRequest request){ HttpSession session = request.getSession(); User user = new User(); user.setId(1L); user.setName(\"张三\"); session.setAttribute(\"user\",user); return \"view\"; } //或者这个方法也一样 @RequestMapping(\"/session2\") public String session2(HttpSession session){ User user = new User(); user.setId(1L); user.setName(\"张三\"); session.setAttribute(\"user\",user); return \"view\"; } 2、@SessionAttribute（==慎用==，全局注解，对所有方法都生效，注解在Handler类上） @SessionAttributes(value = {\"user\",\"address\"}) public class ViewHandler { } 对于 ViewHandler 中的所有业务方法，只要向 request 中添加了 key = “user”、key = “address” 的对象时，Spring MVC 会自动将该数据添加到 session 中，保存 key 不变。 @SessionAttributes(types = {User.class,Address.class}) public class ViewHandler { } 对于 ViewHandler 中的所有业务方法，只要向 request 中添加了数据类型是 User 、Address 的对象时，Spring MVC 会自动将该数据添加到 session 中，保存 key 不变。 将模型数据绑定到 application 对象 @RequestMapping(\"/application\") public String application(HttpServletRequest request){ ServletContext application = request.getServletContext(); User user = new User(); user.setId(1L); user.setName(\"张三\"); application.setAttribute(\"user\",user); return \"view\"; } Spring MVC 自定义数据转换器数据转换器是指将客户端 HTTP 请求中的参数转换为业务方法中定义的形参，自定义表示开发者可以自主设计转换的方式，HandlerApdter 已经提供了通用的转换，String 转 int，String 转 double，表单数据的封装等，但是在特殊的业务场景下，HandlerAdapter 无法进行转换，就需要开发者自定义转换器。 客户端输入 String 类型的数据 “2019-03-03”，自定义转换器将该数据转为 Date 类型的对象。 创建 DateConverter 转换器，实现 Conveter 接口。 package com.southwind.converter; import org.springframework.core.convert.converter.Converter; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class DateConverter implements Converter&lt;String, Date&gt; { private String pattern; public DateConverter(String pattern){ this.pattern = pattern; //这里pattern是\"yyyy-MM-dd\" } @Override public Date convert(String s) { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(this.pattern); //创建对应\"yyyy-MM-dd\"的日期格式 Date date = null; try { date = simpleDateFormat.parse(s); } catch (ParseException e) { e.printStackTrace(); } return date; } } springmvc.xml 配置转换器。 &lt;!-- 配置自定义转换器 --&gt; &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"com.southwind.converter.DateConverter\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"yyyy-MM-dd\"&gt;&lt;/constructor-arg&gt; &lt;!--这里有参构造是给DateConverter的有参构造传\"yyyy-MM-dd\"的日期格式--&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--conversion-service=\"conversionService\" 注册一个转化器 --&gt; &lt;mvc:annotation-driven conversion-service=\"conversionService\"&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\" value=\"text/html;charset=UTF-8\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置fastjson --&gt; &lt;bean class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4\"&gt;&lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 14:47 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/converter/date\" method=\"post\"&gt; 请输入日期:&lt;input type=\"text\" name=\"date\"/&gt;(yyyy-MM-dd)&lt;br/&gt; &lt;!--这里的name=\"date\"与Handler的public String date(Date date)的参数date一致--&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; Handler package com.southwind.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.Date; @RestController @RequestMapping(\"/converter\") public class ConverterHandler { @RequestMapping(\"/date\") public String date(Date date){ return date.toString(); } } String 转 Student StudentConverter package com.southwind.converter; import com.southwind.entity.Student; import org.springframework.core.convert.converter.Converter; public class StudentConverter implements Converter&lt;String, Student&gt; { @Override public Student convert(String s) { String[] args = s.split(\"-\"); Student student = new Student(); student.setId(Long.parseLong(args[0])); student.setName(args[1]); student.setAge(Integer.parseInt(args[2])); return student; } } springmvc.xml &lt;!-- 配置自定义转换器 --&gt; &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"com.southwind.converter.DateConverter\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"yyyy-MM-dd\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class=\"com.southwind.converter.StudentConverter\"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven conversion-service=\"conversionService\"&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\" value=\"text/html;charset=UTF-8\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置fastjson --&gt; &lt;bean class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4\"&gt;&lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-14 Time: 15:23 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/converter/student\" method=\"post\"&gt; 请输入学生信息：&lt;input type=\"text\" name=\"student\"/&gt;(id-name-age)&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; Handler @RequestMapping(\"/student\") public String student(Student student){ return student.toString(); } Spring MVC 文件上传下载 单文件上传 底层是使用 Apache fileupload 组件完成上传，Spring MVC 对这种方式进行了封装。 pom.xml &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-15 Time: 09:09 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/file/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"img\"/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;img src=\"${path}\"&gt; &lt;/body&gt; &lt;/html&gt; 1、input 的 type 设置为 file。 2、form 的 method 设置为 post（get 请求只能将文件名传给服务器） 3、from 的 enctype 设置为 multipart-form-data（如果不设置只能将文件名传给服务器） springmvc.xml &lt;!-- 配置上传组件 --&gt; &lt;!--这个bena的id必须为：multipartResolver ，否则上传文件会报400的错误！--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 下面几个属性可以不配置，会有默认值 --&gt; &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt; &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt; &lt;property name=\"maxInMemorySize\" value=\"40960\"/&gt; &lt;/bean&gt; Handler package com.southwind.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.File; import java.io.IOException; @Controller @RequestMapping(\"/file\") public class FileHandler { @PostMapping(\"/upload\") public String upload(MultipartFile img, HttpServletRequest request){ if(img.getSize()&gt;0){ //获取保存上传文件的file路径 String path = request.getServletContext().getRealPath(\"file\"); //这里可以做一个目录存在否判断 // File realPath = new File(path); // if (!realPath.exists()){ // realPath.mkdir(); // } //获取上传的文件名 String name = img.getOriginalFilename(); File file = new File(path,name); try { img.transferTo(file); //保存上传之后的文件路径 request.setAttribute(\"path\",\"/file/\"+name); } catch (IOException e) { e.printStackTrace(); } } return \"upload\"; } } CommonsMultipartFile 的 常用方法： String getOriginalFilename()：获取上传文件的原名 InputStream getInputStream()：获取文件流 void transferTo(File dest)：将上传文件保存到一个目录文件中 web.xml 添加如下配置，否则客户端无法访问 png &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 多文件上传 pom.xml &lt;!-- 标准表单标签库依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-15 Time: 09:32 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"/file/uploads\" method=\"post\" enctype=\"multipart/form-data\"&gt; file1:&lt;input type=\"file\" name=\"imgs\"/&gt;&lt;br/&gt; file2:&lt;input type=\"file\" name=\"imgs\"/&gt;&lt;br/&gt; file3:&lt;input type=\"file\" name=\"imgs\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;c:forEach items=\"${files}\" var=\"file\" &gt; &lt;img src=\"${file}\" width=\"300px\"&gt; &lt;/c:forEach&gt; &lt;/body&gt; &lt;/html&gt; Handler @PostMapping(\"/uploads\") public String uploads(MultipartFile[] imgs,HttpServletRequest request){ List&lt;String&gt; files = new ArrayList&lt;&gt;();//用来存储上传文件名 for (MultipartFile img:imgs){ if(img.getSize()&gt;0){ //获取保存上传文件的file路径 String path = request.getServletContext().getRealPath(\"file\"); //获取上传的文件名 String name = img.getOriginalFilename(); File file = new File(path,name); try { img.transferTo(file); //保存上传之后的文件路径 files.add(\"/file/\"+name); } catch (IOException e) { e.printStackTrace(); } } } request.setAttribute(\"files\",files); return \"uploads\"; } 下载 Rest格式 JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-15 Time: 10:36 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"/file/download/1\"&gt;1.png&lt;/a&gt; &lt;a href=\"/file/download/2\"&gt;2.png&lt;/a&gt; &lt;a href=\"/file/download/3\"&gt;3.png&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; Handler @GetMapping(\"/download/{name}\") //这里是rest格式URL，所以下面需要@PathVariable(\"name\")来映射取值 public void download(@PathVariable(\"name\") String name, HttpServletRequest request, HttpServletResponse response){ if(name != null){ name += \".png\"; String path = request.getServletContext().getRealPath(\"file\"); File file = new File(path,name); OutputStream outputStream = null; if(file.exists()){ response.setContentType(\"application/forc-download\"); //设置为下载类型 response.setHeader(\"Content-Disposition\",\"attachment;filename=\"+name); //告诉浏览器文件的名字和类型，Content-Disposition中指定的类型是文件的扩展名，并且弹出的下载对话框中的文件类型图片是按照文件的扩展名显示的，点保存后，文件以filename的值命名，保存类型以Content中设置的为准。 注意：在设置Content-Disposition头字段之前，一定要设置Content-Type头字段。 try { outputStream = response.getOutputStream(); outputStream.write(FileUtils.readFileToByteArray(file)); outputStream.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if(outputStream != null){ try { outputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } } } } 普通方式 JSP &lt;a href=\"/download\"&gt;点击下载&lt;/a&gt; Handler @RequestMapping(value=\"/download\") public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception{ //要下载的图片地址 String path = request.getServletContext().getRealPath(\"/upload\"); String fileName = \"基础语法.jpg\"; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(\"UTF-8\"); //字符编码 response.setContentType(\"multipart/form-data\"); //二进制传输数据 //设置响应头 response.setHeader(\"Content-Disposition\", \"attachment;fileName=\"+URLEncoder.encode(fileName, \"UTF-8\")); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1){ out.write(buff, 0, index); out.flush(); } out.close(); input.close(); return null; } Spring MVC 表单标签库 Handler @GetMapping(\"/get\") public ModelAndView get(){ ModelAndView modelAndView = new ModelAndView(\"tag\"); Student student = new Student(1L,\"张三\",22); modelAndView.addObject(\"student\",student); return modelAndView; } JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-15 Time: 10:53 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;学生信息&lt;/h1&gt; &lt;form:form modelAttribute=\"student\"&gt; &lt;!--第一个form是&lt;%@ taglib prefix=\"form\" %&gt;的form，第二个form才是form标签--&gt; 学生ID：&lt;form:input path=\"id\"/&gt;&lt;br/&gt; 学生姓名：&lt;form:input path=\"name\"/&gt;&lt;br/&gt; 学生年龄：&lt;form:input path=\"age\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 1、JSP 页面导入 Spring MVC 表单标签库，与导入 JSTL 标签库的语法非常相似，前缀 prefix 可以自定义，通常定义为 from。 &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; 2、将 form 表单与模型数据进行绑定，通过 modelAttribute 属性完成绑定，将 modelAttribute 的值设置为模型数据对应的 key 值。 Handeler: modelAndView.addObject(\"student\",student); JSP: &lt;form:form modelAttribute=\"student\"&gt; 3、form 表单完成绑定之后，将模型数据的值取出绑定到不同的标签中，通过设置标签的 path 属性完成，将 path 属性的值设置为模型数据对应的属性名即可。 学生ID：&lt;form:input path=\"id\"/&gt;&lt;br/&gt; 学生姓名：&lt;form:input path=\"name\"/&gt;&lt;br/&gt; 学生年龄：&lt;form:input path=\"age\"/&gt;&lt;br/&gt; 常用的表单标签 form &lt;form:form modelAttribute=\"student\"/&gt; 渲染的是 HTML 中的&lt;form&gt;&lt;/from&gt;，通过 modelAttribute 属性绑定具体的模型数据。 input &lt;form:input path=\"name\"/&gt; 渲染的是 HTML 中的 ==&lt;input type=\"text\"/&gt;==(文本类型的input标签)，form 标签绑定的是模型数据，input 标签绑定的是模型数据中的属性值，通过 path 属性可以与模型数据中的属性名对应，并且支持及联操作。 &lt;form:input path=\"address.name\"/&gt; password &lt;form:password path=\"password\"/&gt; 渲染的是 HTML 中的 &lt;input type=\"password\"/&gt;，通过 path 属性与模型数据的属性值进行绑定，password 标签的值不会在页面显示。 checkbox &lt;form:checkbox path=\"hobby\" value=\"读书\"/&gt; student.setFlag(false); checkbox：&lt;form:checkbox path=\"flag\" value=\"flag\"&gt;&lt;/form:checkbox&gt;&lt;br/&gt; 上面代码行的 ==value=”flag”==是设置表单提交后这个CheckBox标签的value值，不关乎这个CheckBox的勾选状态 渲染的是 HTML 中的 &lt;input type=\"checkbox\"/&gt;，通过 path 与模型数据的属性值进行绑定，可以绑定 boolean、数组和集合。 如果绑定 boolean 值，若该变量的值为 true，则表示该复选框选中，否则表示不选中。 ==如果绑定数组或者集合，数组/集合中的元素等于 checkbox 的 value 值，则选中。== student.setHobby(Arrays.asList(\"读书\",\"看电影\",\"玩游戏\")); modelAndView.addObject(\"student\",student); 爱好：&lt;form:checkbox path=\"hobby\" value=\"摄影\"&gt;&lt;/form:checkbox&gt;摄影&lt;br/&gt; &lt;form:checkbox path=\"hobby\" value=\"读书\"&gt;&lt;/form:checkbox&gt;读书&lt;br/&gt; &lt;form:checkbox path=\"hobby\" value=\"听音乐\"&gt;&lt;/form:checkbox&gt;听音乐&lt;br/&gt; &lt;form:checkbox path=\"hobby\" value=\"看电影\"&gt;&lt;/form:checkbox&gt;看电影&lt;br/&gt; &lt;form:checkbox path=\"hobby\" value=\"旅游\"&gt;&lt;/form:checkbox&gt;旅游&lt;br/&gt; &lt;form:checkbox path=\"hobby\" value=\"玩游戏\"&gt;&lt;/form:checkbox&gt;玩游戏&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; checkboxes &lt;form:checkboxes items=${student.hobby} path=\"selecHobby\"/&gt; 渲染的是 HTML 中的一组 &lt;input type=\"checkbox\"/&gt;，是对 &lt;form:checkbox/&gt; 的一种简化，需要结合 items 和 path 属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的集合或数组，可以这样理解，items 为全部可选集合，path 为默认的选中集合 (student 选择的 hobby 的数据)。 student.setHobby(Arrays.asList(\"摄影\",\"读书\",\"听音乐\",\"看电影\",\"旅游\",\"玩游戏\")); student.setSelectHobby(Arrays.asList(\"摄影\",\"读书\",\"听音乐\")); modelAndView.addObject(\"student\",student); 爱好：&lt;form:checkboxes path=\"selectHobby\" items=\"${student.hobby}\"/&gt;&lt;br/&gt; &lt;!-- items=\"${student.hobby}\" 只能这样写，规定--&gt; 需要注意的是 path 可以直接绑定模型数据的属性值，items 则需要通过 EL 表达式的形式从域对象中获取数据，不能直接写属性名。==items=”${student.hobby}” 只能这样写，规定== rad-iobutton &lt;form:radiobutton path=\"radioId\" value=\"0\"/&gt; 渲染的是 HTML 中的一个 &lt;input type=\"radio\"/&gt;，绑定的数据与标签的 value 值相等则为选中，否则不选中。 student.setRadioId(1); modelAndView.addObject(\"student\",student); radiobutton:&lt;form:radiobutton path=\"radioId\" value=\"1\"/&gt;radiobutton&lt;br/&gt; radiobuttons &lt;form:radiobuttons itmes=\"${student.grade}\" path=\"selectGrade\"/&gt; 渲染的是 HTML 中的一组 &lt;input type=\"radio\"/&gt;，这里需要结合 items 和 path 两个属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的值，items 为全部的可选类型，path 为默认选中的选项，用法与 &lt;form:checkboxes/&gt; 一致。 Map&lt;Integer,String&gt; gradeMap = new HashMap&lt;&gt;(); gradeMap.put(1,\"一年级\"); gradeMap.put(2,\"二年级\"); gradeMap.put(3,\"三年级\"); gradeMap.put(4,\"四年级\"); gradeMap.put(5,\"五年级\"); gradeMap.put(6,\"六年级\"); student.setGradeMap(gradeMap); student.setSelectGrade(3); modelAndView.addObject(\"student\",student); 学生年级：&lt;form:radiobuttons items=\"${student.gradeMap}\" path=\"selectGrade\"/&gt;&lt;br/&gt; select &lt;form:select items=\"${student.citys}\" path=\"selectCity\"/&gt; 渲染的是 HTML 中的一个 &lt;select/&gt; 标签，需要结合 items 和 path 两个属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的值，用法与 &lt;from:radiobuttons/&gt;一致。 Map&lt;Integer,String&gt; cityMap = new HashMap&lt;&gt;(); cityMap.put(1,\"北京\"); cityMap.put(2,\"上海\"); cityMap.put(3,\"广州\"); cityMap.put(4,\"深圳\"); student.setCityMap(cityMap); student.setSelectCity(3); modelAndView.addObject(\"student\",student); 所在城市：&lt;form:select items=\"${student.cityMap}\" path=\"selectCity\"&gt;&lt;/form:select&gt;&lt;br/&gt; options form:select 结合 form:options 的使用，from:select 只定义 path 属性，在 form:select 标签内部添加一个子标签 form:options ，设置 items 属性，获取被遍历的集合。 所在城市：&lt;form:select path=\"selectCity\"&gt; &lt;form:options items=\"${student.cityMap}\"&gt;&lt;/form:options&gt; &lt;/form:select&gt;&lt;br/&gt; option form:select 结合 form:option 的使用，from:select 定义 path 属性，给每一个 form:option 设置 value 值，path 的值与哪个 value 值相等，该项默认选中。 所在城市：&lt;form:select path=\"selectCity\"&gt; &lt;form:option value=\"1\"&gt;杭州&lt;/form:option&gt; &lt;form:option value=\"2\"&gt;成都&lt;/form:option&gt; &lt;form:option value=\"3\"&gt;西安&lt;/form:option&gt; &lt;/form:select&gt;&lt;br/&gt; textarea 渲染的是 HTML 中的一个 &lt;textarea/&gt; ，path 绑定模型数据的属性值，作为文本输入域的默认值。 student.setIntroduce(\"你好，我是...\"); modelAndView.addObject(\"student\",student); 信息：&lt;form:textarea path=\"introduce\"/&gt;&lt;br/&gt; errors 处理错误信息，一般用在数据校验，该标签需要结合 Spring MVC 的验证器结合起来使用。 Spring MVC 数据校验Spring MVC 提供了两种数据校验的方式：1、基于 Validator 接口。2、使用 Annotation JSR - 303 标准进行校验。 基于 Validator 接口的方式需要自定义 Validator 验证器，每一条数据的验证规则需要开发者手动完成，使用 Annotation JSR - 303 标准则不需要自定义验证器，通过注解的方式可以直接在实体类中添加每个属性的验证规则，这种方式更加方便，实际开发中推荐使用。 基于 Validator 接口 实体类 Account package com.southwind.entity; import lombok.Data; @Data public class Account { private String name; private String password; } 自定义验证器 AccountValidator，实现 Validator 接口。 package com.southwind.validator; import com.southwind.entity.Account; import org.springframework.validation.Errors; import org.springframework.validation.ValidationUtils; import org.springframework.validation.Validator; public class AccountValidator implements Validator { @Override public boolean supports(Class&lt;?&gt; aClass) { return Account.class.equals(aClass); } @Override public void validate(Object o, Errors errors) { ValidationUtils.rejectIfEmpty(errors,\"name\",null,\"姓名不能为空\"); ValidationUtils.rejectIfEmpty(errors,\"password\",null,\"密码不能为空\"); } } 控制器 package com.southwind.controller; import com.southwind.entity.Account; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.validation.BindingResult; import org.springframework.validation.annotation.Validated; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/validator\") public class ValidatorHandler { @GetMapping(\"/login\") public String login(Model model){ model.addAttribute(\"account\",new Account()); return \"login\"; } @PostMapping(\"/login\") public String login(@Validated Account account, BindingResult bindingResult){ if(bindingResult.hasErrors()){ return \"login\"; } return \"index\"; } } springmvc.xml 配置验证器。 &lt;bean id=\"accountValidator\" class=\"com.southwind.validator.AccountValidator\"&gt;&lt;/bean&gt; &lt;mvc:annotation-driven validator=\"accountValidator\"&gt;&lt;/mvc:annotation-driven&gt; JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-18 Time: 10:31 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=\"account\" action=\"/validator/login\" method=\"post\"&gt; 姓名：&lt;form:input path=\"name\"/&gt;&lt;form:errors path=\"name\"&gt;&lt;/form:errors&gt;&lt;br/&gt; 密码：&lt;form:input path=\"password\"/&gt;&lt;form:errors path=\"password\"&gt;&lt;/form:errors&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; Annotation JSR - 303 标准使用 Annotation JSR - 303 标准进行验证，需要导入支持这种标准的依赖 jar 文件，这里我们使用 Hibernate Validator。 pom.xml &lt;!-- JSR-303 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.3.6.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt; &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt; &lt;version&gt;3.3.2.Final&lt;/version&gt; &lt;/dependency&gt; 通过注解的方式直接在实体类中添加相关的验证规则。 package com.southwind.entity; import lombok.Data; import org.hibernate.validator.constraints.Email; import org.hibernate.validator.constraints.NotEmpty; import javax.validation.constraints.Pattern; import javax.validation.constraints.Size; @Data public class Person { @NotEmpty(message = \"用户名不能为空\") private String username; @Size(min = 6,max = 12,message = \"密码6-12位\") private String password; @Email(regexp = \"^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\\\\\\\\.[a-zA-Z0-9-]+)*\\\\\\\\.[a-zA-Z0-9]{2,6}$\",message = \"请输入正确的邮箱格式\") private String email; @Pattern(regexp = \"^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\\\\\\\\\\\\\\\d{8}$\",message = \"请输入正确的电话\") private String phone; } ValidatorHandler @GetMapping(\"/register\") public String register(Model model){ model.addAttribute(\"person\",new Person()); return \"register\"; } @PostMapping(\"/register\") public String register(@Valid Person person, BindingResult bindingResult){ if(bindingResult.hasErrors()){ return \"register\"; } return \"index\"; } springmvc.xml &lt;mvc:annotation-driven /&gt; 这里的配置必须单独配，即使上面已经配过，不配会不能正常验证。 JSP &lt;%-- Created by IntelliJ IDEA. User: southwind Date: 2019-03-18 Time: 11:29 To change this template use File | Settings | File Templates. --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=\"person\" action=\"/validator/register2\" method=\"post\"&gt; 用户名：&lt;form:input path=\"username\"&gt;&lt;/form:input&gt;&lt;form:errors path=\"username\"/&gt;&lt;br/&gt; 密码：&lt;form:password path=\"password\"&gt;&lt;/form:password&gt;&lt;form:errors path=\"password\"/&gt;&lt;br/&gt; 邮箱：&lt;form:input path=\"email\"&gt;&lt;/form:input&gt;&lt;form:errors path=\"email\"/&gt;&lt;br/&gt; 电话：&lt;form:input path=\"phone\"&gt;&lt;/form:input&gt;&lt;form:errors path=\"phone\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form:form&gt; &lt;/body&gt; &lt;/html&gt; 校验规则详解： @Null 被注解的元素必须为null @NotNull 被注解的元素不能为null @Min(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注解的元素必须是一个数字，其值必须小于于等于指定的最大值 @Email 被注解的元素必须是电子邮箱地址 @Pattern 被注解的元素必须符合对应的正则表达式 @Length 被注解的元素的大小必须在指定的范围内 @NotEmpty 被注解的字符串的值必须非空 Null 和 Empty 是不同的结果，String str = null，str 是 null，String str = “”，str 不是 null，其值为空。","categories":[],"tags":[]},{"title":"","slug":"Spring Cloud笔记","date":"2021-09-14T08:22:45.985Z","updated":"2021-09-14T08:22:46.216Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"Spring Cloud 这个阶段如何学习? 三层架构 + MVC 框架： Spring(轻量级的Java开源框架)：解决企业开发的复杂性 IOC、AOP SpringBoot(Spring的升级版)：新一代的JavaEE开发标准 自动装配 模块化~ all in one 模块化的开发===all in one 代码没发生变 微服务架构4个核心问题: 1. 服务很多,客户端怎么访问? 2. 这么多服务,服务之间如何通信? 3. 这么多服务,如何治理? 4. 服务挂了怎么办? 解决方案选型: SpringCloud 是一种生态！ 学习前提已经会使用Springboot,有分布式基础,了解Dubbo+ZooKeeper 1. Spring Cloud NetFlix(已经停止维护)：一站式解决方案！可解决上述4个核心问题 API网关：zuul组件 通信：Feign ---- HttpClient ---- Http通信方式,同步,阻塞 服务注册和发现：Eureka 熔断机制：Hystrix ...... 2. Apache Dubbo Zookeeper：半自动！需要整合别人的 API网关：没有,找第三方组件(比如整合zull组件),或者自己实现 通信：Dubbo 是一个基于Java的高性能的RPC通信框架(性能比Feign强大) 服务注册和发现：Zookeeper 熔断机制：没有,需要借助Hystrix 3. Spring Cloud Alibaba：目前最新的一站式解决方案！可解决上述4个核心问题,更简单 API网关： 通信： 服务注册和发现： 熔断机制： 新概念：服务网格~ Server Mesh istio 万变不离其宗4个问题： 1. API网关 2. HTTP,RPC通信 3. 注册和发现 4. 熔断机制 1. 常见面试题1.1 什么是微服务？ 1.2 微服务之间是如何独立通讯的？ 1.3 SpringCloud 和 Dubbo有那些区别？ 1.4 SpringBoot 和 SpringCloud，请谈谈你对他们的理解 1.5 什么是服务熔断？什么是服务降级？ 1.6 微服务的优缺点分别是什么？说下你在项目开发中遇到的坑 1.7 你所知道的微服务技术栈有哪些？列举一二 1.8 Eureka和Zookeeper都可以提供服务注册与发现的功能，请说说两者的区别 … 2. 微服务概述2.1 什么是微服务？什么是微服务？微服务(Microservice Architecture) 是近几年流行的一种架构思想，关于它的概念很难一言以蔽之。 究竟什么是微服务呢？我们在此引用ThoughtWorks 公司的首席科学家 Martin Fowler 于2014年提出的一段话： 原文：https://martinfowler.com/articles/microservices.html 汉化：https://www.cnblogs.com/liuning8023/p/4493156.html 就目前而言，对于微服务，业界并没有一个统一的，标准的定义。 但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，它体长将单一的应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(HTTP)互相沟通，每个服务都围绕着具体的业务进行构建，并且能狗被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(Maven)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。 再来从技术维度角度理解下： 微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。 2.2 微服务与微服务架构微服务 强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。 IDEA 工具里面使用Maven开发的一个个独立的小Moudel，它具体是使用SpringBoot开发的一个小模块，专业的事情交给专业的模块来做，一个模块就做着一件事情。 强调的是一个个的个体，每个个体完成一个具体的任务或者功能。 微服务架构 一种新的架构形式，Martin Fowler 于2014年提出。 微服务架构是一种架构模式，它体长将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制**(如HTTP)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如Maven)**对其进行构建。 2.3 微服务优缺点优点 单一职责原则； 每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求； 开发简单，开发效率高，一个服务可能就是专一的只干一件事； 微服务能够被小团队单独开发，这个团队只需2-5个开发人员组成； 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的； 微服务能使用不同的语言开发； 易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins，Hudson，bamboo； 微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值； 微服务允许利用和融合最新技术； 微服务只是业务逻辑的代码，不会和HTML，CSS，或其他的界面混合; 每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库； 缺点 开发人员要处理分布式系统的复杂性； 多服务运维难度，随着服务的增加，运维的压力也在增大； 系统部署依赖问题； 服务间通信成本问题； 数据一致性问题； 系统集成测试问题； 性能和监控问题； 2.4 微服务技术栈有那些？ 微服务技术条目 落地技术 服务开发 SpringBoot、Spring、SpringMVC等 服务配置与管理 Netfix公司的Archaius、阿里的Diamond等 服务注册与发现 Eureka、Consul、Zookeeper等 服务调用 Rest、PRC、gRPC 服务熔断器 Hystrix、Envoy等 负载均衡 Ribbon、Nginx等 服务接口调用(客户端调用服务的简化工具) Fegin等 消息队列 Kafka、RabbitMQ、ActiveMQ等 服务配置中心管理 SpringCloudConfig、Chef等 服务路由(API网关) Zuul等 服务监控 Zabbix、Nagios、Metrics、Specatator等 全链路追踪 Zipkin、Brave、Dapper等 数据流操作开发包 SpringCloud Stream(封装与Redis，Rabbit，Kafka等发送接收消息) 时间消息总栈 SpringCloud Bus 服务部署 Docker、OpenStack、Kubernetes等 2.5 为什么选择SpringCloud作为微服务架构 选型依据 整体解决方案和框架成熟度 社区热度 可维护性 学习曲线 当前各大IT公司用的微服务架构有那些？ 阿里：dubbo+HFS 京东：JFS 新浪：Motan 当当网：DubboX … 各微服务框架对比 功能点/服务框架 Netflix/SpringCloud Motan gRPC Thrift Dubbo/DubboX 功能定位 完整的微服务框架 RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册发现 RPC框架 RPC框架 服务框架 支持Rest 是，Ribbon支持多种可拔插的序列号选择 否 否 否 否 支持RPC 否 是(Hession2) 是 是 是 支持多语言 是(Rest形式) 否 是 是 否 负载均衡 是(服务端zuul+客户端Ribbon)，zuul-服务，动态路由，云端负载均衡Eureka（针对中间层服务器） 是(客户端) 否 否 是(客户端) 配置服务 Netfix Archaius，Spring Cloud Config Server 集中配置 是(Zookeeper提供) 否 否 否 服务调用链监控 是(zuul)，zuul提供边缘服务，API网关 否 否 否 否 高可用/容错 是(服务端Hystrix+客户端Ribbon) 是(客户端) 否 否 是(客户端) 典型应用案例 Netflix Sina Google Facebook 社区活跃程度 高 一般 高 一般 2017年后重新开始维护，之前中断了5年 学习难度 中等 低 高 高 低 文档丰富程度 高 一般 一般 一般 高 其他 Spring Cloud Bus为我们的应用程序带来了更多管理端点 支持降级 Netflix内部在开发集成gRPC IDL定义 实践的公司比较多 3. SpringCloud入门概述3.1 SpringCloud是什么？Spring官网：https://spring.io/ Spring Cloud为开发人员提供了快速构建分布式系统中的一些常见模式的工具(例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导人选举、分布式会话、集群状态)。分布式系统的协调导致了锅炉板模式，而使用Spring Cloud开发人员可以快速建立实现这些模式的服务和应用程序。它们在任何分布式环境中都能很好地工作，包括开发人员自己的笔记本电脑、裸金属数据中心和云计算等托管平台。 3.2 SpringCloud和SpringBoot的关系 SpringBoot专注于开苏方便的开发单个个体微服务； SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、为代理、事件总栈、全局锁、决策竞选、分布式会话等等集成服务； SpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系； SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架； 3.3 Dubbo 和 SpringCloud技术选型1. 分布式+服务治理Dubbo目前成熟的互联网架构，应用服务化拆分+消息中间件 2. Dubbo 和 SpringCloud对比可以看一下社区活跃度： https://github.com/dubbo https://github.com/spring-cloud 对比结果： Dubbo SpringCloud 服务注册中心 Zookeeper Spring Cloud Netfilx Eureka 服务调用方式 RPC REST API 服务监控 Dubbo-monitor Spring Boot Admin 断路器 不完善 Spring Cloud Netfilx Hystrix 服务网关 无 Spring Cloud Netfilx Zuul 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总栈 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task 最大区别: SpringCloud抛弃 了Dubbo的RPC通信，采用的是基于HTTP的REST方式。严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约, 不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。 品牌机与组装机的区别很明显，Spring Cloud的功能比DUBBO更加强大，涵盖面更广,而且作为Spring的拳头项目，它也能够与SpringFramework、Spring Boot、Spring Data、Spring Batch等其他Spring项目完美融合,这些对于微服务而言是至关重要的。使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手， 那这些都不是问题;而SpringCloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性,但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。 社区支持与更新力度最为重要的是，DUBBO停止了5年左右的更新，虽然2017.7重启了。对于技术发展的新需求，需要由开发者自行拓展升级(比如当当网弄出了DubboX)，这对于很多想要采用微服务架构的中小软件组织，显然是不太合适的,中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案,并不是每-一个公司都有阿里的大牛+真实的线上生产环境测试过。 总结:二者解决的问题域不一样：Dubbo的定位是一款RPC框架，而SpringCloud的目标是微服务架构下的一站式解决方案。 3.4 SpringCloud能干嘛？ Distributed/versioned configuration 分布式/版本控制配置 Service registration and discovery 服务注册与发现 Routing 路由 Service-to-service calls 服务到服务的调用 Load balancing 负载均衡配置 Circuit Breakers 断路器 Distributed messaging 分布式消息管理 … 3.5 SpringCloud下载官网：http://projects.spring.io/spring-cloud/ 版本号有点特别： SpringCloud没有采用数字编号的方式命名版本号，而是采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如最早的Realse版本：Angel，第二个Realse版本：Brixton，然后是Camden、Dalston、Edgware，目前最新的是Hoxton SR4 CURRENT GA通用稳定版。 自学参考书： SpringCloud Netflix 中文文档：https://springcloud.cc/spring-cloud-netflix.html SpringCloud 中文API文档(官方文档翻译版)：https://springcloud.cc/spring-cloud-dalston.html SpringCloud中国社区：http://springcloud.cn/ SpringCloud中文网：https://springcloud.cc 4. SpringCloud Rest学习环境搭建：服务提供者4.1 介绍 我们会使用一个Dept部门模块做一个微服务通用案例Consumer消费者(Client)通过REST调用Provider提供者(Server)提供的服务。 回顾Spring，SpringMVC，Mybatis等以往学习的知识。 Maven的分包分模块架构复习。 一个简单的Maven模块结构是这样的： -- app-parent: 一个父项目(app-parent)聚合了很多子项目(app-util\\app-dao\\app-web...) |-- pom.xml | |-- app-core ||---- pom.xml | |-- app-web ||---- pom.xml ...... 一个父工程带着多个Moudule子模块 MicroServiceCloud父工程(Project)下初次带着3个子模块(Module) microservicecloud-api 【封装的整体entity/接口/公共配置等】 microservicecloud-consumer-dept-80 【服务提供者】 microservicecloud-provider-dept-8001 【服务消费者】 4.2 SpringCloud版本选择大版本说明 SpringBoot SpringCloud 关系 1.2.x Angel版本(天使) 兼容SpringBoot1.2x 1.3.x Brixton版本(布里克斯顿) 兼容SpringBoot1.3x，也兼容SpringBoot1.4x 1.4.x Camden版本(卡姆登) 兼容SpringBoot1.4x，也兼容SpringBoot1.5x 1.5.x Dalston版本(多尔斯顿) 兼容SpringBoot1.5x，不兼容SpringBoot2.0x 1.5.x Edgware版本(埃奇韦尔) 兼容SpringBoot1.5x，不兼容SpringBoot2.0x 2.0.x Finchley版本(芬奇利) 兼容SpringBoot2.0x，不兼容SpringBoot1.5x 2.1.x Greenwich版本(格林威治) 实际开发版本关系 spring-boot-starter-parent spring-cloud-dependencles 版本号 发布日期 版本号 发布日期 1.5.2.RELEASE 2017-03 Dalston.RC1 2017-x 1.5.9.RELEASE 2017-11 Edgware.RELEASE 2017-11 1.5.16.RELEASE 2018-04 Edgware.SR5 2018-10 1.5.20.RELEASE 2018-09 Edgware.SR5 2018-10 2.0.2.RELEASE 2018-05 Fomchiey.BULD-SNAPSHOT 2018-x 2.0.6.RELEASE 2018-10 Fomchiey-SR2 2018-10 2.1.4.RELEASE 2019-04 Greenwich.SR1 2019-03 使用后两个 4.3 创建父工程 新建父工程项目springcloud，切记Packageing是pom模式 主要是定义POM文件，将后续各个子模块公用的jar包等统一提取出来，类似一个抽象父类 pom.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;springcloud-api&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8001&lt;/module&gt; &lt;module&gt;springcloud-consumer-dept-80&lt;/module&gt; &lt;module&gt;springcloud-eureka-7001&lt;/module&gt; &lt;module&gt;springcloud-eureka-7002&lt;/module&gt; &lt;module&gt;springcloud-eureka-7003&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8002&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-8003&lt;/module&gt; &lt;module&gt;springcloud-consumer-dept-feign&lt;/module&gt; &lt;module&gt;springcloud-provider-dept-hystrix-8001&lt;/module&gt; &lt;module&gt;springcloud-consumer-hystrix-dashboard&lt;/module&gt; &lt;module&gt;springcloud-zuul-9527&lt;/module&gt; &lt;module&gt;springcloud-config-server-3344&lt;/module&gt; &lt;module&gt;springcloud-config-client-3355&lt;/module&gt; &lt;module&gt;springcloud-config-eureka-7001&lt;/module&gt; &lt;module&gt;springcloud-config-dept-8001&lt;/module&gt; &lt;/modules&gt; &lt;!--打包方式 pom--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;0.2.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--springCloud的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--SpringBoot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringBoot 启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志测试~--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${lombok.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; 父工程为springcloud，其下有多个子mudule，详情参考完整代码了解 springcloud-consumer-dept-80访问springcloud-provider-dept-8001下的controller使用REST方式 如DeptConsumerController.java @RestController public class DeptConsumerController { // 理解：消费者，不应该有service层~ // RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中 // (url, 实体：Map ,Class&lt;T&gt; responseType) @Autowired private RestTemplate restTemplate; //提供多种便捷访问远程http服务的方法，简单的Restful服务模板~ //Ribbon。我们这里的地址，应该是一个变量，通过服务名来访问 private static final String REST_URL_PREFIX = \"http://localhost:8001\"; //private static final String REST_URL_PREFIX = \"http://SPRINGCLOUD-PROVIDER-DEPT\"; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept){ return restTemplate.postForObject(REST_URL_PREFIX+\"/dept/add\",dept,Boolean.class); } @RequestMapping(\"/consumer/dept/get/{id}\") public Dept get(@PathVariable(\"id\") Long id){ return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/get/\"+id,Dept.class); } @RequestMapping(\"/consumer/dept/list\") public List&lt;Dept&gt; list(){ return restTemplate.getForObject(REST_URL_PREFIX+\"/dept/list\",List.class); } } 使用RestTemplete先需要放入Spring容器中 ConfigBean.java @Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml //配置负载均衡实现RestTemplate // IRule // RoundRobinRule 轮询 // RandomRule 随机 // AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~ // RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试 @Bean public RestTemplate getRestTemplate(){ return new RestTemplate(); } } springcloud-provider-dept-8001的dao接口调用springcloud-api模块下的pojo，可使用在springcloud-provider-dept-8001的pom文件导入springcloud-api模块依赖的方式： &lt;!--我们需要拿到实体类，所以要配置api module--&gt; &lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; springcloud-consumer-dept-80和springcloud-provider-dept-8001的pom.xml和父工程下的依赖基本一样，直接看完整代码即可，不再添加重复笔记。 5. Eureka服务注册与发现5.1 什么是Eureka Netflix在涉及Eureka时，遵循的就是API原则. Eureka是Netflix的有个子模块，也是核心模块之一。Eureka是基于REST的服务，用于定位服务，以实现云端中间件层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心，比如Zookeeper. 5.2 原理理解 Eureka基本的架构 Springcloud 封装了Netflix公司开发的Eureka模块来实现服务注册与发现 (对比Zookeeper). Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心. 而系统中的其他微服务，使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，Springcloud 的一些其他模块 (比如Zuul) 就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑. 和Dubbo架构对比. Eureka 包含两个组件：Eureka Server 和 Eureka Client. Eureka Server 提供服务注册，各个节点启动后，回在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会储存所有课用服务节点的信息，服务节点的信息可以在界面中直观的看到. Eureka Client 是一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳 (默认周期为30秒) 。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除掉 (默认周期为90s). 三大角色 Eureka Server：提供服务的注册与发现 Service Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能狗找到 Service Consumer：服务消费方，从Eureka中获取注册服务列表，从而找到消费服务 目前工程状况 5.3 构建步骤1. eureka-server springcloud-eureka-7001 模块建立 pom.xml 配置 &lt;!--导包~--&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;!--导入Eureka Server依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; application.yml server: port: 7001 #Eureka配置 eureka: instance: hostname: localhost #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 源码中Eureka的默认端口以及访问路径: 主启动类 //启动之后，访问 http://localhost:7001/ @SpringBootApplication @EnableEurekaServer //EnableEurekaServer 表示是 Eureka服务端的启动类，可以接受别人注册进来~ public class EurekaServer_7001 { public static void main(String[] args) { SpringApplication.run(EurekaServer_7001.class,args); } } 启动成功后访问 http://localhost:7001/ 得到以下页面 2. eureka-client调整之前创建的springlouc-provider-dept-8001 导入Eureca依赖 &lt;!--Eureka依赖--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; application中新增Eureca配置 # Eureka配置：配置服务注册中心地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ 为主启动类添加@EnableEurekaClient注解 @SpringBootApplication @EnableEurekaClient //EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务 public class DeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(DeptProvider_8001.class,args); } } 先启动7001服务端后启动8001客户端进行测试，然后访问监控页http://localhost:7001/ 产看结果如图，成功 修改Eureka上的默认描述信息 # Eureka配置：配置服务注册中心地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ instance: instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息 结果如图： 如果此时停掉springcloud-provider-dept-8001 等30s后 监控会开启保护机制 配置关于服务加载的监控信息 pom.xml中添加依赖 &lt;!--actuator完善监控信息--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; application.yml中添加配置 #info配置 info: app.name: haust-springcloud #项目的名称 company.name: com.haust #公司的名称 此时刷新监控页，点击进入跳转新页面显示如下内容： 3. EureKa自我保护机制：好死不如赖活着一句话总结就是：某时刻某一个微服务不可用，eureka不会立即清理，依旧会对该微服务的信息进行保存！ 默认情况下，当eureka server在一定时间内没有收到实例的心跳，便会把该实例从注册表中删除（默认是90秒），但是，如果短时间内丢失大量的实例心跳，便会触发eureka server的自我保护机制，比如在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启（因为在开发过程中不会修改eureka注册中心），当一分钟内收到的心跳数大量减少时，会触发该保护机制。可以在eureka管理界面看到Renews threshold和Renews(last min)，当后者（最后一分钟收到的心跳数）小于前者（心跳阈值）的时候，触发保护机制，会出现红色的警告：**EMERGENCY!EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT.RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEGING EXPIRED JUST TO BE SAFE.**从警告中可以看到，eureka认为虽然收不到实例的心跳，但它认为实例还是健康的，eureka会保护这些实例，不会把它们从注册表中删掉。 该保护机制的目的是避免网络连接故障，在发生网络故障时，微服务和注册中心之间无法正常通信，但服务本身是健康的，不应该注销该服务，如果eureka因网络故障而把微服务误删了，那即使网络恢复了，该微服务也不会重新注册到eureka server了，因为只有在微服务启动的时候才会发起注册请求，后面只会发送心跳和服务列表请求，这样的话，该实例虽然是运行着，但永远不会被其它服务所感知。所以，eureka server在短时间内丢失过多的客户端心跳时，会进入自我保护模式，该模式下，eureka会保护注册表中的信息，不在注销任何微服务，当网络故障恢复后，eureka会自动退出保护模式。自我保护模式可以让集群更加健壮。 但是我们在开发测试阶段，需要频繁地重启发布，如果触发了保护机制，则旧的服务实例没有被删除，这时请求有可能跑到旧的实例中，而该实例已经关闭了，这就导致请求错误，影响开发测试。所以，在开发测试阶段，我们可以把自我保护模式关闭，只需在eureka server配置文件中加上如下配置即可：eureka.server.enable-self-preservation=false 详细内容可以参考下这篇博客内容：https://blog.csdn.net/wudiyong22/article/details/80827594 4. 注册进来的微服务，获取一些消息（团队开发会用到）DeptController.java新增方法 //获取一些配置的信息，得到具体的微服务！ @Autowired private DiscoveryClient client; //注册进来的微服务~，获取一些消息~ @GetMapping(\"/dept/discovery\") public Object discovery() { //获取微服务列表的清单 List&lt;String&gt; services = client.getServices(); System.out.println(\"discovery=&gt;services:\" + services); //得到一个具体的微服务信息,通过具体的微服务id，applicaioinName； List&lt;ServiceInstance&gt; instances = client.getInstances(\"SPRINGCLOUD-PROVIDER-DEPT\"); for (ServiceInstance instance : instances) { System.out.println( instance.getHost() + \"\\t\" + // 主机名称 instance.getPort() + \"\\t\" + // 端口号 instance.getUri() + \"\\t\" + // uri instance.getServiceId() // 服务id ); } return this.client; } 主启动类中加入@EnableDiscoveryClient 注解 @SpringBootApplication @EnableEurekaClient //在服务启动后自动注册到Eureka中！ @EnableDiscoveryClient //服务发现~ public class DeptProvider_8001 { ... } 结果如图： 5.4 Eureka：集群环境配置1.初始化新建springcloud-eureka-7002、springcloud-eureka-7003 模块 1.为pom.xml添加依赖 (与springcloud-eureka-7001相同) &lt;!--导包~--&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;!--导入Eureka Server依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.application.yml配置(与springcloud-eureka-7001相同) server: port: 7003 #Eureka配置 eureka: instance: hostname: localhost #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 3.主启动类(与springcloud-eureka-7001相同) //启动之后，访问 http://localhost:7001/ @SpringBootApplication @EnableEurekaServer //EnableEurekaServer 服务端的启动类，可以接受别人注册进来~ public class EurekaServer_7003 { public static void main(String[] args) { SpringApplication.run(EurekaServer_7003.class,args); } } 2.集群成员相互关联配置一些自定义本机名字，找到本机hosts文件并打开 在hosts文件最后加上，要访问的本机名称，默认是localhost 修改application.yml的配置，如图为springcloud-eureka-7001配置，springcloud-eureka-7002/springcloud-eureka-7003同样分别修改为其对应的名称即可 在集群中使springcloud-eureka-7001关联springcloud-eureka-7002、springcloud-eureka-7003 完整的springcloud-eureka-7001下的application.yml如下 server: port: 7001 #Eureka配置 eureka: instance: hostname: eureka7001.com #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ # 单机： defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ # 集群（关联）：7001关联7002、7003 defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 同时在集群中使springcloud-eureka-7002关联springcloud-eureka-7001、springcloud-eureka-7003 完整的springcloud-eureka-7002下的application.yml如下 server: port: 7002 #Eureka配置 eureka: instance: hostname: eureka7002.com #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/ # 单机： defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ # 集群（关联）：7002关联7001、7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7003.com:7003/eureka/ springcloud-eureka-7003配置方式同理可得. 通过springcloud-provider-dept-8001下的yml配置文件，修改Eureka配置：配置服务注册中心地址 # Eureka配置：配置服务注册中心地址 eureka: client: service-url: # 注册中心地址7001-7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息 这样模拟集群就搭建号了，就可以把一个项目挂载到三个服务器上了 5.5 对比和Zookeeper区别1. 回顾CAP原则RDBMS (MySQL\\Oracle\\sqlServer) ===&gt; ACID NoSQL (Redis\\MongoDB) ===&gt; CAP 2. ACID是什么？ A (Atomicity) 原子性 C (Consistency) 一致性 I (Isolation) 隔离性 D (Durability) 持久性 3. CAP是什么? C (Consistency) 强一致性 A (Availability) 可用性 P (Partition tolerance) 分区容错性 CAP的三进二：CA、AP、CP 4. CAP理论的核心 一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求 根据CAP原理，将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类 CA：单点集群，满足一致性，可用性的系统，通常可扩展性较差 CP：满足一致性，分区容错的系统，通常性能不是特别高 AP：满足可用性，分区容错的系统，通常可能对一致性要求低一些 5. 作为分布式服务注册中心，Eureka比Zookeeper好在哪里？著名的CAP理论指出，一个分布式系统不可能同时满足C (一致性) 、A (可用性) 、P (容错性)，由于分区容错性P再分布式系统中是必须要保证的，因此我们只能再A和C之间进行权衡。 Zookeeper 保证的是CP Eureka 保证的是AP Zookeeper保证的是CP ​ 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接收服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30-120s，且选举期间整个zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题使得zookeeper集群失去master节点是较大概率发生的事件，虽然服务最终能够恢复，但是，漫长的选举时间导致注册长期不可用，是不可容忍的。 Eureka保证的是AP ​ Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的信息可能不是最新的，除此之外，Eureka还有之中自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： Eureka不在从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上 (即保证当前节点依然可用) 当网络稳定时，当前实例新的注册信息会被同步到其他节点中 因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪 6. Ribbon：负载均衡(基于客户端)6.1 负载均衡以及RibbonRibbon是什么？ Spring Cloud Ribbon 是基于Netflix Ribbon 实现的一套客户端负载均衡的工具。 简单的说，Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 的客户端组件提供一系列完整的配置项，如：连接超时、重试等。简单的说，就是在配置文件中列出 LoadBalancer (简称LB：负载均衡) 后面所有的及其，Ribbon 会自动的帮助你基于某种规则 (如简单轮询，随机连接等等) 去连接这些机器。我们也容易使用 Ribbon 实现自定义的负载均衡算法！ Ribbon能干嘛？ LB，即负载均衡 (LoadBalancer) ，在微服务或分布式集群中经常用的一种应用。 负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高用)。 常见的负载均衡软件有 Nginx、Lvs 等等。 Dubbo、SpringCloud 中均给我们提供了负载均衡，SpringCloud 的负载均衡算法可以自定义。 负载均衡简单分类： 集中式LB 即在服务的提供方和消费方之间使用独立的LB设施，如Nginx，由该设施负责把访问请求通过某种策略转发至服务的提供方！ 进程式LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。 Ribbon 就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址！ 6.2 集成Ribbonspringcloud-consumer-dept-80向pom.xml中添加Ribbon和Eureka依赖 &lt;!--Ribbon--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka: Ribbon需要从Eureka服务中心获取要拿什么--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 在application.yml文件中配置Eureka # Eureka配置 eureka: client: register-with-eureka: false # 不向 Eureka注册自己 service-url: # 从三个注册中心中随机取一个去访问 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ 主启动类加上@EnableEurekaClient注解，开启Eureka //Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号 @SpringBootApplication @EnableEurekaClient //开启Eureka 客户端 public class DeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_80.class, args); } } 自定义Spring配置类：ConfigBean.java 配置负载均衡实现RestTemplate @Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml @LoadBalanced //配置负载均衡实现RestTemplate @Bean public RestTemplate getRestTemplate() { return new RestTemplate(); } } 修改conroller：DeptConsumerController.java //Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 //private static final String REST_URL_PREFIX = \"http://localhost:8001\"; private static final String REST_URL_PREFIX = \"http://SPRINGCLOUD-PROVIDER-DEPT\"; 6.3 使用Ribbon实现负载均衡流程图： 1.新建两个服务提供者Moudle：springcloud-provider-dept-8003、springcloud-provider-dept-8002 2.参照springcloud-provider-dept-8001 依次为另外两个Moudle添加pom.xml依赖 、resourece下的mybatis和application.yml配置，Java代码 3.启动所有服务测试(根据自身电脑配置决定启动服务的个数)，访问http://eureka7001.com:7002/查看结果 测试访问http://localhost/consumer/dept/list 这时候随机访问的是服务提供者8003 再次访问http://localhost/consumer/dept/list这时候随机的是服务提供者8001 以上这种每次访问http://localhost/consumer/dept/list随机访问集群中某个服务提供者，这种情况叫做轮询，轮询算法在SpringCloud中可以自定义。 如何切换或者自定义规则呢？ 在springcloud-provider-dept-80模块下的ConfigBean中进行配置，切换使用不同的规则 @Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml /** * IRule: * RoundRobinRule 轮询 * RandomRule 随机 * AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~ * RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试 */ @LoadBalanced //配置负载均衡实现RestTemplate @Bean public RestTemplate getRestTemplate() { return new RestTemplate(); } @Bean public IRule myRule(){ return new RandomRule();//使用随机规则 } } 也可以自定义规则，在myRule包下自定义一个配置类MyRule.java，注意：该包不要和主启动类所在的包同级(不能被扫描)，要跟启动类所在包同级： MyRule.java /** * @Auther: csp1999 * @Date: 2020/05/19/11:58 * @Description: 自定义规则 */ @Configuration public class MyRule { @Bean public IRule myRule(){ return new MyRandomRule();//默认是轮询RandomRule,现在自定义为自己的 } } 主启动类开启负载均衡并指定自定义的MyRule配置类 //Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号 @SpringBootApplication @EnableEurekaClient //在微服务启动的时候就能加载自定义的Ribbon类(自定义的规则会覆盖原有默认的规则) @RibbonClient(name = \"SPRINGCLOUD-PROVIDER-DEPT\",configuration = MyRule.class)//开启负载均衡,并指定自定义的规则 public class DeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_80.class, args); } } 自定义的规则(这里我们参考Ribbon中默认的规则代码自己稍微改动)：MyRandomRule.java public class MyRandomRule extends AbstractLoadBalancerRule { /** * 每个服务访问5次则换下一个服务(总共3个服务) * &lt;p&gt; * total=0,默认=0,如果=5,指向下一个服务节点 * index=0,默认=0,如果total=5,index+1 */ private int total = 0;//被调用的次数 private int currentIndex = 0;//当前是谁在提供服务 //@edu.umd.cs.findbugs.annotations.SuppressWarnings(value = \"RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE\") public Server choose(ILoadBalancer lb, Object key) { if (lb == null) { return null; } Server server = null; while (server == null) { if (Thread.interrupted()) { return null; } List&lt;Server&gt; upList = lb.getReachableServers();//获得当前活着的服务 List&lt;Server&gt; allList = lb.getAllServers();//获取所有的服务 int serverCount = allList.size(); if (serverCount == 0) { /* * No servers. End regardless of pass, because subsequent passes * only get more restrictive. */ return null; } //int index = chooseRandomInt(serverCount);//生成区间随机数 //server = upList.get(index);//从或活着的服务中,随机获取一个 //=====================自定义代码========================= if (total &lt; 5) { server = upList.get(currentIndex); total++; } else { total = 0; currentIndex++; if (currentIndex &gt; upList.size()) { currentIndex = 0; } server = upList.get(currentIndex);//从活着的服务中,获取指定的服务来进行操作 } //====================================================== if (server == null) { /* * The only time this should happen is if the server list were * somehow trimmed. This is a transient condition. Retry after * yielding. */ Thread.yield(); continue; } if (server.isAlive()) { return (server); } // Shouldn't actually happen.. but must be transient or a bug. server = null; Thread.yield(); } return server; } protected int chooseRandomInt(int serverCount) { return ThreadLocalRandom.current().nextInt(serverCount); } @Override public Server choose(Object key) { return choose(getLoadBalancer(), key); } @Override public void initWithNiwsConfig(IClientConfig clientConfig) { // TODO Auto-generated method stub } } 7.Feign：负载均衡(基于服务端)7.1 Feign简介Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Ribbon和Eureka，可以使用Feigin提供负载均衡的http客户端 只需要创建一个接口，然后添加注解即可~ Feign，主要是社区版，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法 微服务名字 【ribbon】 接口和注解 【feign】 Feign能干什么？ Feign旨在使编写Java Http客户端变得更容易 前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一个客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解)，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon 时，自动封装服务调用客户端的开发量。 Feign默认集成了Ribbon 利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。 7.2 Feign的使用步骤 创建springcloud-consumer-fdept-feign模块 拷贝springcloud-consumer-dept-80模块下的pom.xml，resource，以及java代码到springcloud-consumer-feign模块，并添加feign依赖。 &lt;!--Feign的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 通过Ribbon实现：—原来的controller：DeptConsumerController.java package com.haust.springcloud.controller; import com.haust.springcloud.pojo.Dept; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import java.util.List; /** * @Auther: csp1999 * @Date: 2020/05/17/22:44 * @Description: */ @RestController public class DeptConsumerController { // 理解：消费者，不应该有service层~ // RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中 // (url, 实体：Map ,Class&lt;T&gt; responseType) @Autowired private RestTemplate restTemplate; //提供多种便捷访问远程http服务的方法，简单的Restful服务模板~ //Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 //private static final String REST_URL_PREFIX = \"http://localhost:8001\"; private static final String REST_URL_PREFIX = \"http://SPRINGCLOUD-PROVIDER-DEPT\"; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept) { return restTemplate.postForObject(REST_URL_PREFIX + \"/dept/add\", dept, Boolean.class); } @RequestMapping(\"/consumer/dept/get/{id}\") public Dept get(@PathVariable(\"id\") Long id) { return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/get/\" + id, Dept.class); } @RequestMapping(\"/consumer/dept/list\") public List&lt;Dept&gt; list() { return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/list\", List.class); } } 通过Feign实现：—改造后controller：DeptConsumerController.java @RestController public class DeptConsumerController { @Autowired private DeptClientService deptClientService = null; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept) { return this.deptClientService.addDept(dept); } @RequestMapping(\"/consumer/dept/get/{id}\") public Dept get(@PathVariable(\"id\") Long id) { return this.deptClientService.queryById(id); } @RequestMapping(\"/consumer/dept/list\") public List&lt;Dept&gt; list() { return this.deptClientService.queryAll(); } } Feign和Ribbon二者对比，前者显现出面向接口编程特点，代码看起来更清爽 主配置类 @SpringBootApplication @EnableEurekaClient //feign客户端注解,并指定要扫描的包以及配置接口DeptClientService @EnableFeignClients(basePackages = {\"com.haust.springcloud\"}) //扫描所有自己的包,让所有注解也能生效 @ComponentScan(\"com.haust.springcloud\") public class FeignDeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(FeignDeptConsumer_80.class, args); } } 改造springcloud-api模块 pom.xml添加feign依赖 &lt;!--Feign的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 新建service包，并新建DeptClientService.java接口， //@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务 @FeignClient(value = \"SPRINGCLOUD-PROVIDER-DEPT\") public interface DeptClientService { @GetMapping(\"/dept/get/{id}\") public Dept queryById(@PathVariable(\"id\") Long id); @GetMapping(\"/dept/list\") public Dept queryAll(); @GetMapping(\"/dept/add\") public Dept addDept(Dept dept); } 7.3 Feign和Ribbon如何选择？根据个人习惯而定，如果喜欢REST风格使用Ribbon；如果喜欢社区版的面向接口风格使用Feign. 8. Hystrix：服务熔断分布式系统面临的问题 复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免失败！ 8.1 服务雪崩​ 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”，如果扇出的链路上某个微服务的调用响应时间过长，或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。 ​ 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几十秒内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障，这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。 ​ 我们需要，弃车保帅 8.2 什么是Hystrix？​ Hystrix是一个应用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整个体系服务失败，避免级联故障，以提高分布式系统的弹性。 ​ “断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控 (类似熔断保险丝) ，向调用方方茴一个服务预期的，可处理的备选响应 (FallBack) ，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证了服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。 8.3 Hystrix能干嘛？ 服务降级 服务熔断 服务限流 接近实时的监控 … 当一切正常时，请求流可以如下所示： 当许多后端系统中有一个潜在时，它可以阻止整个用户请求： 随着大容量通信量的增加，单个后端依赖项的潜在性会导致所有服务器上的所有资源在几秒钟内饱和。 应用程序中通过网络或客户端库可能导致网络请求的每个点都是潜在故障的来源。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，从而备份队列、线程和其他系统资源，从而导致更多跨系统的级联故障。 当使用hystrix包装每个基础依赖项时，上面的图表中所示的体系结构会发生类似于以下关系图的变化。每个依赖项是相互隔离的，限制在延迟发生时它可以填充的资源中，并包含在回退逻辑中，该逻辑决定在依赖项中发生任何类型的故障时要做出什么样的响应： 官网资料：https://github.com/Netflix/Hystrix/wiki 8.4 服务熔断什么是服务熔断​ 熔断机制是赌赢雪崩效应的一种微服务链路保护机制。 ​ 在微服务架构中，微服务之间的数据交互通过远程调用完成，微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，此时如果链路上某个微服务的调用响应时间过长或者不可用，那么对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，导致“雪崩效应”。 服务熔断是应对雪崩效应的一种微服务链路保护机制。例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。同样，在微服务架构中，熔断机制也是起着类似的作用。当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。 ​ 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阀值缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是：**@HystrixCommand** 。 ​ 服务熔断解决如下问题： 1. 当所依赖的对象不稳定时，能够起到快速失败的目的；2. 快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复。 入门案例新建springcloud-provider-dept-hystrix-8001模块并拷贝springcloud-provider-dept–8001内的pom.xml、resource和Java代码进行初始化并调整。 导入hystrix依赖 &lt;!--导入Hystrix依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 调整yml配置文件 server: port: 8001 # mybatis配置 mybatis: # springcloud-api 模块下的pojo包 type-aliases-package: com.haust.springcloud.pojo # 本模块下的mybatis-config.xml核心配置文件类路径 config-location: classpath:mybatis/mybatis-config.xml # 本模块下的mapper配置文件类路径 mapper-locations: classpath:mybatis/mapper/*.xml # spring配置 spring: application: #项目名 name: springcloud-provider-dept datasource: # 德鲁伊数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db01?useUnicode=true&amp;characterEncoding=utf-8 username: root password: root # Eureka配置：配置服务注册中心地址 eureka: client: service-url: # 注册中心地址7001-7003 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: springcloud-provider-dept-hystrix-8001 #修改Eureka上的默认描述信息 prefer-ip-address: true #改为true后默认显示的是ip地址而不再是localhost #info配置 info: app.name: haust-springcloud #项目的名称 company.name: com.haust #公司的名称 prefer-ip-address: false: prefer-ip-address: true： 修改controller //提供Restful服务 @RestController public class DeptController { @Autowired private DeptService deptService; @HystrixCommand(fallbackMethod = \"hystrixGet\")//如果根据id查询出现异常,走这段代码 @GetMapping(\"/dept/get/{id}\")//根据id查询 public Dept get(@PathVariable(\"id\") Long id){ Dept dept = deptService.queryById(id); if (dept==null){ throw new RuntimeException(\"这个id=&gt;\"+id+\",不存在该用户，或信息无法找到~\"); } return dept; } //根据id查询备选方案(熔断) public Dept hystrixGet(@PathVariable(\"id\") Long id){ return new Dept().setDeptno(id) .setDname(\"这个id=&gt;\"+id+\",没有对应的信息,null---@Hystrix~\") .setDb_source(\"在MySQL中没有这个数据库\"); } } 为主启动类添加对熔断的支持注解@EnableCircuitBreaker @SpringBootApplication @EnableEurekaClient //EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务 @EnableCircuitBreaker//添加对熔断的支持注解 public class HystrixDeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(HystrixDeptProvider_8001.class,args); } } 测试： 使用熔断后，当访问一个不存在的id时，前台页展示数据如下 而不适用熔断的springcloud-provider-dept–8001模块访问相同地址会出现下面状况 因此，为了避免因某个微服务后台出现异常或错误而导致整个应用或网页报错，使用熔断是必要的 8.5 服务降级什么是服务降级​ 服务降级是指 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。说白了，就是尽可能的把系统资源让给优先级高的服务。 资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证核心功能服务的可用性，都要对某些服务降级处理。比如当双11活动时，把交易无关的服务统统降级，如查看蚂蚁深林，查看历史订单等等。 服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，可以将一些 不重要 或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用。 降级的方式可以根据业务来，可以延迟服务，比如延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行 ；或者在粒度范围内关闭服务，比如关闭相关文章的推荐。 由上图可得，当某一时间内服务A的访问量暴增，而B和C的访问量较少，为了缓解A服务的压力，这时候需要B和C暂时关闭一些服务功能，去承担A的部分服务，从而为A分担压力，叫做服务降级。 服务降级需要考虑的问题 1）那些服务是核心服务，哪些服务是非核心服务 2）那些服务可以支持降级，那些服务不能支持降级，降级策略是什么 3）除服务降级之外是否存在更复杂的业务放通场景，策略是什么？ 自动降级分类1）超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况 2）失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况 3）故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据） 4）限流降级：秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。 入门案例在springcloud-api模块下的service包中新建降级配置类DeptClientServiceFallBackFactory.java //降级 ~ @Component public class DeptClientServiceFallBackFactory implements FallbackFactory { @Override public DeptClientService create(Throwable cause) { return new DeptClientService() { @Override public Dept queryById(Long id) { return new Dept() .setDeptno(id) .setDname(\"id=&gt;\" + id + \"没有对应的信息，客户端提供了降级的信息，这个服务现在已经被关闭\") .setDb_source(\"没有数据~\"); } @Override public List&lt;Dept&gt; queryAll() { return null; } @Override public Boolean addDept(Dept dept) { return false; } }; } } 在DeptClientService中指定降级配置类DeptClientServiceFallBackFactory @Component //注册到spring容器中 //@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务 @FeignClient(value = \"SPRINGCLOUD-PROVIDER-DEPT\",fallbackFactory = DeptClientServiceFallBackFactory.class)//fallbackFactory指定降级配置类 public interface DeptClientService { @GetMapping(\"/dept/get/{id}\") public Dept queryById(@PathVariable(\"id\") Long id); @GetMapping(\"/dept/list\") public List&lt;Dept&gt; queryAll(); @GetMapping(\"/dept/add\") public Boolean addDept(Dept dept); } 在springcloud-consumer-dept-feign模块中开启降级 server: port: 80 # Eureka配置 eureka: client: register-with-eureka: false # 不向 Eureka注册自己 service-url: # 从三个注册中心中随机取一个去访问 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ # 开启降级feign.hystrix feign: hystrix: enabled: true 8.6 服务熔断和降级的区别 服务熔断—&gt;服务端：某个服务超时或异常，引起熔断~，类似于保险丝(自我熔断) 服务降级—&gt;客户端：从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再被调用，此时在客户端，我们可以准备一个 FallBackFactory ，返回一个默认的值(缺省值)。会导致整体的服务下降，但是好歹能用，比直接挂掉强。 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始） 实现方式不太一样，服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为自我熔断。 限流：限制并发的请求访问量，超过阈值则拒绝；降级：服务分优先级，牺牲非核心服务（不可用），保证核心服务稳定；从整体负荷考虑；熔断：依赖的下游服务故障触发熔断，避免引发本系统崩溃；系统自动执行和恢复 8.7 Dashboard 流监控新建springcloud-consumer-hystrix-dashboard模块 添加依赖 &lt;!--Hystrix依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifact &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--dashboard依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Ribbon--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactI &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactI &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--实体类+web--&gt; &lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 消费者端application.yml配一个端口 server: port: 9001 主启动类 @SpringBootApplication //开启Dashboard @EnableHystrixDashboard public class DeptConsumerDashboard_9001 { public static void main(String[] args) { SpringApplication.run(DeptConsumerDashboard_9001.class,args); } } 给springcloud-provider-dept-8001模块下的主启动类添加如下代码,添加监控 @SpringBootApplication @EnableEurekaClient //EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务 public class DeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(DeptProvider_8001.class,args); } //增加一个 Servlet @Bean public ServletRegistrationBean hystrixMetricsStreamServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet()); //访问该页面就是监控页面 registrationBean.addUrlMappings(\"/actuator/hystrix.stream\"); return registrationBean; } } Hystirx-dashboard 效果图(先打开http://localhost:9001/hystrix，然后在输入栏里输入http://消费端口+/actuator/hystrix.stream，会打开消费端口的监控页面) 9. Zull路由网关概述什么是zuul? ​ Zull包含了对请求的路由(用来跳转的)和过滤两个最主要功能： ​ 其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础，而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础。Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。 ​ 注意：Zuul服务最终还是会注册进Eureka ​ 提供：代理+路由+过滤 三大功能！ Zuul能干嘛？ 路由 过滤 官方文档：https://github.com/Netflix/zuul/ 入门案例新建springcloud-zuul模块，并导入依赖 &lt;dependencies&gt; &lt;!--导入zuul依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Hystrix依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifac &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--dashboard依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboar &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Ribbon--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifact &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Eureka--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifact &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--实体类+web--&gt; &lt;dependency&gt; &lt;groupId&gt;com.haust&lt;/groupId&gt; &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; application.yml server: port: 9527 spring: application: name: springcloud-zuul #微服务名称 eureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: #实例的id instance-id: zuul9527.com prefer-ip-address: true # 显示ip info: app.name: haust.springcloud #项目名称 company.name: haust #公司名称 zuul: routes: mydept.serviceId: springcloud-provider-dept mydept.path: /mydept/** ignored-services: \"*\" # 不能再使用某个(*：全部)路径访问了，ignored ： 忽略,隐藏全部的~ prefix: /kuagn # 设置公共的前缀,实现隐藏原有路由 主启动类 @SpringBootApplication @EnableZuulProxy //开启Zuul public class ZuulApplication_9527 { public static void main(String[] args) { SpringApplication.run(ZuulApplication_9527.class,args); } } 详情参考springcloud中文社区zuul组件 :https://www.springcloud.cc/spring-cloud-greenwich.html#_router_and_filter_zuul 10. Spring Cloud Config 分布式配置Dalston.RELEASE Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持。使用Config Server，您可以在所有环境中管理应用程序的外部属性。客户端和服务器上的概念映射与Spring Environment和PropertySource抽象相同，因此它们与Spring应用程序非常契合，但可以与任何以任何语言运行的应用程序一起使用。随着应用程序通过从开发人员到测试和生产的部署流程，您可以管理这些环境之间的配置，并确定应用程序具有迁移时需要运行的一切。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。很容易添加替代实现，并使用Spring配置将其插入。 概述分布式系统面临的–配置文件问题 微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的，动态的配置管理设施是必不可少的。spring cloud提供了configServer来解决这个问题，我们每一个微服务自己带着一个application.yml，那上百个的配置文件修改起来，令人头疼！ 什么是SpringCloud config分布式配置中心？ ​ spring cloud config 为微服务架构中的微服务提供集中化的外部支持，配置服务器为各个不同微服务应用的所有环节提供了一个中心化的外部配置。 ​ spring cloud config 分为服务端和客户端两部分。 ​ 服务端也称为 分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密，解密信息等访问接口。 ​ 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可用通过git客户端工具来方便的管理和访问配置内容。 spring cloud config 分布式配置中心能干嘛？ 集中式管理配置文件 不同环境，不同配置，动态化的配置更新，分环境部署，比如 /dev /test /prod /beta /release 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息 当配置发生变动时，服务不需要重启，即可感知到配置的变化，并应用新的配置 将配置信息以REST接口的形式暴露 spring cloud config 分布式配置中心与GitHub整合 ​ 由于spring cloud config 默认使用git来存储配置文件 (也有其他方式，比如自持SVN 和本地文件)，但是最推荐的还是git ，而且使用的是 http / https 访问的形式。 入门案例服务端新建springcloud-config-server-3344模块导入pom.xml依赖 &lt;dependencies&gt; &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--config--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--eureka--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; resource下创建application.yml配置文件，Spring Cloud Config服务器从git存储库（必须提供）为远程客户端提供配置： server: port: 3344 spring: application: name: springcloud-config-server # 连接码云远程仓库 cloud: config: server: git: #注意是https的而不是ssh uri: https://gitee.com/cao_shi_peng/springcloud-config.git # 通过 config-server可以连接到git，访问其中的资源以及配置~ # 不加这个配置会报Cannot execute request on any known server 这个错：连接Eureka服务端地址不对 # 或者直接注释掉eureka依赖 这里暂时用不到eureka eureka: client: register-with-eureka: false fetch-registry: false 主启动类 @EnableConfigServer //开启spring cloud config server服务 @SpringBootApplication public class Config_server_3344 { public static void main(String[] args) { SpringApplication.run(Config_server_3344.class,args); } } 将本地git仓库springcloud-config文件夹下新建的application.yml提交到码云仓库： 定位资源的默认策略是克隆一个git仓库（在spring.cloud.config.server.git.uri），并使用它来初始化一个迷你SpringApplication。小应用程序的Environment用于枚举属性源并通过JSON端点发布。 HTTP服务具有以下格式的资源： /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 其中“应用程序”作为SpringApplication中的spring.config.name注入（即常规的Spring Boot应用程序中通常是“应用程序”），“配置文件”是活动配置文件（或逗号分隔列表的属性），“label”是可选的git标签（默认为“master”）。 测试访问http://localhost:3344/application-dev.yml 测试访问 http://localhost:3344/application/test/master 测试访问 http://localhost:3344/master/application-dev.yml 如果测试访问不存在的配置则不显示 如：http://localhost:3344/master/application-aaa.yml 客户端将本地git仓库springcloud-config文件夹下新建的config-client.yml提交到码云仓库： 新建一个springcloud-config-client-3355模块，并导入依赖 &lt;!--config--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; resources下创建application.yml和bootstrap.yml配置文件 bootstrap.yml是系统级别的配置 # 系统级别的配置 spring: cloud: config: name: config-client # 需要从git上读取的资源名称，不要后缀 profile: dev label: master uri: http://localhost:3344 application.yml是用户级别的配置 # 用户级别的配置 spring: application: name: springcloud-config-client 创建controller包下的ConfigClientController.java用于测试 @RestController public class ConfigClientController { @Value(\"${spring.application.name}\") private String applicationName; //获取微服务名称 @Value(\"${eureka.client.service-url.defaultZone}\") private String eurekaServer; //获取Eureka服务 @Value(\"${server.port}\") private String port; //获取服务端的端口号 @RequestMapping(\"/config\") public String getConfig(){ return \"applicationName:\"+applicationName + \"eurekaServer:\"+eurekaServer + \"port:\"+port; } } 主启动类 @SpringBootApplication public class ConfigClient { public static void main(String[] args) { SpringApplication.run(ConfigClient.class,args); } } 测试： 启动服务端Config_server_3344 再启动客户端ConfigClient 访问：http://localhost:8201/config/ 小案例 本地新建config-dept.yml和config-eureka.yml并提交到码云仓库 这里配置文件内容不再列举直接到代码中看把。 新建springcloud-config-eureka-7001模块，并将原来的springcloud-eureka-7001模块下的内容拷贝的该模块。 1.清空该模块的application.yml配置，并新建bootstrap.yml连接远程配置 spring: cloud: config: name: config-eureka # 仓库中的配置文件名称 label: master profile: dev uri: http://localhost:3344 2.在pom.xml中添加spring cloud config依赖 &lt;!--config--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-config --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; 3.主启动类 @SpringBootApplication @EnableEurekaServer //EnableEurekaServer 服务端的启动类，可以接受别人注册进来~ public class ConfigEurekaServer_7001 { public static void main(String[] args) { SpringApplication.run(ConfigEurekaServer_7001.class,args); } } 4.测试 第一步：启动 Config_Server_3344，并访问 http://localhost:3344/master/config-eureka-dev.yml 测试 第二部：启动ConfigEurekaServer_7001，访问 http://localhost:7001/ 测试 显示上图则成功 新建springcloud-config-dept-8001模块并拷贝springcloud-provider-dept-8001的内容 同理导入spring cloud config依赖、清空application.yml 、新建bootstrap.yml配置文件并配置 spring: cloud: config: name: config-dept label: master profile: dev uri: http://localhost:3344 主启动类 @SpringBootApplication @EnableEurekaClient //在服务启动后自动注册到Eureka中！ @EnableDiscoveryClient //服务发现~ @EnableCircuitBreaker // public class ConfigDeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(ConfigDeptProvider_8001.class,args); } //增加一个 Servlet @Bean public ServletRegistrationBean hystrixMetricsStreamServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet()); registrationBean.addUrlMappings(\"/actuator/hystrix.stream\"); return registrationBean; } } 测试 (略) 服务跟踪Spring Cloud Zipkin Zipkin 是一个可以采集并且跟踪分布式系统中请求数据的组件，让开发者可以更加直观的监控到请求在各个微服务所耗费的时间等，Zipkin：Zipkin Server、Zipkin Client。 ####创建 Zipkin Server 创建 Maven 工程，pom.xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;version&gt;2.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;version&gt;2.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建配置文件 application.yml server: port: 9090 创建启动类 package com.southwind; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import zipkin.server.internal.EnableZipkinServer; @SpringBootApplication @EnableZipkinServer public class ZipkinApplication { public static void main(String[] args) { SpringApplication.run(ZipkinApplication.class,args); } } 注解说明 @EnableZipkinServer：声明启动 Zipkin Server 创建 Zipkin Client 创建 Maven 工程，pom.xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建配置文件 application.yml server: port: 8090 spring: application: name: zipkinclient sleuth: web: client: enabled: true sampler: probability: 1.0 zipkin: base-url: http://localhost:9090/ eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 属性说明 spring.sleuth.web.client.enabled：设置开启请求跟踪 spring.sleuth.sampler.probability：设置采样比例，默认是 1.0 srping.zipkin.base-url：Zipkin Server 地址 创建启动类 package com.southwind; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ZipkinClientApplication { public static void main(String[] args) { SpringApplication.run(ZipkinClientApplication.class,args); } } Handler package com.southwind.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/zipkin\") public class ZipkinHandler { @Value(\"${server.port}\") private String port; @GetMapping(\"/index\") public String index(){ return this.port; } }","categories":[],"tags":[]},{"title":"","slug":"Spring笔记","date":"2021-09-14T08:22:45.915Z","updated":"2021-09-14T08:22:46.216Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"Spring 简介 Spring : 春天 —&gt;给软件行业带来了春天 2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。 2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。 很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。 Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术 优点 Spring是一个开源免费的框架（容器） Spring是一个轻量级的、非入侵式的框架 控制反转 IoC，面向切面 AOP 对事物的支持，对框架的支持 一句话概括：Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。 组成 Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 . 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 拓展 Spring Boot与Spring Cloud Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; Spring Cloud是基于Spring Boot实现的； Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。 Spring 框架两大核心机制（IoC、AOP） IoC（控制反转）/ DI（依赖注入） AOP（面向切面编程） Spring 是一个企业级开发框架，是软件设计层面的框架，优势在于可以将应用程序进行分层，开发者可以自主选择组件。 MVC：Struts2、Spring MVC ORMapping：Hibernate、MyBatis、Spring Data Spring配置 别名 alias 设置别名 , 为bean设置别名 , 可以设置多个别名 &lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt; &lt;alias name=\"user\" alias=\"userNew\"/&gt; Bean的配置 &lt;!--bean就是java对象,由Spring创建和管理--&gt; &lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; class是bean的全限定名=包名+类名 --&gt; &lt;bean id=\"hello\" name=\"hello2 h2,h3;h4\" class=\"com.kuang.pojo.Hello\"&gt; &lt;property name=\"name\" value=\"Spring\"/&gt; &lt;/bean&gt; import 团队的合作通过import来实现 . &lt;import resource=\"{path}/beans.xml\"/&gt; IoC基础新建一个空白的maven项目 分析实现 我们先用我们原来的方式写一段代码 . 1、先写一个UserDao接口 public interface UserDao { public void getUser(); } 2、再去写Dao的实现类 public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\"获取用户数据\"); } } 3、然后去写UserService的接口 public interface UserService { public void getUser(); } 4、最后写Service的实现类 public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } } 5、测试一下 @Test public void test(){ UserService service = new UserServiceImpl(); service.getUser(); } 这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 . 把Userdao的实现类增加一个 . public class UserDaoMySqlImpl implements UserDao { @Override public void getUser() { System.out.println(\"MySql获取用户数据\"); } } 紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现 public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() { userDao.getUser(); } } 在假设, 我们再增加一个Userdao的实现类 . public class UserDaoOracleImpl implements UserDao { @Override public void getUser() { System.out.println(\"Oracle获取用户数据\"); } } 那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 . 那我们如何去解决呢 ? 我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 . public class UserServiceImpl implements UserService { private UserDao userDao; // 利用set实现 public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } } 现在去我们的测试类里 , 进行测试 ; @Test public void test(){ UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢 service.setUserDao( new UserDaoOracleImpl() ); service.getUser(); } 大家发现了区别没有 ? 可能很多人说没啥区别 ,但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 . 这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 ! IOC本质 控制反转 IoC (Inversion of Control)，是一种设计思想，DI (依赖注入)是实现 IoC 的一种方法，也有人认为 DI 只是 IoC 的另一种说法。没有 IoC 的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。 Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI），依赖注入 : 就是利用set方法来进行注入的。 IoC 底层原理 读取配置文件，解析 XML。 通过反射机制实例化配置文件中所配置所有的 bean。 package com.southwind.ioc; import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Iterator; import java.util.Map; public class ClassPathXmlApplicationContext implements ApplicationContext { private Map&lt;String,Object&gt; ioc = new HashMap&lt;String, Object&gt;(); public ClassPathXmlApplicationContext(String path){ try { SAXReader reader = new SAXReader(); Document document = reader.read(\"./src/main/resources/\"+path); Element root = document.getRootElement(); Iterator&lt;Element&gt; iterator = root.elementIterator(); while(iterator.hasNext()){ Element element = iterator.next(); String id = element.attributeValue(\"id\"); String className = element.attributeValue(\"class\"); //通过反射机制创建对象 Class clazz = Class.forName(className); //获取无参构造函数，创建目标对象 Constructor constructor = clazz.getConstructor(); Object object = constructor.newInstance(); //给目标对象赋值 Iterator&lt;Element&gt; beanIter = element.elementIterator(); while(beanIter.hasNext()){ Element property = beanIter.next(); String name = property.attributeValue(\"name\"); String valueStr = property.attributeValue(\"value\"); String ref = property.attributeValue(\"ref\"); if(ref == null){ String methodName = \"set\"+name.substring(0,1).toUpperCase()+name.substring(1); Field field = clazz.getDeclaredField(name); Method method = clazz.getDeclaredMethod(methodName,field.getType()); //根据成员变量的数据类型将 value 进行转换 Object value = null; if(field.getType().getName() == \"long\"){ value = Long.parseLong(valueStr); } if(field.getType().getName() == \"java.lang.String\"){ value = valueStr; } if(field.getType().getName() == \"int\"){ value = Integer.parseInt(valueStr); } method.invoke(object,value); } ioc.put(id,object); } } } catch (DocumentException e) { e.printStackTrace(); } catch (ClassNotFoundException e){ e.printStackTrace(); } catch (NoSuchMethodException e){ e.printStackTrace(); } catch (InstantiationException e){ e.printStackTrace(); } catch (IllegalAccessException e){ e.printStackTrace(); } catch (InvocationTargetException e){ e.printStackTrace(); } catch (NoSuchFieldException e){ e.printStackTrace(); } } public Object getBean(String id) { return ioc.get(id); } } 如何使用 IoC 创建 Maven 工程，pom.xml 添加依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.southwind&lt;/groupId&gt; &lt;artifactId&gt;aispringioc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 创建实体类 Student package com.southwind.entity; import lombok.Data; @Data public class Student { private long id; private String name; private int age; } 传统的开发方式，手动 new Student Student student = new Student(); student.setId(1L); student.setName(\"张三\"); student.setAge(22); System.out.println(student); 通过 IoC 创建对象，在配置文件中添加需要管理的对象，XML 格式的配置文件，文件名可以自定义。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd \"&gt; &lt;bean id=\"student\" class=\"com.southwind.entity.Student\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 从 IoC 中获取对象，通过 id 获取。 //加载配置文件 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); Student student = (Student) applicationContext.getBean(\"student\"); System.out.println(student); 通过运行时类获取 bean ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\"); Student student = (Student) applicationContext.getBean(Student.class); System.out.println(student); 这种方式存在一个问题，配置文件中一个数据类型的对象==只能有一个实例==，否则会抛出异常，因为没有唯一的 bean。 依赖注入（Dependency Injection,DI） 概念 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 . 构造器注入 通过无参构造方法来创建 1、User.java public class User { private String name; public User() { System.out.println(\"user无参构造方法\"); } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\"name=\"+ name ); } } 2、beans.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\"&gt; &lt;property name=\"name\" value=\"kuangshen\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 3、测试类 @Test public void test(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //在执行getBean之前, user已经创建好了 , 通过无参构造 User user = (User) context.getBean(\"user\"); //调用对象的方法 . user.show(); } 结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！ 通过有参构造方法来创建 1、UserT . java public class UserT { private String name; public UserT(String name) { this.name = name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\"name=\"+ name ); } } 2、beans.xml 有三种方式编写 &lt;!-- 第一种根据index参数下标设置 --&gt; &lt;bean id=\"userT\" class=\"com.kuang.pojo.UserT\"&gt; &lt;!-- index指构造方法参数下标 , 下标从0开始 --&gt; &lt;constructor-arg index=\"0\" value=\"kuangshen2\"/&gt; &lt;/bean&gt; &lt;!-- 第二种根据参数名字设置 --&gt; &lt;bean id=\"userT\" class=\"com.kuang.pojo.UserT\"&gt; &lt;!-- name指参数名 --&gt; &lt;constructor-arg name=\"name\" value=\"kuangshen2\"/&gt; &lt;/bean&gt; &lt;!-- 第三种根据参数类型设置 --&gt; &lt;bean id=\"userT\" class=\"com.kuang.pojo.UserT\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"kuangshen2\"/&gt; &lt;/bean&gt; 3、测试 @Test public void testT(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserT user = (UserT) context.getBean(\"userT\"); user.show(); } 结论：在配置文件加载的时候，其中管理的对象都已经初始化了！ Set 注入要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 测试pojo类 : Address.java public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } Student.java package com.kuang.pojo; import java.util.List; import java.util.Map; import java.util.Properties; import java.util.Set; public class Student { private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; public void setName(String name) { this.name = name; } public void setAddress(Address address) { this.address = address; } public void setBooks(String[] books) { this.books = books; } public void setHobbys(List&lt;String&gt; hobbys) { this.hobbys = hobbys; } public void setCard(Map&lt;String, String&gt; card) { this.card = card; } public void setGames(Set&lt;String&gt; games) { this.games = games; } public void setWife(String wife) { this.wife = wife; } public void setInfo(Properties info) { this.info = info; } public void show(){ System.out.println(\"name=\"+ name + \",address=\"+ address.getAddress() + \",books=\" ); for (String book:books){ System.out.print(\"&lt;&lt;\"+book+\"&gt;&gt;\\t\"); } System.out.println(\"\\n爱好:\"+hobbys); System.out.println(\"card:\"+card); System.out.println(\"games:\"+games); System.out.println(\"wife:\"+wife); System.out.println(\"info:\"+info); } } 1、常量注入 &lt;bean id=\"student\" class=\"com.kuang.pojo.Student\"&gt; &lt;property name=\"name\" value=\"小明\"/&gt; &lt;/bean&gt; 测试： @Test public void test01(){ ApplicationContext context = newClassPathXmlApplicationContext(\"applicationContext.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student.getName()); } 2、Bean注入 注意点：这里的值是一个引用，ref，引用另一个bean &lt;bean id=\"addr\" class=\"com.kuang.pojo.Address\"&gt; &lt;property name=\"address\" value=\"重庆\"/&gt; &lt;/bean&gt; &lt;bean id=\"student\" class=\"com.kuang.pojo.Student\"&gt; &lt;property name=\"name\" value=\"小明\"/&gt; &lt;property name=\"address\" ref=\"addr\"/&gt; &lt;/bean&gt; 3、数组注入 &lt;bean id=\"student\" class=\"com.kuang.pojo.Student\"&gt; &lt;property name=\"name\" value=\"小明\"/&gt; &lt;property name=\"address\" ref=\"addr\"/&gt; &lt;property name=\"books\"&gt; &lt;array&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 4、List注入 &lt;property name=\"hobbys\"&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;value&gt;爬山&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 给 bean 注入类集合 &lt;bean id=\"student\" class=\"com.southwind.entity.Student\"&gt; &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"33\"&gt;&lt;/property&gt; &lt;property name=\"addresses\"&gt; &lt;list&gt; &lt;ref bean=\"address\"&gt;&lt;/ref&gt; &lt;ref bean=\"address2\"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"address\" class=\"com.southwind.entity.Address\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"科技路\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"address2\" class=\"com.southwind.entity.Address\"&gt; &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"高新区\"&gt;&lt;/property&gt; &lt;/bean&gt; 5、Map注入 &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"中国邮政\" value=\"456456456465456\"/&gt; &lt;entry key=\"建设\" value=\"1456682255511\"/&gt; &lt;/map&gt; &lt;/property&gt; 6、Set (集合)注入 &lt;property name=\"games\"&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; 7、Null注入 &lt;property name=\"wife\"&gt; &lt;null/&gt; &lt;/property&gt; 8、Properties注入 &lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"学号\"&gt;20190604&lt;/prop&gt; &lt;prop key=\"性别\"&gt;男&lt;/prop&gt; &lt;prop key=\"姓名\"&gt;小明&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; p命名和c命名注入User.java ：【注意：这里没有有参构造器！】 public class User { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 1、P命名空间注入 : 需要在头文件中加入约束文件 导入约束 : xmlns:p=\"http://www.springframework.org/schema/p\" &lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\" p:name=\"狂神\" p:age=\"18\"/&gt; 2、C命名空间注入 : 需要在头文件中加入约束文件 导入约束 : xmlns:c=\"http://www.springframework.org/schema/c\" &lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\" c:name=\"狂神\" c:age=\"18\"/&gt; ==c命名空间注入需要把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！== 测试代码： @Test public void test02(){ ApplicationContext context = newClassPathXmlApplicationContext(\"applicationContext.xml\"); User user = (User) context.getBean(\"user\"); System.out.println(user); } scope 作用域Spring 管理的 bean 是根据 scope 来生成的，表示 bean 的作用域，共4种，默认值是 singleton。 范围 描述 singleton (默认)为每个 Spring IoC 容器的单个 object 实例定义单个 bean 定义。 prototype 为任意数量的 object 实例定义单个 bean 定义。 request 将单个 bean 定义范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有自己的 bean 实例，该实例是在单个 bean 定义的后面创建的。仅在 web-aware Spring ApplicationContext的 context 中有效。 session 将单个 bean 定义范围限定为 HTTP Session的生命周期。仅在 web-aware Spring ApplicationContext的 context 中有效。 Application 将单个 bean 定义范围限定为ServletContext的生命周期。仅在 web-aware Spring ApplicationContext的 context 中有效。 WebSocket 将单个 bean 定义范围限定为WebSocket的生命周期。仅在 web-aware Spring ApplicationContext的 context 中有效。 singleton：单例，表示通过 IoC 容器获取的 bean 是唯一的。 prototype：原型，表示通过 IoC 容器获取的 bean 是不同的。 request：请求，表示在一次 HTTP 请求内有效。 session：回话，表示在一个用户会话内有效。 request 和 session 只适用于 Web 项目，大多数情况下，使用单例和原型较多。 prototype 模式当业务代码获取 IoC 容器中的 bean 时，Spring 才去调用无参构造创建对应的 bean。 &lt;bean id=\"ServiceImpl\" class=\"cn.csdn.service.ServiceImpl\" scope=\"singleton\"&gt; singleton 模式无论业务代码是否获取 IoC 容器中的 bean，Spring 在加载 spring.xml 时就会创建 bean。 &lt;bean id=\"account\" class=\"com.foo.DefaultAccount\" scope=\"prototype\"/&gt; 或者 &lt;bean id=\"account\" class=\"com.foo.DefaultAccount\" singleton=\"false\"/&gt; Spring 的继承与 Java 的继承不同，Java 是类层面的继承，子类可以继承父类的内部结构信息；Spring 是对象层面的继承，子对象可以继承父对象的属性值。 &lt;bean id=\"student2\" class=\"com.southwind.entity.Student\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt; &lt;property name=\"addresses\"&gt; &lt;list&gt; &lt;ref bean=\"address\"&gt;&lt;/ref&gt; &lt;ref bean=\"address2\"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"address\" class=\"com.southwind.entity.Address\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"科技路\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"address2\" class=\"com.southwind.entity.Address\"&gt; &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"高新区\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"stu\" class=\"com.southwind.entity.Student\" parent=\"student2\"&gt; &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt; &lt;/bean&gt; Spring 的继承关注点在于==具体的对象==，而不在于类，即==不同的两个类的实例化对象可以完成继承==，前提是==子对象必须包含父对象的所有属性==，同时可以在此基础上添加其他的属性。 Spring 的依赖与继承类似，依赖也是描述 bean 和 bean 之间的一种关系，配置依赖之后，被依赖的 bean 一定先创建，再创建依赖的 bean，A 依赖于 B，先创建 B，再创建 A。==没有依赖关系的话 bean 会根据写的先后顺序创建== &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \"&gt; &lt;bean id=\"student\" class=\"com.southwind.entity.Student\" depends-on=\"user\"&gt;&lt;/bean&gt; &lt;bean id=\"user\" class=\"com.southwind.entity.User\"&gt;&lt;/bean&gt; &lt;/beans&gt; Spring 的工厂方法IoC 通过工厂模式创建 bean 的方式有两种： 静态工厂方法 实例工厂方法 静态工厂方法 package com.southwind.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class Car { private long id; private String name; } package com.southwind.factory; import com.southwind.entity.Car; import java.util.HashMap; import java.util.Map; public class StaticCarFactory { private static Map&lt;Long, Car&gt; carMap; static{ carMap = new HashMap&lt;Long, Car&gt;(); carMap.put(1L,new Car(1L,\"宝马\")); carMap.put(2L,new Car(2L,\"奔驰\")); } public static Car getCar(long id){ return carMap.get(id); } } &lt;!-- 配置静态工厂创建 Car --&gt; &lt;bean id=\"car\" class=\"com.southwind.factory.StaticCarFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg value=\"2\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 实例工厂方法 package com.southwind.factory; import com.southwind.entity.Car; import java.util.HashMap; import java.util.Map; public class InstanceCarFactory { private Map&lt;Long, Car&gt; carMap; public InstanceCarFactory(){ carMap = new HashMap&lt;Long, Car&gt;(); carMap.put(1L,new Car(1L,\"宝马\")); carMap.put(2L,new Car(2L,\"奔驰\")); } public Car getCar(long id){ return carMap.get(id); } } &lt;!-- 配置实例工厂 bean --&gt; &lt;bean id=\"carFactory\" class=\"com.southwind.factory.InstanceCarFactory\"&gt;&lt;/bean&gt; &lt;!-- 配置实例工厂创建 Car --&gt; &lt;bean id=\"car2\" factory-bean=\"carFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg value=\"1\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; IoC 自动装载（Autowire）Bean的自动装配 自动装配说明 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配机制，分别是： 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的 IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。 推荐不使用自动装配xml配置 , 而使用注解 . 测试环境搭建 1、新建一个项目 2、新建两个实体类，Cat Dog 都有一个叫的方法 public class Cat { public void shout() { System.out.println(\"miao~\"); } } public class Dog { public void shout() { System.out.println(\"wang~\"); } } 3、新建一个用户类 User public class User { private Cat cat; private Dog dog; private String str; } 4、编写Spring配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\"&gt; &lt;property name=\"cat\" ref=\"cat\"/&gt; &lt;property name=\"dog\" ref=\"dog\"/&gt; &lt;property name=\"str\" value=\"qinjiang\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 5、测试 public class MyTest { @Test public void testMethodAutowire() { ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"user\"); user.getCat().shout(); user.getDog().shout(); } } 结果正常输出，环境OK 自动装配的两种方式：1、byName (按名称自动装配) 2、byType (按类型自动装配) byName autowire byName (按名称自动装配) 由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。 采用自动装配将避免这些错误，并且使配置简单化。 测试： 1、修改bean配置，增加一个属性 autowire=”byName” &lt;bean id=\"user\" class=\"com.kuang.pojo.User\" autowire=\"byName\"&gt; &lt;property name=\"str\" value=\"qinjiang\"/&gt; &lt;/bean&gt; 2、再次测试，结果依旧成功输出！ 3、我们将 cat 的bean id修改为 catXXX 4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat方法就没执行，对象就没有初始化，所以调用时就会报空指针错误。 小结： 当一个bean节点带有 autowire byName的属性时。 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称 id 的bean。 如果有，就取出注入；如果没有，就报空指针异常。 byType autowire byType (按类型自动装配) 使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。 NoUniqueBeanDefinitionException 测试： 1、将user的bean配置修改一下 ： autowire=”byType” 2、测试，正常输出 3、在注册一个cat 的bean对象！ &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"cat2\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\" autowire=\"byType\"&gt; &lt;property name=\"str\" value=\"qinjiang\"/&gt; &lt;/bean&gt; 4、测试，报错：NoUniqueBeanDefinitionException 5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。 使用注解 jdk1.5开始支持注解，spring2.5开始全面支持注解。 准备工作：利用注解的方式注入属性。 1、在spring配置文件中引入context文件头 xmlns:context=\"http://www.springframework.org/schema/context\" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd 2、开启属性注解支持！ &lt;context:annotation-config/&gt; @Autowired @Autowired是按类型自动转配的，不支持 id 匹配。 需要导入 spring-aop 的 jar包！ 测试： 1、将User类中的set方法去掉，使用@Autowired注解 public class User { @Autowired private Cat cat; @Autowired private Dog dog; private String str; public Cat getCat() { return cat; } public Dog getDog() { return dog; } public String getStr() { return str; } } 2、此时配置文件内容 &lt;context:annotation-config/&gt; &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\"/&gt; 3、测试，成功输出结果！ 【小狂神科普时间】 @Autowired(required=false) 说明：false，对象可以为null；true，对象必须存在，不能为null。 //如果允许对象为null，设置required = false,默认为true @Autowired(required = false) private Cat cat; @Qualifier @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用。 测试实验步骤： 1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ &lt;bean id=\"dog1\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"dog2\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat1\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"cat2\" class=\"com.kuang.pojo.Cat\"/&gt; 2、没有加Qualifier测试，直接报错 3、在属性上添加Qualifier注解 @Autowired @Qualifier(value = \"cat2\") private Cat cat; @Autowired @Qualifier(value = \"dog2\") private Dog dog; 测试，成功输出！ @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 实体类： public class User { @Resource(name = \"cat2\") private Cat cat; @Resource private Dog dog; private String str; } beans.xml &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat1\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"cat2\" class=\"com.kuang.pojo.Cat\"/&gt; &lt;bean id=\"user\" class=\"com.kuang.pojo.User\"/&gt; 测试：结果OK 配置文件2：beans.xml ， 删掉cat2 &lt;bean id=\"dog\" class=\"com.kuang.pojo.Dog\"/&gt; &lt;bean id=\"cat1\" class=\"com.kuang.pojo.Cat\"/&gt; 实体类上只保留注解 @Resource private Cat cat; @Resource private Dog dog; 结果：OK 结论：先进行byName查找，失败；再进行byType查找，成功。 小结 @Autowired与@Resource异同： 1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用 3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。 使用注解开发 说明 在spring4之后，想要使用注解形式，必须得要引入 spring-aop 的 jar 包 在配置文件当中，还得要引入一个context约束 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解支持 --&gt; &lt;context:annotation-config/&gt; &lt;/beans&gt; Bean的实现 我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！ 1、配置扫描哪些包下的注解 &lt;!--指定注解扫描包，有 @Component 注解会自动装配 bean --&gt; &lt;context:component-scan base-package=\"com.kuang.pojo\"/&gt; 2、在指定包下编写类，增加注解 @Component(\"user\") // 相当于配置文件中 &lt;bean id=\"user\" class=\"当前注解的类\"/&gt; public class User { public String name = \"秦疆\"; } 3、测试 @Test public void test(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) applicationContext.getBean(\"user\"); System.out.println(user.name); } 属性注入 使用注解注入属性 1、可以不用提供set方法，直接在直接名上添加 @value(“值”) @Component(\"user\") // 相当于配置文件中 &lt;bean id=\"user\" class=\"当前注解的类\"/&gt; // @Component 默认是 @Component(\"类名首字母小写\") public class User { @Value(\"秦疆\") // 相当于配置文件中 &lt;property name=\"name\" value=\"秦疆\"/&gt; public String name; } 2、如果提供了set方法，在set方法上添加**@value(“值”)**; @Component(\"user\") public class User { public String name; @Value(\"秦疆\") public void setName(String name) { this.name = name; } } 衍生注解 我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！ @Component三个衍生注解 为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。 @Controller：web层 @Service：service层 @Repository：dao层 写上这些注解，就相当于将这个类交给Spring管理装配了！ 自动装配注解 @Autowired是按类型自动转配的，不支持 id 匹配。 @Qualifier：@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配，**@Qualifier不能单独使用。** @Resource：@Resource如有指定的name属性，先按该属性进行byName方式查找装配；其次再进行默认的byName方式进行装配；如果以上都不成功，则按byType的方式自动装配。 作用域 @scope singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 @Controller(\"user\") @Scope(\"prototype\") public class User { @Value(\"秦疆\") public String name; } 小结 XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践 xml 管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 开启注解支持 ： &lt;context:annotation-config/&gt; 作用： 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显式的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！ 基于Java类进行配置JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。 测试： 1、编写一个实体类，Dog @Component //将这个类标注为Spring的一个组件，放到容器中！ 在这里可不写，没有作用，因为 bean 已经在 MyConfig 类中注册 与@ComponentScan 搭配使用 public class Dog { public String name = \"dog\"; } 2、新建一个config配置包，编写一个MyConfig配置类 @Configuration //代表这是一个配置类 @ComponentScan(\"com.xu.bean\") //自动扫描包，有 @Component 注解的会自动装配 bean public class MyConfig { @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！ public Dog getdog(){ return new Dog(); } } 3、测试 @Test public void test2(){ ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class); //注意这里是 AnnotationConfigApplicationContext 类 Dog dog = (Dog) applicationContext.getBean(\"getdog\"); // 这样写用的是 @Component 和 @ComponentScan 注解 // Dog dog = (Dog) applicationContext.getBean(\"dog\"); System.out.println(dog.name); } 4、成功输出结果！ 导入其他配置如何做呢？ 1、我们再编写一个配置类！ @Configuration //代表这是一个配置类 public class MyConfig2 { } 2、在之前的配置类中我们来选择导入这个配置类 @Configuration @Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签 public class MyConfig { @Bean public Dog dog(){ return new Dog(); } } 关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！ 代理模式为什么要学习代理模式，因为AOP的底层机制就是动态代理！ 代理模式： 静态代理 动态代理 学习aop之前 , 我们要先了解一下代理模式！ 静态代理 静态代理角色分析 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 代码实现 Rent . java 即抽象角色 //抽象角色：租房 public interface Rent { public void rent(); } Host . java 即真实角色 //真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\"房屋出租\"); } } Proxy . java 即代理角色 //代理角色：中介 public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } //租房 public void rent(){ seeHouse(); host.rent(); fare(); } //看房 public void seeHouse(){ System.out.println(\"带房客看房\"); } //收中介费 public void fare(){ System.out.println(\"收中介费\"); } } Client . java 即客户 //客户类，一般客户都会去找代理！ public class Client { public static void main(String[] args) { //房东要租房 Host host = new Host(); //中介帮助房东 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); } } 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。 静态代理的好处: 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 缺点 : 类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 . 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 ! 静态代理再理解 同学们练习完毕后，我们再来举一个例子，巩固大家的学习！ 练习步骤： 1、创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！ //抽象角色：增删改查业务 public interface UserService { void add(); void delete(); void update(); void query(); } 2、我们需要一个真实对象来完成这些增删改查操作 //真实对象，完成增删改查操作的人 public class UserServiceImpl implements UserService { public void add() { System.out.println(\"增加了一个用户\"); } public void delete() { System.out.println(\"删除了一个用户\"); } public void update() { System.out.println(\"更新了一个用户\"); } public void query() { System.out.println(\"查询了一个用户\"); } } 3、需求来了，现在我们需要增加一个日志功能，怎么实现！ 思路1 ：在实现类上增加代码 【麻烦！】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！ 4、设置一个代理类来处理日志！代理角色 //代理角色，在这里面增加日志的实现 public class UserServiceProxy implements UserService { private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) { this.userService = userService; } public void add() { log(\"add\"); userService.add(); } public void delete() { log(\"delete\"); userService.delete(); } public void update() { log(\"update\"); userService.update(); } public void query() { log(\"query\"); userService.query(); } public void log(String msg){ System.out.println(\"执行了\"+msg+\"方法\"); } } 5、测试访问类： public class Client { public static void main(String[] args) { //真实业务 UserServiceImpl userService = new UserServiceImpl(); //代理类 UserServiceProxy proxy = new UserServiceProxy(); //使用代理类实现日志功能！ proxy.setUserService(userService); proxy.add(); } } OK，到了现在代理模式大家应该都没有什么问题了，重点大家需要理解其中的思想； 我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想 聊聊AOP：纵向开发，横向开发 动态代理 动态代理的角色和静态代理的一样 . 动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理—-JDK动态代理 基于类的动态代理–cglib 现在用的比较多的是 javasist 来生成动态代理 . 百度一下 javasist 我们这里使用JDK的原生代码来实现，其余的道理都是一样的！、 JDK的动态代理需要了解两个类 核心 : InvocationHandler 和 Proxy ， 打开JDK帮助文档看看 【InvocationHandler：调用处理程序】 Object invoke(Object proxy, 方法 method, Object[] args)； //参数 //proxy - 调用该方法的代理实例 //method -对应代理业务接口的方法对象。方法对象的声明类型将是该方法所属的接口类型，它可以是代理类继承该方法的代理接口的超级接口。 //args -method 的参数列，即业务方法的参数列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 【Proxy : 代理】 //生成代理类 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } 代码实现 抽象角色和真实角色和之前的一样！ Rent . java 即抽象角色 //抽象角色：租房 public interface Rent { public void rent(); } Host . java 即真实角色 //真实角色: 房东，房东要出租房子 public class Host implements Rent{ public void rent() { System.out.println(\"房屋出租\"); } } ProxyInvocationHandler. java 即代理角色 public class ProxyInvocationHandler implements InvocationHandler { private Rent rent; public void setRent(Rent rent) { this.rent = rent; } //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); } // proxy : 代理类 method : 代理类的调用处理程序的方法对象. // 处理代理实例上的方法调用并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable { seeHouse(); //核心：本质利用反射实现！ Object result = method.invoke(rent, args); fare(); return result; } //看房 public void seeHouse(){ System.out.println(\"带房客看房\"); } //收中介费 public void fare(){ System.out.println(\"收中介费\"); } } Client . java //租客 public class Client { public static void main(String[] args) { //真实角色 Host host = new Host(); //代理实例的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //隐式向上转型 pih.setRent(host); //将真实角色放置进去！ Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！ proxy.rent(); } } 核心：一个静态态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口! 深化理解 我们来使用动态代理实现代理我们后面写的 UserService！ 我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为 Object 即可！ public class ProxyInvocationHandler implements InvocationHandler { private Object target; public void setTarget(Object target) { this.target = target; } //生成代理类 public Object getProxy(){ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); } // proxy : 代理类 // method : 代理类的调用处理程序的方法对象. public Object invoke(Object proxy, Method method, Object[] args) throwsThrowable { log(method.getName()); Object result = method.invoke(target, args); return result; } public void log(String methodName){ System.out.println(\"执行了\"+methodName+\"方法\"); } } 测试！ public class Test { public static void main(String[] args) { //真实对象 UserServiceImpl userService = new UserServiceImpl(); //代理对象的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //隐式向上转型 pih.setTarget(userService); //设置要代理的对象 UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！ proxy.delete(); } } 测试，增删改查，查看结果！ 动态代理的好处 静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . 公共的业务由代理来完成 . 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ AOPAOP：Aspect Oriented Programming 面向切面编程。 AOP 的优点： 降低模块之间的耦合度。 使系统更容易扩展。 更好的代码复用。 非业务代码更加集中，不分散，便于统一管理。 业务代码更加简洁存粹，不参杂其他代码的影响。 AOP 是对面向对象编程的一个补充，在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。将不同方法的同一个位置抽象成一个切面对象，对该切面对象进行编程就是 AOP。 Aop在Spring中的作用 提供声明式事务；允许用户自定义切面 以下名词需要了解下： 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 . 使用Spring实现Aop【重点】使用AOP织入，需要导入一个依赖包！ &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; 第一种方式 通过 Spring API 实现首先编写我们的业务接口和实现类 public interface UserService { public void add(); public void delete(); public void update(); public void search(); } public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\"增加用户\"); } @Override public void delete() { System.out.println(\"删除用户\"); } @Override public void update() { System.out.println(\"更新用户\"); } @Override public void search() { System.out.println(\"查询用户\"); } } 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强 public class Log implements MethodBeforeAdvice { //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //Object : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable { System.out.println( o.getClass().getName() + \"的\" + method.getName() + \"方法被执行了\"); } } public class AfterLog implements AfterReturningAdvice { //returnValue 返回值 //method被调用的方法 //args 被调用的方法的对象的参数 //target 被调用的目标对象 @Override public void afterReturning(Object returnValue, Method method, Object[] args,Object target) throws Throwable { System.out.println(\"执行了\" + target.getClass().getName() +\"的\"+method.getName()+\"方法,\" +\"返回值：\"+returnValue); } } 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 . &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--注册bean--&gt; &lt;bean id=\"userService\" class=\"com.kuang.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"com.kuang.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"com.kuang.log.AfterLog\"/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--切入点 expression:表达式匹配要执行的方法--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/&gt; &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 测试 public class MyTest { @Test public void test(){ ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\"); UserService userService = (UserService) context.getBean(\"userService\"); userService.search(); } } Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 . Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . 第二种方式 自定义类来实现Aop目标业务类不变依旧是userServiceImpl 第一步 : 写我们自己的一个切入类 public class DiyPointcut { public void before(){ System.out.println(\"---------方法执行前---------\"); } public void after(){ System.out.println(\"---------方法执行后---------\"); } } 去spring中配置 &lt;!--第二种方式自定义实现--&gt; &lt;!--注册bean--&gt; &lt;bean id=\"diy\" class=\"com.kuang.config.DiyPointcut\"/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--第二种方式：使用AOP的标签实现--&gt; &lt;aop:aspect ref=\"diy\"&gt; &lt;aop:pointcut id=\"diyPonitcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/&gt; &lt;aop:before pointcut-ref=\"diyPonitcut\" method=\"before\"/&gt; &lt;aop:after pointcut-ref=\"diyPonitcut\" method=\"after\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试： public class MyTest { @Test public void test(){ ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\"); UserService userService = (UserService) context.getBean(\"userService\"); userService.add(); } } 第三种方式 使用注解实现第一步：编写一个注解实现的增强类 package com.kuang.config; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; @Aspect public class AnnotationPointcut { @Before(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void before(){ System.out.println(\"---------方法执行前---------\"); } @After(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void after(){ System.out.println(\"---------方法执行后---------\"); } @Around(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void around(ProceedingJoinPoint jp) throws Throwable { System.out.println(\"环绕前\"); //获取方法名 System.out.println(\"签名:\"+jp.getSignature()); //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(\"环绕后\"); System.out.println(proceed); } @AfterThrowing(value = \"execution(* com.xu.Service.*.*(..))\", throwing = \"exception\") public void afterThrowing(JoinPoint joinPoint, Exception exception){ //获取方法名 String name = joinPoint.getSignature().getName(); System.out.println(name+\"方法抛出异常：\"+exception); } @AfterReturning(value = \"execution(* com.xu.Service.*.*(..))\",returning = \"result\") public void afterReturning(JoinPoint joinPoint,Object result) { //获取方法名 String name = joinPoint.getSignature().getName(); System.out.println(name+\"方法的结果是\"+result); } } 第二步：在Spring配置文件中，注册bean，并增加支持注解的配置 &lt;!--第三种方式:注解实现--&gt; &lt;bean id=\"annotationPointcut\" class=\"com.kuang.config.AnnotationPointcut\"/&gt; &lt;!-- 开启注解支持，自动代理 --&gt; &lt;aop:aspectj-autoproxy/&gt; aop:aspectj-autoproxy：说明 通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 &lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy poxy-target-class=\"true\"/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 整合MyBatis步骤1、导入相关jar包 junit &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; mybatis &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; mysql-connector-java &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; spring相关 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; aspectJ AOP 织入器 &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; mybatis-spring整合包 【重点】 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; 配置Maven静态资源过滤问题！ &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 2、编写配置文件 3、代码实现 回忆MyBatis编写pojo实体类 package com.kuang.pojo; public class User { private int id; //id private String name; //姓名 private String pwd; //密码 } 实现mybatis的配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.kuang.pojo\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=\"com.kuang.dao\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; UserDao接口编写 public interface UserMapper { public List&lt;User&gt; selectUser(); } 接口对应的Mapper映射文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.kuang.dao.UserMapper\"&gt; &lt;select id=\"selectUser\" resultType=\"User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 测试类 @Test public void selectUser() throws IOException { String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.selectUser(); for (User user: userList){ System.out.println(user); } sqlSession.close(); } MyBatis-Spring学习什么是 MyBatis-Spring？ MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。 知识基础 在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要 MyBatis-Spring 需要以下版本： MyBatis-Spring MyBatis Spring 框架 Spring Batch Java 2.0 3.5+ 5.0+ 4.0+ Java 8+ 1.3 3.4+ 3.2.2+ 2.1+ Java 6+ 如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可： &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; 要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。 DataSource 的 bean 配置 &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"admin\"/&gt; &lt;/bean&gt; 在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中： &lt;!--配置 sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!-- 绑定Mybatis配置文件--&gt; &lt;property name=\"configLocation\" value=\"Mybatis.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/xu/Mapper/UserMapper.xml\"/&gt; &lt;!-- mybatis的配置文件可以全部在这里配置，mybatis的配置文件可以不写，但是一般留着mybatis配置文件来配置别名和设置（&lt; settings&gt; 和 &lt; typeAliases&gt;元素）--&gt; &lt;/bean&gt; 注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。 在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。 在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。 SqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。 一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt; settings&gt; 或 &lt; typeAliases&gt;元素。 需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（），数据源（）和 MyBatis 的事务管理器（）都会被忽略，Spring 的配置文件里会用 bean 配好。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。 SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。 模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。 可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。 &lt;!-- sqlSession 的 bean--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; 现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样： public class UserDaoImpl implements UserDao { private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) { this.sqlSession = sqlSession; } public User getUser(String userId) { return sqlSession.getMapper...; } } 按下面这样，注入 SqlSessionTemplate： &lt;bean id=\"userDao\" class=\"com.xu.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\" /&gt; &lt;/bean&gt; 整合实现一1、引入Spring配置文件beans.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; 2、配置数据源替换mybaits的数据源 &lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt; &lt;bean id=\"dataSource\"class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/bean&gt; 3、配置SqlSessionFactory，关联MyBatis &lt;!--配置SqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--关联Mybatis--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/kuang/dao/*.xml\"/&gt; &lt;/bean&gt; 4、注册sqlSessionTemplate，关联sqlSessionFactory； &lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!--利用构造器注入--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; 5、增加Dao接口的实现类；私有化sqlSessionTemplate public class UserDaoImpl implements UserMapper { //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) { this.sqlSession = sqlSession; } public List&lt;User&gt; selectUser() { UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); } } 6、注册bean实现 &lt;bean id=\"userDao\" class=\"com.kuang.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\"/&gt; &lt;/bean&gt; 7、测试 @Test public void test2(){ ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\"); UserMapper mapper = (UserMapper) context.getBean(\"userDao\"); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user); } 结果成功输出！现在我们的Mybatis配置文件的内容一般就剩下 和！ &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.kuang.pojo\"/&gt; &lt;/typeAliases&gt; &lt;!-- 还有settings 设置--&gt; &lt;/configuration&gt; 整合实现二**mybatis-spring1.2.3版以上的才有这个 ** dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看 测试： 1、将我们上面写的UserDaoImpl修改一下 public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper { public List&lt;User&gt; selectUser() { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.selectUser(); } } 2、修改bean的配置 &lt;bean id=\"userDao\" class=\"com.kuang.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; 3、测试 @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); // 这里注意不是bean的类型，而是mapper接口的类型 UserMapper mapper = (UserMapper) context.getBean(\"userDao\"); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user); } ==注意：上面获取的bean的类型是mapper接口的类型== 总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习SpringBoot的时候还会测试整合！ 声明式事务 回顾事务 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。 事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。 事务四个属性ACID 原子性（atomicity） 事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（consistency） 一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 隔离性（isolation） 可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏 持久性（durability） 事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中 测试 将上面的代码拷贝到一个新项目中 在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户； //添加一个用户 int addUser(User user); //根据id删除用户 int deleteUser(int id); mapper文件，我们故意把 deletes 写错，测试！ &lt;insert id=\"addUser\" parameterType=\"com.kuang.pojo.User\"&gt; insert into user (id,name,pwd) values (#{id},#{name},#{pwd}) &lt;/insert&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; deletes from user where id = #{id} &lt;/delete&gt; 编写接口的实现类，在实现类中，我们去操作一波 public class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper { //一个函数包含多个事务 public List&lt;User&gt; selectUser() { User user = new User(4,\"小明\",\"123456\"); UserMapper mapper = getSqlSession().getMapper(UserMapper.class); //增加一些操作 mapper.addUser(user); mapper.deleteUser(4); return mapper.selectUser(); } //新增 public int addUser(User user) { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.addUser(user); } //删除 public int deleteUser(int id) { UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.deleteUser(id); } } 测试 @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserMapper mapper = (UserMapper) context.getBean(\"userDao\"); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user); } 报错：sql异常，delete写错了 结果 ：插入成功！ 没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要事务！ 以前我们都需要自己手动管理事务，十分麻烦！但是Spring给我们提供了事务管理，我们只需要配置即可； Spring中的事务管理 Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。 编程式事务管理 将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 声明式事务管理 一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。 使用Spring管理事务，注意头文件的约束导入 : tx xmlns:tx=\"http://www.springframework.org/schema/tx\" http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; 事务管理器 无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。 JDBC事务 &lt;bean id=\"transactionManager\"class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; 配置好事务管理器后我们需要去配置事务的通知 &lt;!--配置事务通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"search*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"get\" read-only=\"true\"/&gt; &lt;!--配置所有方法--&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; spring事务传播特性： 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为： propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。 假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。 就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！ 配置AOP 导入aop的头文件！ &lt;!--配置aop织入事务--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.kuang.dao.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/&gt; &lt;/aop:config&gt; 进行测试 删掉刚才插入的数据，再次测试！ @Test public void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserMapper mapper = (UserMapper) context.getBean(\"userDao\"); List&lt;User&gt; user = mapper.selectUser(); System.out.println(user); } 思考问题？ 为什么需要配置事务？ 如果不配置，就需要我们手动提交控制事务； 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！","categories":[],"tags":[]},{"title":"","slug":"MyBatis-Plus笔记","date":"2021-09-14T08:22:35.287Z","updated":"2021-09-14T08:22:35.520Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"1、MyBatisPlus概述为什么要学习它呢？MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成！ JPA 、 tk-mapper、MyBatisPlus 1.1、简介是什么？ MyBatis 本来就是简化 JDBC 操作的！ 官网：https://mp.baomidou.com/ MyBatis Plus，简化 MyBatis ！ 1.2、特性无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作， BaseMapper 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分CRUD 操作，更有强大的条件构造器，满足各类使用需求, 以后简单的CRUD操作，它不用自己编写了！ 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（自动帮你生成代码） 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 1.3、快速入门地址：https://mp.baomidou.com/guide/quick-start.html 使用第三方组件： 导入对应的依赖 研究依赖如何配置 代码如何编写 提高扩展技术能力！ 1.4、步骤1、创建数据库 mybatis_plus 2、创建user表 DROP TABLE IF EXISTS user; CREATE TABLE user ( id BIGINT(20) NOT NULL COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); INSERT INTO user (id, name, age, email) VALUES (1, 'Jone', 18, 'test1@baomidou.com'), (2, 'Jack', 20, 'test2@baomidou.com'), (3, 'Tom', 28, 'test3@baomidou.com'), (4, 'Sandy', 21, 'test4@baomidou.com'), (5, 'Billie', 24, 'test5@baomidou.com'); -- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified 3、编写项目，初始化项目！使用SpringBoot初始化！ 4、导入依赖 &lt;!-- 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;!-- mybatis-plus 是自己开发，并非官方的！ --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; 说明：我们使用 mybatis-plus 可以节省我们大量的代码，尽量不要同时导入 mybatis 和 mybatis plus！版本的差异！ 5、连接数据库！这一步和 mybatis 相同！ # mysql 5 驱动不同 com.mysql.jdbc.Driver # mysql 8 驱动不同com.mysql.cj.jdbc.Driver、需要增加时区的配置 serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=981204 spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 6、传统方式pojo-dao（连接mybatis，配置mapper.xml文件）-service-controller 6、使用了mybatis-plus 之后 pojo @Data @AllArgsConstructor @NoArgsConstructor public class User { //对应数据库中的主键(uuid、自塘id、 雪花算法、redis、 zookeeper! ) private Long id; private String name; private Integer age; private String email; } mapper // 在对应的Mapper上面继承基本的类 BaseMapper @Repository // 代表持久层 public interface UserMapper extends BaseMapper&lt;User&gt; {//泛型类型代表pojo类 // 所有的CRUD操作都已经编写完成了 // 你不需要像以前的配置一大堆文件了！ } 注意点，我们需要在主启动类上去扫描我们的mapper包下的所有接口 @MapperScan(\"com.kuang.mapper\") 7、测试类中测试 @SpringBootTest class MybatisPlusApplicationTests { // 继承了BaseMapper，所有的方法都来自己父类 // 我们也可以编写自己的扩展方法！ @Autowired private UserMapper userMapper; @Test void contextLoads() { // 参数是一个 Wrapper ，条件构造器，这里我们先不用 null // 查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); } } 8、结果 1.5、思考问题？1、SQL谁帮我们写的 ? MyBatis-Plus 都写好了 2、方法哪里来的？ MyBatis-Plus 都写好了 2、配置日志我们所有的sql现在是不可见的，我们希望知道它是怎么执行的，所以我们必须要看日志！ #配置日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 配置完毕日志之后，后面的学习就需要注意这个自动生成的SQL，你们就会喜欢上 MyBatis-Plus！ 3、CRUD扩展3.1、插入操作 Insert 插入 // 测试插入 @Test public void testInsert() { User user = new User(); user.setName(\"狂神说Java\"); user.setAge(3); user.setEmail(\"24736743@qq.com\"); int result = userMapper.insert(user);// 帮我们自动生成id System.out.println(result);// 受影响的行数 System.out.println(user); // 发现，id会自动回填 } 数据库插入的id的默认值为：全局的唯一id 3.2、主键生成策略 默认 ID_WORKER 全局唯一id 分布式系统唯一id生成：https://www.cnblogs.com/haoxinyue/p/5208136.html 雪花算法：(mybatis使用的id生成默认是雪花算法) snowflflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！ 主键自增 我们需要配置主键自增： 1、实体类id字段上 @TableId(type = IdType.AUTO) 2、数据库字段一定要是自增！ 3、再次测试插入即可！ 其余的源码解释 public enum IdType { AUTO(0), // 数据库id自增 NONE(1), // 未设置主键 INPUT(2), // 手动输入 ID_WORKER(3), // 默认的全局唯一id （注意看源码，有些版本默认是none，如果表设置了主键，就得自己设值，否则会出现异常，第一次插入是0，第二次抛出异常） UUID(4), // 全局唯一id uuid ID_WORKER_STR(5); //ID_WORKER 字符串表示法 } 3.3、更新操作// 测试更新 @Test public void testUpdate() { User user = new User(); //通过条件自动拼接动态sql user.setId(6L); user.setName(\"关注公众号：狂神说\"); /*user.setAge(18);*/ //注意：updateById 但是参数是一个 对象！ int i = userMapper.updateById(user); System.out.println(i); } 所有的sql都是自动帮你动态配置的！ 自动填充 创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！ 阿里巴巴开发手册：所有的数据库表：gmt_create(数据创建时间)、gmt_modifified（数据修改时间）几乎所有的表都要配置上！而且需要自动化！ 方式一：数据库级别（工作中不允许你修改数据库） 1、在表中新增字段 create_time, update_time 2、再次测试插入方法，我们需要先把实体类同步！ private Date createTime; private Date updateTime; 3、再次更新查看结果即可 方式二：代码级别 1、删除数据库的默认值、更新操作！ 2、实体类字段属性上需要增加注解 // 字段添加填充内容 @TableField(fill = FieldFill.INSERT) private Date createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private Date updateTime; 3、编写处理器来处理这个注解即可！ package com.kuang.handle; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import lombok.extern.slf4j.Slf4j; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.util.Date; @Slf4j @Component // 一定不要忘记把处理器加到IOC容器中！ public class MyMetaObjectHandler implements MetaObjectHandler { // 插入时的填充策略 @Override public void insertFill(MetaObject metaObject) { log.info(\"start insert fill.....\"); // setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject this.setFieldValByName(\"createTime\", new Date(), metaObject); this.setFieldValByName(\"updateTime\", new Date(), metaObject); } // 更新时的填充策略 @Override public void updateFill(MetaObject metaObject) { log.info(\"start update fill.....\"); this.setFieldValByName(\"updateTime\", new Date(), metaObject); } } 4、测试插入 5、测试更新、观察时间即可！ 3.4、乐观锁在面试过程中，我们经常会被问道乐观锁，悲观锁！这个其实非常简单！ 乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试 悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！ 我们这里主要讲解 乐观锁机制！ 乐观锁实现方式： 取出记录时，获取当前 version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 乐观锁：1、先查询，获得版本号 version = 1 -- A update user set name = \"kuangshen\", version = version + 1 where id = 2 and version = 1 -- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！ update user set name = \"kuangshen\", version = version + 1 where id = 2 and version = 1 测试一下Mybatis-Plus的乐观锁插件 1、给数据库中增加version字段！ 2、我们实体类加对应的字段 @Version //乐观锁Version注解 private Integer version; 3、注册组件 // 扫描我们的 mapper 文件夹 @MapperScan(\"com.kuang.mapper\") @EnableTransactionManagement @Configuration // 配置类 public class MyBatisPlusConfig { // 注册乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() { return new OptimisticLockerInterceptor(); } } 4、测试一下！ // 测试乐观锁成功！ @Test public void testOptimisticLocker() { // 1、查询用户信息 User user = userMapper.selectById(1L); // 2、修改用户信息 user.setName(\"小樱\"); user.setEmail(\"24736743@qq.com\"); // 3、执行更新操作 userMapper.updateById(user); } // 测试乐观锁失败！多线程下 @Test public void testOptimisticLocker2() { // 线程 1 User user = userMapper.selectById(1L); user.setName(\"kuangshen111\"); user.setEmail(\"24736743@qq.com\"); // 模拟另外一个线程执行了插队操作 User user2 = userMapper.selectById(1L); user2.setName(\"kuangshen222\"); user2.setEmail(\"24736743@qq.com\"); userMapper.updateById(user2); // 自旋锁来多次尝试提交！ userMapper.updateById(user); // 如果没有乐观锁就会覆盖插队线程的值！ } 3.5、查询操作// 测试查询 @Test public void testSelectById() { User user = userMapper.selectById(1L); System.out.println(user); } // 测试批量查询！ @Test public void testSelectByBatchId() { List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3)); users.forEach(System.out::println); } // 按条件查询之一使用map操作 @Test public void testSelectByBatchIds() { HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 自定义要查询 map.put(\"name\", \"狂神说Java\"); map.put(\"age\", 3); List&lt;User&gt; users = userMapper.selectByMap(map); users.forEach(System.out::println); } 3.6、分页查询分页在网站使用的十分之多！ 1、原始的 limit 进行分页2、pageHelper 第三方插件3、MyBatisPlus 其实也内置了分页插件！ 如何使用！ 1、配置拦截器组件即可 // 分页插件 @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); } 2、直接使用Page对象即可！ // 测试分页查询 @Test public void testPage(){ // 参数一：当前页 // 参数二：页面大小 // 使用了分页插件之后，所有的分页操作也变得简单的！ Page&lt;User&gt; page = new Page&lt;&gt;(2,5); userMapper.selectPage(page,null); page.getRecords().forEach(System.out::println); System.out.println(page.getTotal());//获取表的所有数据行数 } 3.7、删除操作1、根据 id 删除记录 // 测试删除 @Test public void testDeleteById() { userMapper.deleteById(1259423899561529348L); } // 通过id批量删除 @Test public void testDeleteBatchId() { userMapper.deleteBatchIds(Arrays.asList(1259423899561529345l, 1259423899561529346l)); } // 通过map删除 @Test public void testDeleteMap() { HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"狂神说Java\"); userMapper.deleteByMap(map); } 我们在工组中会遇到一些问题：逻辑删除！ 3.8、逻辑删除 物理删除 ：从数据库中直接移除 逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ deleted = 0 =&gt; deleted = 1 管理员可以查看被删除的记录！防止数据的丢失，类似于回收站！ 测试一下： 1、在数据表中增加一个 deleted 字段 2、实体类中增加属性@TableLogic //逻辑删除 private Integer deleted; 3、配置！MyBatisPlusConfig.java // 逻辑删除组件！ @Bean public ISqlInjector sqlInjector() { return new LogicSqlInjector(); } application.properties # 配置逻辑删除 mybatis-plus.global-config.db-config.logic-delete-value=1 mybatis-plus.global-config.db-config.logic-not-delete-value=0 4、测试一下删除！// 测试查询 @Test public void testSelectById() { User user = userMapper.selectById(1L); System.out.println(user); } 记录依旧在数据库，但是值确已经变化了！ 以上的所有CRUD操作及其扩展操作，我们都必须精通掌握！会大大提高你的工作和写项目的效率！ 3.9、性能分析插件我们在平时的开发中，会遇到一些慢sql。测试！ druid,,,,, 作用：性能分析拦截器，用于输出每条 SQL 语句及其执行时间 MP也提供性能分析插件，如果超过这个时间就停止运行！ 1、导入插件/** * SQL执行效率插件 */ @Bean @Profile({\"dev\", \"test\"})// 设置 dev test 环境开启，保证我们的效率 public PerformanceInterceptor performanceInterceptor() { PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100); // ms设置sql执行的最大时间，如果超过了则不 执行 performanceInterceptor.setFormat(true); // 是否格式化代码 return performanceInterceptor; } 记住，要在SpringBoot中配置环境为dev或者 test 环境！ 2、测试使用！@Test void contextLoads() { // 参数是一个 Wrapper ，条件构造器，这里我们先不用 null // 查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); } 使用性能分析插件，可以帮助我们提高效率！ 3.10、条件构造器十分重要：Wrapper wapper介绍 Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 ​ QueryWrapper ： Entity 对象封装操作类，不是用lambda语法 ​ UpdateWrapper ： Update 条件封装，用于Entity对象更新操作 AbstractLambdaWrapper ： Lambda 语法使用 Wrapper统一处理解析 lambda 获取 column。 ​ LambdaQueryWrapper ：看名称也能明白就是用于Lambda语法使用的查询Wrapper ​ LambdaUpdateWrapper ： Lambda 更新封装Wrapper 我们写一些复杂的sql就可以使用它来替代！ 1、测试一，记住查看输出的SQL进行分析 @Test void test1() { // 查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.isNotNull(\"name\").isNotNull(\"email\").ge(\"age\", 12); userMapper.selectList(wrapper).forEach(System.out::println); // 和我们刚才学习 的map对比一下 } 2、测试二，记住查看输出的SQL进行分析 @Test void test2() { // 查询名字狂神说 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(\"name\", \"狂神说\"); User user = userMapper.selectOne(wrapper); // 查询一个数据，出现多个结果使用List 或者 Map System.out.println(user); } 3、测试三，记住查看输出的SQL进行分析 @Test void test3() { // 查询年龄在 20 ~ 30 岁之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.between(\"age\", 20, 30); // 区间 Integer count = userMapper.selectCount(wrapper);// 查询结果数 System.out.println(count); } 4、测试四，记住查看输出的SQL进行分析 // 模糊查询 @Test void test4() { // 查询年龄在 20 ~ 30 岁之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 左和右 t% wrapper.notLike(\"name\", \"e\").likeRight(\"email\", \"t\"); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper); maps.forEach(System.out::println); } 5、测试五，记住查看输出的SQL进行分析 // 模糊查询 @Test void test5() { QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // id 在子查询中查出来 // inSql(\"id\", \"select id from table where id &lt; 3\")---&gt;id in (select id from table where id &lt; 3) wrapper.inSql(\"id\", \"select id from user where id&lt;3\"); List&lt;Object&gt; objects = userMapper.selectObjs(wrapper); objects.forEach(System.out::println); } 6、测试六，记住查看输出的SQL进行分析 //测试六 @Test void test6() { QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 通过id进行排序 wrapper.orderByAsc(\"id\");//升序 wrapper.orderByDesc(\"id\");//降序 List&lt;User&gt; users = userMapper.selectList(wrapper); users.forEach(System.out::println); } 7、or、and 注意：这里使用的是 UpdateWrapper 不调用or则默认为使用 and 连 @Test public void testUpdate1() { //修改值 User user = new User(); user.setAge(99); user.setName(\"Andy\"); //修改条件 UpdateWrapper&lt;User&gt; userUpdateWrapper = new UpdateWrapper&lt;&gt;(); userUpdateWrapper .like(\"name\", \"h\") .or() .between(\"age\", 20, 30); int result = userMapper.update(user, userUpdateWrapper); System.out.println(result); } UPDATE user SET name=?, age=?, update_time=? WHERE deleted=0 AND name LIKE ? OR age BETWEEN ? AND ? 8、嵌套or、嵌套and 这里使用了lambda表达式，or中的表达式最后翻译成sql时会被加上圆括号 @Test public void testUpdate2() { //修改值 User user = new User(); user.setAge(99); user.setName(\"Andy\"); //修改条件 UpdateWrapper&lt;User&gt; userUpdateWrapper = new UpdateWrapper&lt;&gt;(); userUpdateWrapper .like(\"name\", \"h\") .or(i -&gt; i.eq(\"name\", \"李白\").ne(\"age\", 20)); int result = userMapper.update(user, userUpdateWrapper); System.out.println(result); } UPDATE user SET name=?, age=?, update_time=? WHERE deleted=0 AND name LIKE ? OR ( name = ? AND age &lt;&gt; ? ) 3.11、代码自动生成器dao、pojo、service、controller都给我自己去编写完成！ AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。 测试 public class KuangCode { public static void main(String[] args) { // 需要构建一个 代码自动生成器 对象 AutoGenerator mpg = new AutoGenerator(); // 配置策略 // 1、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\");//获取用户目录 gc.setOutputDir(projectPath + \"/src/main/java\");//项目输出路径 gc.setAuthor(\"狂神说\"); gc.setOpen(false);//是否打开资源管理器 gc.setFileOverride(false);// 是否覆盖原来生成的 gc.setServiceName(\"%sService\");//通过正则表达式去Service的I前缀（服务名字） gc.setIdType(IdType.ID_WORKER);//生成策略，默认初始算法 gc.setDateType(DateType.ONLY_DATE);//设置日期类型，仅仅只是时间 gc.setSwagger2(true);//自动配置Swagger文档 mpg.setGlobalConfig(gc);//全局配置放到自动生成器 //2、设置数据源 DataSourceConfig dsc = new DataSourceConfig(); //jdbc:oracle:thin:@localhost:1521:orcl /*dsc.setUrl(\"jdbc:oracle:thin:@192.168.7.26:1521:testgkdb\"); dsc.setDriverName(\"oracle.jdbc.driver.OracleDriver\"); dsc.setUsername(\"FASP2020\"); dsc.setPassword(\"FASP2020\"); dsc.setDbType(DbType.ORACLE);*/ dsc.setUrl(\"jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"981204\"); dsc.setDbType(DbType.MYSQL);//设置数据库类型 mpg.setDataSource(dsc);//数据源放到自动生成器 //3、包的配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(\"blog\");//设置包名 pc.setParent(\"com.kuang\");//放在哪个包下 pc.setEntity(\"entity\");//要自动生成的 pc.setMapper(\"mapper\"); pc.setService(\"service\"); pc.setController(\"controller\"); mpg.setPackageInfo(pc);//数据源放到自动生成器 //4、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(\"user\"); // 设置要映射的表名 strategy.setNaming(NamingStrategy.underline_to_camel);//表名转驼峰 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//字段名转驼峰 strategy.setEntityLombokModel(true);//自动生成使用lombok strategy.setLogicDeleteFieldName(\"deleted\");//逻辑删除字段自动配置 // 自动填充配置 TableFill gmtCreate = new TableFill(\"gmt_create\", FieldFill.INSERT);//自动创建时间执行insert操作 TableFill gmtModified = new TableFill(\"gmt_modified\", FieldFill.INSERT_UPDATE);//自动修改时间执行insert操作 ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills);// 自动填充配置到策略中 // 乐观锁 strategy.setVersionFieldName(\"version\"); strategy.setRestControllerStyle(true);//开启Restful的驼峰命名 strategy.setControllerMappingHyphenStyle(true);// localhost:8080/hello_id_2 //Controlle的的链接请求设置 mpg.setStrategy(strategy); mpg.execute(); //执行 } } 效果 4、使用Oracle数据库的代码自动生成器1、&lt;!--连接Oracle数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--客户端全球化--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.easyproject&lt;/groupId&gt; &lt;artifactId&gt;orai18n&lt;/artifactId&gt; &lt;version&gt;12.1.0.2.0&lt;/version&gt; &lt;/dependency&gt; 2、spring.datasource.url=jdbc\\:oracle\\:thin\\:@192.168.7.26\\:1521\\:testgkdb spring.datasource.username=FASP2020 spring.datasource.password=FASP2020 spring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriver 3、public class KuangCode { public static void main(String[] args) { // 需要构建一个 代码自动生成器 对象 AutoGenerator mpg = new AutoGenerator(); // 配置策略 // 1、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\"); gc.setAuthor(\"狂神说\"); gc.setOpen(false); gc.setFileOverride(false);// 是否覆盖 gc.setServiceName(\"%sService\");// 去Service的I前缀 gc.setIdType(IdType.ID_WORKER); gc.setDateType(DateType.ONLY_DATE); /* gc.setSwagger2(true);*/ mpg.setGlobalConfig(gc); //2、设置数据源 DataSourceConfig dsc = new DataSourceConfig(); //jdbc:oracle:thin:@localhost:1521:orcl dsc.setUrl(\"jdbc:oracle:thin:@192.168.7.26:1521:testgkdb\"); dsc.setDriverName(\"oracle.jdbc.driver.OracleDriver\"); dsc.setUsername(\"FASP2020\"); dsc.setPassword(\"FASP2020\"); dsc.setDbType(DbType.ORACLE); mpg.setDataSource(dsc); //3、包的配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(\"blog\"); pc.setParent(\"com.kuang\"); pc.setEntity(\"entity\"); pc.setMapper(\"mapper\"); pc.setService(\"service\"); pc.setController(\"controller\"); mpg.setPackageInfo(pc); //4、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(\"GLB_BAL\"); // 设置要映射的表名 strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); /*strategy.setEntityLombokModel(true);*/ // 自动lombok； strategy.setLogicDeleteFieldName(\"deleted\"); // 自动填充配置 TableFill gmtCreate = new TableFill(\"gmt_create\", FieldFill.INSERT); TableFill gmtModified = new TableFill(\"gmt_modified\", FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills); // 乐观锁 strategy.setVersionFieldName(\"version\"); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true);// localhost:8080/hello_id_2 mpg.setStrategy(strategy); mpg.execute(); //执行 } }","categories":[],"tags":[]},{"title":"","slug":"MyBatis笔记","date":"2021-09-14T08:22:35.221Z","updated":"2021-09-14T08:22:35.518Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"MyBatis半自动化 ORM 框架: Object Relationship Mapping 对象关系映射 对象指面向对象 关系指关系型数据库 Java 到 MySQL 的映射，开发者可以以面向对象的思想来管理数据库。 什么是MyBatis MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects 普通老式的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目 ibatis, 2010年这个项目由 apache 迁移到了 google code，并且改名为 MyBatis 。 2013年11月迁移到 Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3 持久化 持久化是将程序数据在持久状态和瞬时状态间转换的机制。 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。 为什么需要持久化服务呢？那是由于内存本身的缺陷引起的 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。 持久层 什么是持久层？ 完成持久化工作的代码块 . —-&gt; dao层 【DAO (Data Access Object) 数据访问对象】 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】 核心配置文件 mybatis-config.xml 系统核心配置文件 MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 能配置的内容如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） &lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt; 我们可以阅读 mybatis-config.xml 上面的dtd的头文件查看元素节点顺序！ environments元素&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${driver}\"/&gt; &lt;property name=\"url\" value=\"${url}\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定） 具体的一套环境，通过设置id进行区别，id保证唯一！ 子元素节点：environment dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 数据源是必须配置的。 有三种内建的数据源类型 type=\"[UNPOOLED|POOLED|JNDI]\" UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 JNDI：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等…. 两种事务管理器类型，这两种事务管理器类型都不需要设置任何属性。 子元素节点：transactionManager - [ 事务管理器 ] &lt;!-- 语法 --&gt; &lt;transactionManager type=\"[ JDBC | MANAGED ]\"/&gt; 子元素节点：数据源（dataSource） mappers元素mappers 映射器 : 定义映射SQL语句文件 既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。 引入资源方式 &lt;!-- 使用相对于类路径的资源引用 --&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/builder/PostMapper.xml\"/&gt; &lt;/mappers&gt; &lt;!-- 使用完全限定资源定位符（URL） --&gt; &lt;mappers&gt; &lt;mapper url=\"file:///var/mappers/AuthorMapper.xml\"/&gt; &lt;/mappers&gt; &lt;!-- 使用映射器接口的完全限定类名 需要配置文件名称和接口名称一致，并且位于同一目录下 --&gt; &lt;mappers&gt; &lt;mapper class=\"org.mybatis.builder.AuthorMapper\"/&gt; &lt;!-- 不能这样写，用* 会出错--&gt; &lt;mapper class=\"org.mybatis.builder.*\"/&gt; &lt;/mappers&gt; &lt;!-- 将包内的映射器接口全部注册为映射器 但是需要配置文件名称和接口名称一致，并且位于同一目录下 --&gt; &lt;mappers&gt; &lt;package name=\"org.mybatis.builder\"/&gt; &lt;/mappers&gt; Mapper文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.kuang.mapper.UserMapper\"&gt; &lt;select&gt;&lt;/select&gt; &lt;/mapper&gt; namespace中文意思：命名空间，作用如下： namespace的命名必须跟某个接口同名 接口中的方法与映射文件中 sql 语句 id 应该一一对应 namespace 和子元素的 id 联合保证唯一 , 区别不同的 mapper 绑定DAO接口 namespace命名规则 : 包名+类名 MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。 Properties优化数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。 第一步 ; 在资源目录下新建一个db.properties driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis? useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8 username=root password=123456 第二步 : 将文件导入properties 配置文件 &lt;configuration&gt; &lt;!--导入properties文件--&gt; &lt;properties resource=\"db.properties\"&gt; &lt;!-- 优先读取properties文件，properties文件里有的属性，即使property标签下面写 了也只读取properties文件的属性（无论properties文件里属性值是否正确都不会 读取property标签），下面写了相当于没写 --&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/properties&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${driver}\"/&gt; &lt;property name=\"url\" value=\"${url}\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 配置文件优先级问题 如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载： 首先读取在 properties 元素体内指定的属性。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。 最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。可以在 SqlSessionFactoryBuilder.build() 方法中传入属性值，例如： SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props); 通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。 新特性：使用占位符 从 MyBatis 3.4.2 开始，你可以为占位符指定一个默认值。例如： &lt;dataSource type=\"POOLED\"&gt; &lt;!-- ... --&gt; &lt;property name=\"username\" value=\"${username:ut_user}\"/&gt; &lt;!-- 如果属性 'username' 没有被配置，'username' 属性的值将为 'ut_user' --&gt; &lt;/dataSource&gt; 这个特性默认是关闭的。要启用这个特性，需要添加一个特定的属性来开启这个特性。例如： &lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;!-- ... --&gt; &lt;property name=\"org.apache.ibatis.parsing.PropertyParser.enable-default-value\" value=\"true\"/&gt; &lt;!-- 启用默认值特性 --&gt; &lt;/properties&gt; typeAliases优化类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。 &lt;!--配置别名,注意顺序--&gt; &lt;typeAliases&gt; &lt;typeAlias type=\"com.kuang.pojo.User\" alias=\"User\"/&gt; &lt;/typeAliases&gt; 当这样配置时，**User可以用在任何使用com.kuang.pojo.User的地方。** 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如: &lt;typeAliases&gt; &lt;package name=\"com.kuang.pojo\"/&gt; &lt;/typeAliases&gt; 每一个在包 com.kuang.pojo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。（即包下的实体类 类名首字母小写作为别名），例如：user 可以用在任何使用 com.kuang.pojo.User 的地方 若有注解，则别名为其注解值。见下面的例子： @Alias(\"user\") public class User { ... } 其他配置浏览设置 设置（settings）相关 =&gt; 查看帮助文档 懒加载 日志实现 缓存开启关闭 一个配置完整的 settings 元素的示例如下： &lt;settings&gt; &lt;!-- 开启缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 是否允许单个语句返回多结果集（需要数据库驱动支持） --&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;!-- 使用列标签代替列名 --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;!--允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。 --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;!-- 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt; &lt;/settings&gt; 类型处理器 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】 对象工厂 MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】 如何使用1，新建 Maven 工程，pom.xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--解决Maven静态资源过滤问题，寻找配置资源文件--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/resources&gt; &lt;/build&gt; 2，新建数据表 use mybatis; create table t_account( id int primary key auto_increment, username varchar(11), password varchar(11), age int )ENGINE=InnoDB DEFAULT CHARSET=UTF8; 3，新建数据表对应的实体类 Account package com.southwind.entity; import lombok.Data; @Data public class Account { private long id; private String username; private String password; private int age; } 4，在 resources 创建 MyBatis 的配置文件 config.xml，文件名可自定义 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!--下面这两行代码需要自己导入--&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!-- 配置MyBatis运行环境 --&gt; &lt;environments default=\"development\"&gt; &lt;!--这里的environments的default值为要选用的数据库源id--&gt; &lt;environment id=\"development\"&gt;&lt;!--environment标签可用多个，即数据源可以有多个--&gt; &lt;!-- 配置JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- POOLED配置JDBC数据源连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"&gt; &lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis? serverTimezone=GMT&amp;amp;useUnicode=true&amp;amp; characterEncoding=utf-8&amp;amp;useSSL=false\"&gt; &lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 使用原生接口1、MyBatis 框架需要开发者自定义 SQL 语句，写在 Mapper.xml 文件中，实际开发中，会为每个实体类创建对应的 Mapper.xml ，定义管理该对象数据的 SQL。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!--下面这两行代码需要自己导入--&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.mapper.AccoutMapper\"&gt; &lt;insert id=\"save\" parameterType=\"com.southwind.entity.Account\"&gt; insert into t_account(username,password,age) values(#{username}, #{password},#{age}) &lt;!--这里的#{username}，#{password}，#{age}对应Account类的属性， 因为传过来的参数是Account--&gt; &lt;/insert&gt; &lt;/mapper&gt; namespace 通常设置为文件所在包+文件名的形式。 insert 标签表示执行添加操作。 select 标签表示执行查询操作。 update 标签表示执行更新操作。 delete 标签表示执行删除操作。 id 是实际调用实体类接口方法名。 parameterType 是调用对应方法时参数的数据类型。 2、在全局配置文件 config.xml 中注册 AccountMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!--下面这两行代码需要自己导入--&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!-- 配置MyBatis运行环境 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 配置JDBC事务管理 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- POOLED配置JDBC数据源连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"&gt; &lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis? serverTimezone=GMT&amp;amp;useUnicode=true&amp;amp; characterEncoding=utf-8&amp;amp;useSSL=false\"&gt; &lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 注册AccountMapper.xml --&gt; &lt;mappers&gt; &lt;mapper resource=\"com/southwind/mapper/AccountMapper.xml\"&gt;&lt;/mapper&gt; &lt;/mappers&gt; &lt;/configuration&gt; 3、调用 MyBatis 的原生接口执行添加操作。 public class Test { public static void main(String[] args) { //加载MyBatis配置文件 InputStream inputStream = Test.class.getClassLoader().getResourceAsStream(\"config.xml\"); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); /* String resource = \"org/mybatis/example/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); */ SqlSession sqlSession = sqlSessionFactory.openSession(); String statement = \"com.southwind.mapper.AccoutMapper.save\"; Account account = new Account(1L,\"张三\",\"123123\",22); sqlSession.insert(statement,account); sqlSession.commit();//对数据进行修改添加的操作就需要commit sqlSession.close(); } } SqlSessionFactoryBuilder 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。 SqlSessionFactory SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession 每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式： try (SqlSession session = sqlSessionFactory.openSession()) { // 你的应用逻辑代码 } 在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。 ==sqlSession.commit(); //对数据进行修改添加的操作就需要commit，如果只进行查询就不用== 通过 Mapper 代理实现自定义接口自定义接口，定义相关业务方法。 编写与方法相对应的 Mapper.xml。 1、自定义接口 package com.southwind.repository; import com.southwind.entity.Account; import java.util.List; public interface AccountRepository { public int save(Account account); public int update(Account account); public int deleteById(long id); public List&lt;Account&gt; findAll(); public Account findById(long id); } 2、创建接口对应的 Mapper.xml，定义接口方法对应的 SQL 语句。 statement 标签可根据 SQL 执行的业务选择 insert、delete、update、select。 MyBatis 框架会根据规定自动创建接口实现类的代理对象。 规则： Mapper.xml 中 namespace 为接口的全类名。 Mapper.xml 中 statement 的 id 为接口中对应的方法名。 Mapper.xml 中 statement 的 parameterType 和接口中对应方法的参数类型一致。 Mapper.xml 中 statement 的 resultType 和接口中对应方法的返回值类型一致。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!--下面这两行代码需要自己导入--&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.repository.AccountRepository\"&gt; &lt;insert id=\"save\" parameterType=\"com.southwind.entity.Account\"&gt; &lt;!--增删改操作不用指定resultType，默认是int类型，因为数据库执行成功返回的是行号--&gt; insert into t_account(username,password,age) values(#{username},# {password},#{age}) &lt;/insert&gt; &lt;update id=\"update\" parameterType=\"com.southwind.entity.Account\"&gt; update t_account set username = #{username},password = #{password},age = #{age} where id = #{id} &lt;/update&gt; &lt;delete id=\"deleteById\" parameterType=\"long\"&gt; delete from t_account where id = #{id} &lt;/delete&gt; &lt;select id=\"findAll\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account &lt;/select&gt; &lt;select id=\"findById\" parameterType=\"long\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where id = #{id} &lt;/select&gt; &lt;/mapper&gt; ==增删改操作不用指定resultType，默认是int类型，因为数据库执行成功返回的是行号== 3、在 config.xml 中注册 AccountRepository.xml &lt;!-- 注册AccountMapper.xml --&gt; &lt;mappers&gt; &lt;mapper resource=\"com/southwind/mapper/AccountMapper.xml\"&gt;&lt;/mapper&gt; &lt;mapper resource=\"com/southwind/repository/AccountRepository.xml\"&gt;&lt;/mapper&gt; &lt;/mappers&gt; 4、调用接口的代理对象完成相关的业务操作 package com.southwind.test; import com.southwind.entity.Account; import com.southwind.repository.AccountRepository; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.InputStream; import java.util.List; public class Test2 { public static void main(String[] args) { InputStream inputStream = Test.class.getClassLoader().getResourceAsStream(\"config.xml\"); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获取实现接口的代理对象 AccountRepository accountRepository = sqlSession.getMapper(AccountRepository.class); //添加对象 // Account account = new Account(3L,\"王五\",\"111111\",24); // int result = accountRepository.save(account); // sqlSession.commit(); //查询全部对象 // List&lt;Account&gt; list = accountRepository.findAll(); // for (Account account:list){ // System.out.println(account); // } // sqlSession.close(); //通过id查询对象 // Account account = accountRepository.findById(3L); // System.out.println(account); // sqlSession.close(); //修改对象 // Account account = accountRepository.findById(3L); // account.setUsername(\"小明\"); // account.setPassword(\"000\"); // account.setAge(18); 这样子account的id还是3L，所以修改的是id为3L的数据，如果写上 account.setId(10l);数据库里面没有的id会无法修改 也可以通过new一个Account来修改，但new来的Account的id必须设置成 数据库有的 // int result = accountRepository.update(account); // sqlSession.commit(); // System.out.println(result); // sqlSession.close(); //通过id删除对象 int result = accountRepository.deleteById(3L); System.out.println(result); sqlSession.commit(); sqlSession.close(); } } Mapper.xml statement 标签：select、update、delete、insert 分别对应查询、修改、删除、添加操作。 parameterType：参数数据类型 1、基本数据类型，通过 id 查询 Account &lt;select id=\"findById\" parameterType=\"long\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where id = #{id} &lt;/select&gt; 2、String 类型，通过 name 查询 Account &lt;select id=\"findByName\" parameterType=\"java.lang.String\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where username = #{username} &lt;/select&gt; 3、包装类，通过 id 查询 Account &lt;select id=\"findById2\" parameterType=\"java.lang.Long\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where id = #{id} &lt;/select&gt; 4、多个参数，通过 name 和 age 查询 Account &lt;select id=\"findByNameAndAge\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where username = #{arg0} and age = #{arg1} &lt;!-- 或者 select * from t_account where username = #{param1} and age = #{param2} --&gt; &lt;/select&gt; 5、Java Bean &lt;update id=\"update\" parameterType=\"com.southwind.entity.Account\"&gt; update t_account set username = #{username},password = #{password}, age =#{age} where id = #{id} &lt;/update&gt; resultType：结果类型 1、基本数据类型，统计 Account 总数 &lt;select id=\"count\" resultType=\"int\"&gt; select count(id) from t_account &lt;/select&gt; 2、包装类，统计 Account 总数 &lt;select id=\"count2\" resultType=\"java.lang.Integer\"&gt; select count(id) from t_account &lt;/select&gt; 3、String 类型，通过 id 查询 Account 的 name &lt;select id=\"findNameById\" resultType=\"java.lang.String\"&gt; select username from t_account where id = #{id} &lt;/select&gt; 4、Java Bean &lt;select id=\"findById\" parameterType=\"long\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where id = #{id} &lt;/select&gt; 课堂练习：根据 密码 和 名字 查询用户 思路一：直接在方法中传递参数 1、在接口方法的参数前加 @Param属性 //通过密码和名字查询用户 User selectUserByNP(@Param(\"username\") String username,@Param(\"pwd\") Stringpwd); /* 或者这样 User FindbyNP3( String name, String p); */ 2、Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型 &lt;select id=\"selectUserByNP\" resultType=\"com.kuang.pojo.User\"&gt; select * from user where name = #{username} and pwd = #{pwd} &lt;/select&gt; &lt;!-- 对应上面 User FindbyNP3( String name, String p); &lt;select id=\"FindbyNP3\" resultType=\"com.kuangshen.entity.User\"&gt; select * from user where name=#{param1} and pwd=#{param2}; &lt;/select&gt; --&gt; 3、使用方法 mapper.selectUserByNP(\"李四\", \"111\") 思路二：使用万能的Map 1、在接口方法中，参数直接传递Map； User selectUserByNP2(Map&lt;String,Object&gt; map); 2、编写sql语句的时候，需要传递参数类型，参数类型为map &lt;select id=\"selectUserByNP2\" parameterType=\"map\" resultType=\"com.kuang.pojo.User\"&gt; &lt;!-- parameterType=\"map\" 可写可不写--&gt; select * from user where name = #{username} and pwd = #{pwd} &lt;!-- username 对应 map 的 key ，pwd一样--&gt; &lt;/select&gt; 3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！ Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"username\",\"小明\"); map.put(\"pwd\",\"123456\"); User user = mapper.selectUserByNP2(map); 总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可 模糊查询like语句该怎么写? 第1种：在Java代码中添加sql通配符。 string wildcardname = “%smi%”; list&lt;name&gt; names = mapper.selectlike(wildcardname); &lt;select id=”selectlike” resultType=\"com.kuangshen.entity.User\"&gt; select * from foo where bar like #{value} &lt;/select&gt; 第2种：在sql语句中拼接通配符，会引起sql注入 (不推荐) string wildcardname = “smi”; list&lt;name&gt; names = mapper.selectlike(wildcardname); &lt;select id=”selectlike” resultType=\"com.kuangshen.entity.User\"&gt; select * from foo where bar like \"%\"#{value}\"%\" &lt;/select&gt; ResultMap 查询为null问题 要解决的问题：属性名和字段名不一致 1、查看之前的数据库的字段名 user（id，name，pwd） 2、Java中的实体类设计 public class User { private int id; //id private String name; //姓名 private String password; //密码和数据库的密码字段名不一样！ } 3、接口 //根据id查询用户 User selectUserById(int id); 4、mapper映射文件 &lt;select id=\"selectUserById\" resultType=\"user\"&gt; select * from user where id = #{id} &lt;/select&gt; 5、测试 @Test public void testSelectUserById() { SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接 UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } 结果: User{id=1, name=’狂神’, password=’null’} 查询出来发现 password 为空 . 说明出现了问题！ 分析： select * from user where id = #{id} 可以看做 select id,name,pwd from user where id = #{id} mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的get方法取值 , 由于找不到getPwd() , 所以password返回null ; 【自动映射】 解决方案 方案一：为列名指定别名 , 别名和java实体类的属性名一致 . &lt;select id=\"selectUserById\" resultType=\"User\"&gt; select id , name , pwd as password from user where id = #{id} &lt;/select&gt; 方案二：使用结果集映射-&gt;ResultMap 【推荐】 &lt;resultMap id=\"UserMap\" type=\"User\"&gt; &lt;!-- id为主键 --&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;!-- column 是数据库表的列名 , property 是对应实体类的属性名 --&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;!-- 一般只写不同名字段，同名字段写了也没用，所以上面 id 和 name 都可以不写 --&gt; &lt;result column=\"pwd\" property=\"password\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectUserById\" resultMap=\"UserMap\"&gt; select id , name , pwd from user where id = #{id} &lt;/select&gt; ResultMap 自动映射 resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来。 实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的长达数千行的代码。 ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。 你已经见过简单映射语句的示例了，但并没有显式指定 resultMap。比如： &lt;select id=\"selectUserById\" resultType=\"map\"&gt; select id , name , pwd from user where id = #{id} &lt;/select&gt; 上述语句只是简单地将所有的列映射到 HashMap 的键上，这由 resultType 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。 ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。 手动映射 1、返回值类型为resultMap &lt;select id=\"selectUserById\" resultMap=\"UserMap\"&gt; select id , name , pwd from user where id = #{id} &lt;/select&gt; 2、编写resultMap，实现手动映射！ &lt;resultMap id=\"UserMap\" type=\"User\"&gt; &lt;!-- id为主键 --&gt; &lt;id column=\"id\" property=\"user_id\"/&gt; &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt; &lt;result column=\"name\" property=\"user_name\"/&gt; &lt;result column=\"pwd\" property=\"user_password\"/&gt; &lt;/resultMap&gt; 如果世界总是这么简单就好了。但是肯定不是的，数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些。 日志工厂思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？ 如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。 对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。 Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具： SLF4J Apache Commons Logging Log4j 2 Log4j JDK logging 具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。 标准日志实现 指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。 &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;/settings&gt; 测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug Log4j简介： Log4j是Apache的一个开源项目 通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件…. 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 使用步骤： 1、导入log4j的包 &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 2、log4j.properties 配置文件编写 (放在 resources 下) #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/xu.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 3、setting设置日志实现 &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;/settings&gt; 4、在程序中使用Log4j进行输出！ //注意导包：org.apache.log4j.Logger static Logger logger = Logger.getLogger(MyTest.class); @Test public void selectUser() { logger.info(\"info：进入selectUser方法\"); logger.debug(\"debug：进入selectUser方法\"); logger.error(\"error: 进入selectUser方法\"); SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users){ System.out.println(user); } session.close(); } 5、测试，看控制台输出！ 使用Log4j 输出日志 可以看到还生成了一个日志的文件 【需要修改 file 的日志级别】 limit实现分页思考：为什么需要分页？ 在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。 使用Limit实现分页 #语法 SELECT * FROM table LIMIT stratIndex，pageSize SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 #为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： #以前支持，现在已经作为bug被修复 SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. #如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; //检索前 5 个记录行 #换句话说，LIMIT n 等价于 LIMIT 0,n。 步骤： 1、修改Mapper文件 &lt;select id=\"selectUser\" parameterType=\"map\" resultType=\"user\"&gt; select * from user limit #{startIndex},#{pageSize} &lt;/select&gt; 2、Mapper接口，参数为map //选择全部用户实现分页 List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map); 3、在测试类中传入参数测试 推断：起始位置 = （当前页面 - 1 ） * 页面大小 //分页查询 , 两个参数startIndex , pageSize @Test public void testSelectUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int currentPage = 1; //第几页 int pageSize = 2; //每页显示几个 Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(\"startIndex\",(currentPage-1)*pageSize); map.put(\"pageSize\",pageSize); List&lt;User&gt; users = mapper.selectUser(map); for (User user: users){ System.out.println(user); } session.close(); } RowBounds分页 我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！ 步骤： 1、mapper接口 //选择全部用户RowBounds实现分页 List&lt;User&gt; getUserByRowBounds(); 2、mapper文件 &lt;select id=\"getUserByRowBounds\" resultType=\"user\"&gt; select * from user &lt;/select&gt; 3、测试类 在这里，我们需要使用RowBounds类 @Test public void testUserByRowBounds() { SqlSession session = MybatisUtils.getSession(); int currentPage = 2; //第几页 int pageSize = 2; //每页显示几个 RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize); //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了] List&lt;User&gt; users =session.selectList(\"com.kuang.mapper.UserMapper.getUserByRowBounds\", null,rowBounds); for (User user: users){ System.out.println(user); } session.close(); } PageHelper 分页插件，了解即可 使用注解开发 面向接口编程 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了； 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 接口的本身反映了系统设计人员对系统的抽象理解。 接口应有两类： 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）； 一个个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向区别 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 . 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 . 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构 利用注解开发 mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射（级联查询）并不能用注解来构建 sql 类型主要分成 : @select () @update () @Insert () @delete () 注意：利用注解开发就不需要mapper.xml映射文件了 . 1、我们在我们的接口中添加注解 //查询全部用户 @Select(\"select id,name,pwd password from user\") public List&lt;User&gt; getAllUser(); 2、在mybatis的核心配置文件中注入 &lt;!--使用class绑定接口--&gt; &lt;mappers&gt; &lt;mapper class=\"com.kuang.mapper.UserMapper\"/&gt; &lt;/mappers&gt; 3、我们去进行测试 @Test public void testGetAllUser() { SqlSession session = MybatisUtils.getSession(); //本质上利用了jvm的动态代理机制 UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.getAllUser(); for (User user : users){ System.out.println(user); } session.close(); } 4、利用Debug查看本质 5、本质上利用了jvm的动态代理机制 6、Mybatis详细的执行流程 注解增删改 改造MybatisUtils工具类的getSession( ) 方法，重载实现。 //获取SqlSession连接 public static SqlSession getSession(){ return getSession(true); //事务自动提交 } public static SqlSession getSession(boolean flag){ return sqlSessionFactory.openSession(flag); } 【注意】确保实体类和数据库字段对应，不对应的话无法查阅对应字段信息 查询： 1、编写接口方法注解 //根据id查询用户 @Select(\"select * from user where id = #{id}\") User selectUserById(@Param(\"id\") int id); 2、测试 @Test public void testSelectUserById() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close(); } 新增： 1、编写接口方法注解 //添加一个用户 @Insert(\"insert into user (id,name,pwd) values (#{id},#{name},#{pwd})\") int addUser(User user); 2、测试 @Test public void testAddUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, \"秦疆\", \"123456\"); mapper.addUser(user); session.close(); } 修改： 1、编写接口方法注解 //修改一个用户 @Update(\"update user set name=#{name},pwd=#{pwd} where id = #{id}\") int updateUser(User user); 2、测试 @Test public void testUpdateUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, \"秦疆\", \"zxcvbn\"); mapper.updateUser(user); session.close(); } 删除： 1、编写接口方法注解 //根据id删除用 @Delete(\"delete from user where id = #{id}\") int deleteUser(@Param(\"id\")int id); 2、测试 @Test public void testDeleteUser() { SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); mapper.deleteUser(6); session.close(); } 【注意点：增删改一定记得对事务的处理】 关于@Param @Param注解用于给方法参数起一个名字。以下是总结的使用原则： 在方法只接受一个参数的情况下，可以不使用@Param。 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 不使用@Param注解时，参数只能有一个，并且是Javabean。 #与$的区别 #{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符?，很大程度上防止 SQL注入 【推荐使用】 INSERT INTO user (name) VALUES (#{name}); INSERT INTO user (name) VALUES (?); ${} 的作用是直接进行字符串替换，无法防止 SQL 注入 INSERT INTO user (name) VALUES ('${name}'); INSERT INTO user (name) VALUES ('kuangshen'); 使用注解和配置文件协同开发，才是MyBatis的最佳实践！ 级联查询一对多Student package com.southwind.entity; import lombok.Data; @Data public class Student { private long id; private String name; private Classes classes; //一个学生对应一个班级 } Classes package com.southwind.entity; import lombok.Data; import java.util.List; @Data public class Classes { private long id; private String name; private List&lt;Student&gt; students; //一个班级对应多个学生 } StudentRepository package com.southwind.repository; import com.southwind.entity.Student; public interface StudentRepository { public Student findById(long id); } StudentRepository.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.repository.StudentRepository\"&gt; &lt;!--将整个studentMap返回--&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"studentMap\"&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes c where s.id = #{id} and s.cid = c.id &lt;!--c.id as cid,c.name as cname这里修改字段名称是为了与前面student的 s.id和s.name做区分，因为查表出来显示的四个字段名称为“id，name，id， name”，方便操作--&gt; &lt;/select&gt; &lt;resultMap id=\"studentMap\" type=\"com.southwind.entity.Student\"&gt; &lt;!--主键使用id标签，其他字段属性用result标签--&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;!-- column 对应数据库字段，property 对应实体类属性--&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;!--这里对应classes类--&gt; &lt;association property=\"classes\" javaType=\"com.southwind.entity.Classes\"&gt; &lt;!--这里因为 c.id as cid ，所以 column 为 cid--&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;/mapper&gt; ==：对象是类就用这个标签，里面的类型定义是javaType属性定义== ==：对象是集合就用这个标签，里面的类型定义是ofType属性定义== 测试 StudentRepository studentRepository = sqlSession.getMapper(StudentRepository.class); System.out.println(studentRepository.findByIdLazy(2)); ClassesRepository package com.southwind.repository; import com.southwind.entity.Classes; public interface ClassesRepository { public Classes findById(long id); } ClassesRepository.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.repository.ClassesRepository\"&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"classesMap\"&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes c where c.id = #{id} and s.cid = c.id &lt;/select&gt; &lt;resultMap id=\"classesMap\" type=\"com.southwind.entity.Classes\"&gt; &lt;!-- column 对应数据库字段，property 对应实体类属性--&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"students\" ofType=\"com.southwind.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;/mapper&gt; 测试 ClassRepository classRepository = sqlSession.getMapper(ClassRepository.class); System.out.println(classRepository.findById(2)); 多对多Customer package com.southwind.entity; import lombok.Data; import java.util.List; @Data public class Customer { private long id; private String name; private List&lt;Goods&gt; goods; //顾客对应多种货物 } Goods package com.southwind.entity; import lombok.Data; import java.util.List; @Data public class Goods { private long id; private String name; private List&lt;Customer&gt; customers; //货物对应多个用户 } CustomerRepository package com.southwind.repository; import com.southwind.entity.Customer; public interface CustomerRepository { public Customer findById(long id); } CustomerRepository.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.repository.CustomerRepository\"&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"customerMap\"&gt; select c.id cid,c.name cname,g.id gid,g.name gname from customer c, goods g,customer_goods cg where c.id = #{id} and cg.cid = c.id and cg.gid = g.id &lt;/select&gt; &lt;resultMap id=\"customerMap\" type=\"com.southwind.entity.Customer\"&gt; &lt;!-- column 对应数据库字段，property 对应实体类属性--&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"goods\" ofType=\"com.southwind.entity.Goods\"&gt; &lt;id column=\"gid\" property=\"id\"/&gt; &lt;result column=\"gname\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;/mapper&gt; 测试 CustomerRepository customerRepository = sqlSession.getMapper(CustomerRepository.class); System.out.println(customerRepository.findById(2l)); GoodsRepository package com.southwind.repository; import com.southwind.entity.Goods; public interface GoodsRepository { public Goods findById(long id); } GoodsRepository.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.southwind.repository.GoodsRepository\"&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"goodsMap\"&gt; select c.id cid,c.name cname,g.id gid,g.name gname from customer c, goods g,customer_goods cg where g.id = #{id} and cg.cid = c.id and cg.gid = g.id &lt;/select&gt; &lt;resultMap id=\"goodsMap\" type=\"com.southwind.entity.Goods\"&gt; &lt;!-- column 对应数据库字段，property 对应实体类属性--&gt; &lt;id column=\"gid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"gname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"customers\" ofType=\"com.southwind.entity.Customer\"&gt; &lt;id column=\"cid\" property=\"id\"/&gt; &lt;result column=\"cname\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;/mapper&gt; 测试 GoodsRepository goodsRepository = sqlSession.getMapper(GoodsRepository.class); System.out.println(goodsRepository.findById(2)); 逆向工程MyBatis 框架需要：实体类、自定义 Mapper 接口、Mapper.xml 传统的开发中上述的三个组件需要开发者手动创建，逆向工程可以帮助开发者来自动创建三个组件，减轻开发者的工作量，提高工作效率。 如何使用MyBatis Generator，简称 MBG，是一个专门为 MyBatis 框架开发者定制的代码生成器，可自动生成MyBatis 框架所需的实体类、Mapper 接口、Mapper.xml，支持基本的 CRUD 操作，但是一些相对复杂的 SQL 需要开发者自己来完成。 1，新建 Maven 工程，pom.xml &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2，在 resources 创建 MBG 配置文件 generatorConfig.xml jdbcConnection 配置数据库连接信息。 javaModelGenerator 配置 JavaBean 的生成策略。 sqlMapGenerator 配置 SQL 映射文件生成策略。 javaClientGenerator 配置 Mapper 接口的生成策略。 table 配置目标数据表（tableName：表名，domainObjectName：JavaBean 类名）。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt; &lt;generatorConfiguration&gt; &lt;context id=\"testTables\" targetRuntime=\"MyBatis3\"&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/mybatis? useUnicode=true&amp;characterEncoding=UTF-8\" userId=\"root\" password=\"root\"&gt; &lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage=\"com.southwind.entity\" targetProject=\"./src/main/java\"&gt; &lt;!--./表示当前文件夹，可省略，resources文件夹就是项目的根目录--&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage=\"com.southwind.repository\" targetProject=\"./src/main/java\"&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.southwind.repository\" targetProject=\"./src/main/java\"&gt; &lt;/javaClientGenerator&gt; &lt;table tableName=\"t_user\" domainObjectName=\"User\"&gt;&lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 3，创建 Generator 执行类。 package com.southwind.test; import org.mybatis.generator.api.MyBatisGenerator; import org.mybatis.generator.config.Configuration; import org.mybatis.generator.config.xml.ConfigurationParser; import org.mybatis.generator.exception.InvalidConfigurationException; import org.mybatis.generator.exception.XMLParserException; import org.mybatis.generator.internal.DefaultShellCallback; import java.io.File; import java.io.IOException; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args) { List&lt;String&gt; warings = new ArrayList&lt;String&gt;(); boolean overwrite = true; String genCig = \"/generatorConfig.xml\"; File configFile = new File(Main.class.getResource(genCig).getFile()); ConfigurationParser configurationParser = new ConfigurationParser(warings); Configuration configuration = null; try { configuration = configurationParser.parseConfiguration(configFile); } catch (IOException e) { e.printStackTrace(); } catch (XMLParserException e) { e.printStackTrace(); } DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = null; try { myBatisGenerator = new MyBatisGenerator(configuration,callback,warings); } catch (InvalidConfigurationException e) { e.printStackTrace(); } try { myBatisGenerator.generate(null); } catch (SQLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } } } MyBatis 延迟加载什么是延迟加载？ 延迟加载也叫懒加载、惰性加载，使用延迟加载可以提高程序的运行效率，针对于数据持久层的操作，在某些特定的情况下去访问特定的数据库，在其他情况下可以不访问某些表，从一定程度上减少了 Java应用与数据库的交互次数。 查询学生和班级时，学生和班级是两张不同的表，如果当前需求只需要获取学生的信息，那么查询学生单表即可，如果需要通过学生获取对应的班级信息，则必须查询两张表。 不同的业务需求，需要查询不同的表，根据具体的业务需求来动态减少数据表查询的动作就是延迟加载。 1,在 config.xml 中开启延迟加载 &lt;settings&gt; &lt;!-- 打印SQL--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;/settings&gt; 2,将多表关联查询拆分成多个单表查询 StudentRepository public Student findByIdLazy(long id); ClassesRepository public Classes findByIdLazy(long id); ClassesRepository.xml &lt;select id=\"findByIdLazy\" parameterType=\"long\" resultType=\"com.southwind.entity.Classes\"&gt; select * from classes where id = #{id} &lt;/select&gt; StudentRepository.xml &lt;resultMap id=\"studentMapLazy\" type=\"com.southwind.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;association property=\"classes\" javaType=\"com.southwind.entity.Classes\" select=\"com.southwind.repository.ClassesRepository.findByIdLazy\" column=\"cid\"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"findByIdLazy\" parameterType=\"long\" resultMap=\"studentMapLazy\"&gt; select * from student where id = #{id} &lt;/select&gt; 3，运行测试 test.java StudentRepository studentRepository = sqlSession.getMapper(StudentRepository.class); Student student = studentRepository.findByIdLazy(2); System.out.println(student.getName()); 日志 ==&gt; Preparing: select * from student where id=? ==&gt; Parameters: 2(Long) &lt;== Columns: id, name, cid &lt;== Row: 2, 张三, 2 &lt;== Total: 1 张三 ==只查询一次，不会去查询班级表== 获取学生班级时，才会查询两次 System.out.println(student.getClasses()); 日志 ==&gt; Preparing: select * from student where id=? ==&gt; Parameters: 2(Long) &lt;== Columns: id, name, cid &lt;== Row: 2, 张三, 2 &lt;== Total: 1 ==&gt; Preparing: select * from class where id=?; ==&gt; Parameters: 2(Long) &lt;== Columns: id, name &lt;== Row: 2, 二年级 &lt;== Total: 1 Classes(id=2, name=二年级, students=null) MyBatis 缓存 缓存简介 1、什么是缓存 [ Cache ]？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 2、为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 3、什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。 什么是 MyBatis 缓存 使用缓存可以减少 Java 应用与数据库的交互次数，从而提升程序的运行效率。比如查询出 id = 1 的对象，第一次查询出之后会自动将该对象保存到缓存中，当下一次查询时，直接从缓存中取出对象即可，无需再次访问数据库。 MyBatis 缓存分类 1、一级缓存：SqlSession 级别，也称为本地缓存，默认开启，并且不能关闭。 操作数据库时需要创建 SqlSession 对象，在对象中有一个 HashMap 用于存储缓存数据，不同的 SqlSession 之间缓存数据区域是互不影响的。 一级缓存的作用域是 SqlSession 范围的，当在同一个 SqlSession 中执行两次相同的 SQL 语句时，第一次执行完毕会将结果保存到缓存中，第二次查询时直接从缓存中获取。 需要注意的是，如果 SqlSession 执行了 DML 操作（insert、update、delete）（即使操作的不是同一条数据），MyBatis 必须将缓存清空以保证数据的准确性。 2、二级缓存：也叫全局缓存，Mapper 级别，默认关闭，可以开启。 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 使二级级缓存时，多个 SqlSession 使用同一个 Mapper 的 SQL 语句操作数据库，得到的数据会存在二级缓存区，同样是使用 HashMap 进行数据存储，相比较于一级缓存，二级缓存的范围更广，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 二级缓存是多个 SqlSession 共享的，其作用域是 Mapper 的同一个 namespace，不同的 SqlSession两次执行相同的 namespace 下的 SQL 语句，参数也相等，则第一次执行成功之后会将数据保存到二级缓存中，第二次可直接从二级缓存中取出数据。 3、自定义二级缓存：为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 缓存原理图 sqlsession 先从二级缓存开始查询有无缓存，如果没有二级缓存再查看有无一级缓存，没有一级缓存的话就只能连接数据库进行查询 代码 一级缓存package com.southwind.test; import com.southwind.entity.Account; import com.southwind.repository.AccountRepository; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream; public class Test4 { public static void main(String[] args) { InputStream inputStream = Test.class.getClassLoader().getResourceAsStream(\"config.xml\"); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); AccountRepository accountRepository = sqlSession.getMapper(AccountRepository.class); Account account = accountRepository.findById(1L); System.out.println(account); // Account account1 = accountRepository.findById(1L); // System.out.println(account1); // 上面这样写就只执行一次SQL查询,sqlSession的一级缓存 sqlSession.close(); // 一级缓存会被清空 sqlSession = sqlSessionFactory.openSession(); accountRepository = sqlSession.getMapper(AccountRepository.class); Account account1 = accountRepository.findById(1L); //执行第二次查询 System.out.println(account1); } } 二级缓存1、MyBatis 自带的二级缓存 config.xml 配置开启二级缓存 &lt;settings&gt; &lt;!-- 打印SQL--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 开启二级缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt; Mapper.xml 中配置二级缓存 &lt;!-- 一般这样写就行，但这样写因为没有缓存处理策略，所以实体类得实现序列化接口--&gt; &lt;cache&gt;&lt;/cache&gt; &lt;!-- 这样写可以进行参数设置 --&gt; &lt;cache eviction=\"FIFO\" #缓存处理方式 flushInterval=\"60000\" #刷新时间 size=\"512\" #缓存数目大小 readOnly=\"true\"/&gt; #只读 这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 实体类实现序列化接口 package com.southwind.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor;import java.io.Serializable; @Data @AllArgsConstructor @NoArgsConstructor public class Account implements Serializable { private long id; private String username; private String password; private int age; } 测试代码 package com.southwind.test; import com.southwind.entity.Account; import com.southwind.repository.AccountRepository; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream; public class Test4 { public static void main(String[] args) { InputStream inputStream = Test.class.getClassLoader().getResourceAsStream(\"config.xml\"); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); AccountRepository accountRepository = sqlSession.getMapper(AccountRepository.class); Account account = accountRepository.findById(1L); System.out.println(account); sqlSession.close(); // 一级缓存会被清空，二级缓存还在 sqlSession = sqlSessionFactory.openSession(); accountRepository = sqlSession.getMapper(AccountRepository.class); Account account1 = accountRepository.findById(1L); System.out.println(account1); } } 结论 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中 2、第三方 ehcache 二级缓存 pom.xml 添加相关依赖 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt; &lt;/dependency&gt; 在 resources 中添加 ehcache.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\" updateCheck=\"false\"&gt; &lt;!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --&gt; &lt;diskStore path=\"./tmpdir/Tmp_EhCache\"/&gt; &lt;defaultCache eternal=\"false\" maxElementsInMemory=\"10000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"259200\" memoryStoreEvictionPolicy=\"LRU\"/&gt; &lt;cache name=\"cloud_user\" eternal=\"false\" maxElementsInMemory=\"5000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" memoryStoreEvictionPolicy=\"LRU\"/&gt; &lt;!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统崩了时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 --&gt; &lt;/ehcache&gt; config.xml 配置开启二级缓存 &lt;settings&gt; &lt;!-- 打印SQL--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 开启二级缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt; Mapper.xml 中配置二级缓存 &lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt; &lt;!-- 下面这些 property 标签可不写 --&gt; &lt;!-- 缓存创建之后，最后一次访问缓存的时间到缓存失效的时间间隔，以秒为单位 --&gt; &lt;property name=\"timeToIdleSeconds\" value=\"3600\"/&gt; &lt;!-- 缓存自创建时间起到失效的时间间隔 --&gt; &lt;property name=\"timeToLiveSeconds\" value=\"3600\"/&gt; &lt;!-- 缓存回收策略，LRU表示移除近期使用最少的对象 --&gt; &lt;property name=\"memoryStoreEvictionPolicy\" value=\"LRU\"/&gt; &lt;/cache&gt; 实体类不需要实现序列化接口 package com.southwind.entity; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class Account { private long id; private String username; private String password; private int age; } MyBatis 动态 SQL动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句。使用动态 SQL 可简化代码的开发，减少开发者的工作量，程序可以自动根据业务参数来决定 SQL 的组成。 AccountRepository . java public Account findByAccount(Account account); if 标签&lt;select id=\"findByAccount\" parameterType=\"com.southwind.entity.Account\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account where &lt;if test=\"id!=0\"&gt; id = #{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username = #{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password = #{password} &lt;/if&gt; &lt;if test=\"age!=0\"&gt; and age = #{age} &lt;/if&gt; &lt;/select&gt; if 标签可以自动根据表达式的结果来决定是否将对应的语句添加到 SQL 中，如果条件不成立则不添加，如果条件成立则添加。==（但是id必须设置，id不设置会查不出或者出异常）== 因为没有设置id，查询语句会变成 ==select * from t_account where and username = #{username}== 测试 Account account = new Account(); account.setId(1l);//必须设置 account.setUsername(\"张三\"); System.out.println(accountRepository.findByAccount(account)); where 标签&lt;select id=\"findByAccount\" parameterType=\"com.southwind.entity.Account\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account &lt;where&gt; &lt;if test=\"id!=0\"&gt; id = #{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username = #{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password = #{password} &lt;/if&gt; &lt;if test=\"age!=0\"&gt; and age = #{age} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; where 标签可以自动判断是否要删除语句块中的 and 或者 or 关键字，如果检测到 where 直接跟 and 或者 or 拼接，则自动删除 and 或者 or，通常情况下 if 和 where 结合起来使用。 测试 Account account = new Account(); // account.setId(1l); 不用必须设置id了 account.setUsername(\"张三\"); // account.setAge(22); account.setPassword(\"123123\"); System.out.println(accountRepository.findByAccount(account)); choose 、when 标签&lt;select id=\"findByAccount\" parameterType=\"com.southwind.entity.Account\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account &lt;where&gt; &lt;if test=\"id!=0\"&gt; id=#{id} &lt;/if&gt; &lt;choose&gt; &lt;when test=\"username!=null\"&gt; and username=#{username} &lt;/when&gt; &lt;when test=\"password!=null\"&gt; and password=#{password} &lt;/when&gt; &lt;when test=\"age!=0\"&gt; and age=#{age} &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; choose相当于switch ， when相当于case ， otherwise相当于default，这样子的话choose标签就只能一个字段判断，多的其他字段不会进行判断，只会选择第一个满足的语句块拼接，即使后面的语句块也满足判断条件 测试 Account account = new Account(); account.setId(5l); account.setUsername(\"王五\"); account.setAge(100); System.out.println(accountRepository.findByAccount(account)); 日志 ==&gt; Preparing: select * from t_account WHERE id=? and username=? ==&gt; Parameters: 5(Long), 王五(String) ==年龄 age 没有进行判断== trim 标签trim 标签中的 prefix 和 suffix 属性会被用于生成实际的 SQL 语句，会和标签内部的语句进行拼接，如果语句前后出现了 prefixOverrides 或者 suffixOverrides 属性中指定的值，MyBatis 框架会自动将其删除。 &lt;select id=\"findByAccount\" parameterType=\"com.southwind.entity.Account\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account &lt;trim prefix=\"where\" prefixOverrides=\"and|or\"&gt; &lt;if test=\"id!=0\"&gt; id = #{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username = #{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password = #{password} &lt;/if&gt; &lt;if test=\"age!=0\"&gt; and age = #{age} &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; set 标签set 标签用于 update 操作，会自动根据参数选择生成 SQL 语句，==生成的SQL只写需要修改的字段==。set 标签会自动去除多余的 “，”。 &lt;update id=\"update\" parameterType=\"com.southwind.entity.Account\"&gt; update t_account &lt;set&gt; &lt;if test=\"username!=null\"&gt; username = #{username}, &lt;/if&gt; &lt;if test=\"password!=null\"&gt; password = #{password}, &lt;/if&gt; &lt;if test=\"age!=0\"&gt; age = #{age} &lt;/if&gt; &lt;/set&gt; where id = #{id} &lt;/update&gt; 测试 Account account = new Account(); account.setId(5l); account.setUsername(\"666\"); account.setAge(100); 日志 ==&gt; Preparing: update t_account SET username=?, age=? where id=?; ==&gt; Parameters: 666(String), 100(Integer), 5(Long) foreach 标签foreach 标签可以迭代生成一系列值，这个标签主要用于 SQL 的 in 语句。 Account .java private List&lt;Long&gt; ids; AccountRepository . java public List&lt;Account&gt; findByIds(Account account); AccountRepositoryMapper .xml &lt;select id=\"findByIds\" parameterType=\"com.southwind.entity.Account\" resultType=\"com.southwind.entity.Account\"&gt; select * from t_account &lt;where&gt; &lt;foreach collection=\"ids\" open=\"id in (\" close=\")\" item=\"id\" separator=\",\"&gt; #{id} &lt;!-- 与item相对应 --&gt; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; 测试 Account account = new Account(); List&lt;Long&gt; ids = new ArrayList&lt;Long&gt;(); ids.add(1l); ids.add(2l); ids.add(4l); ids.add(5l); account.setIds(ids); System.out.println(accountRepository.findByIds(account)); 日志 ==&gt; Preparing: select * from t_account WHERE id in ( ? , ? , ? , ? ) ==&gt; Parameters: 1(Long), 2(Long), 4(Long), 5(Long) &lt;== Columns: id, username, password, age &lt;== Row: 1, 张三, 123123, 22 &lt;== Row: 2, 李四, 123123, 25 &lt;== Row: 4, 小明, 12345, 11 &lt;== Row: 5, 王五, 8080, 90 重用SQL片段有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。 提取SQL片段： &lt;sql id=\"if-title-author\"&gt; &lt;if test=\"title != null\"&gt; title = #{title} &lt;/if&gt; &lt;if test=\"author != null\"&gt; and author = #{author} &lt;/if&gt; &lt;/sql&gt; 引用SQL片段： &lt;select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"&gt; select * from blog &lt;where&gt; &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt; &lt;include refid=\"if-title-author\"&gt;&lt;/include&gt; &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt; &lt;/where&gt; &lt;/select&gt; 注意： ①、最好基于单表操作来定义 sql 片段，提高片段的可重用性 ②、在 sql 片段中不要包括 where","categories":[],"tags":[]},{"title":"","slug":"注解与反射","date":"2021-09-14T08:22:09.742Z","updated":"2021-09-14T08:22:10.042Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"注解与反射注解什么是注解？Annotation是从JDK5.0开始引入的新技术，Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。 作用： 不是程序本身，可以对程序作出解释（这一点和注释comment没什么区别） 可以被其他程序（如编译器）读取 Annotation格式： 注解是以“@注释名”在代码重尊在的，还可以添加一些参数值，例如：@SuppressWarnings（value=”unchecked”） Annotation在哪里使用？ 可以附加在package，class，method，filed等上面，相当给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 内置注解 @Override：定义在java.lang.Override中， 此注解只适用于修辞方法，表示一个方法打算重写超类中的另一个方法声明 @Deprecated：定义在java.lang.Deprecated中，此注解可以用于修辞方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为他很危险或者存在更好的选择。标记过时方法。 @SuppressWarnings：定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息，指示编译器去忽略注解中声明的警告。 与前两个不同，需要添加一个参数才能够正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了 @SupressWarnings（“all”） @SupressWarnings(“unchecked”) @SupressWarnings(value = { “unchecked”, “ deprecation”}) 元注解 元注解的作用是负责注解其他注解，Java定义了4个标准的meta-annotation类型，它们被用来提供对其他annotation类型作说明 这些类型和他们所支持的类在java.lang.annotation包中可以找到。（**@Target， **@Retention， @Documented， @Inherited） @Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） @Target 有下面的取值 @Target(ElementType.TYPE) 可以有多个取值 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。一般写runtime 。 它参数的取值如下：**@Retention(RetentionPolicy.RUNTIME)只能有一个取值** RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 （SOURCE &lt; CLASS &lt; RUNTIME） @Documented：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的注解 从 Java 7 开始，额外添加了 3 个注解: @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 自定义注解 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口 分析 @interface用来声明一个注解，格式： public @interface 注解名 {定义内容} 其中的每一个方法实际上是声明了一个配置参数 方法的名称就是参数的名称 返回值类型就是参数的类型（返回值只能是基本类：Class（不是class）, String, enum） 可以通过default来声明参数的默认值 如果只有一个参数成员，一般参数名为value 注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值。 import java.lang.annotation.*; @MyAnnotation public class Test01 { /* * 如果只有一个参数的话，我们如果将参数名设置为value，那么我们在复制的时候 * 可以省略key，直接写value。否则不可以省略key。 * */ @MyAnnotation3(\"wo\") public void test3(){} /* * 注解如果有默认值的话， 那我们可以不进行赋值，也可以进行显式赋值 * 如果没有默认值的话，我们就必须要进行赋值 * */ @MyAnnotation2(woc = 231.2f)//多参数注解 public void test2(){} @MyAnnotation public void test(){} } @Target(value = {ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation3{ /* * 如果只有一个参数的话，我们如果将参数名设置为value，那么我们在复制的时候 * 可以省略key，直接写value。否则不可以省略key。 * */ String value(); } @Target(value = {ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation2{ // 注释的参数 ： 参数类型 + 参数名 (); String name() default \"\";//默认值为空，有默认值就可以不写该参数 int age() default 0; int id() default -1; //如果默认值为 -1， 代表不存在 String[] schools() default {\"清华大学\"}; //数组，可以多个参数，参数类型为string ，如果数组名为value在注解写参数时可以不用 写“value= ” float woc(); } @Target(value = {ElementType.METHOD, ElementType.TYPE}) @Retention(value = RetentionPolicy.RUNTIME) @Documented @Inherited @interface MyAnnotation{ } 反射机制反射概述静态语言 VS 动态语言 动态语言 是一类在运行时，可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。 主要动态语言：Object-C， C#， JavaScript， PHP， Python等 静态语言 与动态语言对应，运行时结构不可变的语言就是静态语言，如C，C++, Java; Java不是动态语言，但Java可以称为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让Java编程的时候更加灵活。 Java获取了一定的动态性，作为代价就失去了一部分的安全性。 Java Reflection Reflection 是Java被视为动态语言的关键，反射机制允许程序在执行期间借助Reflection API取得任何类的内部信息，并且能直接操作任意对象的内部属性及方法。 Class c = Class.forName(\"java.lang.String\"); 记载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构。所以，我们形象的称之为：反射。 Java反射机制研究及应用 Java反射机制提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 生成动态代理 …… 反射优缺点 优点：可以实现动态创建对象和编译，体现出很大的灵活性 缺点：对性能有影响。使用反射基本上是一种解释性操作，我们可以告诉JVM，我们希望做什么并且它会满足我们的需求，这类操作总是慢于直接执行相同的操作。 取得反射对象反射 API Java.lang.Class：代表一个类 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Constructor：代表类的构造器 Class类在Object类中定义了以下方法，此方法被所有的子类继承 public final Class getClass(); 该方法返回值的类型是Class类，此类是Java反射的源头，实际上所谓的反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称 反射对象可以得到的信息 某个类的属性、方法和构造器 某个类到底实现了哪个接口 对于每个类而言，JRE都为其保留了一个不变的Class对象。一个Class对象包含了特定某个结构（class / interface / enum / annotation / primitive type / void / []）的有关信息： Class对象本身也是一个类 Class对象只能由系统建立对象 一个加载的类在JVM中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个Class实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得的相应的Class对象 得到Class类的实例 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高： Class class = Person.class; 已知某个各类的实例，调用该实例的getClass()方法获取Class对象： Class class = person.getClass(); 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName（）获取，可能抛出ClassNotFoundException Class class = Class.forName(\"demo01.Student\"); 内置基本数据类型可以直接用类名.Type 还可以利用 ClassLoader 我们之后讲解。 哪些类可以有Class对象 外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。 interface：接口 []：数组 只要元素类型和维度一样， 就是同一个Class enum：枚举 annotation：注解@interface primitive type：基本数据类型 void 类的加载 当程序主动使用某个类的时候，如果该类还没有被加载到内存中，则系统会通过如下三个步骤对该类进行初始化。 加载：将class字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 验证：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为类变量（static）分配内存并设置类变量默认值的阶段，这些内存都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 初始化： 执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造信息的，不是构造该类对象的构造器）。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发父类的初始化。 虚拟机会保证一个类的()方法在多线程环境中被正确的加锁和同步 public class test3 { public static void main(String[] args) { System.out.println(A.m); // 100 // m=100 如果写在静态代码快上面的话 m就是300； } } class A { //在类文件被加载时，产生Class对象 //在链接时进行代码校验后，把类变量（static）分配内存并设置默认初始值，此时m为0 //接着初始化，不同于创建对象时的初始化，执行类构造器&lt;clinit&gt;()方法的过程， // 该类构造器由执行类变量（static）的赋值和静态代码块中的语句合并产生 //语句按代码顺序执行 static { System.out.println(\"A被初始化\"); m = 300; } static int m = 100; } 类什么时候会发生初始化？public class Test06 { static { System.out.println(\"Main类被加载\"); } public static void main(String[] args) throws ClassNotFoundException { //下面每个部分都会添加一段代码在这个部分进行执行 } } class Father{ static{ System.out.println(\"Father类被加载\"); } static int b = 2; } class Son extends Father{ static { System.out.println(\"Son类被加载\"); } static int m = 100; static final int M = 1; } 类的主动引用（一定会发生类的初始化） 当虚拟机启动，先初始化main方法所在类 主类中的静态代码块就会被执行 //Main类被加载 new一个类的对象 Son son = new Son(); /* Main类被加载 Father类被加载 Son类被加载 */ 调用类的静态成员（除了final常量）和静态方法 System.out.println(Son.m); /* Main类被加载 Father类被加载 Son类被加载 100 */ 使用java.lang.reflect包的方法对类进行反射调用 Class.forName(\"javalearning.reflection.Son\"); /* Main类被加载 Father类被加载 Son类被加载 */ 当初始化一个类，如果其父类没有被初始化，则会先初始化它的父类。 //上述Demo都是在加载子类之前先加载了父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引父类的静态变量，不会导致子类初始化。 System.out.println(Son.b); /* Main类被加载 Father类被加载 2 因为是父类声明了静态变量b，子类只是从父类身上继承了下来，子类并不是声明该字段的类，所以会去找子类的爸爸，和子类没太大关系（子类算是个中介吧） */ 通过数组定义引用，不会触发此类的初始化。 Son[] son = new Son[10]; /* Main类被加载 只是开辟了一个这个类型的空间，并没有用到这个类做任何事情 */ 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） System.out.println(Son.M); /* Main类被加载 1 */ public class test5 { static { System.out.println(\"main 被初始化\"); } public static void main(String[] args) throws ClassNotFoundException { Son son = new Son();//子父类都初始化 Class.forName(\"reflection.Son\");//子父类都初始化 System.out.println(Son.m);//子父类都初始化 System.out.println(Son.f);//初始化父类 Class c = Son.class;//只初始化main System.out.println(Son.s);//只初始化main Son[ ] array = new Son[ 3];//只初始化main } } class Father { static int f =1000; static { System.out.println(\"father 被初始化\"); } } class Son extends Father { static final int s = 100; static int m = 10; static { System.out.println(\"son 被初始化\"); } } 类加载器的作用 类加载的作用：将class文件字节码内容加载到内存中，并将在这些静态数据转换成方法去的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载中，它将维持加载（缓存）一段时间。不过JVM GC机制可以回收这些Class对象 类加载作用是用来把类（class）装载进内存的。JVM规范定义了如下类型的类加载器 引导类加载器（Bootstap Classloader）：用C++编写的，是JVM自带的类加载器，负责Java平台核心库（rt.jar），用来装载核心类库。该加载去无法直接获取 拓展类加载器（Extension Classloader）：负责jre/lib/ext目录下的jar包或 -D java.ext.dirs指定目录下的jar包 装入工作库 系统类加载器（System Classloader / Application Classloader）：负责 java -classpath 或 -D java.class.path所指的目录下的类与jar包装入工作，是最常用的加载器。 双亲委派机制：如果java需要加载一个类，例如java.lang.String ，然鹅你自己也想写一个同名的。他会从低级类加载器到高级类加载器逐渐寻找，如果在高层找到了那个类，那么你手写的同名包就不会被调用。（你不配重写我的类 —-Sun公司） 双亲委派机制 工作原理：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。 好处：Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子类ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。 public class Test07 { public static void main(String[] args) throws ClassNotFoundException { // 获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); // 获取系统类加载器的父类加载器 ---》 拓展类加载器 ClassLoader parent = systemClassLoader.getParent(); System.out.println(parent); // 获取拓展类加载器的父类加载器 ---》 根加载器（C / C++） ClassLoader parent1 = parent.getParent(); System.out.println(parent1); // 查看当前类是哪个加载器加载的 ClassLoader classLoader = Class.forName(\"javalearning.reflection.Test07\").getClassLoader(); System.out.println(classLoader); // 测试JDK内置的类是谁加载的 classLoader = Class.forName(\"java.lang.Object\").getClassLoader(); System.out.println(classLoader); //如何获取系统类加载器可以加载的路径 System.out.println(System.getProperty(\"java.class.path\")); /* * E:\\ProjectFiles\\IJproject\\JavaLearning\\out\\production\\JavaLearning; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.transaction.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.persistence.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.resource.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.ejb.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.servlet.jsp.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.servlet.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.jms.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.annotation.jar; * E:\\ProjectFiles\\IJproject\\JavaLearning\\lib\\javax.servlet.jsp.jstl.jar; * * */ } } /* jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733d jdk.internal.loader.ClassLoaders$PlatformClassLoader@506e1b77 null jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733d null //根加载器我们JVM无法读取， 所以是null */ 创建运行时类的完整结构通过反射获取运行时类的完整结构： Field、Method、Constructor、Superclass、Interface、Annotation 实现的全部结构 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 …… import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; // 获得类的信息 public class Test08 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException { Class c1 = Class.forName(\"javalearning.reflection.User\"); //获得类的名字 System.out.println(c1.getName()); // 包名 + 类名 System.out.println(c1.getSimpleName());// 类名 //获得类的属性 System.out.println(\"===================================\"); Field[] fields = c1.getFields(); //只能获取自身以及父类的公共属性 for (Field field : fields){ System.out.println(field); } System.out.println(\"===================================\"); fields = c1.getDeclaredFields(); //能获取自身所有属性 for (Field field : fields){ System.out.println(field); } //获取指定的属性的值 System.out.println(\"======================================\"); Field name = c1.getDeclaredField(\"name\"); System.out.println(name); System.out.println(\"======================================\"); Method[] methods = c1.getMethods(); //获得本类及其父类的所有public方法 for (Method method : methods){ System.out.println(method); } methods = c1.getDeclaredMethods(); //获得本类的所有方法 for (Method method : methods){ System.out.println(method); } System.out.println(\"======================================\"); // 获取指定的方法 //重载 通过参数类型判断是哪个方法 Method getName = c1.getMethod(\"getName\", null); Method setName = c1.getMethod(\"setName\", String.class); System.out.println(getName); System.out.println(setName); System.out.println(\"======================================\"); //获得构造器 Constructor[] constructors = c1.getConstructors(); // 获得本类和父类public构造方法 for (Constructor constructor : constructors){ System.out.println(constructor); } // 获得本类所有构造方法 constructors = c1.getDeclaredConstructors(); for (Constructor constructor : constructors){ System.out.println(\"#\"+ constructor); } System.out.println(\"指定构造器\" + c1.getDeclaredConstructor(String.class, int.class, int.class)); } } 小结 在实际操作中，取得类的信息的操作代码，并不会经常开发 一定要熟悉java.lang.reflect包的作用，反射机制。 如何取得属性、方法、构造器的名称、修饰符等 有了Class对象之后，能做什么？ 创建类的对象：调用Class对象的newInstance（）方法 类必须有一个无参数的构造器 类的构造器的访问权限需要足够 思考？：难道没有无参的构造器就不能创建对象了吗？ 只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作 步骤如下： 通过Class的 getDeclaredConstructor（Class … parameterTypes）取得本类的指定形参类型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需要的各个参数 通过Constructor实例化对象 调用指定的方法通过反射，调用类中的方法，通过Method类完成。 通过Class类的getMethod（String name， Class … parameterTypes）方法取得一个Method对象，并设置此方法操作时所需要的参数类型。 之后使用Object invoke（Object obj， Object[] args）进行调用，并向方法中传递要设置的obj对象的参数信息 Object invoke(Object obj, Obj ... args) Object对应方法的返回值，若原方法无返回值，此时返回null 若原方法为静态方法，此时形参Object obj可为null 若原方法形参列表为空，则Object[] args 为null 若原方法声明为private，则需要再调用此invoke（）方法前，显式调用方法对象的setAccessible（true）方法，将可访问private的方法。 setAccessible Method和Field、Constructor对象都有setAccessible（）方法 setAccesible作用是启动和禁用访问安全检查的开关。 参数值为true， 指示反射的对象在使用时应该取消Java语言访问检查。 提高反射的效率。如果代码中必须使用反射，而该句代码需要频繁的被调用，那么请设置为true 使得原本无法访问的私有成员也可以访问 参数值为false，指示反谁的对象应该是是java语言的访问检查 import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Test09 { public static void main(String[] args) throws Exception { Class c1 = Class.forName(\"javalearning.reflection.User\"); // User user = (User) c1.newInstance(); //本质是调用了类的无参构造器，无参数构造函数不需要获取构造函数对象 // System.out.println(user); //通过构造器创建对象 Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class); System.out.println(constructor); User user1 = (User) constructor.newInstance(\"岛市老八\", 1, 18); System.out.println(user1); //通过反射调用普通方法 //获取一个对象 User user2 = (User)c1.newInstance(); //通过反射获取一个方法 Method setName = c1.getDeclaredMethod(\"setName\", String.class); //invoke： 激活 // (对象， \"方法的值\") setName.invoke(user2, \"奥里给\"); System.out.println(user2.getName()); //通过反射操作属性 User user3 = (User) c1.newInstance(); Field name = c1.getDeclaredField(\"name\"); //取消私有属性的安全检测 name.setAccessible(true); name.set(user3, \"wocao\"); System.out.println(user3.getName()); } } 性能分析import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; //分析性能问题 public class Test10 { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { test01(); test02(); test03(); } //普通方式调用 public static void test01(){ User user = new User(); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++){ user.getName(); } long endTime = System.currentTimeMillis(); System.out.println(\"普通方法: \" + (endTime - startTime) + \" ms\"); } //反射方法调用 public static void test02() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(\"getName\", null); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++){ getName.invoke(user, null); } long endTime = System.currentTimeMillis(); System.out.println(\"反射方法: \" + (endTime - startTime) + \" ms\"); } //反射方式调用 关闭私有属性安全检测 public static void test03() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class c1 = user.getClass(); Method getName = c1.getDeclaredMethod(\"getName\", null); getName.setAccessible(true); long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++){ getName.invoke(user, null); } long endTime = System.currentTimeMillis(); System.out.println(\"关闭检测方法: \" + (endTime - startTime) + \" ms\"); } } /* 普通方法: 4 ms 反射方法: 330 ms 关闭检测方法: 159 ms */ 反射确实会降低程序执行的性能，关闭安全检查可以较为显著地提升性能。 反射操作泛型 Java采用泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题。但是，一旦编译完成，所有和泛性有关的类型全部擦除。 为了通过反射操作这些类型，Java新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType 几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型 ParameterizedType：表示一种参数化类型，比如Collection GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型 TypeVariable：是各种类型变量的公共父接口 WildcardType：代表一种通配符类型表达式 import java.lang.reflect.Method; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.util.List; import java.util.Map; //通过反射获取泛型 public class Test11 { public static void main(String[] args) throws NoSuchMethodException { Method method = Test11.class.getMethod(\"test01\", Map.class, List.class); //返回函数的参数列表 Type[] genericExceptionTypes = method.getGenericParameterTypes(); //遍历每一项参数 for (Type genericExceptionType : genericExceptionTypes){ System.out.println(\"#\"+ genericExceptionType); //判断每一项的泛型的参数类型是否为结构化参数类型 if (genericExceptionType instanceof ParameterizedType){ //强制转换为结构化参数类型，然后用函数获得其真实类型数组 Type[] actualTypeArguments = ((ParameterizedType) genericExceptionType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments){ System.out.println(actualTypeArgument); } } } method = Test11.class.getDeclaredMethod(\"test02\"); //这个方法获取的是返回值类型，别的和上面的逻辑没啥区别 Type genericReturnType = method.getGenericReturnType(); if (genericReturnType instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments){ System.out.println(actualTypeArgument); } } } public void test01(Map&lt;String, User&gt; map, List&lt;User&gt; list){ System.out.println(\"test01\"); } public Map&lt;String,User&gt; test02(){ System.out.println(\"test02\"); return null; } } 反射操作注解 getAnnotations getAnnotation import java.lang.annotation.*; import java.lang.reflect.Field; //联系反射操作注解 public class test12 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { Class c1 = Class.forName(\"javalearning.reflection.Student2\"); //通过反射获取注解 Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations){ System.out.println(annotation); } /* @javalearning.reflection.TableName(value=\"db_student\") */ //获取注解value的值 //获取指定注解，传入注解的Class 返回类型是Annotation类型的，然后强转为目标类型 TableName tableName = (TableName) c1.getAnnotation(TableName.class); String value = tableName.value(); //通过.value()就能获取了 System.out.println(value); /* db_student */ // 获取类指定的注解 Field field = c1.getDeclaredField(\"name\"); FieldName annotation = field.getAnnotation(FieldName.class); System.out.println(annotation.columnName()); System.out.println(annotation.type()); System.out.println(annotation.length()); /* db_name varchar 3 */ } } @TableName(\"db_student\") class Student2{ @FieldName(columnName = \"db_id\", type=\"int\", length=10) private int id; @FieldName(columnName = \"db_age\", type=\"int\", length=10) private int age; @FieldName(columnName = \"db_name\", type=\"varchar\", length=3) private String name; public Student2() { } public Student2(int id, int age, String name) { this.id = id; this.age = age; this.name = name; } public void setId(int id) { this.id = id; } public void setAge(int age) { this.age = age; } public void setName(String name) { this.name = name; } public int getId() { return id; } public int getAge() { return age; } public String getName() { return name; } @Override public String toString() { return \"Student2{\" + \"id=\" + id + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } //类名的注解 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @interface TableName{ String value(); } //表属性的注解 @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @interface FieldName{ String columnName(); String type(); int length(); }","categories":[],"tags":[]},{"title":"","slug":"多线程","date":"2021-09-14T08:22:09.725Z","updated":"2021-09-14T08:22:10.040Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"线程创建三种创建线程的方式 继承Thread.start() 方法启动线程执行的是 run() 里的线程体！ 测试一： // 创建线程方式一：继承Thread类，重写run()方法，调用start开启线程 //总结：注意，线程开启不一定立即执行，由cpu调度执行 public class TestThread1 extends Thread{ @Override public void run(){ //run方法线程体 for (int i = 0;i&lt;20;i++){ System.out.println(\"我在看代码-----\"+i); } } public static void main(String[] args){ //main线程，主线程 //创建一个线程对象 TestThread1 testThread1 = new TestThread1(); //调用start()方法开启线程 testThread1.start(); for(int i= 0 ;i&lt;200;i++){ System.out.println(\"我在学习多线程----\"+i); } } } 输出结果： 可以发现 start() 开启的线程和主线程是交替执行的！！！ 而直接调用 run() 方法，会发现先执行run()方法，再执行主线程： public static void main(String[] args){ //main线程，主线程 //创建一个线程对象 TestThread1 testThread1 = new TestThread1(); //调用run()方法开启线程 testThread1.run(); for(int i= 0 ;i&lt;200;i++){ System.out.println(\"我在学习多线程----\"+i); } } 输出结果 以上对比直接调用 run() 和调用 start()可以得出以下结论： 为了更好地验证上述结论，我们进行测试二： 测试二： //练习Thread,实现多线程同步下载图片 public class TestThread2 extends Thread { private String url; //网络图片地址 private String name; //保存的文件名 public TestThread2(String url,String name){ this.url=url; this.name=name; } //下载图片的线程执行体 @Override public void run(){ WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url,name); System.out.println(\"下载的文件名为：\"+name); } public static void main(String[] args) { TestThread2 t1 = new TestThread2(\"https://pics7.baidu.com/feed/a50f4bfbfbedab64cddfc490f31fc9c578311ee4.jpeg?token=d6cc78140999ca5390cd8002a754d9a4\",\"1.jpg\"); TestThread2 t2 = new TestThread2(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628161248586-632368241.png\",\"2.jpg\"); TestThread2 t3 = new TestThread2(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628162624243-370438535.png\",\"3.jpg\"); t1.start(); t2.start(); t3.start(); } } //下载器 class WebDownloader{ //下载方法 public void downloader(String url,String name){ try{ FileUtils.copyURLToFile(new URL(url),new File(name)); }catch (IOException e){ e.printStackTrace(); System.out.println(\"IO异常，downloader方法出现问题\"); } } 下载结果为：（发现并不是按1，2，3的顺序下载） 从而更好的说明，start() 方法开启的子线程和主线程是并行交替执行的！ 实现Runnable 测试一： //创建线程方式2：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类Thread中，调用start()。 public class TestThread3 implements Runnable{ @Override public void run(){ //run方法线程体 for (int i = 0;i&lt;20;i++){ System.out.println(\"我在看代码-----\"+i); } } public static void main(String[] args){ //创建runnable接口的实现类对象 TestThread3 testThread3 = new TestThread3(); //创建线程对象，通过线程对象来开启我们的线程，代理 Thread thread = new Thread(testThread3); thread.start(); for(int i= 0 ;i&lt;200;i++){ System.out.println(\"我在学习多线程----\"+i); } } } 输出结果： 测试二：让TestThread2实现Runnable接口下载图片，而非继承Thread //实现Runnable接口下载图片 public class TestThread2 implements Runnable { private String url; //网络图片地址 private String name; //保存的文件名 public TestThread2(String url,String name){ this.url=url; this.name=name; } //下载图片的线程执行体 @Override public void run(){ WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url,name); System.out.println(\"下载的文件名为：\"+name); } public static void main(String[] args) { TestThread2 t1 = new TestThread2(\"https://pics7.baidu.com/feed/a50f4bfbfbedab64cddfc490f31fc9c578311ee4.jpeg?token=d6cc78140999ca5390cd8002a754d9a4\",\"1.jpg\"); TestThread2 t2 = new TestThread2(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628161248586-632368241.png\",\"2.jpg\"); TestThread2 t3 = new TestThread2(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628162624243-370438535.png\",\"3.jpg\"); new Thread(t1).start(); new Thread(t2).start(); new Thread(t3).start(); } } 下载结果：（交替下载，而非顺序下载） 小结 初识并发问题//多个线程同时操作同一个对象 //买车票的例子 //发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱 public class TestThread4 implements Runnable { //票数 private int ticketNums = 10; @Override public void run(){ while(true){ if (ticketNums&lt;=0){ break; } //模拟延时 try{ Thread.sleep(200); }catch (InterruptedException e){ e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"拿到了第\"+ticketNums--+\"张票\"); } } public static void main(String[] args) { TestThread4 ticket = new TestThread4(); new Thread(ticket,\"小明\").start(); new Thread(ticket,\"老师\").start(); new Thread(ticket,\"黄牛\").start(); } } 输出结果：（发现线程不安全） 案例：龟兔赛跑—Race //模拟龟兔赛跑 public class Race implements Runnable { //胜利者 private static String winner; @Override public void run(){ for (int i = 1; i&lt;=100 ; i++){ //模拟兔子休息 if(Thread.currentThread().getName().equals(\"兔子\") &amp;&amp; i%10==0){ try{ Thread.sleep(10); }catch (InterruptedException e){ e.printStackTrace(); } } //判断比赛是否结束 boolean flag = gameOver(i); //如果比赛结束了，就停止程序 if (flag){ break; } System.out.println(Thread.currentThread().getName()+\"----&gt;跑了\"+i+\"步\"); } } //判断是否完成比赛 private boolean gameOver(int steps){ //判断是否有胜利者 if (winner!=null){ //已经有胜利者 return true; }else{ if (steps&gt;=100){ winner = Thread.currentThread().getName(); System.out.println(\"winner is \"+winner); return true; } } return false; } public static void main(String[] args) { Race race = new Race(); new Thread(race,\"兔子\").start(); new Thread(race,\"乌龟\").start(); } } 实现Callable接口（了解即可） //线程创建方式三：实现callable接口 /* * callable的好处 * 1.可以定义返回值 * 2.可以抛出异常 * */ public class TestCallable implements Callable&lt;Boolean&gt; { private String url; //网络图片地址 private String name; //保存的文件名 public TestCallable(String url,String name){ this.url=url; this.name=name; } //下载图片的线程执行体 @Override public Boolean call(){ WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url,name); System.out.println(\"下载的文件名为：\"+name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable t1 = new TestCallable(\"https://pics7.baidu.com/feed/a50f4bfbfbedab64cddfc490f31fc9c578311ee4.jpeg?token=d6cc78140999ca5390cd8002a754d9a4\",\"1.jpg\"); TestCallable t2 = new TestCallable(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628161248586-632368241.png\",\"2.jpg\"); TestCallable t3 = new TestCallable(\"https://images2015.cnblogs.com/blog/1168144/201706/1168144-20170628162624243-370438535.png\",\"3.jpg\"); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(3); //提交执行 Future&lt;Boolean&gt; r1 = ser.submit(t1); Future&lt;Boolean&gt; r2 = ser.submit(t2); Future&lt;Boolean&gt; r3 = ser.submit(t3); //获取结果 boolean rs1 = r1.get(); boolean rs2 = r2.get(); boolean rs3 = r3.get(); System.out.println(rs1); System.out.println(rs2); System.out.println(rs3); //关闭服务 ser.shutdownNow(); } } //下载器 class WebDownloader{ //下载方法 public void downloader(String url,String name){ try{ FileUtils.copyURLToFile(new URL(url),new File(name)); }catch (IOException e){ e.printStackTrace(); System.out.println(\"IO异常，downloader方法出现问题\"); } } } 下载结果： 静态代理 //静态代理模式总结： //真实对象和代理对象都要实现同一个接口 //代理对象要代理真实角色 //好处： //代理对象可以做很多真实对象做不了的事情 //真实对象专注做自己的事情 public class StaticProxy { public static void main(String[] args) { You you = new You();//你要结婚 WeddingCompany weddingCompany = new WeddingCompany(you); weddingCompany.HappyMarry(); } } interface Marry{ void HappyMarry(); } //真实角色，你去结婚 class You implements Marry{ @Override public void HappyMarry(){ System.out.println(\"秦老师要结婚了，超开心\"); } } //代理角色，帮助你结婚 class WeddingCompany implements Marry{ //代理谁-&gt; 真实目标角色 private Marry target; public WeddingCompany(Marry target){ this.target = target; } @Override public void HappyMarry(){ before(); this.target.HappyMarry(); //这就是真实对象 after(); } private void after(){ System.out.println(\"结婚后，收尾款\"); } private void before(){ System.out.println(\"结婚前，布置现场\"); } 和上文实现Runnable接口创建线程作对比： ​ Marry接口——&gt;Runnable接口 ​ 实现Marry接口的You类——&gt;实现Runnable接口的TestThread3类 ​ 实现Marry接口的WeddingCompany类——&gt;实现Runnable接口的Thread类 Lambda表达式 /** * 推导lambda表达式: * 1.创建外部类——&gt;2.创建静态内部类——&gt;3.创建局部内部类——&gt;4.创建匿名内部类——&gt;5.使用lambda表达式 */ public class TestLambda { //3.静态内部类 static class Like2 implements ILike{ @Override public void lambda(){ System.out.println(\"I like lambda2\"); } } public static void main(String[] args) { //调用外部类创建对象 ILike like1 = new Like(); like1.lambda(); //调用静态内部类创建对象 ILike like2 = new Like2(); like2.lambda(); //4.局部内部类 class Like3 implements ILike{ @Override public void lambda(){ System.out.println(\"I like lambda3\"); } } ILike like3 = new Like3(); like3.lambda(); //5.匿名内部类，没有类名字，必须借助接口或者父类 ILike like4 = new ILike() { @Override public void lambda() { System.out.println(\"I like lambda4\"); } }; like4.lambda(); //6.用lambda简化 ILike like5 = ()-&gt;{ System.out.println(\"I like lambda5\"); }; like5.lambda(); } } //1.定义一个函数接口 interface ILike{ void lambda(); } //2.实现外部类 class Like implements ILike{ @Override public void lambda(){ System.out.println(\"I like lambda\"); } } 在函数式接口的抽象函数有参数的情况下，使用lambda表达式： public class TestLambda2 { public static void main(String[] args) { //使用lambda表达式，不做任何化简 ILove love1 = (int a)-&gt;{ System.out.println(\"I love you--&gt;\"+a); }; love1.love(1); //1.简化参数类型 ILove love2 = (a)-&gt;{ System.out.println(\"I love you--&gt;\"+a); }; love2.love(2); //2.简化括号和参数类型 ILove love3 = a-&gt;{ System.out.println(\"I love you--&gt;\"+a); }; love2.love(3); //3.简化括号和参数类型和花括号 ILove love4 = a-&gt;System.out.println(\"I love you--&gt;\"+a); love4.love(4); //总结： //lambda表达式只能在方法体有一行代码的情况下才能简化成为一行(即去掉花括号)，如果有多行，那么就用代码块包裹(即使用花括号) //lambda的使用前提是接口为函数式接口（即接口里只有一个函数方法） //多个参数也可以去掉参数类型(参数类型不同也可以)，要去掉就都去掉，但必须加括号 //当使用lambda有返回值时，方法体即使只有一行代码，也要用花括号包裹！ } } //函数式接口 interface ILove{ void love(int a); } 线程状态线程的五大状态 停止线程 使用我们自定义的stop方法，通过改变标志位让线程停止： //测试stop //1.建议线程正常停止————&gt;利用次数，不建议死循环 //2.建议使用标志位————&gt;设置一个标志位 //3.不要使用stop或者destroy等过时或者JDK不建议使用的方法 public class TestStop implements Runnable{ //1.设置一个标识位 private boolean flag = true; @Override public void run(){ int i = 0; while(flag){ System.out.println(\"run ..... Thread\"+i++); } } //2.设置一个公开的方法停止线程，转换标志位 public void stop(){ this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i=0;i&lt;1000;i++){ System.out.println(\"main\"+i); if (i==900){ //调用 stop方法切换标志位，让线程停止 testStop.stop(); System.out.println(\"线程该停止了！！！\"); } } } } 线程在执行第1060次时停止： 线程休眠 import com.ztx.dem01.TestThread4; //模拟网络延时：放大问题的发生行 public class TestSleep implements Runnable{ //票数 private int ticketNums = 10; @Override public void run(){ while(true){ if (ticketNums&lt;=0){ break; } //模拟延时 try{ Thread.sleep(200); }catch (InterruptedException e){ e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\"拿到了第\"+ticketNums--+\"张票\"); } } public static void main(String[] args) { TestThread4 ticket = new TestThread4(); new Thread(ticket,\"小明\").start(); new Thread(ticket,\"老师\").start(); new Thread(ticket,\"黄牛\").start(); } } //模拟倒计时 public class TestSleep2 { public static void main(String[] args) { try { tenDown(); }catch (InterruptedException e){ e.printStackTrace(); } } //模拟倒计时 public static void tenDown() throws InterruptedException{ int num = 10; while(true){ Thread.sleep(1000); System.out.println(num--); if (num&lt;=0){ break; } } } } //模拟倒计时 public class TestSleep2 { public static void main(String[] args) { //打印当前系统时间 Date startTime = new Date(System.currentTimeMillis());//获取当前系统时间 while(true){ try{ Thread.sleep(1000); System.out.println(new SimpleDateFormat(\"HH:MM:SS\").format(startTime)); startTime = new Date(System.currentTimeMillis());//更新当前系统时间 }catch (InterruptedException e){ e.printStackTrace(); } } } } 线程礼让 //测试礼让线程 //礼让不一定成功，看cpu心情 public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield,\"a\").start(); new Thread(myYield,\"b\").start(); } } class MyYield implements Runnable{ @Override public void run(){ System.out.println(Thread.currentThread().getName()+\"线程开始执行\"); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+\"线程停止执行\"); } } 理想情况下，当把 Thread.yield(); 注释掉，输出情况应为：（实际上，不可能这么理想！） 加上礼让代码后，输出情况可能就不会很规整：（让执行的线程暂停，但不阻塞） join //测试join方法 //想象为插队 public class TestJoin implements Runnable{ @Override public void run(){ for (int i=0;i&lt;1000;i++){ System.out.println(\"线程vip来了\"+i); } } public static void main(String[] args) throws InterruptedException { //启动我们的线程 TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); thread.start(); //主线程 for(int i=0;i&lt;500;i++){ if (i==200){ thread.join();//插队 } System.out.println(\"main\"+i); } } } 输出结果：（在“main199”之前，线程是交替执行的，main199之后，线程VIP开始插队直到执行结束，main在开始继续执行！！！） 线程状态观测 //观测线程的状态 public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-&gt;{ for (int i=0;i&lt;10;i++){ try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } } System.out.println(\"///////\"); }); //观察状态 Thread.State state = thread.getState(); System.out.println(state); //状态为：new，即新生的 //观察启动后的状态 thread.start();//启动线程 state = thread.getState(); System.out.println(state);//状态应为：run while(state!=Thread.State.TERMINATED){//只要线程不终止，就一直输出状态 Thread.sleep(1000); state = thread.getState(); //更新线程状态 System.out.println(state); } thread.start(); } } 线程优先级 测试线程优先级： //测试线程的优先级 public class TestPriority { public static void main(String[] args) { //主线程默认优先级 System.out.println(Thread.currentThread().getName()+\"---&gt;\"+Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); Thread t6 = new Thread(myPriority); //先设置优先级，再启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(4); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); t5.setPriority(8); t5.start(); t6.setPriority(7); t6.start(); } } class MyPriority implements Runnable{ @Override public void run(){ System.out.println(Thread.currentThread().getName()+\"---&gt;\"+Thread.currentThread().getPriority()); } } 运行结果： 守护(daemon)线程 测试守护线程： //测试守护线程 //上帝守护你 public class TestDaemon { public static void main(String[] args) { God god = new God(); You you = new You(); Thread thread = new Thread(god); thread.setDaemon(true); //默认为false表示用户线程，正常的线程都是用户线程 thread.start();//上帝守护线程开启 new Thread(you).start();//you 用户线程开启 } } //上帝 class God implements Runnable{ @Override public void run(){ //这里设置为一直循环，但虚拟机不会等到该线程执行结束(该线程也不会自动结束)，就会将其停止，它只要确保用户线程执行完毕即可 while(true){ System.out.println(\"s上帝保佑着你！\"); } } } //你 class You implements Runnable{ @Override public void run(){ for (int i=0;i&lt;36500;i++){ System.out.println(\"你一生都开心的活着\"); } System.out.println(\"======goodbye! world!=======\"); } } 输出结果： 这里的用户线程执行完毕后，守护线程依旧执行是因为虚拟机完毕需要时间，在这期间守护线程还可以一直运行！ 线程同步多个线程操作同一个资源 并发：同一个对象被多个线程同时操作 队列和锁：实现线程同步需要队列和锁 队列和锁的理解可以联想排队上厕所：队列就像等待上厕所的队伍，锁就像蹲坑的门，当你进去时把门关上，则其他人就进不去了，如果没有门（锁）就不能独占资源，也就没有了安全性 三大不安全案例//不安全的买票 public class UnsafeBuyTicket { public static void main(String[] args) { // TODO Auto-generated method stub BuyTicket station = new BuyTicket(); new Thread(station,\"苦逼的我\").start(); new Thread(station,\"牛逼的大家\").start(); new Thread(station,\"可恶的黄牛\").start(); } } class BuyTicket implements Runnable{ //票 private int ticketNums = 10; boolean flag = true;//外部停止方式 @Override public void run() { //买票 while(flag) { try{ buy(); }catch(InterruptedException e) { e.printStackTrace(); } } } private void buy() throws InterruptedException{ //判断是否有票 if(ticketNums&lt;=0) { return; } //模拟延时 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+\"拿到了\"+ticketNums--+\"票\"); } } 输出结果：（拿票混乱，且出现负数） //不安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { // TODO Auto-generated method stub Account a = new Account(100,\"结婚基金\"); Drawing you = new Drawing(a,50,\"你\"); Drawing girl = new Drawing(a,100,\"girl\"); you.start(); girl.start(); } } //账户 class Account{ int money;//余额 String name;//卡名 public Account(int money,String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ Account account;//账户 int drawingMoney;//取了多少钱 int nowMoney;//现在手里有多少钱 public Drawing(Account account,int drawingMoney,String name) { super(name); //定义线程名 this.account = account; this.drawingMoney = drawingMoney; } //取钱 @Override public void run() { //判断有没有钱 if(account.money-drawingMoney&lt;0) { System.out.println(Thread.currentThread().getName()+\"钱不够\"); return; } //sleep可以放大问题的发生性 try { Thread.sleep(1000); }catch(Exception e) { e.printStackTrace(); } //卡内余额=余额-你取的钱 account.money = account.money-drawingMoney; //你手里的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为\"+account.money); //这两个操作等价 //this.getName()=Thread.currentThread().getName() System.out.println(this.getName()+\"手里的钱\"+nowMoney); } } 输出结果：（存款为负数） //线程不安全的集合 public class UnsafeList { public static void main(String[] args) { // TODO Auto-generated method stub List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) { new Thread(()-&gt;{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(3000); }catch(Exception e) { e.printStackTrace(); } System.out.println(list.size()); } } 输出结果：（不足10000，因为存在多个线程同时看到一个标志，于是name就存在被覆盖掉的可能） 同步方法及同步块(synchronized)(把不安全的改成安全的) //加锁，同步方法，实现安全的买票 public class UnsafeBuyTicket { public static void main(String[] args) { // TODO Auto-generated method stub BuyTicket station = new BuyTicket(); new Thread(station,\"苦逼的我\").start(); new Thread(station,\"牛逼的大家\").start(); new Thread(station,\"可恶的黄牛\").start(); } } class BuyTicket implements Runnable{ //票 private int ticketNums = 10; boolean flag = true;//外部停止方式 @Override public void run() { //买票 while(flag) { try{ buy(); }catch(InterruptedException e) { e.printStackTrace(); } } } //同步方法，锁的是BuyTicket类实例出的对象 private synchronized void buy() throws InterruptedException{ //判断是否有票 if(ticketNums&lt;=0) { return; } //模拟延时 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+\"拿到了\"+ticketNums--+\"票\"); } } 输出结果:（输出结果整洁有序，没有重复，没有负数） 同步方法的弊端 同步块 //使用方法块，找准修改的对象作为同步监视器来实现安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { // TODO Auto-generated method stub Account a = new Account(100,\"结婚基金\"); Drawing you = new Drawing(a,50,\"你\"); Drawing girl = new Drawing(a,100,\"girl\"); you.start(); girl.start(); } } //账户 class Account{ int money;//余额 String name;//卡名 public Account(int money,String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ Account account;//账户 int drawingMoney;//取了多少钱 int nowMoney;//现在手里有多少钱 public Drawing(Account account,int drawingMoney,String name) { super(name); //定义线程名 this.account = account; this.drawingMoney = drawingMoney; } //取钱 // 如果直接在run方法前加锁，默认是锁的是调用该方法的对象，即Drawing类的实例化对象， // 而我们这里实际上是对account这个共享资源做修改，故应该对account加锁 @Override public void run() { // 是对account加锁，account称之为同步监视器 // 锁的对象就是变化的量，需要增删改操作的对象 synchronized (account){ //判断有没有钱 if(account.money-drawingMoney&lt;0) { System.out.println(Thread.currentThread().getName()+\"钱不够\"); return; } //sleep可以放大问题的发生性 try { Thread.sleep(1000); }catch(Exception e) { e.printStackTrace(); } //卡内余额=余额-你取的钱 account.money = account.money-drawingMoney; //你手里的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为\"+account.money); //这两个操作等价 //System.out.println(this.getName()+Thread.currentThread().getName()); System.out.println(this.getName()+\"手里的钱\"+nowMoney); } } } 输出结果：（不会出现负数了） //使用同步块实现线程安全的集合 public class UnsafeList { public static void main(String[] args) { // TODO Auto-generated method stub List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) { new Thread(()-&gt;{ //使用同步块 synchronized (list){ list.add(Thread.currentThread().getName()); } }).start(); } try { Thread.sleep(3000); }catch(Exception e) { e.printStackTrace(); } System.out.println(list.size()); } } 输出结果：（size正确） CopyOnWriteArrayListimport java.util.concurrent.CopyOnWriteArrayList; //测试JUC安全类型的集合,使用juc下的集合不用添加同步块就可实现线程的同步 public class TestJUC { public static void main(String[] args) { // TODO Auto-generated method stub CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); for(int i=0;i&lt;10000;i++) { new Thread(()-&gt;{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(3000); }catch(Exception e) { e.printStackTrace(); } System.out.println(list.size()); } } 死锁 注意：一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”问题！ 制造死锁： //死锁：多个线程相互抱着对方需要的资源，然后形成死锁 public class DeadLock { public static void main(String[] args) { Makeup g1 = new Makeup(0,\"灰姑娘\"); Makeup g2 = new Makeup(1,\"白雪公主\"); g1.start(); g2.start(); } } //口红 class Lipstick{ } //镜子 class Mirror{ } class Makeup extends Thread{ //需要的资源只有一份，用static来保证只有一份 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice; //选择 String girlName; //使用化妆品的人 Makeup(int chioce,String girlName){ this.choice = chioce; this.girlName = girlName; } @Override public void run(){ //化妆 try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } //化妆，互相持有对方的锁，就是需要拿到对象的资源 private void makeup() throws InterruptedException { if (choice==0){ synchronized (lipstick){ System.out.println(this.girlName+\"获得口红的锁\"); Thread.sleep(1000); //下面代码是在synchronized (lipstick){}里面 synchronized (mirror){ //一秒钟后想获得镜子 System.out.println(this.girlName+\"获得镜子的锁\"); } } }else{ synchronized (mirror){ //获得镜子的锁、 System.out.println(this.girlName+\"获得镜子的锁\"); Thread.sleep(2000); //下面代码是在synchronized (mirror){}里面 synchronized (lipstick){ //一秒后想获得镜子 System.out.println(this.girlName+\"获得口红的锁\"); } } } } } 这种代码就是产生死锁的关键点：(一个同步块包含两个对象) synchronized (lipstick){ System.out.println(this.girlName+\"获得口红的锁\"); Thread.sleep(1000); //下面代码是在synchronized (lipstick){}里面 synchronized (mirror){ //一秒钟后想获得镜子 System.out.println(this.girlName+\"获得镜子的锁\"); } 输出结果：(发生死锁) 解除死锁： //解除死锁 public class DeadLock { public static void main(String[] args) { Makeup g1 = new Makeup(0,\"灰姑娘\"); Makeup g2 = new Makeup(1,\"白雪公主\"); g1.start(); g2.start(); } } //口红 class Lipstick{ } //镜子 class Mirror{ } class Makeup extends Thread{ //需要的资源只有一份，用static来保证只有一份 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice; //选择 String girlName; //使用化妆品的人 Makeup(int chioce,String girlName){ this.choice = chioce; this.girlName = girlName; } @Override public void run(){ //化妆 try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } //化妆，互相持有对方的锁，就是需要拿到对象的资源 private void makeup() throws InterruptedException { if (choice==0){ synchronized (lipstick){ System.out.println(this.girlName+\"获得口红的锁\"); Thread.sleep(1000); } //将下面代码从上面同步块中拿出，即可化解死锁 synchronized (mirror){ //一秒钟后想获得镜子 System.out.println(this.girlName+\"获得镜子的锁\"); } }else{ synchronized (mirror){ //获得镜子的锁、 System.out.println(this.girlName+\"获得镜子的锁\"); Thread.sleep(2000); } //将下面代码从上面同步块中拿出，即可化解死锁 synchronized (lipstick){ //一秒后想获得镜子 System.out.println(this.girlName+\"获得口红的锁\"); } } } } 输出结果：（不发生死锁） 避免死锁的方法 Lock(锁) 下面使用可重入锁ReentrantLock对共享资源进行显示加锁、解锁： import java.util.concurrent.locks.ReentrantLock; public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); } } class TestLock2 implements Runnable{ int ticketNums = 10; //定义lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run(){ while(true){ try { lock.lock(); //加锁 if (ticketNums&gt;0){ try{ Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } System.out.println(ticketNums--); }else{ break; } }finally { lock.unlock(); //解锁 } } } } 输出结果： synchronized与Lock的对比 线程协作生产者消费者问题 线程通信 解决方式1 //测试:生产者消费者模型 ---&gt;利用缓存区解决：管程法 public class TestPC { public static void main(String[] args) { SyncContainer container = new SyncContainer(); new ProviderThread(container).start(); new ConsumerThread(container).start(); } } //生产者 class ProviderThread extends Thread { //创建好的缓冲区 private SyncContainer syncContainer; public ProviderThread(SyncContainer syncContainer) { this.syncContainer = syncContainer; } @Override public void run() { for (int i = 1; i &lt;= 100; i++) { syncContainer.push(new Product(i)); System.out.println(\"生产了第\" + i + \"只鸡!\"); } } } //消费者 class ConsumerThread extends Thread { private SyncContainer syncContainer; public ConsumerThread(SyncContainer syncContainer) { this.syncContainer = syncContainer; } @Override public void run() { for (int i = 1; i &lt;= 100; i++) { Product pop = syncContainer.pop(); System.out.println(\"消费了第\"+ pop.getId() + \"号产品\"); } } } //产品 class Product { private int id; public Product(int id) { this.id = id; } public int getId() { return id; } public void setId(int id) { this.id = id; } } //缓冲区 class SyncContainer { //容器大小，product[0]为空，不使用，即最多放10件产品 Product[] products = new Product[11]; //容器计数器 int count = 0; //生产者放入产品 public synchronized void push(Product product){ //如果容器满了,就要等待消费者 //这里为什么减2才能实现最多连续存储10只鸡，而减1会出现最多连续存储11只鸡，我不清楚，比较费解 if(count == products.length-2) { //等待消费者消费,生产者等待 try { this.wait(); } catch (InterruptedException e){ e.printStackTrace(); } } //如果容器没有满,我们就要丢入产品 count++; products[count] = product; //可以通知消费者消费 this.notifyAll(); } //消费者消费产品 public synchronized Product pop(){ //判断容器是否为空 if(count == 0){ //等待生产者生产.消费者等待 try { this.wait(); } catch (InterruptedException e){ e.printStackTrace(); } } //如果可以消费 Product product = products[count]; count--; //通知生产者生产 this.notifyAll(); return product; } } 小疑问： count == products.length-2 //容器实际能存放10件产品，数组长度为11，减2则count为9，对应product[9],而实际可以存放至product[10],因为下标为0时，不存放产品。为什么-2才能最大连续打至出生产了第10只鸡，而-1会连续打印至生产第11只鸡 输出结果：（符合要求） 解决方式2 //测试生产者消费者问题2：信号灯法，标志位解决 public class TestPC2 { public static void main(String[] args) { TV tv = new TV(); new Player(tv).start(); new Watcher(tv).start(); } } //生产者--&gt;演员 class Player extends Thread{ TV tv; public Player(TV tv){ this.tv = tv; } @Override public void run(){ for (int i = 0;i&lt;20;i++){ if (i%2==0){ this.tv.play(\"快乐大本营播放中\"); }else{ this.tv.play(\"抖音：记录美好生活\"); } } } } //消费之--&gt;观众 class Watcher extends Thread{ TV tv; public Watcher(TV tv){ this.tv = tv; } @Override public void run(){ for (int i=0;i&lt;20;i++){ tv.watch(); } } } //产品--&gt;节目 class TV { //演员表演，观众等待 T //观众观看，演员等待 F String voice; //表演的节目 boolean flag = true; //flag为真时，观众等待，为假时演员等待 //表演 public synchronized void play(String voice){ if (!flag){ try{ this.wait(); }catch (InterruptedException e){ e.printStackTrace(); } } System.out.println(\"演员表演了：\"+voice); //通知观众观看 this.notifyAll(); //通知唤醒 this.voice = voice; this.flag = !this.flag; } //观看 public synchronized void watch(){ if (flag){ try { this.wait(); }catch (InterruptedException e){ e.printStackTrace(); } } System.out.println(\"观看了：\"+voice); //通知演员表演 this.notifyAll(); this.flag = !this.flag; } } 输出结果： 使用线程池 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; //测试线程池 public class TestPool { public static void main(String[] args) { //1.创建服务，创建线程池 //newFixedThreadPool 参数为线程池大小 ExecutorService service = Executors.newFixedThreadPool(10); //执行runnable接口实现类对象 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //2.关闭连接 service.shutdown(); } } class MyThread implements Runnable{ @Override public void run(){ System.out.println(Thread.currentThread().getName()); } } 输出结果： package com.ztx.gaoji; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; //JUC并发编程 import java.util.concurrent.*; public class TestCallable implements Callable&lt;Boolean&gt; { private String url; private String name; public TestCallable(String url,String name){ this.url = url; this.name = name; } @Override public Boolean call() throws Exception { //下载图片 WebDownloader webDownloader = new WebDownloader();//下载器 webDownloader.downloader(url,name);//下载文件的方式 System.out.println(\"下载了图片--&gt;\"+name); return true; } //启动线程 public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable t1 = new TestCallable(\"https://img2020.cnblogs.com/blog/1732557/202006/1732557-20200617142339091-966351471.png\",\"你好1.jpg\"); TestCallable t2 = new TestCallable(\"https://img2020.cnblogs.com/blog/1732557/202006/1732557-20200617142428143-1598758167.png\",\"你好2.jpg\"); TestCallable t3 = new TestCallable(\"https://img2020.cnblogs.com/blog/1732557/202006/1732557-20200617142459110-1793347461.png\",\"你好3.jpg\"); //创建执行服务： ExecutorService ser = Executors.newFixedThreadPool(3); //提交执行： Future&lt;Boolean&gt; result1 = ser.submit(t1); Future&lt;Boolean&gt; result2 = ser.submit(t2); Future&lt;Boolean&gt; result3 = ser.submit(t3); //获取结果 boolean r1 = result1.get(); boolean r2 = result2.get(); boolean r3 = result3.get(); //判断线程是否顺利结束或者有异常 System.out.println(r1); System.out.println(r2); System.out.println(r3); //关闭服务 ser.shutdownNow(); } } //下载图片 class WebDownloader{ //下载方法 public void downloader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); //输出异常信息 System.out.println(\"downloader方法出现异常\"); } } } 输出结果：","categories":[],"tags":[]},{"title":"","slug":"JVM","date":"2021-09-14T08:22:09.701Z","updated":"2021-09-14T08:22:10.039Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"JVM 友情链接：常见OMM Error和七大垃圾回收器详解 友情链接：JVM调参、GCRoots与四大引用浅析 JVM介绍 1.方法区和堆区是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行时线程私有的内存区域。 2.Java栈又叫做jvm虚拟机栈 3.方法区（永久代）在 jdk8 中又叫做元空间 Metaspace 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT编译器，英文写作Just-In-Time Compiler）编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代 在JDK1.7 字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代 在JDK1.8之后JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。同时在 jdk 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。默认大概是用了20M的大小。 4.java代码执行流程： java程序–（编译javac）–&gt;字节码文件.class–&gt;类装载子系统化身为反射类Class—&gt;运行时数据区—&gt;（解释执行）–&gt;操作系统（Win，Linux，Mac JVM） 所有的栈和程序计数器并不会产生垃圾，所以不会有垃圾回收 我们所说的JVM调优是在方法区和堆里进行调优，99%是堆调优 注意：我们平时说的栈是指的Java栈，本地方法栈（native method stack） 里面装的都是native方法。 JVM生命周期 1.启动 通过引导类根加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的. 2.执行 一个运行中的java虚拟机有着一个清晰的任务：执行Java程序； 程序开始执行的时候他才运行，程序结束时他就停止； 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。 3.退出 程序正常执行结束 程序异常或错误而异常终止 操作系统错误导致终止 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作 除此之外，JNI 规范描述了用 JNI Invocation API 来加载或卸载Java虚拟机时，Java虚拟机的退出情况 类加载子系统作用1.类加载子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识，JVM并不是通过检查文件后缀是不是.class来判断是否需要加载的，而是通过文件开头的特定文件标志即16进制CA TE BA BE； 2.加载后的Class类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射） 来一张经典的JVM内存结构图：其中类加载器的工作范围只限于下图的左半部分，不包含调用构造器实例化对象 3.ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定 4.如果调用构造器实例化对象，则其实例存放在堆区 功能细分 加载模块1.通过一个类的全限定名获取定义此类的二进制字节流； 2.将这个字节流所代表的的静态存储结构转化为方法区的运行时数据； 3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 链接模块分为三块，即验证、准备、解析验证 1.目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 2.主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。 准备 1.为类变量分配内存并且设置该类变量的默认初始值，即零值； 2.这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化； 3.不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。 解析 1.将常量池内的符号引用转换为直接引用的过程。 2.事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行 3.符号引用就是一组符号来描述所引用的目标。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄 4.解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info/CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。 初始化模块，初始化阶段就是执行类构造器方法clinit（）的过程1.clinit()即“class or interface initialization method”，注意他并不是指构造器init() 2.此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 3.我们注意到如果没有静态变量c，那么字节码文件中就不会有clinit方法 构造器方法clinit()中指令按语句在源文件中出现的顺序执行 java程序对类的使用方式分为：主动使用和被动使用，即是否调用了clinit()方法 主动使用在类加载系统中的第三阶段initialization（初始化模块），即初始化阶段调用了clinit()方法 而被动使用不会去调用 主动使用，分为七种情况 1.创建类的实例 2.访问某各类或接口的静态变量，或者对静态变量赋值 3.调用类的静态方法 4.反射 比如Class.forName(com.dsh.jvm.xxx) 5.初始化一个类的子类 6.java虚拟机启动时被标明为启动类的类 7.JDK 7 开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化。 虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁即一个类只需被clinit一次，之后该类的内部信息就被存储在方法区。 可以看到线程2并不会重复执行初始化操作 类加载器种类 注意： Class loader有多种，可以说三个，也可以说是四个（第四个为自己定义的加载器，继承 ClassLoader），系统自带的三个分别为： 启动类加载器(Bootstrap) ，C++所写 这个类加载使用C/C++语言实现的，嵌套在JVM内部 它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar/resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类 并不继承自java.lang.ClassLoader,没有父加载器 加载拓展类和应用程序类加载器，并指定为他们的父加载器，即ClassLoader 出于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun等开头的类 扩展类加载器(Extension) ，Java所写 java语言编写 ，由sun.misc.Launcher$ExtClassLoader实现。 派生于ClassLoader类，不是继承 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会由拓展类加载器自动加载 应用程序类加载器 (AppClassLoader) java语言编写， 由sun.misc.Launcher$AppClassLoader实现。 派生于ClassLoader类，不是继承 它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库 该类加载器是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器： 在日常Java应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，必要时可以自定义类加载器来定制类的加载方式。 为什么要自定义类加载器呢？ 隔离加载类 修改类加载方式 扩展加载源 防止源码泄露 我们自己new的时候创建的是应用程序类加载器(AppClassLoader)。 import com.gmail.fxding2019.T; public class Test{ //Test:查看类加载器 public static void main(String[] args) { Object object = new Object(); //查看是那个“ClassLoader”（快递员把Object加载进来的） System.out.println(object.getClass().getClassLoader()); //查看Object的加载器的上一层 // error Exception in thread \"main\" java.lang.NullPointerException（已经是祖先了） //System.out.println(object.getClass().getClassLoader().getParent()); System.out.println(); Test t = new Test(); System.out.println(t.getClass().getClassLoader().getParent().getParent()); System.out.println(t.getClass().getClassLoader().getParent()); System.out.println(t.getClass().getClassLoader()); } } /* *output: * null * * null * sun.misc.Launcher$ExtClassLoader@4554617c * sun.misc.Launcher$AppClassLoader@18b4aac2 * */ 注意： 如果是JDK自带的类(Object、String、ArrayList等)，其使用的加载器是Bootstrap加载器；如果自己写的类，使用的是AppClassLoader加载器；Extension加载器是负责将把java更新的程序包的类加载进行 输出中，sun.misc.Launcher是JVM相关调用的入口程序 Java加载器个数为3+1。前三个是系统自带的，用户可以定制类的加载方式，通过继承Java. lang. ClassLoader JVM中表示两个class对象是否为同一个类 1.在jvm中表示两个class对象是否为同一个类存在的两个必要条件 类的完整类名必须一致，包括包名 即使类的完整类名一致，同时要求加载这个类的ClassLoader（指ClassLoader实例对象）必 须相同；是引导类加载器、还是定义类加载器 2.换句话说，在jvm中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的. 3.对类加载器的引用，JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的。如果一个类型由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证两个类型的加载器是相同的。 双亲委派机制 注意： 双亲委派机制：“我爸是李刚，有事找我爹”。例如：需要用一个A.java这个类，首先去顶部Bootstrap根加载器去找，找得到你就用，找不到再下降一层，去Extension加载器去找，找得到就用，找不到再将一层，去AppClassLoader加载器去找，找得到就用，找不到就会报”CLASS NOT FOUND EXCEPTION”。 //测试加载器的加载顺序 package java.lang; public class String { public static void main(String[] args) { System.out.println(\"hello world!\"); } } /* * output: * 错误: 在类 java.lang.String 中找不到 main 方法 * */ 上面代码是为了测试加载器的顺序：首先加载的是Bootstrap加载器，由于JVM中有java.lang.String这个类，所以会首先加载这个类，而不是自己写的类，而这个类中并无main方法，所以会报“在类 java.lang.String 中找不到 main 方法”。 这个问题就涉及到，如果有两个相同的类，那么java到底会用哪一个？如果使用用户自己定义的java.lang.String，那么别使用这个类的程序会去全部出错，所以，为了保证用户写的源代码不污染java出厂自带的源代码，而提供了一种“双亲委派”机制，保证“沙箱安全”。即先找到先使用。 沙箱安全机制 Java安全模型的核心就是Java沙箱(sandbox) , 什么是沙箱? 沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。 沙箱主要限制系统资源访问，那系统资源包括什么? CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。 所有的Java程序运行都可以指定沙箱，可以定制安全策略。 组成沙箱的基本组件●字节码校验器(bytecode verifier) :确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。●类裝载器(class loader) :其中类装载器在3个方面对Java沙箱起作用  它防止恶意代码去干涉善意的代码;  它守护了被信任的类库边界;  它将代码归入保护域,确定了代码可以进行哪些操作。 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成， 每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。 类装载器采用的机制是双亲委派模式。 1.从最内层JVM自带类加载器开始加载,外层恶意同名类得不到加载从而无法使用; 2.由于严格通过包来区分了访问域,外层恶意的类通过内置代码也无法获得权限访问到内层类，破 坏代码就自然无法生效。●存取控制器(access controller) :存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定,可以由用户指定。●安全管理器(security manager) : 是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。●安全软件包(security package) : java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:  安全提供者  消息摘要  数字签名  加密  鉴别 Native 本地 native :凡是带了native关键字的，说明java的作用范围达不到了，回去调用底层c语言的库! 会进入本地方法栈 调用本地方法本地接口 JNI (Java Native Interface) JNI作用:开拓Java的使用，融合不同的编程语言为Java所用!最初: C、C++ Java诞生的时候C、C++横行，想要立足，必须要有调用C、C++的程序 它在内存区域中专门开辟了一块标记区域: Native Method Stack，登记native方法 在最终执行的时候，加载本地方法库中的方法通过JNI 例如：Java程序驱动打印机，管理系统，掌握即可，在企业级应用比较少 private native void start0(); //调用其他接口:Socket. . WebService. .http Thread类的start方法如下： public synchronized void start() { /** * This method is not invoked for the main method thread or \"system\" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } private native void start0(); Thread类中竟然有一个只有声明没有实现的方法，并使用native关键字。用native表示，也此方法是系统级（底层操作系统或第三方C语言）的，而不是语言级的，java并不能对其进行操作。native方法装载在native method stack中。 本地方法栈1.Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法（一般非Java实现的方法）的调用 2.本地方法栈，也是线程私有的。 3.允许被实现成固定或者是可动态拓展的内存大小。（和Java虚拟机栈在内存溢出方面情况是相同的） 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverFlowError异常。 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。 4.本地方法是使用C语言实现的 5.它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。 6.当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限 本地方法可以通过本地方法接口来 访问虚拟机内部的运行时数据区 它甚至可以直接使用本地处理器中的寄存器 直接从本地内存的堆中分配任意数量的内存 7.并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。 PC寄存器 注意：native方法不归java管，所以计数器是空的 PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。 1.它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域 2.在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致 3.任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）,因为程序计数器不负责本地方法栈。 4.它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成 5.字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令 6.它是唯一一个在java虚拟机规范中没有规定任何OOM（Out Of Memery）情况的区域,而且没有垃圾回收 利用javap -v xxx.class反编译字节码文件，查看指令等信息 上面图中是亮色的地方有两个特点： 所有线程共享（灰色是线程私有） 亮色地方存在垃圾回收 PC寄存器面试常问1.使用PC寄存器存储字节码指令地址有什么用呢（为什么使用PC寄存器记录当前线程的执行地址呢） （1）多线程宏观上是并行（多个事件在同一时刻同时发生）的，但实际上是并发交替执行的 （2）因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行 （3）JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 所以，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。 2.PC寄存器为什么会设定为线程私有？ （1）我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停做任务切换，这样必然会导致经常中断或恢复，如何保证分毫无差呢？ （2）为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是**为每一个线程都分配一个PC寄存器,**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。 方法区 注意： 方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义,简单说，所有定义的方法的信息都保存在该区域,此区域属于共享区间; *静态变量、常量、类信息(构造方法、接口定义、普通方法)、运行时的常量池存在方法区中，但是实例变量（普通变量）存在堆内存中，和方法区无关** 方法区：绝对不是放方法的地方，他是存储的每一个类的结构信息(比如static) 永久代和元空间的解释：方法区是一种规范，类似于接口定义的规范：List list = new ArrayList();把这种比喻用到方法区则有： java 7中：方法区 f = new 永久代(); java 8中：方法去 f = new 元空间(); 栈 注意： 栈是运行时的单位，堆是存储的单位。 即，栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放在哪里。 栈是线程私有，不存在垃圾回收 虚拟机栈的生命周期同线程一致 栈帧的概念：java中的方法被扔进虚拟机的栈空间之后就成为“栈帧”，比如main方法，是程序的入口，被压栈之后就成为栈帧。 栈的作用： *主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。** 栈运行原理 不同线程所包含的栈帧是私有的，不允许存在相互引用，即不可能在一个栈帧之中引用另一个线程的栈帧。 如果当前方法调用了其他方法，被调用方法返回之际，当前栈帧会传回此被调用方法的执行结果给前一个栈帧（调用者方法），接着，虚拟机会丢弃当前栈帧（被调用方法的栈帧），使得前一个栈帧重新成为当前栈帧。 Java方法有两种返回函数的方式 。一种是正常的函数返回，使用return指令，另一种是如果出现未经捕捉的异常，则已抛出异常的形式返回。不管使用哪种方式，都会导致栈帧被弹出。 栈帧的内部结构1. 局部变量表 StartPC：变量的作用域起始字节码指令位置，Length：作用域长度；StartPC+Length=总字节码指令数 局部变量表也被称之为局部变量数组或者本地变量表。 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，包括8种基本数据类型、对象引用以及returnAddress类型。 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对于一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求，进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，局部变量表随着方法栈帧的销毁而销毁。 局部变量表最基本的存储单元是Slot（变量槽），其中，32位以内的类型只占一个slot(包括returnAddress类型)，64位的类型（long和double占用两个slot）；byte、short、char在存储前被转换为int，boolean也被转化为int，0表示false,非0表示true。 JVM会为每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，如果要访问一个64bit的局部变量值时，只需要使用两个slot中的第一个slot的索引即可。如果当前栈帧是由构造方法或者实例方法创建的，那么该对象引用this将会放在index=0的slot处，其余的参数按照参数表顺序继续排列，这也就解释了为什么静态方法中不可以引用this，因为this变量（当前对象的引用）不存在于静态方法的局部变量表中。此外，栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。 在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。局部变量表中的变量也是重要的垃圾回收的根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。 静态变量与局部变量的对比及小结 变量的分类： 按照数据类型分： ①基本数据类型; ②引用数据类型； 按照在类中声明的位置分： ①成员变量：在使用前，都经历过默认初始化赋值 static修饰：类变量：类加载链接的准备preparation阶段给类变量默认赋0值——&gt;初始化阶段initialization给类变量显式赋值即静态代码块赋值； 不被static修饰：实例变量：随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值 ②局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过 2. 操作数栈每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出的操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即操作数栈的入栈/出栈。例如某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈。（如字节码指令bipush操作） 比如：执行复制、交换、求和等操作 如果说Java虚拟机的解释引擎是基于栈的执行引擎，其中栈指的就是操作数栈。 操作数栈主要用于保存计算过程中的中间结果，同时作为计算过程中的变量临时的存储空间。 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的code属性中，为max_stack的值。 栈中任何一个元素都是可以任意的Java数据类型，其中，32bit类型占用一个栈单位深度，64bit类型占用两个。 操作数栈不同于局部变量表，并非采用访问索引的方式来进行数据访问，而是通过标准的入栈出栈操作来完成一次数据访问。 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。 操作数栈代码追踪 结合上图结合下面的图来看一下一个方法（栈帧）的执行过程 ①15入栈；②存储15，15进入局部变量表 注意：局部变量表的0号位被构造器占用，这里的15从局部变量表1号开始 ③压入8；④8出栈，存储8进入局部变量表； ⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈；⑥iadd相加操作 ⑦iadd操作结果23出栈⑧将23存储在局部变量表索引为3的位置上istore_3 栈顶缓存技术ToS（Top-of-Stack Cashing） 基于栈式架构的虚拟机所使用的零地址指令（即不考虑地址，单纯入栈出栈）更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率 3.动态链接（或指向运行时常量池的方法引用） 运行时常量池位于方法区（注意： JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。） ​ 每一个栈帧内部都包含一个指向运行时常量池（运行时常量池是在方法区里的）中该栈帧所属方法的引用。这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如：invokedynamic指令。 ​ 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其它方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。 ​ 常量池的作用就是为了提供一些符号和常量以便于指令的识别，以节约内存。 方法的调用 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关 静态链接当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。 动态链接如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。 对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。 早期绑定早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 晚期绑定如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 随着高级语言的横空出世，类似于java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装，集成和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。 虚方法和非虚方法 子类对象的多态性使用前提：①类的继承关系（父类的声明）②方法的重写（子类的实现） 实际开发编写代码中用的接口，实际执行是导入的的三方jar包已经实现的功能 非虚方法 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法 静态方法、私有方法、final方法、实例构造器（实例已经确定，this()表示本类的构造器）、父类方法（super调用）都是非虚方法 虚方法 其他所有体现多态特性的方法称为虚方法 虚拟机中提供了以下几条方法调用指令 普通调用指令：1**.invokestatic：调用静态方法，解析阶段确定唯一方法版本；2.invokespecial**:调用方法、私有及父类方法，解析阶段确定唯一方法版本；3.invokevirtual调用所有虚方法；4.invokeinterface：调用接口方法；动态调用指令（Java7新增）：5.invokedynamic：动态解析出需要调用的方法，然后执行 .前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。 其中invokestatic指令和invokespecial指令调用的方法称为非虚方法 其中invokevirtual（final修饰的除外，JVM会把final方法调用也归为invokevirtual指令，但要注意final方法调用不是虚方法）invokeinterface指令调用的方法称称为虚方法。 /** * 解析调用中非虚方法、虚方法的测试 */ class Father { public Father(){ System.out.println(\"Father默认构造器\"); } public static void showStatic(String s){ System.out.println(\"Father show static\"+s); } public final void showFinal(){ System.out.println(\"Father show final\"); } public void showCommon(){ System.out.println(\"Father show common\"); } } public class Son extends Father{ public Son(){ super(); } public Son(int age){ this(); } public static void main(String[] args) { Son son = new Son(); son.show(); } //不是重写的父类方法，因为静态方法不能被重写 public static void showStatic(String s){ System.out.println(\"Son show static\"+s); } private void showPrivate(String s){ System.out.println(\"Son show private\"+s); } public void show(){ //invokestatic showStatic(\" 大头儿子\"); //invokestatic super.showStatic(\" 大头儿子\"); //invokespecial showPrivate(\" hello!\"); //invokespecial super.showCommon(); //invokevirtual 因为此方法声明有final 不能被子类重写，所以也认为该方法是非虚方法 showFinal(); //虚方法如下 //invokevirtual showCommon();//没有显式加super，被认为是虚方法，因为子类可能重写showCommon info(); MethodInterface in = null; //invokeinterface 不确定接口实现类是哪一个 需要重写 in.methodA(); } public void info(){ } } interface MethodInterface { void methodA(); } 关于invokedynamic指令 JVM字节码指令集一直比较稳定，一直到java7才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进 但是java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令，直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接生成方式 Java7中增加的动态语言类型支持的本质是对java虚拟机规范的修改，而不是对java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在java平台的动态语言的编译器 动态类型语言和静态类型语言 动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言。 直白来说 静态语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征 Java是静态类型语言（尽管lambda表达式为其增加了动态特性），js，python是动态类型语言. Java：String info = \"硅谷\";//静态语言 JS：var name = \"硅谷“；var name = 10;//动态语言 Pythom: info = 130;//更加彻底的动态语言 方法重写的本质 找到操作数栈的第一个元素所执行的对象的实际类型，记作C。 如果在类型C中找到与常量池中的描述符、简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。IllegalAccessError介绍 程序视图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。 否则，按照继承关系从下往上依次对c的各个父类进行第二步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 虚方法表 在面向对象编程中，会很频繁期使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，jvm采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 那么虚方法表什么时候被创建？ 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，jvm会把该类的虚方法表也初始化完毕。 4.方法返回地址（或方法正常退出或者异常退出的定义）​ 存放调用该方法得到PC寄存器的值 ​ 一个方法的结束，有正常执行完成和出现未处理的异常从而非正常退出两种方式，无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条地址。如果是异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分的信息。 ​ 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。 ​ 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。 5.一些附加信息栈帧中还允许携带与java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。（很多资料都忽略了附加信息） 开发过程中，关于虚拟机栈可能的异常？ Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。 如果采用固定大小的虚拟机栈，拿每一个线程的Java虚拟机栈容量可以再线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机会抛出一个StackOverflowError的异常。在开发过程中，不合理的递归方法就会导致这个问题。 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMerroyError异常。 public class Test{ public static void m(){ m(); } public static void main(String[] args) { System.out.println(\"111\"); //Exception in thread \"main\" java.lang.StackOverflowError m(); System.out.println(\"222\"); } } /* *output: * 111 * Exception in thread \"main\" java.lang.StackOverflowError * */ 注意： StackOverflowError是一个“错误”，而不是“异常”。 关于Error我们再多说一点，上面的讨论不涉及Exception 首先Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。 Exception和Error体现了JAVA这门语言对于异常处理的两种方式。 Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。 Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。 其中的Exception又分为检查性异常和非检查性异常。两个根本的区别在于，检查性异常 必须在编写代码时，使用try catch捕获（比如：IOException异常）。非检查性异常 在代码编写使，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。 虚拟机栈的相关面试题1.举例栈溢出的情况？（StackOverflowError） 递归调用等，通过-Xss设置栈的大小； 2.调整栈的大小，就能保证不出现溢出么？ 不能 如递归无限次数肯定会溢出，调整栈大小只能保证溢出的时间晚一些，极限情况会导致OOM内存溢出（Out Of Memery Error）注意是Error 3.分配的栈内存越大越好么？ 不是 ，会挤占其他线程的空间 4.垃圾回收是否会涉及到虚拟机栈？ 不会 5.方法中定义的局部变量是否线程安全？ 具体问题具体分析，如果是线程内部产生内部消亡的，那一定是线程安全的，如果是外部传入或者是要返回到外部的局部变量，是线程不安全的，就是要注意局部变量的生命周期。 注意： HotSpot：如果没有明确指明，JDK的名字就叫HotSpot 元数据：描述数据的数据（即模板，也就是“大Class”）上面的关系图的一个实例为下图： 堆 核心概述 一个JVM实例值存在一个堆内存，堆也是Java内存管理的核心区域。 Java堆区在JVM启动的时候就被创建了，其空间大小也就确定了，是JVM管理的最大一块内存空间。《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（TLAB，Thread Local Allocation Buffer）。《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上（但并不是全部）。数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。堆，是GC（垃圾收集器）执行垃圾回收的重点区域。 注意： Java 7之前和图上一模一样，Java 8把永久区换成了元空间（方法区） 堆逻辑上由”新生+养老+元空间“三个部分组成，物理上由”新生+养老“两个部分组成 当执行new Person()；时，其实是new在新生区的伊甸园区，然后往下走，走到养老区，但是并未到元空间。 虽然说，逻辑上是将堆空间划分为新生代、老年代和永久代三部分，实际上是不考虑永久代（也就是Java8中提到的元空间）的，可以将其看做是方法区的落地实现。 注意： GC发生在伊甸园区，当对象快占满新生代时，就会发生YGC（Young GC，轻量级GC）操作，伊甸园区基本全部清空 幸存者0区(S0)，别名“from区”。伊甸园区没有被YGC清空的对象将移至幸存者0区，幸存者1区别名“to 区” 每次进行YGC操作，幸存的对象就会从伊甸园区移到幸存者0区，如果幸存者0区满了，就会继续往下移，如果经历数次YGC操作对象还没有消亡，最终会来到养老区 如果到最后，养老区也满了，那么就对养老区进行FGC(Full GC，重GC)，对养老区进行清洗 如果进行了多次FGC之后，还是无法腾出养老区的空间，就会报OOM（out of Memory）异常 from区和to区位置和名分不是固定的，每次GC过后都会交换，GC交换后，谁空谁是to区 大对象直接进入养老区，大对象就是需要大量连续内存空间的对象（比如：字符串、数组），为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。 注意： 整个堆分为新生区和养老区，新生区占整个堆的1/3，养老区占2/3。新生区又分为3份：伊甸园区：幸存者0区(from区):幸存者1区(to区) = 8:1:1 每次从伊甸园区经过GC幸存的对象，年龄(代数)会+1 -XX:MaxTenuringThreshold=15调整多少代进入老年区 关于默认的晋升年龄是15，这个说法的来源大部分都是《深入理解Java虚拟机》这本书。 如果你去Oracle的官网阅读相关的虚拟机参数，你会发现-XX:MaxTenuringThreshold=threshold这里有个说明 Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector. 默认晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6. 堆空间的分代思想 为什么需要把Java堆分代？不分代就不能正常工作了吗？ 经研究，不同对象的生命周期不同，70%-90%的对象是临时对象。 TLAB（Thread Local Allocation Buffer）我们知道，堆区是线程共享区域，任何线程都可以访问到堆区的共享数据，由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度，TLAB就是为了解决这一问题。 什么是TLAB？ 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配一个私有缓存区域，它包含在Eden空间内。 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但是JVM确实是将TLAB作为内存分配的首选。 在程序中，开发人员通过”-XX:UseTLAB”设置是否开启TLAB空间（可以通过 jinfo -flag UseTLAB 线程号 查询是否开启）。 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的１％，可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。 ​ 加入TLAB后的对象分配过程 注意： 临时对象就是说明，其在伊甸园区生，也在伊甸园区死。 堆逻辑上由”新生+养老+元空间“三个部分组成，物理上由”新生+养老“两个部分组成，元空间也叫方法区 永久代(方法区)几乎没有垃圾回收，里面存放的都是加载的rt.jar等，让你随时可用 注意 上面的图展示的是物理上的堆，分为两块，新生区和养老区。 堆的参数主要有两个：-Xms，Xmx： -Xms堆的初始化的内存大小 -Xmx堆的最大内存 Young Gen(新生代)有一个参数-Xmn，这个参数可以调新生区和养老区的比例。但是，这个参数一般不调。 永久代也有两个参数：-XX:PermSize，-XX:MaxPermSize，可以分别调永久代的初始值和最大值。Java 8 后没有这两个参数啦，因为Java 8后元空间不在虚拟机内啦，而是在本机物理内存中 //查看自己机器上的默认堆内存和最大堆内存 public class Test{ public static void main(String[] args) { System.out.println(Runtime.getRuntime().availableProcessors()); //返回 Java虚拟机试图使用的最大内存量。物理内存的1/4（-Xmx） long maxMemory = Runtime.getRuntime().maxMemory() ; //返回 Java虚拟机中的内存总量(初始值)。物理内存的1/64（-Xms） long totalMemory = Runtime.getRuntime().totalMemory() ; System.out.println(\"MAX_MEMORY =\" + maxMemory +\"(字节)、\" + (maxMemory / (double)1024 / 1024) + \"MB\"); System.out.println(\"DEFALUT_MEMORY = \" + totalMemory + \" (字节)、\" + (totalMemory / (double)1024 / 1024) + \"MB\"); } } /* * 8 MAX_MEMORY =1868038144(字节)、1781.5MB TOTAL_MEMORY = 126877696 (字节)、121.0MB * */ 注意：JVM参数调优，平时可以随便挑初始大小和最大大小，但是实际工作中，初始大小和最大大小应该是一致的，原因是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。避免内存忽高忽低产生停顿 IDEA 的JVM内存配置 点击Run列表下的Edit Configuration 在VM Options中输入以下参数:-Xms1024m -Xmx1024m -XX:+PrintGCDetails。 运行程序查看结果 把堆内存调成10M后，再一直new对象，导致Full GC也无法处理，直至撑爆堆内存，查看堆溢出错误(OOM)，程序及结果如下： GC收集日志信息详解 第一次进行YGC相关参数：[PSYoungGen: 2008K-&gt;482K(2560K)] 2008K-&gt;782K(9728K), 0.0011440 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 最后一次进行FGC相关参数：[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 4025K-&gt;4005K(7168K)] 4025K-&gt;4005K(9216K), [Metaspace: 3289K-&gt;3289K(1056768K)], 0.0082055 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 面试题：GC是什么（分代收集算法） 次数上频繁收集Young区 次数上较少收集Old区 基本不动元空间 面试题：GC的四大算法（后有详解） 引用计数法 复制算法(Copying) 标记清除(Mark-Sweep) 标记压缩(Mark-Compact) 面试题：下面程序中，有几个线程在运行Answer:有两个线程，一个是main线程，一个是后台的gc线程。 知识点： JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC or Young GC），一种是全局GC（major GC or Full GC） Minor GC和Full GC的区别 * 普通GC（minor GC）：只针对新生代区域的GC,指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快。 全局GC（major GC or Full GC）：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上 (因为养老区比较大，占堆的2/3) 对象实例化 从创建对象的执行步骤来分析 对象的创建过程： 判断对象对应的类是否加载、链接、初始化。虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象。 为对象分配内存。首先计算对象占用空间大小，接着在堆中划分一块内存给新对象，如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。如果内存是规整的，那么虚拟机将采用指针碰撞法来为对象分配内存。假设java堆中内存是绝对规整的，所有用过的内存放一边，未使用过的放一边，中间有一个指针作为临界点，如果新创建了一个对象则是把指针往未分配的内存挪动与对象内存大小相同距离，这个称为指针碰撞。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有整理过程的收集器时使用指针碰撞；如果内存不规整，则使用空闲列表法（Free List）。事实上，Java堆的内存并不是完整的，已分配的内存和空闲内存相互交错，JVM通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。使用的GC收集器：CMS，适用堆内存不规整的情况下。 处理并发安全问题。在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：一是采用CAS， CAS 是乐观锁的一种实现方式。所谓乐观锁就是每次不加锁，而是假设没有冲突而去完成某项操作，如果因为冲突失败，就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性；二是为每个线程预先分配一块TLAB——通过-XX:+/-UseTLAB参数来设定（JDK8及之后默认开启），为每一个线程预先分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。 初始化分配到的空间。所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用。（这里要区别一下类加载过程的准备阶段） 设置对象的对象头。将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM的实现。 执行init方法进行初始化。在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。 对象的访问定位 一、句柄访问。虚拟机栈的局部变量表中记录了对象引用，指向堆空间中对应的句柄，句柄位于Java堆空间的句柄池中，一个句柄包含两个指针，分别是到堆空间的实例池的对应对象实例数据的指针和到方法区的对象类型数据的指针。 二、直接指针，虚拟机栈的局部变量表中记录的对象引用直接指向了对象实例数据，而在对象实例数据中有一个到对象类型数据的指针，指向方法区中相应的对象类型数据。HotSpot采用的就是这种直接指针法。 三、两者比较。两种访问定位方式各有优劣，一方面，很明显直接指针法要比句柄访问的效率高一些，另一方面，对于句柄访问而言，reference中存储稳定的句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只需改变句柄中实例数据指针即可，reference本身不需要被修改，而对于直接指针而言，对象移动的话reference也要修改。 逃逸分析-堆是分配对象存储的唯一选择吗？ 随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识，但是，有一种特殊的情况，就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就有可能被优化成栈上分配。这样就无需在堆上分配内存，也无需进行垃圾回收了。这也是常见的堆外存储技术。 此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移到heap外，并且GC 不能管理GCIH内部的Java对象，以此达到降低GC回收频率跟提升GC的回收效率的目的。 逃逸分析 如何将堆上的对象分配到栈，需要使用逃逸分析手段。 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 逃逸分析的基本行为就是分析对象的动态作用域: 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸，那就使用栈上分配，随着方法执行的结束，栈空间就被移除。当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如，作为调用参数传递到其他地方中。几种常见的情况进行逃逸分析： public class EscapeAnalysis { public EscapeAnalysis obj; /* *方法返回EscapeAnalysis对象，发生逃逸 */ public EscapeAnalysis getInstance(){ return obj == null ? new EscapeAnalysis() : obj; } /* *为成员属性赋值，发生逃逸 */ public void setObj(){ this.obj = new EscapeAnalysis(); } /* * 对象的作用域只在当前方法中有效，没有发生逃逸 */ public void useEscapeAnalysis(){ EscapeAnalysis escapeAnalysis = new EscapeAnalysis(); } /* *引用成员变量的值，发生逃逸 */ public void useEscapeAnalysis1(){ EscapeAnalysis escapeAnalysis = getInstance(); } } 在JDK 6u23之后，HotSpot就默认开启了逃逸分析，较早的版本可以通过“-XX:+DoEscapeAnalysis”显示开启逃逸分析，“-XX: +PrintEscapeAnalysis”查看逃逸分析的筛选结果。 为了提高性能，使用逃逸分析，编译器可以对代码做如下优化： 栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配，这就要求开发中能使用局部变量的，就不要在方法外定义。同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。线程同步的代价是相当高的，同步的后果是降低并发性和性能。在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步，这个过程就叫做同步省略，也叫锁消除。分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。所谓标量，是指一个无法再分解成更小的数据的数据，Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量。在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个成员变量来代替，这个过程就是标量替换。可以通过-XX:+EliminateAllocation开启标量替换，默认是打开的，允许将对象打散分配在栈上。 其实即使到如今逃逸分析技术也不是特别成熟，其根本原因就是无法保证逃逸分析的性能消耗一定能低于其他的消耗，虽然经过逃逸分析可以以做标量替换、栈上分配和锁消除，但是逃逸分析本身也是需要进行一系列复杂的分析的。一个比较极端的例子就是，经过逃逸分析后，发现没有一个对象是不逃逸的，那这个逃逸分析的过程就白白浪费掉了。 四类垃圾收集器Java 8可以将垃圾收集器分为四类。 串行垃圾收集器Serial为单线程环境设计且只使用一个线程进行GC，会暂停所有用户线程，不适用于服务器。就像去餐厅吃饭，只有一个清洁工在打扫。 并行垃圾收集器Parrallel使用多个线程并行地进行GC，会暂停所有用户线程，适用于科学计算、大数据后台，交互性不敏感的场合。多个清洁工同时在打扫。停顿的时间会比串行垃圾收集器短。 并发垃圾收集器CMS用户线程和GC线程同时执行（不一定是并行，交替执行），GC时不需要停顿用户线程，互联网公司多用，适用对响应时间有要求的场合。清洁工打扫的时候，也可以就餐。 G1垃圾收集器对内存的划分与前面3种很大不同，G1将堆内存分割成不同的区域，然后并发地进行垃圾回收。 默认收集器有哪些？ 有Serial、Parallel、ConcMarkSweep（CMS）、ParNew、ParallelOld、G1。还有一个SerialOld，快被淘汰了。 查看默认垃圾收集器 使用java -XX:+PrintCommandLineFlags即可看到，**Java 8默认使用-XX:+UseParallelGC**。 -XX:InitialHeapSize=132375936 -XX:MaxHeapSize=2118014976 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 七大垃圾收集器(上面四种垃圾收集器的实现，重要！) 七种回收器的使用： Serial(串行) Parallel Scavenge(并行) ParNew(只在新生代使用并行)； SerialOld(原本用在养老区，已经不用啦) ParallelOld(老年代的并行) CMS(并发标记清除，用于回收老年代) G1收集器，既可以回收新生代，也可以回收老年代。 连线表示可以搭配使用，红叉表示不推荐一同使用，比如新生代用Serial，老年代用CMS搭配使用。并且，配置好新生代后，会默认配置好老年代相搭配的回收器。 1. Serial收集器（Serial/Serial Copying）一句话：一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。 串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在进行垃圾收集过程中可能会产生较长的停顿（Stop- The-World”状态）。虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是java虛拟机运行在 Client模式下默认的新生代垃圾收集器。其使用复制算法： 优点：单个线程收集，没有线程切换开销，拥有最高的单线程GC效率 缺点：收集的时候会暂停用户线程。 使用-XX:+UseSerialGC可以显式开启，开启后默认使用Serial+SerialOld的组合。 2. ParNew收集器ParNew收集器其实就是 Seria收集器新生代的并行多线程版本，最常见的应用场景是配合老年代的 CMS GC工作，其余的行为和Seria收集器完全一样， ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。它是很多java虚拟机运行在 Server的默认新生代收集器，采用复制算法。 使用-XX:+UseParNewGC可以显式开启，开启后默认使用ParNew+SerialOld的组合。但是由于SerialOld已经过时，所以建议配合CMS使用。ParNew收集器只影响新生代，不影响老年代。 3. Parallel Scavenge收集器(JDK 1.8后默认)ParNew收集器仅在新生代使用多线程收集，老年代默认是SerialOld，所以是单线程收集。而Parallel Scavenge在新、老两代都采用多线程收集。Parallel Scavenge还有一个特点就是吞吐量优先收集器，可以通过自适应调节，保证最大吞吐量。采用复制算法。 它重点关注的是:可控制的吞吐量（ Thoughput = 运行用户代码时间/ (运行用户代码时间+垃圾收集时间），也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99％）。高吞吐量意味着高效利用CPU的时间，它多用于在后台运算而不需要太多交互的任务。 自适应调节策略也是parallelScavenge收集器与 ParNew收集器的一个重要区别。（自适应调节策略:虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间: MaxGCPause Millis）或最大的吞吐量。 常用JVM参数: XX: +Use ParallelGC或-XX:+ Use ParallelOldGC（可互相激活）使用 Paralle！ Scavenge收集器开启该参数后:新生代使用复制算法，老年代使用标记-整理算法。 使用-XX:+UseParallelGC可以开启， 同时也会使用ParallelOld收集老年代。其它参数，比如-XX:ParallelGCThreads=N可以选择N个线程进行GC，-XX:+UseAdaptiveSizePolicy使用自适应调节策略。 4. SerialOld收集器Serial Old是 Seria 垃圾收集器老年代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的老年代垃圾收集器。 在 Server模式下，主要有两个用途（了解，版本已经到8及以后） 在JDK1.5之前版本中与新生代的 Parallel Scavenge收集器搭配使用。（ Parallel Scavenge+ Serial old） 作为老年代版中使用CMS收集器的后备垃圾收集方案 5. ParallelOld收集器Parallel Old收集器是 Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，parallel Old收集器在JDK1.6才开始提供。 在JDK1.6之前，新生代使用 ParalleIScavenge收集器只能搭配年老代的 Serial old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6之前（ Parallel Scavenge+ Serial old），Parallel old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8后可以优先考虑新生代Parallel Scavenge和老年代 Parallel old收集器的搭配策略。在JDK1.8及后（ Parallel Scavenge+ Parallel old） 使用-XX:+UseParallelOldGC可以开启， 同时也会使用Parallel收集新生代(JDK 1.8之后默认的就是这种组合)。 6. CMS收集器CMS并发标记清除收集器，是标记清除(Mark-Sweep)算法的实现，是一种以获得最短GC停顿为目标的收集器。适用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望停顿时间最短。是G1收集器出来之前大型应用的首选收集器。 在GC的时候，会与用户线程并发执行，不会停顿用户线程。但是在标记的时候，仍然会STW，只不过时间非常短。 使用-XX:+UseConcMarkSweepGC开启。开启过后，新生代默认使用ParNew，如果CMS收集效果不太理想，老年代会使用SerialOld作为CMS的后备收集器。 CMS有四步过程： 初始标记：只是标记一下GC Roots能直接关联的对象，速度很快，需要STW(暂停所有的工作线程)。 并发标记：主要标记过程，标记全部对象，和用户线程一起工作，不需要STW。 重新标记：修正在并发标记阶段出现的变动，需要STW。 并发清除：和用户线程一起，清除垃圾，不需要STW。 优缺点优点：停顿时间少，响应速度快，用户体验好 **(并发收集低停顿)**。 缺点： 由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间 对CPU资源非常敏感：由于需要并发工作，多少会占用系统线程资源。 无法处理浮动垃圾：由于标记垃圾的时候，用户进程仍然在运行，无法有效处理新产生的垃圾。 产生内存碎片：由于使用标记清除算法，会产生内存碎片。 回收器的选择： 7. G1收集器G1（Garbage-First）收集器，是一款面向服务器端应用的收集器。 G1收集器与之前垃圾收集器的一个显著区别就是——之前收集器都有三个区域，新、老两代和元空间。**而G1收集器只有G1区(garbage-first heap)和元空间(Metaspace)**。而G1区，不像之前的收集器，分为新、老两代，而是一个一个Region，每个Region既可能包含新生代，也可能包含老年代。 G1收集器既可以提高吞吐量，又可以减少GC时间。最重要的是STW可控，增加了预测机制，让用户指定停顿时间。 CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器——G1垃圾收集器。 主要改变是Eden， Survⅳor和 Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的 region，每个 region从1M到32M不等。一个 region有可能属于Eden， Survivor或者 Tenured内存区域。 G1收集器的设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色，G1与CMS的区别： G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。 G1的 Stop The World（STW）更可控，G1在停顿时间上添加预测机制，用户可以指定期望停顿时间 G1整理空闲空间更快 G1需要更多的时间来预测GC停顿的时间 G1不希望牺牲大量的吞吐性能 G1不需要更大的Java Heap 使用-XX:+UseG1GC开启，还有-XX:G1HeapRegionSize=n、-XX:MaxGCPauseMillis=n等参数可调。 特点对比： G1之前收集器的特点： 年轻代和老年代是各自独立且连续的内存块； 年轻代收集使用单Eden+S0+S1进行复制算法； 老年代收集必须扫描整个老年代区域； 都是以尽可能少而快速地执行GC为设计原则。 G1收集器的特点： 并行和并发：像CMS一样，能与应用程序线程并发执行。充分利用多核、多线程CPU，尽量缩短STW 分代收集：虽然还保留着新、老两代的概念（逻辑上分代），但物理上不再隔离，而是融合在Region中，Region也不要求连续，且会采用不同的GC方式处理不同的区域 空间整合：G1整体上看是标整算法，在局部看又是复制算法，不会产生内存碎片 可预测停顿：用户可以指定一个GC停顿时间，G1收集器会尽量满足 G1过程与CMS类似，最大的好处是化整为零，只需要按照区域来进行扫描即可。 在堆的使用上，G1并不要求对象的存储一定是物理上连续的只要逻辑上连续即可，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n可指定分区大小（1MB~32MB，且必须是2的幂），默认将整堆划分为2048个分区。 大小范围在1MB~32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048=65536MB=64G 内存。 G1 YGC过程： 针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片 Eden区数据移动到Survivor区，假如出现Survivor区空间不够，Eden区数据会部分晋升到Old区 Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区 最后Eden区收拾干净了，GC结束，用户的应用程序继续执行 G1收集过程小结： 初始标记。 并发标记。 最终标记。 筛选回收。 判断对象已经死亡堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。 引用计数法给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。 public class ReferenceCountingGc { Object instance = null; public static void main(String[] args) { ReferenceCountingGc objA = new ReferenceCountingGc(); ReferenceCountingGc objB = new ReferenceCountingGc(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; } } 可达性分析算法这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。 再谈引用无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。 JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。 JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱） 1．强引用（StrongReference） 以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 2．软引用（SoftReference） 如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。 3．弱引用（WeakReference） 如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。 4．虚引用（PhantomReference） “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。 虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。 不可达的对象并非“非死不可”即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。 如何判断一个常量是废弃常量运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？ 假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。 注意： JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 如何判断一个类是无用的类方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。 GC四大算法详解：1. 引用计数法（现在一般不采用） 代码示例如下：虽然objectA和objectB都置空，但是他们之前曾发生过相互引用，所以调用system.gc（手动版唤醒GC，后台也开着自动档）并不能进行垃圾回收。并且，system.gc执行完之后也不是立刻执行垃圾回收。 注意：在实际工作中，禁用system.gc() !!! 2. 复制算法(Copying)年轻代中使用的是Minor GC（YGC），这种GC算法采用的是复制算法(Copying)。 Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，即一旦收集后，Eden是就变成空的了。 当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过 -XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。 -XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数 年轻代中的GC,主要是复制算法（Copying）。 HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块(from)，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法的优点是不会产生内存碎片，缺点是耗费空间。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 上面动画中，Area空闲代表to，Area激活代表from，绿色代表不被回收的，红色代表被回收的。 复制算法它的缺点也是相当明显的: 它浪费了一半的内存，这太要命了。 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。 3 .标记清除(Mark-Sweep)复制算法的缺点就是费空间，其是用在年轻代的，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。 用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。 主要进行两项工作，第一项则是标记，第二项则是清除。 标记：从引用根节点开始标记遍历所有的GC Roots， 先标记出要回收的对象。 清除：遍历整个堆，把标记的对象清除。 缺点：此算法需要暂停整个应用，会产生内存碎片 标记清除算法小结： 1、首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止 应用程序，这会导致用户体验非常差劲 2、其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。 4. 标记压缩(Mark-Compact)标记压缩(Mark-Compact)又叫标记清除压缩(Mark-Sweep-Compact)，或者标记清除整理算法。老年代一般是由标记清除或者是标记清除与标记整理的混合实现 面试题：四种算法那个好Answer：没有那个算法是能一次性解决所有问题的，因为JVM垃圾回收使用的是分代收集算法，没有最好的算法，只有根据每一代他的垃圾回收的特性用对应的算法。新生代使用复制算法，老年代使用标记清除和标记整理算法。没有最好的垃圾回收机制，只有最合适的。 面试题：请说出各个垃圾回收算法的优缺点 内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。 内存整齐度：复制算法=标记整理算法&gt;标记清除算法。 内存利用率：标记整理算法=标记清除算法&gt;复制算法。 可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程 难道就没有一种最优算法吗？Java 9 之后出现了G1垃圾回收器，能够解决以上问题，有兴趣参考这篇文章。 总结： 年轻代(Young Gen)年轻代特点是区域相对老年代较小，对象存活率低。 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。 老年代(Tenure Gen) 老年代的特点是区域较大，对象存活率高。 这种情况，存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。 Mark（标记）阶段的开销与存活对象的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。 Sweep（清除）阶段的开销与所管理区域的大小正相关，但Sweep“就地处决”的特点，回收的过程没有对象的移动。使其相对其它有对象移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。 Compact（压缩）阶段的开销与存活对像的数量成正比，如上一条所描述，对于大量对象的移动是很大开销的，做为老年代的第一选择并不合适。 基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。 JMM1.什么是JMM？JMM：（Java Memory Model 的缩写）JAVA 内存模型 2.作用是什么？作用：缓存一致性协议，用于定义数据读写规则JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory） JMM规定了内存主要划分为主内存和工作内存两种。此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的层次上进行的，如果非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域，从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。 解决共享对象可见性问题：volatile或者synchronized 同步机制 内存交互操作 内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外） lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态 unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用 load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中 use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令 assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中 store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用 write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中 JMM对这八种指令的使用，制定了如下规则： 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 不允许一个线程将没有assign的数据从工作内存同步回主内存 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 对一个变量进行unlock操作之前，必须把此变量同步回主内存 JMM对这八种操作规则和对volatile的一些特殊规则就能确定哪些操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。 happens-before原则： Java内存模型中定义的两项操作之间的次序关系，如果说操作A先行发生于操作B，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。 下面是Java内存模型下一些”天然的“happens-before关系，这些happens-before关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。 a.程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。 b.管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于对同一个锁的lock操作的后面。lock先于unlock c.volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作。volatile变量写先于读。 d.线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。 e.线程终于规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。 f.线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。中断先于中断检测 g.对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。 f.传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。 Java编译与解释编程语言分为低级语言和高级语言，机器语言、汇编语言是低级语言，C、C++、java、python等是高级语言。机器语言是最底层的语言，能够直接执行。而我们编写的源代码是人类语言, 计算机只能识别某些特定的二进制指令，在程序真正运行之前必须将源代码转换成二进制指令。汇编语言通过汇编器翻译成机器指令后执行，一条汇编指令，对应着一条机器指令。高级语言编程的程序有三种执行方式： 1.一种是编译执行，源程序先通过编译器（负责将源程序翻译成目标机器指令）翻译成机器指令，通过编译–&gt;链接–&gt;目标可执行文件，然后执行；即提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序。比如C，C++等语言都是编译执行的。 2.一种是解释执行，是使用解释器会将我们的一句句代码解释成机器可以识别的二进制代码来执行，可以认为是，解释一句，执行一句。在这个过程中，不会生成中间文件。如：脚本方式是一条条命令，在执行时，是由系统的解释器，将其一条条翻译成机器可识别的指令，例如shell脚本是由shell程序执行的，js是由浏览器解释执行的。 3.最后一种是编译和解释相结合的执行方式，比如Java。 理解Java的几个编译器前端编译器：把.java文件转变成.class文件。包括Sun的Javac、Eclipse JDT中的增量式编辑器（ECJ） 后端运行期即时编译器（JIT编译器，Just In Time Compiler）：把字节码转成机器码。包括HotSpot VM的C1、C2编译器 静态提前编译器（AOT编译器，Ahead Of Time Compiler）：把*.java编译成本地机器码。包括GNU Compiler for the Java（GCJ）、Excelsior JET Java采用的是解释和编译混合的模式在编译时期，我们通过将源代码编译成.class ，配合JVM这种跨平台的抽象，屏蔽了底层计算机操作系统和硬件的区别，实现了“一次编译，到处运行” 。 而在运行时期，目前主流的JVM 都是混合模式（-Xmixed），即解释运行和编译运行配合使用。 Java一开始被定位为“解释执行”的语言，但是现在主流的虚拟机中都包含了即时编译器JIT。 程序从源代码到运行经历阶段：java程序–（编译javac）–&gt;字节码文件.class–&gt;类装载子系统化身为反射类Class—&gt;运行时数据区—&gt;（解释执行+JIT编译器编译）–&gt;操作系统（Win，Linux，Mac JVM）。 .class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码，这是是由JVM来执行的，即Java的第二次编译。 Java采用的是解释和编译混合的模式:基于JVM执行引擎当中的解释器interpreter与即使编译器JIT共存 执行引擎获取到由javac将源码编译成的字节码文件class，然后在运行的时候通过解释器interpreter转换成最终的机器码。（解释型） 另外JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，这种方式可以使执行效率大幅度提升（直接编译型） JIT将字节码转换成最终的机器码：以 Oracle JDK提供的HotSpot虚拟机为例，在HotSpot虚拟机中，提供了两种编译模式：解释执行 和 即时编译（JIT，Just-In-Time）。 解释执行即逐条翻译字节码为可运行的机器码，而即时编译则以方法为单位将字节码翻译成机器码（上述提到的“编译执行”）。前者的优势在于不用等待，后者则在实际运行当中效率更高。 即时编译存在的意义在于它是提高程序性能的重要手段之一。根据“二八定律”（即：百分之二十的代码占据百分之八十的系统资源），对于大部分不常用的代码，我们无需耗时间将之编译为机器码，而是采用解释执行的方式，用到就去逐条解释运行；对于一些仅占据小部分的热点代码（可认为是反复执行的重要代码），则可将之翻译为符合机器的机器码高效执行，提高程序的效率，即运行时的即时编译。 为了满足不同的场景，HotSpot虚拟机内置了多个即时编译器：C1,C2与Graal。Graal 是Java10正式引入的实验性即时编译器，在此暂不叙述。先看一下C1、C2 ，相信大家或多或少接触过。 C1：即Client编译器，面向对启动性能有要求的客户端GUI程序，采用的优化手段比较简单，因此编译的时间较短。 C2：即Server编译器，面向对性能峰值有要求的服务端程序，采用的优化手段复杂，因此编译时间长，但是在运行过程中性能更好。 从Java7开始，HotSpot虚拟机默认采用分层编译的方式：热点方法首先被C1编译器编译，而后 热点方法中的热点再进一步被C2编译，根据前面的运行计算出更优的编译优化。为了不干扰程序的正常运行，JIT编译时放在额外的线程中执行的，HotSpot根据实际CPU的资源，以 1:2的比例分配给C1和C2线程数。在计算机资源充足的情况，字节码的解释运行和编译运行时可以同时进行，JIT编译执行完后的机器码会在下次调用该方法时启动，已替换原本的解释执行（意思就是已经翻译出效率更高的机器码，自然替换原来的相对低效率执行的方法）。 以上，可以看出在Java中不单单是解释执行，即时编译（编译执行）在Java性能优化中彰显重要的作用，所以现在应该说：Java是解释执行和编译执行共同存在的，至少大部分是这样。 编译与解释比较？1.一段程序编译会浪费时间，并且移植到其他平台上时还要进行重新编译，但是其编译后生成的可执行文件运行速度快。 2.解释型程序可跨平台执行，无需将全部代码编译之后再运行，能够及时运行，但因为是逐条解释执行所以最终的运行速度不如编译型程序。 3.内存使用：编译执行需要生成编译后的机器码文件，而解释执行时逐句解释执行，所以解释执行对内存占用更少。 单独使用解释器的缺点： 抛弃了JIT可能带来的性能优势。如果代码没有被JIT编译的话，再次运行时需要重复解析。 单独使用JIT编译器的缺点： 需要将全部的代码编译成本地机器码。要花更多的时间，JVM启动会变慢非常多； 增加可执行代码的长度（字节码比JIT编译后的机器码小很多），这将导致页面调度，从而降低程序的速度。 有些JIT编译器的优化方式，比如分支预测，如果不进行profiling，往往并不能进行有效优化。 因此，HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。 JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。 注：JIT为方法级，它会缓存编译过的字节码在CodeCache中，而不需要被重复解释。","categories":[],"tags":[]},{"title":"","slug":"JUC","date":"2021-09-14T08:22:09.671Z","updated":"2021-09-14T08:22:10.034Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"1.什么是JUC java.util工具包 业务: 普通的线程代码, 之前都是用的thread或者runnable接口 但是相比于callable来说,thread没有返回值,且效率没有callable高 2.线程和进程 线程,进程 进程 : 一个运行中的程序的集合; 一个进程往往可以包含多个线程,至少包含一个线程 java默认有几个线程? 两个， main线程 和 gc线程 线程 : 线程（thread）是操作系统能够进行运算调度的最小单位。 对于java而言如何创建thread: 继承自thread,实现runnable接口,实现callable接口,线程池创建 Java真的可以开启线程吗? 开不了的,底层是用native关键词修饰.调用本地实现 public synchronized void start() { /** * This method is not invoked for the main method thread or \"system\" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } //本地方法,调用底层c++, java无法操作硬件 private native void start0(); 并发,并行 并发编程: 并发和并行 并发(多线程操作同一个资源,交替执行) CPU一核, 模拟出来多条线程,天下武功,唯快不破,快速交替 并行(多个人一起行走, 同时进行) CPU多核,多个线程同时进行 ; 使用线程池操作 public static void main(String[] args) { //获取CPU核数 //CPU 密集型,IO密集型 System.out.println(Runtime.getRuntime().availableProcessors()); } 并发编程的本质: 充分利用CPU的资源 所有的公司都很看重! 线程有几个状态? public enum State { // 新生 NEW, // 运行 RUNNABLE, // 阻塞 BLOCKED, // 等待 WAITING, //超时等待 TIMED_WAITING, //终止 TERMINATED; } wait/sleep的区别 1.来自不同的类 wait来自object类, sleep来自线程类 2.关于锁的释放 wait会释放锁, sleep不会释放锁 3.使用的范围不同 wait必须在同步代码块中 sleep可以在任何地方睡 4.是否需要捕获异常 wait不需要捕获异常 sleep需要捕获异常 3.Lock锁(重点)在java的锁的实现上就有共享锁和独占锁的区别，而这些实现都是基于AbstractQueuedSynchronizer对于共享同步和独占同步的支持。 独占模式 AbstractQueuedSynchronizer（AQS）使用一个volatile类型的int来作为同步变量，任何想要获得锁的线程都需要来竞争该变量，获得锁的线程可以继续业务流程的执行，而没有获得锁的线程会被放到一个FIFO的队列中去，等待再次竞争同步变量来获得锁。 锁的独占与共享 java并发包提供的加锁模式分为独占锁和共享锁，独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁。共享锁，则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。AQS的内部类Node定义了两个常量SHARED（共享）和EXCLUSIVE（独占），他们分别标识 AQS队列中等待线程的锁获取模式。 很显然，独占锁是一种悲观保守的加锁策略，它避免了读/写冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 java 的并发包中提供了ReadWriteLock，读-写锁。**它允许一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行**。 锁的公平与非公平 锁的公平与非公平，是指线程请求获取锁的过程中，是否允许插队。在公平锁上，线程将按他们发出请求的顺序来获得锁；而非公平锁则允许在线程发出请求后立即尝试获取锁，如果可用则可直接获取锁，尝试失败才进行排队等待。ReentrantLock提供了两种锁获取方式，FairSyn和NofairSync。**结论：ReentrantLock是以独占锁的加锁策略实现的互斥锁，同时它提供了公平和非公平两种锁获取方式**。 AQS提供的模板方法 AQS提供了独占锁和共享锁必须实现的方法，具有独占锁功能的子类，它必须实现tryAcquire、tryRelease、isHeldExclusively等；共享锁功能的子类，必须实现tryAcquireShared和tryReleaseShared等方法，带有Shared后缀的方法都是支持共享锁加锁的语义。Semaphore是一种共享锁，ReentrantLock是一种独占锁。 独占锁获取锁时，设置节点模式为Node.EXCLUSIVE public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 共享锁获取锁，节点模式则为Node.SHARED private void doAcquireShared(int arg) { final Node node = addWaiter(Node.SHARED); boolean failed = true; ..... } 对ConditionObject的认识 ReentrantLock是独占锁，而且AQS的ConditionObject只能与ReentrantLock一起使用，它是为了支持条件队列的锁更方便。ConditionObject的signal和await方法都是基于独占锁的，如果线程非锁的独占线程，则会抛出IllegalMonitorStateException。例如signalAll源码： public final void signalAll() { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignalAll(first); } 我在想，既然Condtion是为了支持Lock的，为什么ConditionObject不作为ReentrantLock的内部类呢？对于实现锁功能的子类，直接扩展它就可以实现对条件队列的支持。但是，对于其它非锁语义的实现类如Semaphore、CountDownLatch等类来说，条件队列是无用的，也会给开发者扩展AQS带来困惑。总之，是各有利弊，大师们的思想，还需要仔细揣摩啊！ 共享模式和独占模式的区别在于，独占模式只允许一个线程获得资源，而共享模式允许多个线程获得资源。 传统synchronized 本质: 队列和锁, synchronized 放在方法上锁的是this,放在代码块中锁的是()里面的对象 package com.kuang.demo01; // 基本的卖票例子 import java.time.OffsetDateTime; /*** 真正的多线程开发，公司中的开发，降低耦合性 * 线程就是一个单独的资源类，没有任何附属的操作！ * 1、 属性、方法 */ public class SaleTicketDemo01 { public static void main(String[] args) { // 并发：多线程操作同一个资源类, 把资源类丢入线程 Ticket ticket = new Ticket(); // @FunctionalInterface 函数式接口，jdk1.8 lambda表达式 (参数)-&gt;{ 代码 } new Thread(()-&gt;{ for (int i = 1; i &lt; 40 ; i++) { ticket.sale(); } },\"A\").start(); new Thread(()-&gt;{ for (int i = 1; i &lt; 40 ; i++) { ticket.sale(); } },\"B\").start(); new Thread(()-&gt;{ for (int i = 1; i &lt; 40 ; i++) { ticket.sale(); } },\"C\").start(); } } // 资源类 OOP class Ticket { // 属性、方法 private int number = 30; // 卖票的方式 // synchronized 本质: 队列，锁 public synchronized void sale(){ if (number&gt;0) { System.out.println(Thread.currentThread().getName()+\"卖出了\"+(number- -)+\"票,剩余：\"+number); } } } Lock 接口 实现类 什么是 “可重入”，可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。 ReentrantLock构造器 public ReentrantLock() { sync = new NonfairSync(); //无参默认非公平锁 } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync();//传参为true为公平锁 } 公平锁: 十分公平: 可以先来后到,一定要排队 非公平锁: 十分不公平,可以插队(默认) public class SaleTicketDemo { public static void main(String[] args) { // 并发：多线程操作同一个资源类, 把资源类丢入线程 Ticket ticket = new Ticket(); // @FunctionalInterface 函数式接口，jdk1.8 lambda表达式 (参数)-&gt;{ 代码 } new Thread(()-&gt;{for(int i = 0; i &lt; 40; i++) {ticket.sale();}}, \"a\").start(); new Thread(()-&gt;{for(int i = 0; i &lt; 40; i++) ticket.sale();}, \"b\").start(); new Thread(()-&gt;{for(int i = 0; i &lt; 40; i++) ticket.sale();}, \"c\").start(); } } class Ticket { // Lock三部曲 // 1、 new ReentrantLock(); // 2、 lock.lock(); // 加锁 // 3、 finally=&gt; lock.unlock(); // 解锁 private int ticketNum = 30; private Lock lock = new ReentrantLock(); public void sale() { lock.lock(); try { if (this.ticketNum &gt; 0) { System.out.println(Thread.currentThread().getName() + \"购得第\" + ticketNum-- + \"张票, 剩余\" + ticketNum + \"张票\"); } } finally { lock.unlock(); } } } synchronized和lock锁的区别 synchronized内置的java关键字,Lock是一个java类 synchronized无法判断获取锁的状态, Lock可以判断是否获取到了锁 synchronized会自动释放锁,Lock必须要手动释放锁!如果不是释放锁,会产生死锁，ReentrantLock 和 synchronized 不一样，需要手动释放锁，所以使用 ReentrantLock的时候一定要手动释放锁，并且加锁次数和释放次数要一样 0synchronized 线程1(获得锁,阻塞),线程2(等待); Lock锁就不一定会等待下去 synchronized 可重入锁,不可以中断的,非公平的; Lock锁,可重入的,可以判断锁,非公平(可自己设置为公平锁); synchronized 适合锁少量的代码同步问题,Lock 适合锁大量的同步代码 4.生产者和消费者问题面试高频: 单例模式, 八大排序,生产者消费者,死锁 Synchronized实现 wait notify package com.xu.PC; public class ProducerAndConsumer { public static void main(String[] args) { Resource resource = new Resource(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"A\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"B\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"C\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"D\").start(); } } class Resource { private int num = 0; public synchronized void increment() throws InterruptedException { // if (num != 0) while (num!=0){//判断是否有值 this.wait(); //有资源，不生产，进入睡眠 } num++; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+num); this.notifyAll();//唤醒其他线程,叫其他线程来消费资源 } public synchronized void decrement() throws InterruptedException { // if (num == 0) while (num == 0) {//判断是否为0 this.wait(); //无资源，不消费，进入睡眠 } num--; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+num); this.notifyAll();//唤醒其他线程，叫其他线程来生产资源 } } 注意：在多个线程通信时，必须使用 while 判断防止虚假唤醒。 if判断改为while判断 因为if只会执行一次，线程醒来会接着向下执行if（）外边的 而while不会，会重新判断条件是否满足，满足才会向下执行while（）外边的 JUC版本生产者和消费者问题 通过Lock 找到 Condition（监视者） 任何一个新的技术,绝对不是仅仅覆盖了原来的技术,一定有优势和补充 package com.xu.PC; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ProducerAndConsumer2 { public static void main(String[] args) { Resource2 resource = new Resource2(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"A\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"C\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"D\").start(); new Thread(()-&gt;{ for (int i = 0; i &lt; 20; i++) { try { resource.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } },\"B\").start(); } } class Resource2 { private int num = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition();//监视器 public void increment() throws InterruptedException { lock.lock(); try { while (num!=0){//判断是否有值 condition.await(); } num++; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+num); condition.signalAll();//唤醒其他线程 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public void decrement() throws InterruptedException { lock.lock(); try { while (num == 0) {//判断是否为0 condition.await(); } num--; System.out.println(Thread.currentThread().getName()+\"-&gt;\"+num); condition.signalAll();//唤醒其他线程 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } condition的精准通知和唤醒线程 package com.xu.PC; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ProducerAndConsumer3 { public static void main(String[] args) { Resource3 resource3 = new Resource3(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { resource3.A(); } }, \"A\").start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { resource3.B(); } }, \"B\").start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { resource3.C(); } }, \"C\").start(); } } class Resource3 { private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); private int number = 1; //A 执行完调用B，B执行完调用C，C执行完调用A 1A 2B 3C public void A() { lock.lock(); try { while (number != 1) { condition1.await(); } number = 2; //这样就可以执行B线程 System.out.println(Thread.currentThread().getName() + \"-&gt;AAAAAA\"); condition2.signal(); //准确唤醒B线程 } catch (Exception exception) { exception.printStackTrace(); } finally { lock.unlock(); } } public void B() { lock.lock(); try { while (number != 2) { condition2.await(); } number = 3; //这样就可以执行C线程 System.out.println(Thread.currentThread().getName() + \"-&gt;BBBBB\"); condition3.signal(); //准确唤醒C线程 } catch (Exception exception) { exception.printStackTrace(); } finally { lock.unlock(); } } public void C() { lock.lock(); try { while (number != 3) { condition3.await(); } number = 1; //这样就可以执行A线程 System.out.println(Thread.currentThread().getName() + \"-&gt;CCCCC\"); condition1.signal(); //准确唤醒A线程 } catch (Exception exception) { exception.printStackTrace(); } finally { lock.unlock(); } } } 5. 8锁现象如何判断锁的是谁！永远的知道什么锁，锁到底锁的是谁！深刻理解我们的锁 package com.xu.LOCK; import java.util.concurrent.TimeUnit; /*** 8锁，就是关于锁的8个问题 * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话 * 1、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话 * synchronized 放在方法上锁的是方法调用者，这里只有一个调用者 phone */ public class Synchronized { public static void main(String[] args) { Phone phone = new Phone(); new Thread(()-&gt;{ try { phone.send(); } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\").start(); // 延迟执行下面t2线程，但是结果无影响，因为他们用的是同把锁。 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(()-&gt;{ phone.call(); },\"t2\").start(); } //两个线程持有的是同一个锁，谁先拿到谁先执行完,另一个才执行 } class Phone { public synchronized void send() throws InterruptedException { System.out.println(Thread.currentThread().getName() + \"sendMessage\"); TimeUnit.SECONDS.sleep(2); call();//与send（）是同一把锁 this，锁的是方法调用者，不是两把锁 } public synchronized void call() { System.out.println(Thread.currentThread().getName() + \"call\"); } } package com.czp.lock; import java.util.concurrent.TimeUnit; /** * 3、 增加了一个普通方法后！先执行发短信还是Hello？ 普通方法 * 4. 两个对象，两个同步方法， 发短信还是 打电话？ // 打电话 */ public class Test2 { public static void main(String[] args) { Phone1 phone = new Phone1(); Phone1 phone2 = new Phone1(); new Thread(() -&gt; { phone.sendMessage(); }, \"A\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { // phone.hello(); phone2.call(); }, \"B\").start(); } } class Phone1 { public synchronized void sendMessage() { try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"sendMessage\"); } public synchronized void call() { System.out.println(Thread.currentThread().getName() + \"call\"); } //这里没有锁,不受锁的影响 public void hello(){ System.out.println(\"hello\"); } } package com.czp.lock; import java.util.concurrent.TimeUnit; /** * 5.增加两个静态的同步方法 * synchronized 锁的是方法调用者 * static 静态方法类一加载就有了 锁的是CLass * * 6. 两个对象,两个静态同步方法,先发短信还是先打电话 //发短信 * */ public class Test3 { public static void main(String[] args) { // 两个对象的Class类模板只有一个，static锁的是Class Phone2 phone2 = new Phone2(); Phone2 phone3 = new Phone2(); new Thread(() -&gt; { phone2.sendMessage(); }, \"A\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone3.call(); }, \"B\").start(); } } class Phone2 { public static synchronized void sendMessage() { try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"sendMessage\"); } public static synchronized void call() { System.out.println(Thread.currentThread().getName() + \"call\"); } } package com.czp.lock; import java.util.concurrent.TimeUnit; /** * 7.一个静态同步方法,一个普通同步方法 ,一个对象,先输出哪一个 //打电话 * * 8. 一个静态同步方法,一个普通同步方法, 两个对象,先打印哪一个 //B打电话 */ public class Test4 { public static void main(String[] args) { Phone3 phone3 = new Phone3(); Phone3 phone4 = new Phone3(); new Thread(() -&gt; { phone3.sendMessage(); }, \"A\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone4.call(); }, \"B\").start(); } } class Phone3 { public static synchronized void sendMessage() { try { TimeUnit.SECONDS.sleep(4); //延迟 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"sendMessage\"); } //普通同步方法 public synchronized void call() { System.out.println(Thread.currentThread().getName() + \"call\"); } } 小结： synchronized 方法锁的是调用者 this 具体的一个手机 static 方法锁的是模板 Class 唯一的一个模板 6.集合类不安全list 不安全//java.util.ConcurrentModificationException 并发修改异常! public class ListTest { public static void main(String[] args) { //并发下 arrayList 是不安全的 /** * 解决方案 * 1. 使用vector解决 * 2. List&lt;String&gt; arrayList = Collections.synchronizedList(new ArrayList&lt;&gt;()); * synchronizedList 方法里面都有 synchronized 同步代码块 * 3. List&lt;String&gt; arrayList = new CopyOnWriteArrayList&lt;&gt;(); * CopyOnWriteArrayList 使用 ReentrantLock 同步，同时使用 Arrays 工具类的 copyOf 接口复制数组 */ //copyOnWrite 写入时复制 COW 计算机程序设计领域的一种优化策略 //多个线程调用的时候, list, 读取的时候固定的,写入的时候,可能会覆盖 //在写入的时候避免覆盖造成数据问题 //读写分离 //CopyOnWriteArrayList 比 vector牛逼在哪里 List&lt;String&gt; arrayList = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) { new Thread(()-&gt;{ arrayList.add(UUID.randomUUID().toString().substring(0,5)); System.out.println(arrayList); },String.valueOf(i)).start(); } } } Set 不安全/** * 同理可证 */ public class SetTest { public static void main(String[] args) { // Set&lt;String&gt; set = new HashSet&lt;&gt;(); //如何解决hashSet线程安全问题 //1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); // 方法里面都有 synchronized 同步代码块 Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); // CopyOnWriteArraySet 实际用的是 CopyOnWriteArrayList 来存储数据，只是在添加数据时会使用 CopyOnWriteArrayList 的 addIfAbsent 方法来检查是否已经存在元素 for (int i = 0; i &lt; 100; i++) { new Thread(() -&gt; { set.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(set); }, String.valueOf(i)).start(); } } } hashSet底层是什么? hashMap public HashSet() { map = new HashMap&lt;&gt;(); } // add 的本质就是 map 的 key key是无法重复的 public boolean add(E e) { return map.put(e, PRESENT)==null; } private static final Object PRESENT = new Object();//这是一个不变的值 HashMap 不安全回顾Map基本操作 package com.kuang.unsafe; import java.util.Collections; import java.util.HashMap; import java.util.Map; import java.util.UUID; import java.util.concurrent.ConcurrentHashMap; // ConcurrentModificationException public class MapTest { public static void main(String[] args) { // map 是这样用的吗？ 不是，工作中不用 HashMap // 默认等价于什么？ new HashMap&lt;&gt;(16,0.75); // Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // 唯一的一个家庭作业：研究ConcurrentHashMap的原理 Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); for (int i = 1; i &lt;=30; i++) { new Thread(()-&gt;{ map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring( 0,5)); System.out.println(map); },String.valueOf(i)).start(); } } } 7. Callable() 可以有返回值 可以抛出异常 方法不同, run() =&gt; call() package com.kuang.callable; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; import java.util.concurrent.locks.ReentrantLock; /** *1、探究原理 *2、觉自己会用 */ public class CallableTest { public static void main(String[] args) throws ExecutionException, InterruptedException { // new Thread(new Runnable()).start(); // new Thread(new FutureTask&lt;V&gt;()).start(); // new Thread(new FutureTask&lt;V&gt;( Callable )).start(); // new Thread().start(); // 怎么启动Callable MyThread thread = new MyThread(); FutureTask futureTask = new FutureTask(thread); // 适配类 new Thread(futureTask,\"A\").start(); new Thread(futureTask,\"B\").start(); // 只输出Acall()，结果会被缓存，效率高 Integer o = (Integer) futureTask.get(); //这个get 方法可能会产生阻塞！把他放到最后 // 或者使用异步通信来处理！ System.out.println(o); } } class MyThread implements Callable&lt;Integer&gt; { @Override public Integer call() { System.out.println(\"call()\"); // 会打印几个call // 耗时的操作 return 1024; } } 细节： 1、有缓存2、结果可能需要等待，会阻塞！ 8. 常用的辅助类CountDownLatch //计数器 public class CountDownLatchDemo { public static void main(String[] args) throws InterruptedException { // 倒计时总数是6, 必须要执行任务的时候,再使用! CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 0; i &lt; 6; i++) { new Thread(()-&gt;{ System.out.println(Thread.currentThread().getName() + \" GO out\"); countDownLatch.countDown(); //数量减1 },String.valueOf(i)).start(); } countDownLatch.await();// 等待计数器归零,唤醒该线程，然后再向下执行 System.out.println(\"close Door\"); } } 原理: countDownLatch.countDown(); //数量减1 countDownLatch.await();// 等待计数器归零,然后再向下执行 每次有线程调用countDown()数量-1,计数器变为0, countDownLatch.await();就会被唤醒,继续执行 CyclicBarrier package com.xu.Others; import java.util.concurrent.BrokenBarrierException; import java.util.concurrent.CyclicBarrier; public class TestCyclicBarrier { public static void main(String[] args) { CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; { System.out.println(\"集齐七颗龙珠召唤神龙\"); }); // CyclicBarrier cyclicBarrier = new CyclicBarrier(7); for (int i = 1; i &lt;= 7; i++) { final int temp = i;//因为该变量会在循环时或者循环完，会消失， //线程延迟还没输出数据，保存在线程里，所以每个线程拥有不同的数据必须final修饰 new Thread(()-&gt;{ System.out.println(Thread.currentThread().getName() + \"集齐了第\" + temp + \"个龙珠\"); try { cyclicBarrier.await();//没有达到7之前会被wait，不会往下执行 //到达7， 才会执行cyclicBarrier的任务 System.out.println(\"ok\"); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } }).start(); } } } SemaphoreSemaphore：信号量 package com.xu.Others; import java.util.concurrent.Semaphore; import java.util.concurrent.TimeUnit; public class TestSemaphore { public static void main(String[] args) { //6车---3个停车位置 Semaphore semaphore = new Semaphore(3); for (int i = 1; i &lt;= 6; i++) { new Thread(() -&gt; { try { System.out.println(\"ok\"); semaphore.acquire();//获得资源，如果资源已经被占满就等待资源释放 System.out.println(Thread.currentThread().getName() + \"抢到了车位\"); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName() + \"离开了车位\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release();//释放资源，唤醒等待线程 } },String.valueOf(i)).start(); } } } 原理: semaphore.acquire(); //获取信号量,假设如果已经满了,等待信号量可用时被唤醒 semaphore.release(); //释放信号量 作用: 多个共享资源互斥的使用!并发限流,控制最大的线程数 9.读写锁ReadWriteLock package com.xu.WriteAndRead; import java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class Test { /** * 独占锁(写锁) 一次只能由一个线程占有 * 共享锁(读锁) 一次可以有多个线程占有 * readWriteLock * 读-读 可以共存 * 读-写 不能共存 * 写-写 不能共存 */ public static void main(String[] args) { Mycache2 mycache = new Mycache2(); //创建写线程 for (int i = 1; i &lt;= 10; i++) { final int temp = i; new Thread(() -&gt; { mycache.write(temp + \"\", temp + \"\"); }, String.valueOf(i)).start(); } //创建读线程 for (int i = 1; i &lt;= 10; i++) { final int temp = i; new Thread(() -&gt; { mycache.read(temp + \"\"); }, String.valueOf(i)).start(); } } } //加读写锁 class Mycache2 { private volatile Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //写,只有一个人能写 public void write(String key, String value) { readWriteLock.writeLock().lock(); try { System.out.println(Thread.currentThread().getName() + \"写\"); map.put(key, value); System.out.println(Thread.currentThread().getName() + \"写OK\"); } finally { readWriteLock.writeLock().unlock(); } } //读，可以多个人读 public void read(String key) { readWriteLock.readLock().lock(); try { System.out.println(Thread.currentThread().getName() + \"读\"); map.get(key); System.out.println(Thread.currentThread().getName() + \"读OK\"); } finally { readWriteLock.readLock().unlock(); } } } //没有任何锁 class Mycache { private volatile Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //写 public void write(String key, String value) { System.out.println(Thread.currentThread().getName() + \"写\"); map.put(key, value); System.out.println(Thread.currentThread().getName() + \"写OK\"); } //读 public void read(String key) { System.out.println(Thread.currentThread().getName() + \"读\"); map.get(key); System.out.println(Thread.currentThread().getName() + \"读OK\"); } } 10.阻塞队列 阻塞队列 Blockqueue 什么情况下我们会使用阻塞队列? 多线程并发处理,线程池! 学会使用队列 添加,移除 四组API 方式 抛出异常 不会抛出异常,有返回值 阻塞等待 超时等待 添加操作 add() offer() 供应 put() offer(obj,int,timeunit.status) 移除操作 remove() poll() 获得 take() poll(int,timeunit.status) 判断队列首部 element() peek() 偷看,偷窥 package com.xu.Queue; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.TimeUnit; public class testBlockingQueue { public static void main(String[] args) throws InterruptedException { test4(); } /** * 等待，阻塞（等待超时） */ public static void test4() throws InterruptedException { ArrayBlockingQueue&lt;Object&gt; arrayBlockingQueue4 = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue4.offer(\"a\")); System.out.println(arrayBlockingQueue4.offer(\"b\")); System.out.println(arrayBlockingQueue4.offer(\"c\")); System.out.println(arrayBlockingQueue4.offer(\"d\",2, TimeUnit.SECONDS));//超时等待，false,不会阻塞 System.out.println(\"_____________\"); System.out.println(arrayBlockingQueue4.poll()); System.out.println(arrayBlockingQueue4.poll()); System.out.println(arrayBlockingQueue4.poll()); System.out.println(arrayBlockingQueue4.poll(2,TimeUnit.SECONDS));//超时等待，null，不会抛出异常 } /** * 等待，阻塞（一直阻塞） */ public static void test3() throws InterruptedException { ArrayBlockingQueue&lt;Object&gt; arrayBlockingQueue3 = new ArrayBlockingQueue&lt;&gt;(3); arrayBlockingQueue3.put(\"a\"); arrayBlockingQueue3.put(\"b\"); arrayBlockingQueue3.put(\"c\"); // arrayBlockingQueue3.put(\"d\");// 队列没有位置了，一直阻塞 System.out.println(\"_____________\"); System.out.println(arrayBlockingQueue3.take()); System.out.println(arrayBlockingQueue3.take()); System.out.println(arrayBlockingQueue3.take()); // System.out.println(arrayBlockingQueue3.take());// 没有这个元素，一直阻塞 } /** * 有返回值，不会抛出异常 */ public static void test2() { ArrayBlockingQueue&lt;Object&gt; arrayBlockingQueue2 = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue2.offer(\"a\")); System.out.println(arrayBlockingQueue2.offer(\"b\")); System.out.println(arrayBlockingQueue2.offer(\"c\")); System.out.println(arrayBlockingQueue2.offer(\"d\"));//false,不会阻塞 System.out.println(\"_____________\"); System.out.println(arrayBlockingQueue2.poll()); System.out.println(arrayBlockingQueue2.poll()); System.out.println(arrayBlockingQueue2.poll()); System.out.println(arrayBlockingQueue2.poll());//null，不会抛出异常 } /** * 抛出异常 */ public static void test() { // 队列的大小 ArrayBlockingQueue&lt;Object&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3); System.out.println(arrayBlockingQueue.add(\"a\")); System.out.println(arrayBlockingQueue.add(\"b\")); System.out.println(arrayBlockingQueue.add(\"c\")); // System.out.println(arrayBlockingQueue.add(\"d\")); //IllegalStateException: Queue full System.out.println(\"_____________\"); System.out.println(arrayBlockingQueue.remove(\"b\")); System.out.println(arrayBlockingQueue.remove()); System.out.println(arrayBlockingQueue.remove()); // System.out.println(arrayBlockingQueue.remove());//NoSuchElementException } } SynchronizedQueue 同步队列 没有容量, 进去一个元素,必须等待取出来之后,才能再往里面放一个元素 put take /** * 同步队列 * 和其他的lockQueue 不一样， SynchronousQueue 不存储元素 * put了一个元素，必须从里面先take取出来，否则不能在put进去值！ */ public class SyncQueue { public static void main(String[] args) { SynchronousQueue&lt;String&gt; synchronousQueue = new SynchronousQueue&lt;&gt;(); //同步队列 new Thread(()-&gt;{ try { System.out.println(Thread.currentThread().getName() + \"put 1\"); synchronousQueue.put(\"1\");//没有被take，会阻塞 System.out.println(Thread.currentThread().getName() + \"put 2\"); synchronousQueue.put(\"2\"); System.out.println(Thread.currentThread().getName() + \"put 3\"); synchronousQueue.put(\"3\"); } catch (InterruptedException e) { e.printStackTrace(); } },\"T1\").start(); new Thread(()-&gt;{ try { TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \"=&gt;\" + synchronousQueue.take()); //没有put，会阻塞 TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \"=&gt;\" + synchronousQueue.take()); TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread().getName() + \"=&gt;\" + synchronousQueue.take()); } catch (InterruptedException e) { e.printStackTrace(); } finally { } },\"T2\").start(); } } 11.线程池线程池: 三大方法,七大参数,4种拒绝策略 池化技术 程序的运行，本质：占用系统的资源！ 优化资源的使用！=&gt;池化技术 线程池、连接池、内存池、对象池///. 创建、销毁。十分浪费资源 池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还给我。 线程池的好处: 1、降低资源的消耗 2、提高响应的速度 3、方便管理。 线程复用、可以控制最大并发数、管理线程 线程池: 三大方法 //Executors 工具类 3大方法 //使用了线程池之后要使用线程池创建线程 public class Demo01 { public static void main(String[] args) { // ExecutorService service = Executors.newSingleThreadExecutor();//单个线程 // ExecutorService service = Executors.newFixedThreadPool(5);//创建一个固定的线程池的大小 ExecutorService service = Executors.newCachedThreadPool();//可伸缩的， try { for (int i = 0; i &lt; 10; i++) { service.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + \"ok\"); }); } //线程池用完要关闭线程池 } finally { service.shutdown(); } } } 7大参数newSingleThreadExecutor构造器 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); } newFixedThreadPool构造器 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } newCachedThreadPool构造器 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); } 本质: 所有线程池最终都调用的ThreadPoolExecutor ThreadPoolExecutor底层构造器 public ThreadPoolExecutor(int corePoolSize, //核心线程池大小 int maximumPoolSize, //最大的线程池大小 long keepAliveTime, // 超时了没有人调用就会释放 TimeUnit unit, //时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列 ThreadFactory threadFactory,//线程工厂,创建线程的,一般不动 RejectedExecutionHandler handler) {//拒绝策略 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } 手动创建线程池 package com.xu.Pool; import java.util.concurrent.*; public class testThreadPoolExecutor { public static void main(String[] args) { ExecutorService threadPoolExecutor = new ThreadPoolExecutor( 2,//核心线程数 4,//最大线程数 3,//多久没调用就释放池 TimeUnit.SECONDS,//超时单位 new ArrayBlockingQueue&lt;&gt;(6),//阻塞队列大小 Executors.defaultThreadFactory(), // 线程工厂，创建线程的，默认不用改 //队列满了，线程池满了，还有其他任务过来时拒绝策略 // new ThreadPoolExecutor.AbortPolicy()//满了，不处理，抛出异常 // new ThreadPoolExecutor.CallerRunsPolicy()//由调用线程（提交任务的线程）处理该任务 // new ThreadPoolExecutor.DiscardPolicy()//满了，丢掉任务，不抛出异常 new ThreadPoolExecutor.DiscardOldestPolicy()//抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务 ); try { // 最大承载：Deque + max 等待队列容量和最大线程数之和 // 超过 RejectedExecutionException 抛不抛出异常看拒绝策略 for (int i = 0; i &lt;12; i++) { // 使用了线程池之后，使用线程池来创建线程 threadPoolExecutor.execute(() -&gt; { System.out.println(Thread.currentThread().getName() + \"run\"); }); } } catch (Exception exception) { exception.printStackTrace(); } finally { // 线程池用完，程序结束，关闭线程池 threadPoolExecutor.shutdown(); } } } 四种拒绝策略/** * new ThreadPoolExecutor.AbortPolicy() 超出最大处理线程抛出异常 * new ThreadPoolExecutor.CallerRunsPolicy() 哪个线程创建就由那个线程执行 * new ThreadPoolExecutor.DiscardPolicy() 队列满了，丢弃任务，不会抛出异常 * new ThreadPoolExecutor.DiscardOldestPolicy() 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务 */ 小结和扩展 了解:最大线程到底应该如何定义 CPU密集型 几核,就是几,可以保证CPU的效率最高 IO 密集型 判断程序中十分耗I/O的线程, 大于两倍 //获取电脑处理器数 System.out.println(Runtime.getRuntime().availableProcessors()); 12.四大函数式接口新时代的程序员：lambda表达式、链式编程、函数式接口、Stream流式计算 函数式接口：只有一个方法的接口 @FunctionalInterface public interface Runnable { public abstract void run(); } // 泛型、枚举、反射 // lambda表达式、链式编程、函数式接口、Stream流式计算 // 超级多FunctionalInterface // 简化编程模型，在新版本的框架底层大量应用！ // foreach(消费者类的函数式接口) Function函数式接口 package com.kuang.function; import java.util.function.Function; /** *Function 函数型接口, 有一个输入参数，有一个输出 *只要是 函数型接口 可以 用 lambda表达式简化 */ public class Demo01 { public static void main(String[] args) { // // Function&lt;String,String&gt; function = new Function&lt;String,String&gt;() { // @Override // public String apply(String str) { // return str; // } // }; Function&lt;String,String&gt; function = (str)-&gt;{return str;}; System.out.println(function.apply(\"asd\")); } } Predicate 断定型接口 package com.kuang.function; import java.util.function.Predicate; /** * 断定型接口：有一个输入参数，返回值只能是 布尔值！ */ public class Demo02 { public static void main(String[] args) { // 判断字符串是否为空 // Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;(){ //// @Override //// public boolean test(String str) { //// return str.isEmpty(); //// } //// }; Predicate&lt;String&gt; predicate = (str)-&gt;{return str.isEmpty(); }; System.out.println(predicate.test(\"\")); } } Consumer 消费型接口 package com.kuang.function; import java.util.function.Consumer; /** * Consumer 消费型接口: 只有输入，没有返回值 */ public class Demo03 { public static void main(String[] args) { // Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() { // @Override // public void accept(String str) { // System.out.println(str); // } // }; Consumer&lt;String&gt; consumer = (str)-&gt;{System.out.println(str);}; consumer.accept(\"sdadasd\"); } } Supplier 供给型接口 package com.kuang.function; import java.util.function.Supplier; /** * Supplier 供给型接口 没有参数，只有返回值 */ public class Demo04 { public static void main(String[] args) { // Supplier supplier = new Supplier&lt;Integer&gt;() { // @Override // public Integer get() { // System.out.println(\"get()\"); // return 1024; // } // }; Supplier supplier = ()-&gt;{ return 1024; }; System.out.println(supplier.get()); } } 13.Stream 流式计算 什么是流式计算 大数据：存储 + 计算 集合、MySQL 本质就是存储东西的； 计算都应该交给流来操作！ package com.kuang.stream; import java.util.Arrays; import java.util.List; /** *题目要求：一分钟内完成此题，只能用一行代码实现！ *现在有5个用户！筛选： *1、ID 必须是偶数 *2、年龄必须大于23岁 *3、用户名转为大写字母 *4、用户名字母倒着排序 *5、只输出一个用户！ */ public class Test { public static void main(String[] args) { User u1 = new User(1,\"a\",21); User u2 = new User(2,\"b\",22); User u3 = new User(3,\"c\",23); User u4 = new User(4,\"d\",24); User u5 = new User(6,\"e\",25); // 集合就是存储 List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5); // 计算交给Stream流 // lambda表达式、链式编程、函数式接口、Stream流式计算 list.stream() .filter(u-&gt;{return u.getId()%2==0;}) .filter(u-&gt;{return u.getAge()&gt;23;}) .map(u-&gt;{return u.getName().toUpperCase();}) .sorted((uu1,uu2)-&gt;{return uu2.compareTo(uu1);}) .limit(1) //取前几个元素，数目可以大于元素总个数 .forEach(System.out::println); } } 14. ForkJoin 什么是ForkJoin ForkJoin在JDK1.7,并行执行任务,大数据量! 大数据: Map Reduce( 把大任务拆分成小任务) ForkJoin特点: 工作窃取 这个里面维护的是一个双端队列 ForkJoin package com.kuang.forkjoin; import java.util.concurrent.RecursiveTask; /** *求和计算的任务！ *3000 6000（ForkJoin） 9000（Stream并行流） * 如何使用 forkjoin * 1、forkjoinPool 通过它来执行 * 2、计算任务 forkjoinPool.execute(ForkJoinTask task) * 3. 计算类要继承 ForkJoinTask */ public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; { private Long start; // 1 private Long end; // 1990900000 // 临界值 private Long temp = 10000L; public ForkJoinDemo(Long start, Long end) { this.start = start; this.end = end; } // 计算方法 @Override protected Long compute() { if ((end-start)&lt;temp){ Long sum = 0L; for (Long i = start; i &lt;= end; i++) { sum += i; } return sum; }else { // forkjoin 递归 long middle = (start + end) / 2; // 中间值 ForkJoinDemo task1 = new ForkJoinDemo(start, middle); task1.fork(); // 拆分任务，把任务压入线程队列 ForkJoinDemo task2 = new ForkJoinDemo(middle+1, end); task2.fork(); // 拆分任务，把任务压入线程队列 return task1.join() + task2.join(); } } } 测试 package com.xu.ForkJoin; import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; import java.util.stream.LongStream; public class test { public static void main(String[] args) throws ExecutionException, InterruptedException { // test1();//611 // test2();//617 test3();//618 } public static void test1() { long start = System.currentTimeMillis(); long sum = 0l; for (long i = 0l; i &lt;=10_0000_0000l ; i++) { sum+=i; } long end = System.currentTimeMillis(); System.out.println(\"sum=\"+sum+\"运行时间；\"+(end-start)); } public static void test2() throws ExecutionException, InterruptedException { long start = System.currentTimeMillis(); Long sum; ForkJoinPool forkJoinPool = new ForkJoinPool(); //forkjoinDemo 是自己创建的计算类，参照上面创建 forkjoinDemo forkjoinDemo = new forkjoinDemo(0l, 10_0000_0000l); ForkJoinTask&lt;Long&gt; task = forkJoinPool.submit(forkjoinDemo);// 提交任务 sum = task.get(); long end = System.currentTimeMillis(); System.out.println(\"sum=\"+sum+\"运行时间；\"+(end-start)); } public static void test3() { long start = System.currentTimeMillis(); // Stream并行流 range() 开区间 () ，rangeClosed() 闭区间左开右闭 (] long sum = LongStream.rangeClosed(0l, 10_0000_0000l).parallel().reduce(1, Long::sum); long end = System.currentTimeMillis(); System.out.println(\"sum=\"+sum+\"运行时间；\"+(end-start)); } } 15. 异步回调 Future设计的初衷: 对将来的某个事件的结果进行建模 package com.xu.CompletableFutrue; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; /** *异步调用： CompletableFuture * 异步执行 * 成功回调 * 失败回调 */ public class test { public static void main(String[] args) throws ExecutionException, InterruptedException { //没有返回值的 runAsync 异步回调 // CompletableFuture&lt;Void&gt; completableFuture=CompletableFuture.runAsync(()-&gt;{ // System.out.println(Thread.currentThread().getName() + \"run\"); // try { // TimeUnit.SECONDS.sleep(2); // } catch (InterruptedException e) { // e.printStackTrace(); // } // }); // completableFuture.get();//阻塞，获取执行结果 // System.out.println(\"1111\"); //有返回值的 supplyAsync 异步回调 // ajax，成功和失败的回调 // 返回的是错误信息； CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;{ System.out.println(Thread.currentThread().getName() + \"run\"); int i =10/0; return 1024; }); System.out.println(completableFuture.whenComplete((u, t) -&gt; { //接收什么信息跟参数位置有关，第一个参数接收正确运行结果，第二个接收错误运行的结果 System.out.println(\"u=\" + u); System.out.println(\"t=\" + t); }).exceptionally((e) -&gt; { System.out.println(e.getMessage()); return 111; // 可以获取到错误的返回结果 }).get()); } } /* 运行结果 ForkJoinPool.commonPool-worker-1run u=null t=java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero java.lang.ArithmeticException: / by zero 111 */ 16.JMM 请你谈谈你对Volate的理解 Volate是java虚拟机提供轻量级的同步机制 保证可见性 不保证原子性 禁止指令重排 JMM是什么 JMM: java内存模型,不存在的东西,概念!约定! 关于JMM的一些同步的约定： 线程解锁前,必须把共享变量立刻刷回主存 线程加锁前,必须读取主存中的最新值到工作内存中! 加锁和解锁必须是同一把锁 线程 工作内存 主内存 8种操作：（这里的 write 和 store 交换位置） 操作 说明 lock （锁定） 作用于主内存的变量，把一个变量标识为线程独占状态 unlock （解锁） 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read （读取） 作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用 load （载入） 作用于工作内存的变量，它把read操作从主存中变量放入工作内存中 use （使用） 作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令 assign （赋值） 作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中 store （存储） 作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用 write （写入） 作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中 八种规则: 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 不允许一个线程将没有assign的数据从工作内存同步回主内存 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 对一个变量进行unlock操作之前，必须把此变量同步回主内存 问题: 程序不知道主内存中的值已经被修改过了 17. Volatile保证可见性public class JMMDemo { //不加volatile 程序就会死循环 //加上volatile 可以保证可见性 private volatile static int number = 0; public static void main(String[] args) { new Thread(()-&gt;{ // 线程 1 对主内存的变化不知道的 while(number == 0){ } }).start(); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } finally { } number = 1; System.out.println(number); } } 不保证原子性原子性: 不可分割 线程A在执行任务的时候.不能被打扰,也不能被分割,要么同时成功,要么同时失败 //测试不保证原子性 public class VDemo { // volatile 不保证原子性 private volatile static int num = 0; public static void add(){ num++; } public static void main(String[] args) { //理论上num结果应该为 2 万 for (int i = 0; i &lt; 20; i++) { new Thread(()-&gt;{ for (int j = 0; j &lt; 1000; j++) { add(); } }).start(); } while (Thread.activeCount() &gt; 2){ // main线程 gc垃圾回收线程 Thread.yield(); } System.out.println(num); } } 如果不加lock和synchronized,如何保证原子性 使用原子类,解决原子性问题 //测试不保证原子性 public class VDemo { //原子类的int private volatile static AtomicInteger num = new AtomicInteger(0); // AtomicInteger 调用的是底层的 CAS public static void add(){ // num++; // 不是一个原子性操作 num.getAndIncrement(); // AtomicInteger + 1 方法， CAS } public static void main(String[] args) { for (int i = 0; i &lt; 20; i++) { new Thread(()-&gt;{ for (int j = 0; j &lt; 1000; j++) { add(); } }).start(); } while (Thread.activeCount() &gt; 2){ Thread.yield(); } System.out.println(num); } } 这些类的底层都直接和操作系统挂钩 ! 在内存中修改值! UnSafe类是一个很特殊的存在 指令重排 什么是指令重排: 你写的程序,计算机并不是按照指定的的步骤执行 源代码—&gt;编译器优化源代码–&gt;指令并行也可能会重排—&gt;内存系统也会重排执行 处理器在进行指令重排的时候，考虑：数据之间的依赖性！ int x = 1; // 1 int y = 2; // 2 x = x + 5; // 3 y = x * x; // 4 我们所期望的：1234 但是可能执行的时候回变成 2134 1324 可不可能是 4123！ 可能造成影响的结果： a b x y 这四个值默认都是 0； 线程A 线程B x=a y=b b=1 a=2 正常的结果： x = 0；y = 0；但是可能由于指令重排 线程A 线程B b=1 a=2 x=a y=b 指令重排导致的诡异结果： x = 2；y = 1； volatile 可以避免指令重排： 内存屏障。CPU指令。作用： 1、保证特定的操作的执行顺序！ 2、可以保证某些变量的内存可见性 （利用这些特性volatile实现了可见性） Volatile 是可以保证可见性, 不能保证原子性,由于内存屏障可以避免指令重排的现象产生 ! 18.单例模式饿汉模式package com.kuang.single; // 饿汉式单例 public class Hungry { // 可能会浪费空间 private Hungry(){ } private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance(){ return HUNGRY; } } 懒汉模式package com.czp.single; //单线程安全 public class LazyMan { private static LazyMan lazyMan = null; private LazyMan(){ } public static LazyMan getInstance(){ if(lazyMan == null){ lazyMan = new LazyMan(); } return lazyMan; } } DCL 懒汉式package com.czp.single; import java.lang.reflect.Constructor; public class LazyManThread { private static volatile LazyManThread lazyManThread = null; private static boolean isExist = false; //执行一次构造函数就把标志位反置为true，第二次执行构造函数就抛出异常 private LazyManThread() { synchronized (LazyManThread.class) { if (!isExist) { isExist = true; } else { throw new RuntimeException(\"禁止使用反射创建该对象\"); } } } // 双重检测锁模式的 懒汉式单例 DCL懒汉式 public static LazyManThread getInstance() { //if只会判断一次,当两个线程同时判断时一个线程就会在同步代码块中等待 if (lazyManThread == null) { //不直接使用同步的原因,提高执行效率 synchronized (LazyManThread.class) { if (lazyManThread == null) { lazyManThread = new LazyManThread(); // 不是一个原子性操作 } } } /** * 由于对象创建不是原子性操作 * 1. 分配内存空间 * 2. 使用构造器创建对象 * 3. 将对象指向内存空间 */ /** * 可能会发生指令重排 * 123 * 132 * 这是就需使用volatile关键字来防止指令重排 */ return lazyManThread; } // 反射！ public static void main(String[] args) throws Exception { // LazyManThread instance = LazyManThread.getInstance(); Constructor&lt;LazyManThread&gt; declaredConstructor = LazyManThread.class.getDeclaredConstructor(); declaredConstructor.setAccessible(true); LazyManThread lazyManThread = declaredConstructor.newInstance(); LazyManThread instance = declaredConstructor.newInstance(); System.out.println(instance); System.out.println(lazyManThread); } } 静态内部类 public class LazyMan1 { private LazyMan1() {} public static final LazyMan1 getInstance(){ return innerClass.LAZY_MAN_1; } public static class innerClass { private static final LazyMan1 LAZY_MAN_1 = new LazyMan1(); } } 单例不安全,反射package com.xu.SingleInstance; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; public class LazyMan { private volatile static LazyMan lazyMan; //volatile 保证不会指令重排 private LazyMan() { System.out.println(\"new lazyman()\"); } public static LazyMan getLazyMan() { if (lazyMan == null) { synchronized (LazyMan.class) { if (lazyMan == null) { lazyMan = new LazyMan();//不是原子性操作 /** * 1，分配内存空间 * 2，执行构造函数，初始化对象 * 3，把这个对象指向这个空间 * * 正常情况是123 * 但虚拟机会优化编译，指令重排132 */ } } } return lazyMan; } public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { // LazyMan lazyMan = getLazyMan(); Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null); declaredConstructor.setAccessible(true); LazyMan lazyMan1 = declaredConstructor.newInstance(); LazyMan lazyMan2 = declaredConstructor.newInstance(); System.out.println(lazyMan2); System.out.println(lazyMan1); } } /* 没有做特殊处理的单例在反射下可以随便创建实例 输出结果： new lazyman() new lazyman() com.xu.SingleInstance.LazyMan@14ae5a5 com.xu.SingleInstance.LazyMan@7f31245a */ 枚举package com.xu.SingleInstance; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; public class Enum { public static void main(String[] args) throws InterruptedException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { //无参构造函数，枚举默认 Constructor&lt;instance&gt; constructor = Instance.class.getDeclaredConstructor(String.class,int.class); //有参构造函数，最后一个String.class 为参数类型 Constructor&lt;instance&gt; constructor = Instance.class.getDeclaredConstructor(String.class,int.class,String.class); constructor.setAccessible(true); Instance instance = constructor.newInstance(); //Exception in thread \"main\" java.lang.IllegalArgumentException: Cannot reflectively create enum objects 不能通过反射创建实例 } } // enum 是一个什么？ 本身也是一个Class类 public enum Instance { ;//注意这里有分号 private String name; Instance(){ } Instance(String name){ this.name = name; } } 下面是探究枚举类构造函数，以及反编译枚举类的源码 package com.kuang.single; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; // enum 是一个什么？ 本身也是一个Class类 public enum EnumSingle { INSTANCE; public EnumSingle getInstance(){ return INSTANCE; } } class Test{ public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { EnumSingle instance1 = EnumSingle.INSTANCE; Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,int.class); declaredConstructor.setAccessible(true); EnumSingle instance2 = declaredConstructor.newInstance(); // NoSuchMethodException: com.kuang.single.EnumSingle.&lt;init&gt;() System.out.println(instance1); System.out.println(instance2); } 枚举类型的最终反编译源码： // Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov. // Jad home page: http://www.kpdus.com/jad.html // Decompiler options: packimports(3) // Source File Name: EnumSingle.java package com.kuang.single; public final class EnumSingle extends Enum { public static EnumSingle[] values() { return (EnumSingle[])$VALUES.clone(); } public static EnumSingle valueOf(String name) { return (EnumSingle)Enum.valueOf(com/kuang/single/EnumSingle, name); } private EnumSingle(String s, int i) { super(s, i); } public EnumSingle getInstance() { return INSTANCE; } public static final EnumSingle INSTANCE; private static final EnumSingle $VALUES[]; static { INSTANCE = new EnumSingle(\"INSTANCE\", 0); $VALUES = (new EnumSingle[] { INSTANCE }); } } 19.深入理解CASpackage com.kuang.cas; import java.util.concurrent.atomic.AtomicInteger; public class CASDemo { // CAS compareAndSwarp : 比较并交换！ public static void main(String[] args) { // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ AtomicInteger atomicInteger = new AtomicInteger(1); System.out.println(atomicInteger.compareAndSet(1, 2));//true System.out.println(atomicInteger.get()); //2 System.out.println(atomicInteger.getAndIncrement());//其实是3,返回旧值，输出2 System.out.println(atomicInteger.get());//3 System.out.println(atomicInteger.compareAndSet(1, 2));//false System.out.println(atomicInteger.get());//3 } } Unsafe 类 CAS ： 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环！ 缺点： 1、 循环会耗时2、一次性只能保证一个共享变量的原子性3、ABA问题 CAS：ABA问题（狸猫换太子） package com.kuang.cas; import java.util.concurrent.atomic.AtomicInteger; public class CASDemo { // CAS compareAndSwarp : 比较并交换！ public static void main(String[] args) { AtomicInteger atomicInteger = new AtomicInteger(2020); // 期望、更新 // public final boolean compareAndSet(int expect, int update) // 如果我期望的值达到了，那么就更新，否则，就不更新, CAS 是CPU的并发原语！ // ============== 捣乱的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2021, 2020)); System.out.println(atomicInteger.get()); // ============== 期望的线程 ================== System.out.println(atomicInteger.compareAndSet(2020, 6666)); System.out.println(atomicInteger.get()); } } 20 . 原子引用 解决ABA问题, 引入原子引用 ! 对应的思想: 乐观锁 带版本号的原子操作 ! package com.xu.CASdemo; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicStampedReference; public class AtomicStampedReferenceDemo { public static void main(String[] args) { //AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题 AtomicStampedReference&lt;Long&gt; atomicStampedReference = new AtomicStampedReference(1L, 1); //这里1是版本号 new Thread(()-&gt;{//模拟狸猫换太子 // 获得版本号 System.out.println(\"a1-&gt;\"+atomicStampedReference.getStamp()); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(atomicStampedReference.compareAndSet(1L, 2L, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1)); System.out.println(\"a2-&gt;\" + atomicStampedReference.getStamp()); System.out.println(atomicStampedReference.compareAndSet(2L, 1L, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1)); System.out.println(\"a3-&gt;\" + atomicStampedReference.getStamp()); },\"a\").start(); // 乐观锁的原理相同 new Thread(()-&gt;{//狸猫换太子后，看能不能进行交换操作 int stamp = atomicStampedReference.getStamp();// 获得版本号 System.out.println(\"b1-&gt;\" +stamp); //此时版本还是1 try { TimeUnit.SECONDS.sleep(2); //让前面的线程换完太子 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(atomicStampedReference.compareAndSet(1L, 6L,stamp, stamp+ 1));//此时版本号已经改变不符，所以交换不成功 //经历过狸猫换太子后版本号变为了3 System.out.println(\"b2-&gt;\"+atomicStampedReference.getStamp()); },\"b\").start(); } } 注意：Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂的方法valueOf 获取对象实例，而不是new，因为valueOf 使用缓存，而new一定会创建新的对象分配新的内存空间； 21.各种锁的理解公平锁, 非公平锁公平锁: 非常公平,先来后到,不允许插队 非公平锁: 非常不公平, 允许插队 public ReentrantLock() { sync = new NonfairSync(); //无参默认非公平锁 } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync();//传参为true为公平锁 } 可重入锁 ( 递归锁 )释义: 可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁 synchronized版本的可重入锁 public class TestLock { public static void main(String[] args) { TestPhone phone = new TestPhone(); new Thread(()-&gt;{ //在调用sendMessage的方法时已经为phone加上了一把锁 //而call方法由为其加上了一把锁 phone.sendMessage(); }).start(); } } class TestPhone { public synchronized void sendMessage() { System.out.println(Thread.currentThread().getName() + \"sendMessage\"); call(); } public synchronized void call() { System.out.println(Thread.currentThread().getName() + \"call\"); } } Lock版本的可重入锁 package com.kuang.lock; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class Demo02 { public static void main(String[] args) { Phone2 phone = new Phone2(); new Thread(()-&gt;{ phone.sms(); },\"A\").start(); new Thread(()-&gt;{ phone.sms(); },\"B\").start(); } } class Phone2{ Lock lock = new ReentrantLock(); public void sms(){ lock.lock(); // 细节问题：lock.lock(); lock.unlock(); // lock 锁必须配对，否则就会死在里面 lock.lock(); try { System.out.println(Thread.currentThread().getName() + \"sms\"); call(); // 这里也有锁 } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); lock.unlock(); } } public void call(){ lock.lock(); try { System.out.println(Thread.currentThread().getName() + \"call\"); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } } 自旋锁 package com.xu.LOCK; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicReference; public class Spinlock { public static void main(String[] args) throws InterruptedException { Mylock mylock = new Mylock(); new Thread(()-&gt;{ mylock.lock(); try { System.out.println(\"a\"); TimeUnit.SECONDS.sleep(5); } catch (Exception e) { e.printStackTrace(); } finally { mylock.unlock(); } },\"A\").start(); TimeUnit.SECONDS.sleep(1); new Thread(()-&gt;{ mylock.lock(); try { System.out.println(\"b\"); TimeUnit.SECONDS.sleep(6); } catch (Exception e) { e.printStackTrace(); } finally { mylock.unlock(); } },\"B\").start(); } } class Mylock { AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); //对象为null，不带版本号的，AtomicStampedReference才是带版本号的类 public void lock() { Thread thread =Thread.currentThread();//对应的线程 while (!atomicReference.compareAndSet(null, thread)) { //B的线程执行到这里就会自旋，直到等到A线程执行unlock（）解锁 //这个自旋主要是对线程B起作用，对线程A不起作用，因为 // atomicReference.compareAndSet(null, thread)对线程A为真 //因为atomicReference刚开始初始值为null System.out.println(thread.getName()+\"-&gt;b\"); } System.out.println(thread.getName()+\"-&gt;lock\"); } public void unlock() { Thread thread = Thread.currentThread(); System.out.println(thread.getName() + \"-&gt;unlock\"); atomicReference.compareAndSet(thread, null); } } /* 程序执行过程：先输出A-&gt;lock，然后再输出a，此时A就睡5秒，B进来因为 while (!atomicReference.compareAndSet(null, thread)) 一直在自旋，疯狂输出B-&gt;b，过了几秒A醒来，进行A-&gt;unlock，B就因为 while (!atomicReference.compareAndSet(null, thread)) 不满足所以跳出了自旋，输出B-&gt;lock，接着输出b，然后睡6秒醒来后输出B-&gt;unlock，解锁 */ 死锁产生死锁的四大条件：互斥、占有等待、循环等待、不可抢占（破坏其中一个就不会产生死锁） package com.czp.lock; import java.util.concurrent.TimeUnit; public class KillLock implements Runnable { private String stringA; private String stringB; public KillLock(String stringA, String stringB) { this.stringA = stringA; this.stringB = stringB; } @Override public void run() { synchronized (stringA) { System.out.println(Thread.currentThread().getName() + \"lock\" + stringA + \"try to lock stringB\"); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (stringB) { System.out.println(Thread.currentThread().getName() + \"lock\" + stringB + \"try to lock stringA\"); } } } public static void main(String[] args) { String a = \"a\"; String b = \"b\"; new Thread(new KillLock(a, b)).start(); new Thread(new KillLock(b, a)).start(); } } 如何排查死锁 先使用jps -l定位进程号 再使用 jstack 查看进程信息找到死锁问题 面试，工作中！ 排查问题： 1、日志 9 2、堆栈 1","categories":[],"tags":[]},{"title":"","slug":"GUI","date":"2021-09-14T08:22:09.592Z","updated":"2021-09-14T08:22:10.033Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://gitee.com/td278121/posts/0.html","excerpt":"","text":"GUI编程GUI：图形用户界面编程 GUI编程学习路线 GUI是什么 GUI怎么写 GUI使用场景 组件 监听 弹窗 面板 鼠标 键盘 按钮 1.简介GUI核心技术：Swing AWT 缺点： 不美观 需要jre环境 为什么要学习 可以写出一些自己用的小工具 可能会涉及到swing的维护工作 -&gt; 破解 了解MVC架构，了解监听 2.AWT2.1.AWT介绍 AWT：抽象的窗口工具，包含了很多的类和接口 元素：窗口、按钮、文本框 java.awt包下 2.2.组件和容器1.Frameimport java.awt.*; //GUI的第一个界面 public class TestFrame { public static void main(String[] args) { Frame frame = new Frame(\"frame标题\"); // 设置窗口可见 frame.setVisible(true); // 设置大小 frame.setSize(400,400); // 设置背景颜色 frame.setBackground(Color.BLACK); // 设置初始位置 frame.setLocation(400,400); // 设置大小固定 frame.setResizable(false); } } 问题：关闭按钮无反应，关闭程序进程才会关闭窗口 封装打开多个实现： import java.awt.*; public class TestFrame2 { public static void main(String[] args) { new MyFrame(100,100,200,200,Color.BLACK); new MyFrame(300,100,200,200,Color.BLUE); new MyFrame(100,300,200,200,Color.YELLOW); new MyFrame(300,300,200,200,Color.WHITE); } } class MyFrame extends Frame{ // 计数器 private static int id = 0; public MyFrame(int x,int y,int w,int h,Color color){ super(\"MyFrame+\"+id++); this.setBounds(x,y,w,h); this.setBackground(color); this.setVisible(true); } } 2.Panelimport java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(\"带面板的Frame\"); Panel panel = new Panel(); frame.setBounds(400,400,500,500); frame.setBackground(Color.BLACK); frame.setLayout(null); panel.setBounds(100,100,300,300); panel.setBackground(Color.YELLOW); // 将面板放入frame中 frame.add(panel); frame.setVisible(true); // 添加监听 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 2.3.布局管理器流式布局 FlowLayout import java.awt.*; //流式布局 public class TestFlowLayout { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); frame.setBounds(400,400,500,500); Button button1 = new Button(\"按钮1\"); Button button2 = new Button(\"按钮2\"); Button button3 = new Button(\"按钮3\"); frame.add(button1); frame.add(button2); frame.add(button3); frame.setLayout(new FlowLayout(FlowLayout.RIGHT)); } } 东西南北中 BorderLayout import java.awt.*; public class TestBorderLayout { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); frame.setBounds(400,400,500,500); Button east = new Button(\"East\"); Button west = new Button(\"West\"); Button south = new Button(\"South\"); Button north = new Button(\"North\"); Button center = new Button(\"Center\"); frame.add(east,BorderLayout.EAST); frame.add(west,BorderLayout.WEST); frame.add(south,BorderLayout.SOUTH); frame.add(north,BorderLayout.NORTH); // frame.add(center,BorderLayout.CENTER); } } 表格式布局 GridLayout import java.awt.*; public class TestGridLayout { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); // frame.setBounds(400,400,500,500); Button button1 = new Button(\"but1\"); Button button2 = new Button(\"but2\"); Button button3 = new Button(\"but3\"); Button button4 = new Button(\"but4\"); Button button5 = new Button(\"but5\"); Button button6 = new Button(\"but6\"); frame.add(button1); frame.add(button2); frame.add(button3); frame.add(button4); frame.add(button5); frame.add(button6); frame.setLayout(new GridLayout(3,2)); // 自动布局大小,测试过程中发现不能在第一行写这个，需要在添加完毕后增加会分配默认size frame.pack(); } } 实现效果： 嵌套布局： import java.awt.*; public class TestDemo1 { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); frame.setBounds(100,100,800,800); Button button1 = new Button(\"button1\"); Button button2 = new Button(\"button2\"); Button button3 = new Button(\"button3\"); Button button4 = new Button(\"button4\"); Button button5 = new Button(\"button5\"); Button button6 = new Button(\"button6\"); Button button7 = new Button(\"button7\"); Button button8 = new Button(\"button8\"); Button button9 = new Button(\"button9\"); Button button10 = new Button(\"button10\"); frame.setLayout(null); Panel panel1 = new Panel(new GridLayout(1,1)); panel1.setBounds(0,0,200,400); panel1.add(button1); Panel panel3 = new Panel(new GridLayout(2,1)); panel3.setBounds(200,0,400,400); panel3.add(button2); panel3.add(button3); Panel panel4 = new Panel(new GridLayout(1,1)); panel4.setBounds(600,0,200,400); panel4.add(button4); Panel panel2 = new Panel(new GridLayout()); panel2.setBounds(0,400,200,400); panel2.add(button5); Panel panel5 = new Panel(new GridLayout(2,2)); panel5.setBounds(200,400,400,400); panel5.add(button6); panel5.add(button7); panel5.add(button8); panel5.add(button9); Panel panel6 = new Panel(new GridLayout()); panel6.setBounds(600,400,200,400); panel6.add(button10); frame.add(panel1); frame.add(panel3); frame.add(panel4); frame.add(panel2); frame.add(panel5); frame.add(panel6); } } 2.4.监听器 一个按钮可以添加多个监听 import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEvent1 { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); frame.setBounds(100,100,500,500); // 一个按钮可以同时添加多个监听 Button button = new Button(); button.addActionListener((actionEvent) -&gt; System.out.println(\"1\")); button.addActionListener((actionEvent) -&gt; System.out.println(\"2\")); frame.add(button,BorderLayout.NORTH); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 一个监听可以给多个按钮共同使用 import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEvent2 { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); frame.setBounds(100,100,500,500); // 顶一个一个监听可以多个按钮共同使用 ActionListener actionListener = new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println(e.getActionCommand()); } }; Button button1 = new Button(\"1\"); // 可以为按钮带参数来控制同一个监听执行不同按钮的方法 button1.setActionCommand(\"11111111111111\"); button1.addActionListener(actionListener); Button button2 = new Button(\"2\"); button2.addActionListener(actionListener); frame.add(button1,BorderLayout.NORTH); frame.add(button2,BorderLayout.SOUTH); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 总结 frame是一个顶级容器 panel面板不能单独存在，需要放到容器中使用 布局管理器 流式布局 东西南北中 表格布局 监听器 // 添加监听 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); 2.5输入框监听import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEvent3 { public static void main(String[] args) { new MyFrame(); } } class MyFrame extends Frame{ public MyFrame(){ TextField textArea = new TextField(); textArea.addActionListener((event)-&gt; { System.out.println(textArea.getText()); textArea.setText(\"\"); }); this.setVisible(true); this.setBounds(100,100,500,500); add(textArea); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 2.6.简易计算器import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestCalc { public static void main(String[] args) { Calc calc = new Calc(); } } class Calc extends Frame{ public Calc(){ TextField jia1 = new TextField(\"10\"); TextField jia2 = new TextField(\"10\"); TextField rest = new TextField(\"20\"); setLayout(new FlowLayout()); add(jia1); add(new Label(\"+\")); add(jia2); Button button = new Button(\"=\"); button.addActionListener(e -&gt; { int jia = Integer.parseInt(jia1.getText()); int beijia = Integer.parseInt(jia2.getText()); rest.setText(jia+beijia+\"\"); jia1.setText(\"\"); jia2.setText(\"\"); }); add(button); add(rest); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); setVisible(true); pack(); } } 2.7.画笔import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestPaint { public static void main(String[] args) { new MyPaint().loadMyPaint(); } } class MyPaint extends Frame{ public void loadMyPaint(){ setVisible(true); setBounds(100,100,800,600); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } @Override public void paint(Graphics g) { // super.paint(g); g.setColor(Color.blue); g.drawOval(100,100,100,100); g.fillOval(100,200,100,100); g.fillRect(100,300,200,100); } } 2.8.鼠标监听目的：想要实现鼠标画画 import java.awt.*; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.util.ArrayList; import java.util.Iterator; import java.util.List; //测试鼠标监听 public class TestMouseListenter { public static void main(String[] args) { new Paint(\"画图\").loadMyPaint(); } } class Paint extends Frame { private List&lt;Point&gt; pointList; private Paint cuttorPaint; public Paint(String title){ super(title); cuttorPaint = this; pointList = new ArrayList&lt;&gt;(); } public void loadMyPaint(){ setVisible(true); setBounds(100,100,800,600); addMouseListener(new MyMouseListenter()); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } @Override public void paint(Graphics g) { Iterator&lt;Point&gt; iterator = pointList.iterator(); while (iterator.hasNext()){ Point point = iterator.next(); //循环画列表的点坐标 g.fillOval(point.x,point.y,10,10); } } private class MyMouseListenter extends MouseAdapter{ // 按下鼠标时触发 @Override public void mousePressed(MouseEvent e) { pointList.add(new Point(e.getX(),e.getY())); //画笔重新画点 cuttorPaint.repaint(); } } } 2.9.窗口监听import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestWindow { public static void main(String[] args) { new MyWindow().loadMyPaint(); } } class MyWindow extends Frame{ public MyWindow(){ super(\"默认窗口名称\"); } public void loadMyPaint(){ setVisible(true); setBounds(100,100,800,600); addWindowListener(new WindowAdapter() { // 点击窗口关闭按钮 @Override public void windowClosing(WindowEvent e) { System.exit(0); } @Override public void windowDeactivated(WindowEvent e) { System.out.println(\"窗口失去焦点\"); } // 打开窗口时执行 @Override public void windowOpened(WindowEvent e) { System.out.println(\"windowOpened\"); } @Override public void windowClosed(WindowEvent e) { System.out.println(\"windowClosed\"); } @Override public void windowIconified(WindowEvent e) { System.out.println(\"缩小\"); } @Override public void windowDeiconified(WindowEvent e) { System.out.println(\"缩小对应的弹出窗口\"); } @Override public void windowActivated(WindowEvent e) { setTitle(\"被激活了窗口\"); } @Override public void windowStateChanged(WindowEvent e) { System.out.println(\"windowStateChanged\"); } @Override public void windowGainedFocus(WindowEvent e) { System.out.println(\"windowGainedFocus\"); } @Override public void windowLostFocus(WindowEvent e) { System.out.println(\"windowLostFocus\"); } }); } } 2.10.键盘监听import java.awt.*; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestKeyListener { public static void main(String[] args) { new MyKeyFrame().loadMyPaint(); } } class MyKeyFrame extends Frame{ public MyKeyFrame(){ super(\"默认窗口名称\"); } public void loadMyPaint(){ setVisible(true); setBounds(100,100,800,600); addKeyListener(new KeyAdapter() { // 按下键时执行 @Override public void keyPressed(KeyEvent e) { int keyCode = e.getKeyCode(); System.out.println(keyCode); if(keyCode == KeyEvent.VK_ENTER){ System.out.println(\"按了回车\"); } } }); addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 3.SwingSwing是AWT的封装演化， 3.1.窗口 JFrameimport javax.swing.*; import java.awt.Container; import static java.awt.Color.YELLOW; public class TestJFrame1 { public static void main(String[] args) { JFrame jFrame = new JFrame(); jFrame.setBounds(10,10,400,400); jFrame.setVisible(true); JLabel jLabel = new JLabel(\"测试标签\"); // jFrame.setBackground(Color.BLACK); Container contentPane = jFrame.getContentPane(); contentPane.setBackground(YELLOW); //标签居中 jLabel.setHorizontalAlignment(SwingConstants.CENTER); jFrame.add(jLabel); // 不设置，默认是隐藏窗口 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } 3.2弹窗 JDialog import javax.swing.*; import java.awt.*; import static java.awt.Color.YELLOW; public class TestJFrame2 { public static void main(String[] args) { JFrame jFrame = new JFrame(); jFrame.setBounds(10,10,400,400); jFrame.setVisible(true); JButton jLabel = new JButton(\"测试按钮\"); // jFrame.setBackground(Color.BLACK); Container contentPane = jFrame.getContentPane(); contentPane.setBackground(YELLOW); // 设置居中 jLabel.setHorizontalAlignment(SwingConstants.CENTER); jLabel.addActionListener(e -&gt; new Mydiglog() ); contentPane.setLayout(null); jLabel.setLocation(50,50); jLabel.setSize(200,50); contentPane.add(jLabel); // 不设置，默认是隐藏窗口 jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } } class Mydiglog extends JDialog{ public Mydiglog(){ setVisible(true); setBounds(10,10,500,500); // 弹窗默认带了关闭，不需要写 // setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); JLabel jLabel = new JLabel(\"测试弹窗标签2 \"); Container container = getContentPane(); container.setLayout(null); jLabel.setLocation(10,10); jLabel.setSize(100,20); container.add(jLabel); } } 3.3 图标Iconpackage com.duan.lesson03; import javax.swing.*; import java.awt.*; public class IconFrame1 { public static void main(String[] args) { JFrame jFrame = new JFrame(); jFrame.setBounds(10,10,400,400); jFrame.setVisible(true); JLabel jButton = new JLabel(\" 标签\",new MyIconDemo(10,10),SwingConstants.CENTER); // 不设置，默认是隐藏窗口 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jButton.setSize(100,100); jFrame.add(jButton); } } class MyIconDemo implements Icon{ private int iconWiddth; private int iconHeight; public MyIconDemo(int iconWiddth,int iconHeight){ this.iconWiddth = iconWiddth; this.iconHeight = iconHeight; } @Override public void paintIcon(Component c, Graphics g, int x, int y) { g.fillOval(x,y,iconWiddth,iconHeight); } @Override public int getIconWidth() { return iconWiddth; } @Override public int getIconHeight() { return iconHeight; } } 其他创建和使用与awt类似，类名加J前缀，增加了一些快捷实现 3.4滚动条面板import javax.swing.*; import java.awt.*; import java.io.File; import java.net.MalformedURLException; public class TestPanle4 { public static void main(String[] args) { JFrame jFrame = new JFrame(); jFrame.setBounds(10,10,400,400); jFrame.setVisible(true); JTextArea jTextArea = new JTextArea(50,50); // 滚动条面板 JScrollPane jButton = new JScrollPane(jTextArea); jFrame.add(jButton); } } 4.贪吃蛇帧，如果时间片足够小，就是动画 一秒三时帧，连起来是动画 拆开就是图片 键盘监听 addKeyListener 需要注意 如果是面板添加监听需要设置当前面板获取焦点 setFocusable (true); 定时器Timer import javax.swing.*; import java.awt.*; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import java.io.File; import java.net.MalformedURLException; import java.net.URL; import java.util.Random; public class StartGame { public static void main(String[] args) { JFrame jFrame = new JFrame(\"贪吃蛇\"); jFrame.add(new GamePanel()); // 设置窗口不可拉伸 jFrame.setResizable(false); // 固定大小 jFrame.setBounds(100,100,900,750); jFrame.setVisible(true); jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } } //游戏面板 class GamePanel extends JPanel{ private int length = 3; private int fx; private int[][] zuobiao = new int[2][850]; private boolean isStart = false; private boolean isError = false; private int[] foot = new int[2]; Random random = new Random(); private Timer timer = new Timer(100,e -&gt; { if(isStart &amp;&amp; !isError){ if(zuobiao[0][0] == foot[0] &amp;&amp; zuobiao[1][0] == foot[1]){ length++; setRandomFoot(); } for (int i = length - 1; i &gt; 0; i--) { zuobiao[0][i] = zuobiao[0][i-1]; zuobiao[1][i] = zuobiao[1][i-1]; } switch (fx){ case KeyEvent.VK_RIGHT: zuobiao[0][0] = zuobiao[0][0]+25; if(zuobiao[0][0] &gt;= 875)zuobiao[0][0]=25; break; case KeyEvent.VK_LEFT: zuobiao[0][0] = zuobiao[0][0]-25; if(zuobiao[0][0] &lt; 25)zuobiao[0][0]=850; break; case KeyEvent.VK_UP: zuobiao[1][0] = zuobiao[1][0]-25; if(zuobiao[1][0] &lt;= 70)zuobiao[1][0]=675; break; case KeyEvent.VK_DOWN: zuobiao[1][0] = zuobiao[1][0]+25; if(zuobiao[1][0] &gt;= 675)zuobiao[1][0]=70; break; } // 失败条件 for (int i = 1; i &lt; length; i++) { if(zuobiao[0][0] == zuobiao[0][i] &amp;&amp; zuobiao[1][0] == zuobiao[1][i]){ isError = true; } } repaint(); } }); public GamePanel(){ addKeyListener(new KeyAdapter() { @Override public void keyPressed(KeyEvent e) { switch (e.getKeyCode()){ case KeyEvent.VK_ENTER: isError = false; timer.stop(); init(); break; case KeyEvent.VK_SPACE: if(!isError){ isStart = !isStart; repaint(); } break; case KeyEvent.VK_UP: if(fx != KeyEvent.VK_DOWN)fx = KeyEvent.VK_UP; break; case KeyEvent.VK_DOWN: if(fx != KeyEvent.VK_UP)fx = KeyEvent.VK_DOWN; break; case KeyEvent.VK_LEFT: if(fx != KeyEvent.VK_RIGHT)fx = KeyEvent.VK_LEFT; break; case KeyEvent.VK_RIGHT: if(fx != KeyEvent.VK_LEFT)fx = KeyEvent.VK_RIGHT; break; } } }); init(); } public void init(){ length = 3; zuobiao[0][0] = 100; zuobiao[1][0] = 95; for (int i = 1; i &lt; length; i++) { zuobiao[0][i] = zuobiao[0][0]-i*25; zuobiao[1][i] = zuobiao[1][0]; } setRandomFoot(); // 默认向右 fx = KeyEvent.VK_RIGHT; setFocusable(true); // timer.setDelay(1); timer.start(); } //设置事物随机坐标 private void setRandomFoot() { foot[0] = 25 + 25*random.nextInt(34); foot[1] = 70 + 25*random.nextInt(24); for (int i = 0; i &lt; length; i++) { if(zuobiao[0][i] == foot[0] &amp;&amp; zuobiao[1][i] == foot[1]){ setRandomFoot(); } } } // 画板 @Override protected void paintComponent(Graphics g) { super.paintComponent(g); setBackground(Color.white); GameData.header.paintIcon(this,g ,25,0); g.fillRect(25,70,850,625); GameData.food.paintIcon(this,g ,foot[0],foot[1]); switch (fx){ case KeyEvent.VK_RIGHT: GameData.right.paintIcon(this,g,zuobiao[0][0],zuobiao[1][0]); break; case KeyEvent.VK_LEFT: GameData.left.paintIcon(this,g,zuobiao[0][0],zuobiao[1][0]); break; case KeyEvent.VK_UP: GameData.up.paintIcon(this,g,zuobiao[0][0],zuobiao[1][0]); break; case KeyEvent.VK_DOWN: GameData.dowm.paintIcon(this,g,zuobiao[0][0],zuobiao[1][0]); break; } for (int i = 1; i &lt; length; i++) { GameData.body.paintIcon(this,g,zuobiao[0][i],zuobiao[1][i]); } if(!isStart){ g.setColor(Color.YELLOW); g.setFont(new Font(\"微软雅黑\",Font.BOLD,48)); g.drawString(\"按空格开启游戏\",250,500); } if(isError){ g.setColor(Color.RED); g.setFont(new Font(\"微软雅黑\",Font.BOLD,48)); g.drawString(\"游戏失败,按回车开启游戏\",250,500); } } } //游戏图标类 class GameData{ private static URL bodyurl; private static URL downurl; private static URL foodurl; private static URL headerurl; private static URL lefturl; private static URL righturl; private static URL upurl; static { try { bodyurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\body.png\").toURL(); foodurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\food.png\").toURL(); headerurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\header.png\").toURL(); upurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\up.png\").toURL(); downurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\down.png\").toURL(); lefturl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\left.png\").toURL(); righturl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\right.png\").toURL(); } catch (MalformedURLException e) { e.printStackTrace(); } } public static ImageIcon header = new ImageIcon(headerurl); public static ImageIcon body = new ImageIcon(bodyurl); public static ImageIcon food = new ImageIcon(foodurl); public static ImageIcon up = new ImageIcon(upurl); public static ImageIcon dowm = new ImageIcon(downurl); public static ImageIcon left = new ImageIcon(lefturl); public static ImageIcon right = new ImageIcon(righturl); } \\\\img\\\\statics\\\\body.png\").toURL(); foodurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\food.png\").toURL(); headerurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\header.png\").toURL(); upurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\up.png\").toURL(); downurl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\down.png\").toURL(); lefturl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\left.png\").toURL(); righturl = new File(\"D:\\\\xuexi\\\\img\\\\statics\\\\right.png\").toURL(); } catch (MalformedURLException e) { e.printStackTrace(); } } public static ImageIcon header = new ImageIcon(headerurl); public static ImageIcon body = new ImageIcon(bodyurl); public static ImageIcon food = new ImageIcon(foodurl); public static ImageIcon up = new ImageIcon(upurl); public static ImageIcon dowm = new ImageIcon(downurl); public static ImageIcon left = new ImageIcon(lefturl); public static ImageIcon right = new ImageIcon(righturl); }","categories":[],"tags":[]},{"title":"Hexo之渲染绕过","slug":"Hexo-xr","date":"2020-04-27T16:00:00.000Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"posts/17fd92ae.html","link":"","permalink":"https://gitee.com/td278121/posts/17fd92ae.html","excerpt":"","text":"0x001 Hexo 渲染 在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。因此对某个文件或者目录进行排除渲染是非常必要的。 0x002 方法一：font matterHexo新建网站页面，然后将你的代码直接写入 index.md 中 在 Front matter 中添加 layout: false，此方法适用于单一的纯HTMLCSS 页面。 --- title: tools date: 2020-04-28 00:00:00 type: \"tools\" layout: false --- 0x003 方法二：skip render在博客根目录下的 _config.yml，找到 skip_render，大概在32行左右，写入你想要的跳过渲染的路径，注意缩进和空格。 # 指定目录跳过hexo渲染 skip_render: - 'tools/*' - 'tools/**' 注释：tools/* 表示在目录 source/fireworks 下的文件全部跳过渲染，tools/** 表示在博客根目录 source/tools/ 文件夹下的文件全部跳过渲染（例如页面的 js、css 在另一个文件夹中）。 0x004 案例：webstack 导航webstack是一个纯静态的网址导航网站，内容均由viggo收集并整理。项目基于bootstrap前端框架开发。 Github：https://github.com/WebStackPage/WebStackPage.github.io 在博客根目录 source/下新建tools，然后新建index.html,将webstack网页源码全选复制粘贴到里面。 本站的webstack源码：view-source:http://luckyzmj.cn/tools/ 注意：将源码里的部分信息以及跳转链接按照你真实个人博客的环境进行修改。 然后打开博客根目录下配置文件_config.yml，找到skip_render，做如下修改： skip_render: - 'tools/*' - 'tools/**' 最后执行hexo clean和hexo s -g 本地预览，检查无误后hexo g -d部署到服务器上即可。 参考文章 https://xiabor.com/2020/04/21/hexo3/#%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87hexo%E7%9A%84%E6%B8%B2%E6%9F%93","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://gitee.com/td278121/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://gitee.com/td278121/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"https://gitee.com/td278121/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"}],"author":"luckyzmj"}],"categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://gitee.com/td278121/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://gitee.com/td278121/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"https://gitee.com/td278121/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"}]}