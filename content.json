{"meta":{"title":"TD","subtitle":"TDの博客","description":"湖南应用技术学院 | 软件技术专业 | 软件开发","author":"TD","url":"https://gitee.com/td278121","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"https://gitee.com/td278121/404.html","excerpt":"","text":""},{"title":"","date":"2021-09-14T05:00:02.323Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://gitee.com/td278121/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-09-14T05:00:24.099Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://gitee.com/td278121/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"https://gitee.com/td278121/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"about/index.html","permalink":"https://gitee.com/td278121/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"categories/index.html","permalink":"https://gitee.com/td278121/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"archives/index.html","permalink":"https://gitee.com/td278121/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"census/index.html","permalink":"https://gitee.com/td278121/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"contact/index.html","permalink":"https://gitee.com/td278121/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"https://gitee.com/td278121/resource/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"friends/index.html","permalink":"https://gitee.com/td278121/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"tags/index.html","permalink":"https://gitee.com/td278121/tags/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"https://gitee.com/td278121/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"https://gitee.com/td278121/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://gitee.com/td278121/List/tools/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-09-14T03:51:12.887Z","updated":"2021-09-14T04:16:02.596Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://gitee.com/td278121/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"TD","slug":"TD","date":"2021-05-05T10:28:52.000Z","updated":"2021-05-05T11:08:23.019Z","comments":true,"path":"posts/eebf0f26.html","link":"","permalink":"https://gitee.com/td278121/posts/eebf0f26.html","excerpt":"","text":"","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}],"author":"TD"},{"title":"Java环境配置","slug":"Java环境配置","date":"2021-05-02T03:37:34.000Z","updated":"2021-07-23T00:26:24.503Z","comments":true,"path":"posts/3bfcc107.html","link":"","permalink":"https://gitee.com/td278121/posts/3bfcc107.html","excerpt":"","text":"一、JDK安装与配置JDK： Java develop kits Java开发工具包 JRE： Java running Enveriment Java运行环境 用户环境变量和系统变量的区别？ 用户环境变量只针对该用户登录系统有效，系统环境变量是对所有用户有效(我们配置的)。 注意： 1.如果环境变量配置正确，任然无法 使用javac或java 需要你重开一个命令提示符，环境变量配置才生效！！ 2.以后工作中，如果你的同事在命令提示符中可以用某个命令，但是你的电脑的命令提示符不能用，提示不是内部或外部命令，则一定要看是否配置了环境变量 二、\\t \\nl \\n 输出换行 \\r回车换行 l \\t 制表符 相当8个空格 用于格式对齐 例如：编程实现输出如下格式的数据，怎么实现？就可以用\\t 姓名 出生地 旺财 湖南衡阳 奥斯特罗夫斯基 莫斯科 三、编写Java程序的步骤 四、println 和print区别a) println 输出后换行 System.out.println(“abc”); System.out.println(“123”); 输出： abc 123 b) print 输出不换行 System.out.print(“abc”); System.out.println(“123”); 输出： abc123 四、Java中注释注释：是会被编译器忽略，给程序员看的 a) 单行注释：一次注释一行 //后面是注释的内容 b) 多行注释：一次注释多行 /一次可以注释一行或者多行/ c) 文档注释(后面讲) 五、jad反编译工具a) jad如何能在命令提示符进行使用？ i. 需要配置环境变量 b) jad反编译.class文件为java文件，并指定生成的java文件的路径","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://gitee.com/td278121/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"我的第一篇文章","slug":"我的第一篇文章","date":"2021-05-02T03:37:34.000Z","updated":"2021-05-03T08:10:25.177Z","comments":true,"path":"posts/7a776471.html","link":"","permalink":"https://gitee.com/td278121/posts/7a776471.html","excerpt":"","text":"我的第一篇文章","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"排序算法","slug":"排序算法","date":"2021-05-02T03:37:34.000Z","updated":"2021-07-23T00:26:20.976Z","comments":true,"path":"posts/3bfcc104.html","link":"","permalink":"https://gitee.com/td278121/posts/3bfcc104.html","excerpt":"","text":"冒泡排序int[] a={8,9,6,2,4}; int temp; for (int i = 0; i &lt; a.length-1; i++) { for (int j = 0; j &lt; a.length-1-i; j++) { if(a[j]&gt;a[j+1]){ temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } for (int i = 0; i &lt; a.length; i++) { System.out.print(a[i]+\"\\t\"); } 选择排序int[] a={8,9,6,2,4}; int temp; int k=1; for (int i = 0; i &lt; a.length-1; i++) { for (int j = k; j &lt;= a.length-1; j++) { if(a[i]&gt;a[j]){ temp=a[i]; a[i]=a[j]; a[j]=temp; } } k++; } for (int i = 0; i &lt; a.length; i++) { System.out.print(a[i]+\"\\t\"); } 插入排序int[] a={8,9,6,2,4}; int temp; for (int i = 1; i &lt; a.length; i++) { for (int j = i; j &gt; 0; j--) { if(a[j]&lt;a[j-1]){ temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; } } } for (int i = 0; i &lt; a.length; i++) { System.out.print(a[i]+\"\\t\"); } 万年历public class CalendarTest { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 1. 2021-7月的万年历 System.out.print(\"请输入年份：\"); int year = in.nextInt(); System.out.print(\"请输入月份：\"); int month = in.nextInt(); //1.关键点1：解决这个月的1号是星期几？ int sum = 0; //1.1整年的天数（1900年+1901+2020年） for (int i = 1900; i &lt;year; i++) { if(i%4==0&amp;&amp;i%100!=0||i%400==0) {//年份能被4整除并且不能被100整除 或者能被400整除 sum+=366; }else { sum+=365; } } //1.2.整月的天数（1月+2月+....+6月） for (int i = 1; i &lt; month; i++) { if(i==2) {//二月 if(year%4==0&amp;&amp;year%100!=0||year%400==0) { sum+=29; }else { sum+=28; } }else if(i==4||i==6||i==9||i==11) {//小月：4 6 9 11 sum+=30; }else {//大月：1，3，5，7，8，10，12 sum+=31; } } //1.3 加上1号那一天 sum++; //2.输出万年历 System.out.println(year+\"年\"+month+\"月的1号是星期：\"+sum%7); System.out.println(\"\\t\\t\\t\" + year + \"年\" + month + \"月\"); System.out.println(\"日\\t一\\t二\\t三\\t四\\t五\\t六\"); //2.1确定1号的位置 for(int i=1;i&lt;=sum%7;i++) { System.out.print(\"\\t\"); } //3.关键点2：确定当前月(month)份天数 int days = 0; if(month==2) {//二月 if(year%4==0&amp;&amp;year%100!=0||year%400==0) { days=29; }else { days=28; } }else if(month==4||month==6||month==9||month==11) {//小月：4 6 9 11 days=30; }else {//大月：1，3，5，7，8，10，12 days=31; } for (int i = 1; i &lt;=days; i++) { System.out.print(i+\"\\t\"); if((sum++)%7==6) { System.out.println(); } } } }","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://gitee.com/td278121/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"SSM图书管理整合","slug":"SSM图书管理整合","date":"2021-05-02T03:37:34.000Z","updated":"2021-07-23T00:30:33.204Z","comments":true,"path":"posts/3bfcc188.html","link":"","permalink":"https://gitee.com/td278121/posts/3bfcc188.html","excerpt":"SSM图书管理整合","text":"SSM图书管理整合 SSM图书管理整合Mybatis层新建数据库CREATE DATABASE `ssmbuild`; USE `ssmbuild`; DROP TABLE IF EXISTS `books`; CREATE TABLE `books` ( `bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id', `bookName` VARCHAR(100) NOT NULL COMMENT '书名', `bookCounts` INT(11) NOT NULL COMMENT '数量', `detail` VARCHAR(200) NOT NULL COMMENT '描述', KEY `bookID` (`bookID`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES (1,'Java',1,'从入门到放弃'), (2,'MySQL',10,'从删库到跑路'), (3,'Linux',5,'从进门到进牢'); 环境配置&lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 过滤器&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; xml配置 com.kuang.pojo com.kuang.dao com.kuang.service com.kuang.controller mybatis-config.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.li.pojo\"/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=\"com/li/dao/BookMapper.xml\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; applicationContext.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"classpath:spring-dao.xml\"/&gt; &lt;import resource=\"classpath:spring-mvc.xml\"/&gt; &lt;import resource=\"classpath:spring-service.xml\"/&gt; &lt;/beans&gt; data.properties ##如果使用的Mysql8.0+，需要加一个时区的配置 &amp;serverTimezone=Asia/Shanghai jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8 jdbc.username=root jdbc.password=123456 实体类public class Books { private int bookID; private String bookName; private int bookCounts; private String detail; } DAO配置Mapper接口public interface BookMapper { //增加一本书 int addBook(Books books); //删除一本书 int deleteBookById(@Param(\"bookId\") int id); //更改一本书 int updateBook(Books books); //查询一本书 Books queryBookById(@Param(\"bookId\") int id); //查询全部书 List&lt;Books&gt; queryAllBook(); Books queryBookByName(@Param(\"bookName\") String bookName); } Mapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.li.dao.BookMapper\"&gt; &lt;insert id=\"addBook\" parameterType=\"Books\"&gt; insert into ssmbuild.books (bookName, bookCounts, detail) values (#{bookName},#{bookCounts},#{detail}); &lt;/insert&gt; &lt;delete id=\"deleteBookById\" parameterType=\"int\"&gt; delete from ssmbuild.books where bookID = #{bookId} &lt;/delete&gt; &lt;update id=\"updateBook\" parameterType=\"Books\"&gt; update ssmbuild.books set bookName=#{bookName},bookCounts=#{bookCounts},detail=#{detail} where bookID=#{bookID}; &lt;/update&gt; &lt;select id=\"queryBookById\" resultType=\"Books\"&gt; select * from ssmbuild.books where bookID = #{bookId} &lt;/select&gt; &lt;select id=\"queryAllBook\" resultType=\"Books\"&gt; select * from ssmbuild.books &lt;/select&gt; &lt;select id=\"queryBookByName\" resultType=\"Books\"&gt; select * from ssmbuild.books where bookName = #{bookName} &lt;/select&gt; &lt;/mapper&gt; 编写Service层的接口和实现类接口 public interface BookService { //增加一本书 int addBook(Books books); //删除一本书 int deleteBookById(int id); //更新Book int updateBook(Books books); //查询一本书 Books queryBookById(int id); //查询全部一本书 List&lt;Books&gt; queryAllBook(); Books queryBookByName(String bookName); } 实现类 //通过注解与spring-service.xml绑定 @Service public class BookServiceImpl implements BookService{ //service调用dao层，组合Dao @Autowired private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } @Override public int addBook(Books books) { return bookMapper.addBook(books); } @Override public int deleteBookById(int id) { return bookMapper.deleteBookById(id); } public int updateBook(Books books) { return bookMapper.updateBook(books); } @Override public Books queryBookById(int id) { return bookMapper.queryBookById(id); } @Override public List&lt;Books&gt; queryAllBook() { return bookMapper.queryAllBook(); } @Override public Books queryBookByName(String bookName) { return bookMapper.queryBookByName(bookName); } } Spring层spring-dao&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 1.关联数据库--&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; &lt;!-- 2、连接池 dbcp:半自动化，不能自动连接 c3p0自动化操作（自动化加在配置文件，并可以自动配置到对象中 druid： hikari--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=\"driverClass\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"jdbcUrl\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"user\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=\"maxPoolSize\" value=\"30\"/&gt; &lt;property name=\"minPoolSize\" value=\"10\"/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=\"autoCommitOnClose\" value=\"false\"/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=\"checkoutTimeout\" value=\"10000\"/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=\"acquireRetryAttempts\" value=\"2\"/&gt; &lt;/bean&gt; &lt;!-- 3.sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 BookMapperImpl动态注入 --&gt; &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=\"basePackage\" value=\"com.li.dao\"/&gt; &lt;/bean&gt; &lt;/beans&gt; jdbc.properties jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8 jdbc.username=root jdbc.password=123 spring-service.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 1 扫描service相关的bean --&gt; &lt;context:component-scan base-package=\"com.li.service\" /&gt; &lt;!--2 BookServiceImpl注入到IOC容器中--&gt; &lt;bean id=\"BookServiceImpl\" class=\"com.li.service.BookServiceImpl\"&gt; &lt;property name=\"bookMapper\" ref=\"bookMapper\"/&gt; &lt;/bean&gt; &lt;!-- 3 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 4 AOP --&gt; &lt;/beans&gt; SpringMVC 层web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!-- DispatchServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 乱码过滤--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;/web-app&gt; spring-mvc.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" /&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=\"com.li.controller\" /&gt; &lt;/beans&gt; applicationContext.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"spring-dao.xml\"/&gt; &lt;import resource=\"spring-mvc.xml\"/&gt; &lt;import resource=\"spring-service.xml\"/&gt; &lt;/beans&gt; 基础框架配置完成 Controller 和 视图层编写增删改查控制层代码@Controller @RequestMapping(\"/book\") public class BookController { //controller 调 service层 @Autowired @Qualifier(\"BookServiceImpl\") private BookService bookService; // 查询全部书籍并返回一个书籍展示面 @RequestMapping(\"/allBook\") public String list(Model model) { List&lt;Books&gt; list = bookService.queryAllBook(); model.addAttribute(\"list\", list); return \"allBook\"; } //跳转到增加书籍页面 @RequestMapping(\"/toAddBook\") public String toAddPaper(){ return \"addBook\"; } //添加书籍页面的请求 @RequestMapping(\"/addBook\") public String addBook(Books books){ System.out.println(\"addBook=&gt;\" + books); bookService.addBook(books); return \"redirect:/book/allBook\"; //重定向到@RequestMapping（\"allBook\") 请求； } //跳转到修改页面 @RequestMapping(\"/toUpdate\") public String toUpdatePaper(int id,Model model){ Books books = bookService.queryBookById(id); model.addAttribute(\"QBook\",books); return \"updateBook\"; } //修改书籍 @RequestMapping(\"/updateBook\") public String updateBook(Books books){ System.out.println(\"updateBook=&gt;\" + books); bookService.updateBook(books); return \"redirect:/book/allBook\"; } //删除书籍 @RequestMapping(\"/deleteBook/{bookId}\") public String deleteBook(@PathVariable(\"bookId\") int id){ bookService.deleteBookById(id); return \"redirect:/book/allBook\"; } //查询书籍 @RequestMapping(\"/queryBook\") public String queryBook(String queryBookName, Model model){ Books books = bookService.queryBookByName(queryBookName); System.err.println(\"book=&gt;\" + books); List&lt;Books&gt; list = new ArrayList&lt;&gt;(); list.add(books); if (books == null){ list = bookService.queryAllBook(); model.addAttribute(\"error\",\"未查到\"); } model.addAttribute(\"list\",list); return \"allBook\"; } } JSP页面编写allBook.jsp&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;body&gt; &lt;head&gt; &lt;title&gt;书籍展示&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;&lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-l2 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;书籍列表-------显示所有书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 column\"&gt; &lt;%-- toAddBook --%&gt; &lt;a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/book/toAddBook\"&gt;新增书籍&lt;/a&gt; &lt;a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/book/allBook\"&gt;显示全部书籍&lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-md-8column\"&gt;&lt;/div&gt; &lt;%-- 查询书籍 --%&gt; &lt;form action=\"${pageContext.request.contextPath}/book/queryBook\" method=\"post\" style=\"float: right\"&gt; &lt;span style=\"color: #ff0000;font-weight: bold\"&gt;${error}&lt;/span&gt; &lt;input type=\"text\" name=\"queryBookName\" class=\"from-control\" placeholder=\"请输入要查询的书籍名称\"&gt; &lt;input type=\"submit\" value=\"查询\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-l2 column\"&gt; &lt;table class=\"table table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;/th&gt; &lt;th&gt;书籍名称&lt;/th&gt; &lt;th&gt;书籍数量&lt;/th&gt; &lt;th&gt;书籍详情&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;%--书籍从数据库查找出来，从这个list中遍历出来：forEach--%&gt; &lt;tbody&gt; &lt;c:forEach var=\"book\" items=\"${list}\"&gt; &lt;tr&gt; &lt;td&gt;${book.bookID}&lt;/td&gt; &lt;td&gt;${book.bookName}&lt;/td&gt; &lt;td&gt;${book.bookCounts}&lt;/td&gt; &lt;td&gt;${book.detail}&lt;/td&gt; &lt;td&gt; &lt;a href=\"${pageContext.request.contextPath}/book/toUpdate?id=${book.bookID}\"&gt;修改&lt;/a&gt; &amp;nbsp; &amp;nbsp; &lt;a href=\"${pageContext.request.contextPath}/book/deleteBook/${book.bookID}\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; addBook.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;新增书籍&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;&lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-l2 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;新增书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=\"${pageContext.request.contextPath}/book/addBook\" method=\"post\"&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍名称：&lt;/label&gt; &lt;input type=\"text\" name=\"bookName\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍数量：&lt;/label&gt; &lt;input type=\"text\" name=\"bookCounts\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍描述：&lt;/label&gt; &lt;input type=\"text\" name=\"detail\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;input type=\"submit\" class=\"form-control\" value=\"添加\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; updateBook.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;修改书籍&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;&lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-l2 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;修改书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=\"${pageContext.request.contextPath}/book/updateBook\" method=\"post\"&gt; &lt;%--隐藏域，用于传递书籍ID，不然传的ID默认值为0 无法完成更改--%&gt; &lt;input type=\"hidden\" name=\"bookID\" value=\"${QBook.bookID}\"&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍名称：&lt;/label&gt; &lt;input type=\"text\" name=\"bookName\" class=\"form-control\" value=\"${QBook.bookName}\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍数量：&lt;/label&gt; &lt;input type=\"text\" name=\"bookCounts\" class=\"form-control\" value=\"${QBook.bookCounts}\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍描述：&lt;/label&gt; &lt;input type=\"text\" name=\"detail\" class=\"form-control\" value=\"${QBook.detail}\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;input type=\"submit\" class=\"form-control\" value=\"修改\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; index.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style&gt; a{ text-decoration:none; color: black; font-size: 18px; } h3{ width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 5px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt; &lt;a href=\"${pageContext.request.contextPath}/book/allBook\"&gt;进入书籍页面&lt;/a&gt; &lt;/h3&gt; &lt;/body&gt; &lt;/html&gt;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Spring","slug":"Spring","date":"2021-05-02T03:37:34.000Z","updated":"2021-07-23T00:26:26.730Z","comments":true,"path":"posts/3bfcc109.html","link":"","permalink":"https://gitee.com/td278121/posts/3bfcc109.html","excerpt":"Spring","text":"Spring 1.Spring1.1简介Spring框架是一个开放源代码的J2EE应用程序框架，是针对bean的生命周期进行管理的轻量级容器（lightweight container），它解决了开发者在J2EE开发中遇到的许多常见的问题。 简单来说，Spring的目的就是为了帮助解决企业应用开发的复杂性。 开发者:Rod Johnson 在悉尼大学不仅获得了计算机学位，同时还获得了音乐学位，更令人吃惊的是在回到软件开发领域之前，他还获得了音乐学的博士学位。 理念:使现有的技术更加容易使用 本身是一个大杂烩,整合了现有的技术框架 1.2设计哲学https://blog.csdn.net/Cap220590/article/details/107070114 当你接触到一个框架的时候，不仅仅要知道这个框架是怎么使用的，更需要了解框架的设计原则，下面是Spring框架的设计原则： 在每一层都提供选项。Spring可以让你尽可能的推迟选择。比如你可以通过配置文件来切换数据存储的提供方而不需要改动代码。这个规则也很好的应用在和第三方API集成中。 适应不同的视角。Spring具有灵活性，它不会强制为你决定该怎么选择。它以不同的视角支持广泛的应用需求。 保持强大的向后兼容性。Spring的发展经过了精心的管理，使得版本之间几乎没有割裂的变化。Spring支持精心选择的一系列JDK版本和第三方库，以便于维护依赖于Spring的应用程序和库。 关心API设计。Spring团队投入了大量的思想和时间来制作直观的API，这些API可以在多个版本中使用，并可以使用很多年。 为代码质量设定高标准。Spring框架将重点放在有意义、最新和准确的JavaDoc上。它是少数几个可以声明在包之间没有循环依赖关系的干净代码结构的项目之一。 &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1.2 优点 Spring是一个开源的免费框架(容器) Spring是一个轻量级的,非侵入式的框架 控制反转(IOC) 面向切面编程(AOP) 支持事务的处理,对框架整合的支持 Spring是一个轻量级的 控制反转(IOC) 和面向切面(AOP)编程的框架 1.3组成 Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速的开发单个微服务 约定大于配置 Spring Cloud ​ SpringCloud 是基于SpringBoot实现的 学习SpringBoot的前提是掌握Spring及SpringMVC 弊端:发展太久以后,与原本来的理念背道而驰, 配置比较繁琐 戏称”配置地狱” 2.IOC理论推导1.UserDao接口 2.UserDaoImpl实现类 3.UserService业务接口 4.UserServiceImpl业务实现类 最大的改变,使得原本开发中程序员要根据用户需求不断更改代码(显然这很耗费人力物力)转变为可根据用户不同需求程序被动改变 使用一个Set接口实现,已经发生革命性变化 public class UserServiceImpl implements UserService { private UserDao userDao; //利用Set进行动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; } 从本质上解决了业务中人为管理对象创建的 不便性,系统耦合性也大大降低,可以更加专注于业务的实现 IOC本质控制反转IoC(Inversion of Control)**是一种设计思想,**DI(依赖注入) 是实现IoC的一种方法,也有人认为DI只是IOC的另一种说法,没有IoC的程序中,我们使用面向对象编程,对象的创建与对象的依赖关系完全硬编码在程序中,对象的创建由程序自己控制,控制反转后由程序自己控制,控制反转后对象的创建转移给第三方 (狂神)个人认为所谓控制反转就是:获得依赖对象的方式反转了 控制反转是一种通过描述(XML或注解)并通过第三方去生产或获取特定对象的方式.在Spring中实现控制反转的是IoC容器,其实现方法是依赖注入(Dependency Injection,DI) 3.HelloSpring利用maven , 他会自动下载对应的依赖项 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; Hello实体类public class Hello { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\"Hello,\"+ name ); } } 编写spring文件 这里我们命名为beans.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--bean就是java对象 , 由Spring创建和管理--&gt; &lt;bean id=\"hello\" class=\"com.kuang.li.Hello\"&gt; &lt;property name=\"name\" value=\"Spring\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 测试@Test public void test(){ //解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //getBean : 参数即为spring配置文件中bean的id . Hello hello = (Hello) context.getBean(\"hello\"); hello.show(); } Hello 对象是谁创建的 ? 【hello 对象是由Spring创建的 Hello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的 这个过程就叫控制反转 : 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 . 依赖注入 : 就是利用set方法来进行注入的. IOC是一种编程思想，由主动的编程变成被动的接收 修改案例一&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 使用Spring创建对象,在Spring这些都称为Bean 类型 变量名 = new 类型(); id = 变量名 class = new Hello(); property相当于给对象中的属性设置一个值 --&gt; &lt;bean id=\"mysqlImpl\" class=\"com.li.dao.UserDaoMysqlImpl\"/&gt; &lt;bean id=\"oracleImpl\" class=\"com.li.dao.UserDaoOracleImpl\"/&gt; &lt;bean id=\"SqlserverImpl\" class=\"com.li.dao.UserSqlserverImpl\"/&gt; &lt;bean id=\"UserServiceImpl\" class=\"com.li.service.UserServiceImpl\"&gt; &lt;property name=\"userDao\" ref=\"SqlserverImpl\"/&gt; &lt;/bean&gt; &lt;!-- ref: 引用Spring容器中创建好的对象 value:具体的值,基本数据类型--&gt; &lt;/beans&gt; 测试 public class MyTest { public static void main(String[] args) { //获取ApplicationContext ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //容器在手,天下我有,需要什么 get什么 UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(\"UserServiceImpl\"); userServiceImpl.getUser(); } } 4.IOC创建对象方式通过无参构造函数 user.java public class User { private String name; public User(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public void show(){ System.out.println(\"name: \" + name); } } beans.xml &lt;!--第一种,下标赋值--&gt; &lt;!-- &lt;bean id=\"user\" class=\"com.li.pojo.User\"&gt;--&gt; &lt;!-- &lt;constructor-arg index=\"0\" value=\"LI\"/&gt;--&gt; &lt;!-- &lt;/bean&gt;--&gt; &lt;!-- 第二种,通过类型创建 不建议使用--&gt; &lt;!-- &lt;bean id=\"user\" class=\"com.li.pojo.User\"&gt;--&gt; &lt;!-- &lt;constructor-arg type=\"java.lang.String\" value=\"Lucy\"/&gt;--&gt; &lt;!-- &lt;/bean&gt;--&gt; &lt;!-- 第三种,之间通过参数名设置--&gt; &lt;bean id=\"user\" class=\"com.li.pojo.User\"&gt; &lt;constructor-arg name=\"name\" value=\"Liu\"/&gt; &lt;/bean&gt; 测试类 public class MyTest { public static void main(String[] args) { //Spring容器, 类似于婚介网站 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = (User) context.getBean(\"user\"); user.show(); } } 通过有参构造方法来创建 7.4 用注解实习自动装配jdk1.5支持的注解,Spring2.5就已经支持 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. 使用注解须知 1.导入约束 2.配置注解的支持 context:annotation-config/ 很重要(不导入就无法使用注解) &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;/beans&gt; @Autowrise 直接在属性上使用 也可以在set方式上使用 底层是反射原理 使用Autowired 我们可以不用编写set方法,前提是你这个地洞装配的属性在IOC(Spring)容器中存在,且符合名字byname 科普: @Nullable 字段标记了这个注解,说明这个字段可以为null public @interface Autowired{ boolean required() default true; } 测试代码 public class People { //显示Autowired(required = false) 说明这个对象的属性可以为null,否则不允许为空 @Autowired(required = false) private Cat cat; @Autowired private Dog dog; private String name; } Auotowired注解是智能识别的,当注入在IoC 容器中该类型只有一个时,就通过byType进行匹配,当注入容器存在多个同一类型的对象时,就根据byName进行装配 如果@Auotowired自动装配环境比较复杂,自动装配比较复杂,无法通过一个注解[Auotowired]完成时候,就可以使用 @Qualifier(value=”***”) 去配合@Auotowired的使用,指定一个唯一的bean对象注入 public class People { //显示Autowired(required = false) 说明这个对象的属性可以为null,否则不允许为空 @Autowired @Qualifier(value = \"cat\") private Cat cat; @Autowired private Dog dog; private String name; } 小结: @Resource 和 @Autowired 区别:@Resource默认通过byName的方式实现,如果找不到则通过byType实现;如果两个都找不到就报错{常用} 执行顺序不同:@Autowired 通过byType实现 @Resource默认通过byName的方式实现 相同:都是自动装配,都可以放在属性字段上 8. 使用注解开发在Spring4后,要使用注解开发,必须保证AOP的包导入了 使用注解需要导入context约束,增加注解支持 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;/beans&gt; 1.bean 2.属性如何注入 //等价于&lt;bean id=\"user\" class=\"com.li.pojo.User\"/&gt; //@Component组件 @Component public class User { public String name; //相当于 &lt;property name=\"name\" value=\"Zy\"/&gt; @Value(\"Zy\") public void setName(String name) { this.name = name; } } 3.衍生的注解 @Component有几个衍生注解,我们在web开发中,会按照MVC三层架构分层 dao [@Repository] service [@Service] controller [@Controller] 这四个注解的功能相同,代表将某个类注册到Spring中,装配Bean 4.自动装配注解 ##注解说明 -@Autowired:自动装配通过类型,名字 如果@Autowired不能唯一自动装配上属性,需要通过@Qualifier(value=\"***\") -@Nullable 字段标记这个属性代表这个字段可以为null -@Resource 自动装配通过名字,类型 5.作用域 @Component @Scope(\"prototype\") public class User { public String name; //相当于 &lt;property name=\"name\" value=\"Zy\"/&gt; @Value(\"Zy\") public void setName(String name) { this.name = name; } } 6.小结 xml与注解: xml更加万能,适用于任何场合,维护更加简单 注解 不是自己类用不了,维护相对复杂 xml用了管理bean 注解只负责完成属性的输入 我们在使用的过程中,只需要注意一个问题:必须让注解生效,就是需要开启注解的支持 &lt;!-- 指定要扫描的包,这个包下的注解就会生效--&gt; &lt;context:component-scan base-package=\"com.li\"/&gt; &lt;context:annotation-config/&gt; 9.使用Java的方式配置SpringJavaConfig是Spring的一个子项目,在Spring4之后,它成为了一个核心功能 实体类//这个类被Spring接管注册到了容器中 @Component public class User { private String name; public String getName() { return name; } @Value(\"Zy\")//注入值 public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; } } 配置类package com.li.config; import com.li.pojo.User; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; //注册到Spring容器中,因为它本身是一个@Component //Configuration代表这是一个配置类,和我们之前看的bean.xml相似 @Configuration @ComponentScan(\"com.li.pojo\") @Import(MyConfig2.class) public class MyConfig { //注册一个bean,相当于我们之前写的bean标签 //这个方法相当于bean标签中的id属性 返回值相当于bean中的Class属性 @Bean public User getUser(){ return new User(); } } 测试public class MyTest { public static void main(String[] args) { //如果完全使用了配置类方式去做,我们只能通过AnnotationConfig上下文来获取容器,通过配置类的class对象加载 ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); User getUser = context.getBean(\"user\", User.class); System.out.println(getUser.getName()); } } 这种纯Java的配置方式在SpringBoot中随处可见 10 代理模式为什么学代理模式 代理模式就是SpringAOP的底层 [SpringAOP SpringMVC] 分类: 静态代理 动态代理 10.1 静态代理角色分析: 抽象角色:一般会使用接口或抽象类来解决 真实角色:被代理的角色 代理角色:代理真实角色,然后做一些附属操作 客户:访问代理对象的人 代码步骤: 接口 //租房 public interface Rent { public void rent(); } 真实角色 //房东 public class Host implements Rent{ public void rent(){ System.out.println(\"出租房子\"); } } 代理角色 public class Proxy implements Rent{ private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } public void rent(){ seeHouse(); host.rent(); heTong(); fare(); } //看房 private void seeHouse(){ System.out.println(\"中介带你看房\"); } private void heTong(){ System.out.println(\"签合同\"); } //收中介费 private void fare(){ System.out.println(\"收中介费\"); } } 客户端访问代理角色 public class Client { public static void main(String[] args) { Host host = new Host(); //代理 中介帮房东出租房子,但是中间有一些附属操作 Proxy proxy = new Proxy(host); //你不用面对房东,直接找中介 proxy.rent(); } } 静态代理模式优势: 可以使真实角色更加纯粹,不用关注一些公共业务 公共也就交给代理角色,实现业务分工 公共业务发生扩展时,方便集中管理 缺点: 一个真实角色会产生一个代理角色,代码量会翻倍–开发效率变低– 10.2加深理解代码: demo_02 10.3 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的,不是直接写好的 动态代理分为两大类: 基于代理的动态代理 基于类的动态代理 基于接口–JDK动态代理 基于类: cglib Java字节码实现:Javassist 需要了解两个类: Proxy invocationHandier 静态代理模式优势: 可以使真实角色更加纯粹,不用关注一些公共业务 公共也就交给代理角色,实现业务分工 公共业务发生扩展时,方便集中管理 一个动态代理类代理的是一个接口,一般就是对应的一类业务 一个动态代理可以代理多个类,只要是实现了同一个接口即可 11.AOP11.1什么是AOP11.2 AOP在Spring中的作用11.3使用Spring实现AOP[AOP]植入,需要导入一个包 &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 方式一:使用Spring的 API 接口 【主要是Spring的 API】 方式二：自定义实现AOP 【主要是切面定义】 方式三：使用注解实现 12. 整合Mybatis步骤： 1.导入相关jar包 junit mybatis mysql数据库 spring相关 AOP织入 mybatis-spring &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;Spring_Study&lt;/artifactId&gt; &lt;groupId&gt;com.li&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;spring_10_mybatis&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring连接操作数据库的话，还需要一个spring-jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2.编写配置文件 3.测试 12.1 回忆mybatis 编写实体类 编写核心配置文件 编写接口 编写Mapper.xml 测试 12.2 Mybatis-Spring中智科学院 编写数据源配置 sqlSessionFactory sqlSessionTemplate 需要给接口加实现类 将自己写的实现类，注入到Spring类中 测试 User实体类 —&gt; UserMapper接口 —-&gt; UserMapper.xml —–&gt; Mybatis配置（Spring-dao.xml) —-&gt; 通过Spring实现类（UserMapMapperImpl）注入到Spring（applicationContext）—-&gt;通过Spring测试 13. 声明式事务1.回顾事务 把一组业务当成一个业务来做 要么都成功，要么都失败 事务在项目开发中，十分重要，涉及数据的一致性问题， 确保完整和一致性 事务的ACID原则： A 原子性 C 一致性 I 隔离性 多个业务可能操作同一个资源，防止数据损坏 D 持久性 事务一旦提交，结果不会受到系统异常运行影响 被持久化写到存储器中 2. spring 中的 声明事务： AOP 编程式事务： 需要在代码中，进行事务管理 为什么需要事务 如果不配置事务，可能存在数据提交不一致的情况下； 如果我们不在Spring中配置声明式事务，我们就需要在代码中手动配置事务 事务在项目中的开发中十分重要，设计到数据的一致性和完整性问题，不容马虎 567","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Mybatis","slug":"mybatis","date":"2021-05-02T03:37:34.000Z","updated":"2021-07-23T00:26:25.637Z","comments":true,"path":"posts/3bfcc108.html","link":"","permalink":"https://gitee.com/td278121/posts/3bfcc108.html","excerpt":"Mybatis","text":"Mybatis 一·简介MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 二·第一个Mybatis程序一 新建数据库CREATE DATABASE `mybatis`; USE `mybatis`; CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL )ENGINE = INNODB DEFAULT CHARSET=utf8; INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,'李珍','000'), (2,'王德发','123') 二搭建环境1 新建普通的maven项目 2 删除src目录 3 导入依赖 &lt;!--父工程--&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Mybatis_Day01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;!--mysql驱动--&gt; &lt;!--https://downloads.mysql.com/archives/c-j/ --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;!--https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 4 创建一个模块 4·1编写mybatis核心文件 （数据库链接）&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;!--configuration核心配置文件--&gt; &lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--数据库配置 在url的后续信息配置中“=”左右不要加空格--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 4·2编写mybatis配置文件public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步：获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); }catch (IOException e){ e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } } 4·3编写代码·实体类 public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '}'; } } ·Dao接口 resultType： 返回一个结果（用的多） resultMap： 返回一个集合 public interface UserDao { List&lt;User&gt; getUserlist(); } ·接口实现类（由原来的UserDaolmpl装变为一个Mapper配置文件） &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!--绑定一个对应的Dao/Mapper接口--&gt; &lt;mapper namespace=\"com.li.dao.UserDao\"&gt; &lt;!--select 查询--&gt; &lt;select id=\"getUserList\" resultType=\"com.li.pojo.User\"&gt; select * from mybatis.user &lt;/select&gt; &lt;/mapper&gt; ·4.4测试注意：Could not find resource mybatis.config.xml Mapper junit maven由于约定大于配置，配置文件无法被导出或生效。解决方案 &lt;!--在build中配置resources，防止资源导出失败 手动导出资源到resources--&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 常见问题： 1.配置文件没有 注册 2.绑定接口错误 3.方法名不对 4.返回类型不对 5.Maven导出资源问题 三.CRUD1.namespace中的报名要和Dao/mapper接口名一致 2.select 选择查询id:就是对应的namespace中的方法名 resultType：Sql语句执行的返回值！parameterType：参数类型! 1.编写接口//根据id查用户 User getUserById(int id); 2.编写对应的mapper中的sql语句&lt;!--select 根据id查询--&gt; &lt;select id=\"getUserById\" parameterType=\"int\" resultType=\"com.li.pojo.User\"&gt; select * from mybatis.user where id = #{id} &lt;/select&gt; 3.测试@Test public void getUserById(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); } 3.Insert&lt;!--insert一个用户（通过对象) 其中对象中的属性可以直接取出来--&gt; &lt;insert id=\"addUser\" parameterType=\"com.li.pojo.User\"&gt; insert into mybatis.user (id, name ,pwd) value (#{id}, #{name}, #{pwd}); &lt;/insert&gt; 4.update&lt;!--update一个用户（通过对象) 其中对象中的属性可以直接取出来--&gt; &lt;update id=\"updateUser\" parameterType=\"com.li.pojo.User\"&gt; update mybatis.user set name = #{name}, pwd = #{pwd} where id = #{id}; &lt;/update&gt; 5.Delete&lt;!--delete一个用户--&gt; &lt;delete id=\"deleteUser\" parameterType=\"com.li.pojo.User\"&gt; delete from mybatis.user where id = #{id} &lt;/delete&gt; ·增删改查需要提交事务！ sqlSession.commit(); 6.万能Map假设，实体类或数据库中的表字段或参数过多，考虑用map传递对象 //万能Map int addUser2(Map&lt;String,Object&gt; map); &lt;!--通过Map insert一个用户（通过对象) 其中对象中的属性可以 直接取出来 传递map的Key--&gt; &lt;insert id=\"addUser\" parameterType=\"map\"&gt; insert into mybatis.user (id, name ,pwd) value (#{userid}, #{username}, #{password}); &lt;/insert&gt; 四·配置解析1.核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 2.环境配置（environments）mybatis可以配置成多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 学会使用配置多套运行环境 Mybatis默认的事务管理器是JDBC， 连接池：POOLED 3.属性（properties）可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置 编写一个配置文件 db.properties driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8 username=root password=123 在核心配置文件中引入 &lt;!--引入外部文件--&gt; &lt;properties resource=\"db.properties\"&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123\"/&gt; &lt;/properties&gt; 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一字段，优先使用外部配置文件 个人犯的错误：在配置完properties文件后测试发现并不能导出数据库信息，查询后发现在db.properties文件中的url地址是不需要加 “” 及其 amp字符，且每个属性应该用 &amp; 连接，而不应该用 ； 需要注意的就是&amp;amp转义字符的使用 xml中url的设置 url=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8\" 4.类型别名（typeAliases）类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写 &lt;!--给实体类起别名--&gt; &lt;typeAliases&gt; &lt;typeAlias type=\"com.li.pojo.User\" alias=\"User\"/&gt; &lt;/typeAliases&gt; 也可以指定一个包名，MyBatis会在包名下搜索需要的JavaBean： 扫描实体类的包，默认别名就为这个类的 类名，首字母小写 &lt;!--给实体类起别名--&gt; &lt;typeAliases&gt; &lt;typeAlias type=\"com.li.pojo\"/&gt; &lt;/typeAliases&gt; 实体类比较少时推荐使用第一种方式； 实体类比较多时使用第二种方式 第一种可以DIY别名，第二种不行，如要强行给需在实体上增加注解 @Alias(\"user\") public class User{} 5.设置（settings）这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为 6.其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） 7.映射器MapperRegistry: 注册绑定我们的Mapper文件； 方式一：【推荐使用】 &lt;mappers&gt; &lt;mapper resource=\"com/li/dao/UserMapper.xml\"/&gt; &lt;/mappers&gt; 方式二：使用class文件绑定注册 &lt;mappers&gt; &lt;mapper class=\"com.li.dao.UserMapper\"/&gt; &lt;/mappers&gt; 注意点： 接口和他的Mapper配置文件必须同名 接口和他的Mapper配置文件必须在同一个包下 方式三：使用扫描包进行注入绑定 &lt;mappers&gt; &lt;package name=\"com.li.dao\"/&gt; &lt;/mappers&gt; 注意点： 接口和他的Mapper配置文件必须同名 接口和他的Mapper配置文件必须在同一个包下 五·解决属性名和字段名不一致的问题1.问题数据库中字段 项目中字段 public class User { private int id; private String name; private String passWord; } 测试出现问题 select * from mybatis.user where id = #{id} //类处理器 select id,name,pwd from mybatis.user where id = #{id} 解决方法： 起别名 &lt;!--select 根据id查询--&gt; &lt;select id=\"getUserById\" parameterType=\"int\" resultType=\"com.li.pojo.User\"&gt; select id,name,pwd as passWord from mybatis.user where id = #{id} &lt;/select&gt; resultMap结果集映射 id name pwd id name passWord &lt;!--结果集映射--&gt; &lt;resultMap id=\"UserMap\" type=\"User\"&gt; &lt;!--column数据库中的字段，property实体类中的属性--&gt; &lt;result column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;result column=\"pwd\" property=\"passWord\"/&gt; &lt;/resultMap&gt; &lt;!--select 根据id查询--&gt; &lt;select id=\"getUserById\" parameterType=\"int\" resultMap=\"UserMap\"&gt; select * from mybatis.user where id = #{id} &lt;/select&gt; resultMap元素是MyBatis中最重要最强大的元素 ResultMap的设计思想是，对于简单的语句根本不需要配置显示的结果映射，而对于复杂一点的语句只要描述它们的关系就行了 ResultMap 最优的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。（哪个字段不一样映射哪个） 六·日志6.1日志工厂如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！ 曾经：sout、debug 现在：日志工厂 SLF4J LOG4J 【掌握】 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 【掌握】 NO_LOGGING 在设置中设定具体使用哪个日志在Mybatis中实现 STDOUT_LOGGING标准日志输出 在mybatis核心配置文件中，配置我们的日志！ 6.1LOG4J 什么是LOG4J？ LOG4J是Apache的一个开源项目，通过使用LOG4J，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码 1.导入LOG4J的包(导入到总项目xml文件配置下) &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.log4j.properties #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/li.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 3.配置log4j为日志的实现 &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;/settings&gt; 4.Log4j的使用！，直接测试运行刚才的查询 包含JDBC池的连接与断开 简单使用步骤 在要使用Log4j 的类中，导入包 import org.apache.log4j.Logger; 日志对象的参数为当前类class static Logger logger = Logger.getLogger(UserMapperTest.class); 日志级别 logger.info(\"info:进入了testLog4j\"); logger.debug(\"debug:进入了testLog4J\"); logger.error(\"error:进入了testLog4J\"); 七·分页目的：在进行数据量较大的操作时减少单次操作量 7.1 使用Limit分页语法：select * from user limit startIndex，pageSize; 例如：select * from user limit 3; #[0,n] 使用Mybatis实现分页，核心SQL 1.接口 //分页 List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); 2.Mapper.xml &lt;!--//分页--&gt; &lt;select id=\"getUserByLimit\" parameterType=\"map\" resultMap=\"UserMap\"&gt; select * from mybatis.user limit #{startIndex},#{pageSize} &lt;/select&gt; 3.测试 @Test public void getUserByLimit(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(\"startIndex\",1); //从索引1开始查 map.put(\"pageSize\",2);//输出两个数据量 List&lt;User&gt; userList = mapper.getUserByLimit(map); for (User user : userList) { System.out.println(user); } sqlSession.close(); } 7.2 RowBounds分页不使用SQL实现 （此方法目前逐渐被淘汰） 1.接口 //分页2 List&lt;User&gt; getUserByRowBounds(); 2.Mapper.xml &lt;!--分页2--&gt; &lt;select id=\"getUserByRowBounds\" resultMap=\"UserMap\"&gt; select * from mybatis.user &lt;/select&gt; 3.测试 @Test public void getUserByRowBounds(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); //RowBounds实现 RowBounds rowBounds = new RowBounds(1, 2); //通过Java代码层面实现分页 List&lt;User&gt; userList = sqlSession.selectList(\"com.li.dao.UserMapper.getUserByRowBounds\",null,rowBounds); for (User user : userList) { System.out.println(user); } sqlSession.close(); } 7.3 分页插件https://pagehelper.github.io/ 八·使用注解开发8.1 面向接口编程真正开发中，面向接口编程应用更广泛 解耦 可拓展 提高复用性 分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发更容易，规范性更好 关于接口的理解：**** 从更深层次理解是定义（规范，约束）与实现的分离 接口本身反映了系统设计人员对系统的抽象理解 三个面向对象区别 面向对象指的是我们考虑现实问题时，以对象为单位去定义它的属性及其方法 面向过程指的是我们考虑现实问题时，以一个具体的事务过程为单位去考虑它的实现 接口设计与非接口设计是针对于复用技术而言的，与面向对象（过程）不属于同一问题下，更多是体现对系统的整体架构 8.2 使用注解开发1.直接在接口上实现 @Select(\"select * from user\") List&lt;User&gt; getUsers(); 2.需要在核心配置文件绑定接口 &lt;!--绑定接口--&gt; &lt;mappers&gt; &lt;mapper class=\"com.li.dao.UserMapper\"/&gt; &lt;/mappers&gt; 3.测试 本质上是底层的反射机制 动态代理 Mybatis执行流程 8.3 CURD（注解完成）九.Lombok使用步骤： 在IDEA中安装Lombok插件！ 在项目中导入lombok的jar包 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; 3.直接在实体类上加注解 @Data 无参构造，get，set，soString，hashcode，equals @AllArgsConstructor @NoArgsConstructor 十.多对一处理 多个学生，对应一个老师 对于学生这边而言， 关联 .. 多个学生，关联一个老师 【多对一】 对于老师而言， 集合 ， 一个老师，有很多学生 【一对多】 SQL： CREATE TABLE `teacher` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAteacherULT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO teacher(`id`, `name`) VALUES ('1', '秦老师'); CREATE TABLE `student` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fktid` (`tid`), CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('1', '小明', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('2', '小红', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('3', '小张', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('4', '小李', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('5', '小王', '1'); 测试环境搭建 导入Lombok 新建实体类Teacher，Student 分别建立实体类的接口Mapper 建立Mapper.xml 在核心配置文件绑定注册Mapper接口/文件 测试查询结果 按查询嵌套处理&lt;!--思路： 1. 查询所有学生信息 2. 根据查询出的学生tid寻找对应的老师 --&gt; &lt;select id=\"getStudent\" resultMap=\"StudentTeacher\"&gt; select * from mybatis.student &lt;/select&gt; &lt;resultMap id=\"StudentTeacher\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;!-- 复杂属性单独处理对象：association 集合：collection--&gt; &lt;association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/&gt; &lt;/resultMap&gt; &lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt; select * from mybatis.teacher where id = #{tid} &lt;/select&gt; 按查询结果嵌套处理&lt;!--按照结果嵌套处理--&gt; &lt;select id=\"getStudent2\" resultMap=\"StudentTeacher2\"&gt; select s.id sid, s.name sname, t.name tname from mybatis.student s, mybatis.teacher t where s.tid = t.id &lt;/select&gt; &lt;resultMap id=\"StudentTeacher2\" type=\"Student\"&gt; &lt;result property=\"id\" column=\"sid\"/&gt; &lt;result property=\"name\" column=\"sname\"/&gt; &lt;association property=\"teacher\" javaType=\"Teacher\"&gt; &lt;result property=\"name\" column=\"tname\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; 相比来讲，第二种更容易理解类似于 Mysql联表查询 第一种类似于 Mysql子查询 十一.一对多处理十二.动态SQL==什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句== 利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 if choose (when, otherwise) trim (where, set) foreach 缓存1.简介 什么是缓存 [ Cache ]？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。【可以使用缓存】 2.MyBatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 2.1一级缓存 一级缓存也叫本地缓存： SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 测试步骤： 开启日志！ 测试在一个Sesion中查询两次相同记录 @Test public void queryById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.queryById(1); System.out.println(user); System.out.println(\"============\"); User user1 = mapper.queryById(1); System.out.println(user1); System.out.println(user == user1); System.out.println(user.equals(user1)); sqlSession.close(); } 3.查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！ mapper.updateUser(new User(2,\"zy\",\"afijdg\")); 3.查询不同的Mapper.xml 4.手动清理缓存！ sqlSession.clearCache(); 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！ 一级缓存就是一个Map。 2.2二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中；","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Vue","slug":"Vue学习笔记","date":"2021-05-02T03:37:34.000Z","updated":"2021-07-23T00:26:23.192Z","comments":true,"path":"posts/3bfcc105.html","link":"","permalink":"https://gitee.com/td278121/posts/3bfcc105.html","excerpt":"","text":"1. css Less中文网 Less快速入门 webpack打包 2. JavaScript github链接 2.1. 调试// 在浏览器的控制台打印变量 console.log(num); 2.2. 数据类型Number // js不区分小数和整数 Number 123 // 整数 123.1 // 浮点数 1.123e3 // 科学计数法 -99 // 负数 NAN // not a number Infinity // 无限大 字符串 'abc' \"abc\" // 转义字符 \\t \\n \\u4e2d // \\u#### Unicode字符 \\x41 // Ascll字符 // 多行字符串 let msg = `我爱你， 中国！` // 模板字符串（必须在多行字符串的引号里面） &lt;script&gt; 'use strict' let name = \"张三\" let msg = `你好呀, ${name}` console.log(msg) &lt;/script&gt; 布尔值 true false 逻辑运算 &amp;&amp; || ! 比较运算符 = // 赋值 == // 等于(类型不一样，值一样，也会判断为true) === // 绝对等于(类型一样，值一样， 结果true) NaN === NaN // false isNaN(NaN) // true null 和 undefined null // 空 undefined // 未定义 数组 let arr = [1,2,'a', \"hello\", null, true] // 数组越界之后 就是 undefined arr.length // 数组长度 arr.indexOf(2) // 下标索引 arr.slice() // 切片 arr.push() // 压入到尾部 arr.pop() // 弹出尾部的一个元素 arr.shift() // 压入到头部 arr.unshift() // 弹出头部的一个元素 arr.sort() // 排序 arr.join() // 使用特定的字符拼接数组成字符串 arr.concat() // 拼接数组 ... 对象 JavaScript中的所有的键都是字符串，值是任意对象！ var person = { name: \"xiaofan\", age: 3, tags: ['js', 'java','web', '...'] } // 对象赋值 person.sex = 'nv' // 使用不存在的对象属性 person.hobby undefined // 动态删减属性 delete person.name // 动态添加属性 person.info = 'info'; // 判断属性值是否在这个对象中 'xxx' in xxx! 'age' in person (person.hasOwnProperty('age')) 2.3. 严格检查模式 2.4. 流程控制let arr = [100, 200, 'a', 'b', true] for (let i = 0; i &lt; arr.length; i++) { console.log(arr[i]) } console.log(\"============\") for (let i in arr) { console.log(arr[i]) } console.log(\"============\") for (let arrElement of arr) { console.log(arrElement) } console.log(\"============\") arr.forEach(function (e){ console.log(e) }) 2.5. Map 和 Set&lt;script&gt; \"use strict\" let map = new Map([['tom', 1000],['jack', 999],['Bob', 888]]) let score = map.get('tom') console.log(score) map.set('admin', 123456) map.delete(\"tom\") let set = new Set([1,2,3,4,5]) set.delete(1) console.log(set.has(3)) console.log(\"======\") for (let number of set) { console.log(number) } &lt;/script&gt; 注意： 遍历arr的时候 for .. in 和for.. of 的区别 2.6. 函数&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; // 定义方式1 function f1(x) { console.log(typeof x) if (x &gt;= 0) { return x } else { return -x } } // 定义方式2 // typeof 检测变量的类型 let f2 = function (x) { // 手动抛出异常 if (typeof x !== \"number\") { throw \"Not a num!\" } if (x &gt;= 0) { return x } else { return -x } }; // arguments 获得所有参数 function f3(x) { console.log(x) console.log(typeof x) console.log(\"=====\") console.log(arguments) } // ...rest 标识， 获取剩余的参数 function f4(x, ...rest1) { console.log(x) console.log(typeof x) console.log(\"=====\") console.log(rest1) } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 2.7. 变量的作用域 JQuery. ===&gt; $() 2.8. 方法&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; 'use strict' // 方法1 let xf1 = { name: '小范', birth: 1991, // 方法 age: function () { let now = new Date().getFullYear(); // this 指向调用它的对象 return now - this.birth; } } // 方法2 function getAge() { let now = new Date().getFullYear(); // this 指向调用它的对象 return now - this.birth; } let xf2 = { name: '小范儿', birth: 2000, age: getAge } // xf2.age() ok // getAge() error // apply 改变了getAge方法中this的指向 let result1 = getAge.apply(xf1, []); let result2 = getAge.apply(xf2, []); console.log(result1, result2) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 2.9. 内部对象// 标准对象 typeof 123 \"number\" typeof '123' \"string\" typeof true \"boolean\" typeof NaN \"number\" typeof [] \"object\" typeof {} \"object\" typeof Math.abs \"function\" typeof undefined \"undefined\" 2.9.1. Date// Date &lt;script&gt; let now = new Date(); now.getFullYear(); now.getMonth(); // 0~11月 now.getDate(); // 日 now.getDay(); now.getHours(); now.getMinutes(); now.getSeconds(); now.getTime(); // 获取时间戳 now.toLocaleString() now.toUTCString() &lt;/script&gt; 2.9.2. JSON&lt;script&gt; 'use strict' let user = { name: \"xiaofan\", age: 3, set: '男' } // 对象转化为json字符串 let jsonUser = JSON.stringify(user); // Json字符串转换成对象 let userBean = JSON.parse('{\"name\":\"xiaofaner\",\"age\":28,\"set\":\"男\"}'); &lt;/script&gt; 2.9.3. Ajax 原生的js写法， xhr异步请求 jQuery封装好的 方法 $(“#name”).ajax(“”) axios 请求 2.10 面向对象编程 面向对象原型继承 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; 'use strict' let student = { name: \"qinjiang\", age: 3, run: function () { console.log(this.name + \" run...\") } }; let xf = { name: \"xiaofan\" } // xf 的原型对象是 student xf.__proto__ = student // 给ss新增加一个方法 function ss(name) { this.name = name; } ss.prototype.hello = function () { alert(\"hello\") } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 面向类继承 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; 'use strict' class Student { constructor(name) { this.name = name; } hello() { alert('hello student..'); } } class SmallStudent extends Student { constructor(name, grade) { super(name); this.grade = grade; } myGrade() { alert(\"我是个小学生..\"); } } let student = new Student(\"xiaofan\") let smallStudent = new SmallStudent(\"xiaofaner\", 22) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 本质：还是原型 原型链 2.11. 操作BOM对象BOM（Browser Object Model）: 浏览器对象模型 window 浏览器窗口 navigator 封装了浏览器信息 screen 屏幕尺寸 location 代表当前页面的URL信息 host: \"www.baidu.com\" hostname: \"www.baidu.com\" href: \"https://www.baidu.com/\" origin: \"https://www.baidu.com\" pathname: \"/\" port: \"\" protocol: \"https:\" reload() //重新加载网页 location.assign('https://jd.com') // 设置新的地址 document 代表当前的页面 history history.back() // 后退 history.forward() // 前进 2.12. 操作DOM对象（核心） DOM： 文档对象模型 获得节点 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"father\"&gt; &lt;h1&gt;标题1&lt;/h1&gt; &lt;p id=\"p1\"&gt;p1&lt;/p&gt; &lt;p class=\"p2\"&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let h1 = document.getElementsByTagName(\"h1\"); let p1 = document.getElementById(\"p1\"); let p2 = document.getElementsByClassName(\"p2\"); let father = document.getElementById(\"father\"); let children = father.children // 获取父节点下的所有子节点 father.lastChild father.firstChild &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 更新节点 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"id1\"&gt;&lt;/div&gt; &lt;script&gt; let div = document.getElementById(\"id1\") // 操作文本 div.innerText = \"123\"; div.innerHTML = \"&lt;strong&gt;123&lt;/strong&gt;\" // 操作JS div.style.color='red' div.style.fontSize='22px' div.style.padding='2em' &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 删除结点 插入结点 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=\"js\"&gt;JavaScript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let js = document.getElementById('js'); let list = document.getElementById('list'); // 追加节点 // list.appendChild(js) let newP = document.createElement('p'); newP.id='newP'; newP.innerText = 'Hello xiaofan!'; list.appendChild(newP) // 设置背景色 let body = document.getElementsByTagName(\"body\")[0]; body.style.backgroundColor = \"#ff00f0\" // 把一个新节点插入到一个结点的前面 let ee = document.getElementById(\"ee\"); list.insertBefore(js, ee); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.13. 操作表单&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=\"post\"&gt; &lt;p&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=\"text\" id=\"username\"/&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;性别：&lt;/span&gt; &lt;input type=\"radio\" name=\"sex\" value=\"1\" id=\"boy\" checked /&gt; 男 &lt;input type=\"radio\" name=\"sex\" value=\"2\" id=\"girl\" /&gt; 女 &lt;/p&gt; &lt;/form&gt; &lt;script&gt; let input_text = document.getElementById(\"username\"); let boy = document.getElementById(\"boy\"); let girl = document.getElementById(\"girl\"); console.log(boy.checked); boy.checked = true &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 隐藏域表单提交验证，对密码进行加密 // md5远程库 https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--md5工具类--&gt; &lt;script src=\"myMd5.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=\"post\" onsubmit=\"return check();\"&gt; &lt;p&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=\"text\" id=\"username\" name=\"username\"/&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;/span&gt;&lt;input type=\"password\" id=\"input-password\"/&gt; &lt;/p&gt; &lt;input type=\"hidden\" id=\"md5-password\" name=\"password\"/&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;script&gt; function check() { let name = document.getElementById(\"username\"); let inputPwd = document.getElementById(\"input-password\"); let md5Pwd = document.getElementById(\"md5-password\"); // password.value = md5(password.value) md5Pwd.value = md5(inputPwd.value); console.log(name.value) console.log(inputPwd.value) console.log(md5Pwd.value) return false } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 注意：1.可以把远程库拷贝到本来！2.onsubmit绑定一个提交检测的函数，当这个函数返回false时，form表单请求会被拦截，当这个函数返回true时，正常提交表单 3. JQuery 文档 cdn 3.1. 第一个Jquery程序&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"\" id=\"test-jquery\"&gt;点我&lt;/a&gt; &lt;script&gt; // 公式 $(选择器).action(方法) $(\"#test-jquery\").click(function () { alert(\"hello jquery!\") }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3.2. 选择器 3.3. 事件&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js\"&gt;&lt;/script&gt; &lt;style&gt; #divMove{ width: 500px; height: 500px; border: 1px solid red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--要求：获取鼠标当前的一个坐标--&gt; mouse: &lt;span id=\"mouseMove\"&gt;&lt;/span&gt; &lt;div id=\"divMove\"&gt; 在这里移动看看 &lt;/div&gt; &lt;script&gt; $(\"#divMove\").mousemove(function (e) { $(\"#mouseMove\").text(`x: ${e.pageX}, y: ${e.pageY}`) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3.4. JQuery 操作DOM&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"test-ul\"&gt; &lt;li class=\"js\"&gt;JavaScript&lt;/li&gt; &lt;li name=\"python\"&gt;Python&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 获取值 let text1 = $(\"#test-ul li[name=python]\").text(); let text2 = $(\"#test-ul li[class=js]\").text(); console.log(text1) console.log(text2) // 设置值 $(\"#test-ul li[class=js]\").text(\"JS\"); // 设置css样式 $(\"#test-ul li[name=python]\").css({ \"color\": \"#ff0011\", \"background\": \"blue\" }) // 元素的显示和隐藏 $(\"#test-ul li[name=python]\").show() $(\"#test-ul li[name=python]\").hide() // 更多查看文档 // https://jquery.cuishifeng.cn/ &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 源码之家 Element UI Ant Design Bootstrap 3.5. Ajax AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ 3.5.1. 伪造Ajax&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;xiaofan&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; 'use strict' window.onload = function(){ let myDate = new Date(); document.getElementById('currentTime').innerText = myDate.toLocaleString() }; function LoadPage(){ let targetUrl = document.getElementById('url').value; console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; } &lt;/script&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" value=\"https://www.baidu.com/\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage()\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3.5.2. Ajax格式jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 项目源代码 4. Vue 4.1. 第一个Vue程序 idea安装vue插件 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"app\"&gt; {{message}} &lt;/div&gt; &lt;script&gt; 'use strict' /*Model 数据*/ let vue = new Vue({ el: \"#app\", data: { message: 'hello vue!' } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"app\"&gt; &lt;span v-bind:title=\"message\"&gt;鼠标悬浮几秒钟查看此处动态绑定的提示信息！&lt;/span&gt; &lt;/div&gt; &lt;script&gt; 'use strict' /*Model 数据*/ let vue = new Vue({ el: \"#app\", data: { message: 'hello vue!' } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 4.2. 基础语法 if &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"app\"&gt; &lt;h1 v-if=\"type==='A'\"&gt;A&lt;/h1&gt; &lt;h1 v-else-if=\"type==='B'\"&gt;B&lt;/h1&gt; &lt;h1 v-else=\"type==='C'\"&gt;C&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; 'use strict' /*Model 数据*/ let vue = new Vue({ el: \"#app\", data: { message: 'hello vue!', type: 'A' } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; for &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"app\"&gt; &lt;p style='color:blue' v-for=\"item in items\"&gt;{{item.message}}&lt;/p&gt; &lt;/div&gt; &lt;script&gt; 'use strict' /*Model 数据*/ let vue = new Vue({ el: \"#app\", data: { message: 'hello vue!', type: 'A', items: [{message: '小范'},{message: '小梁'},{message: '小红'}] } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 事件 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"app\"&gt; &lt;button v-on:click=\"sayHi\"&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;script&gt; 'use strict' /*Model 数据*/ let vue = new Vue({ el: \"#app\", data: { message: 'hello vue!', type: 'A', items: [{message: '小范'},{message: '小梁'},{message: '小红'}] }, methods: { sayHi: function () { alert(this.message) } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 双向绑定 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"message\"/&gt; {{message}} &lt;/div&gt; &lt;script&gt; 'use strict' /*Model 数据*/ let vue = new Vue({ el: \"#app\", data: { message: \"\" } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"app\"&gt; &lt;select v-model=\"selected\"&gt; &lt;option value=\"\" disabled&gt;---请选择---&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; {{selected}} &lt;/div&gt; &lt;script&gt; 'use strict' /*Model 数据*/ let vue = new Vue({ el: \"#app\", data: { selected: \"\" } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 4.3. vue组件 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"app\"&gt; &lt;xiaofan v-for=\"item in items\" v-bind:xf=\"item\"&gt;&lt;/xiaofan&gt; &lt;/div&gt; &lt;script&gt; 'use strict' Vue.component(\"xiaofan\", { // 给组件传递数据需要用props props: ['xf'], template: '&lt;h1&gt;{{xf}}&lt;/h1&gt;' }) /*Model 数据*/ let vue = new Vue({ el: \"#app\", data: { items: ['java', 'linux', 'python'] } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 4.4. 网络通信Axios &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;!--导入axios--&gt; &lt;script src=\"https://unpkg.com/axios@0.20.0/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"vue\"&gt; &lt;div&gt;{{info.name}}&lt;/div&gt; &lt;div&gt;{{info.age}}&lt;/div&gt; &lt;div&gt;{{info.hobbies}}&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; 'use strict' let vue = new Vue({ el: '#vue', // data: {info: {name: \"sss\"}}, data() { return { //请求的返回参数合适，必须和json字符串一样，但可以省略不需要的 info: { name: null, age: 0, hobbies: [] } } }, mounted() { // 钩子函数 链式编程 axios.get('../data.json').then(response=&gt;(this.info=response.data)) // axios.get(\"../data.json\").then(response=&gt;(console.log(response.data))) } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 参考链接： https://blog.csdn.net/qq_40359381/article/details/106853936 4.5. 计算属性 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;!--导入axios--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.1.0/axios.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"vue\"&gt; &lt;p&gt;currentTime1 {{currentTime1()}}&lt;/p&gt; &lt;p&gt;currentTime2 {{currentTime2}}&lt;/p&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; 'use strict' let vue = new Vue({ el: '#vue', data: { message: \"xiaofan\" }, methods: { currentTime1: function () { return Date.now(); } }, computed: { //计算属性methods computed的方法名不要重名字，对于不经常变化的内容可以通过这种方式进行缓存，更优 currentTime2: function () { console.log(this.message); return Date.now(); } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 4.6. 插槽&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;!--导入axios--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.1.0/axios.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"vue\"&gt; &lt;todo&gt; &lt;todo-title slot=\"todo-title\" v-bind:title=\"title\"&gt;&lt;/todo-title&gt; &lt;todo-items slot=\"todo-items\" v-for=\"item in todoitems\" v-bind:item=\"item\"&gt;&lt;/todo-items&gt; &lt;/todo&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; 'use strict' Vue.component(\"todo-title\", { props: [\"title\"], template: '&lt;div&gt;{{title}}&lt;/div&gt;' }); Vue.component(\"todo-items\", { props: [\"item\"], template: '&lt;li&gt;{{item}}&lt;/li&gt;' }); // slot插槽 Vue.component(\"todo\", { template: '&lt;div&gt;\\ &lt;slot name=\"todo-title\"&gt;&lt;/slot&gt;\\ &lt;ul&gt;\\ &lt;slot name=\"todo-items\"&gt;&lt;/slot&gt;\\ &lt;/ul&gt;\\ &lt;/div&gt;' }); let vue = new Vue({ el: '#vue', data: { title: \"秦老师\", todoitems: [\"狂神说Java\", \"狂神说Linux\", \"狂神说Vue\", \"狂神说Linux\", \"狂神说Vue\"] } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 4.7. 自定义事件内容分发 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--导入vue--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.min.js\"&gt;&lt;/script&gt; &lt;!--导入axios--&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.1.0/axios.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--view层 模板--&gt; &lt;div id=\"vue\"&gt; &lt;todo&gt; &lt;todo-title slot=\"todo-title\" v-bind:title=\"title\"&gt;&lt;/todo-title&gt; &lt;todo-items slot=\"todo-items\" v-for=\"(item, index) in todoitems\" v-bind:item=\"item\" v-bind:index=\"index\" v-on:remove=\"removeItem(index)\" v-bind:key=\"index\"&gt;&lt;/todo-items&gt; &lt;/todo&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; 'use strict' Vue.component(\"todo-title\", { props: [\"title\"], template: '&lt;div&gt;{{title}}&lt;/div&gt;' }); Vue.component(\"todo-items\", { props: [\"item\",\"index\"], template: '&lt;li&gt;{{item}}&lt;button v-on:click=\"remove\"&gt;删除&lt;/button&gt;&lt;/li&gt;', // 只能绑定当前组件的方法 methods: { remove: function (index) { // 自定义事件分发 $emit(自定义事件名， 下标) this.$emit('remove', index) } } }); // slot插槽 Vue.component(\"todo\", { template: '&lt;div&gt;\\ &lt;slot name=\"todo-title\"&gt;&lt;/slot&gt;\\ &lt;ul&gt;\\ &lt;slot name=\"todo-items\"&gt;&lt;/slot&gt;\\ &lt;/ul&gt;\\ &lt;/div&gt;' }); let vue = new Vue({ el: '#vue', data: { title: \"秦老师\", todoitems: [\"狂神说Java\", \"狂神说Linux\", \"狂神说Vue\", \"狂神说Linux\", \"狂神说Vue\"] }, methods: { removeItem: function (index) { this.todoitems.splice(index, 1) } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 4.8. 第一个vue-cli项目 安装Nodejs 下载地址 node -v npm -v 安装Node.js淘宝镜像加速器（cnpm）npm install cnpm -g 安装vue-cli cnpm install vue-cli -g 测试是否安装成功 查看可以寄语那些模板创建vue应用vue list 创建项目vue init webpack myvue 初始化并运行 cd myvue npm install npm run dev 4.9. webpack打包 安装并测试 npm install webpack -g npm install webpack-cli -g webpack -v webpack-cli -v 4.10 vue-router路由 在当前项目安装 npm install vue-router –save-dev 源码地址：vue-04-router 4.11 vue+elementUI 创建工程 hello-vue vue init webpack hello-vue 安装依赖 进入工程目录cd hello-vue 安装vue-routernpm install vue-router --save-dev 安装 element-ui npm i element-ui -S 安装依赖npm install 安装SASS加载器cnpm install sass-loader node-sass --save-dev 启动测试npm run dev 注意sass-loader的版本 整体效果 4.12. 路由嵌套import Vue from 'vue' import VueRouter from \"vue-router\" import Main from '../views/Main' import Login from '../views/Login' import UserList from '../views/user/List' import UserProfile from '../views/user/Profile' import Telephone from '../views/user/Telephone' Vue.use(VueRouter) export default new VueRouter({ routes: [ { path: '/main', component: Main, children: [ // 嵌套路由 {path: '/user/profile', component: UserProfile}, {path: '/user/list', component: UserList}, {path: '/user/telephone', component: Telephone} ] }, { path: '/login', component: Login } ] }) 4.13. 参数传递及重定向 方式1 // 传递 &lt;!--name-传组件名 params传递参数，需要对象： v-bind--&gt; &lt;router-link :to=\"{name: 'UserProfile', params: {id: 1}}\"&gt;个人信息&lt;/router-link&gt; // 接收 import Vue from 'vue' import VueRouter from \"vue-router\" import Main from '../views/Main' import Login from '../views/Login' import UserList from '../views/user/List' import UserProfile from '../views/user/Profile' import Telephone from '../views/user/Telephone' Vue.use(VueRouter) export default new VueRouter({ routes: [ { path: '/main', component: Main, children: [ // 嵌套路由 {path: '/user/profile:id', name: 'UserProfile', component: UserProfile}, {path: '/user/list', component: UserList}, {path: '/user/telephone', component: Telephone} ] }, { path: '/login', component: Login } ] }) // 展示 &lt;template&gt; &lt;div&gt; &lt;h1&gt;个人信息&lt;/h1&gt; {{$route.params.id}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"UserProfile\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 方式2 // 设置props import Vue from 'vue' import VueRouter from \"vue-router\" import Main from '../views/Main' import Login from '../views/Login' import UserList from '../views/user/List' import UserProfile from '../views/user/Profile' import Telephone from '../views/user/Telephone' Vue.use(VueRouter) export default new VueRouter({ routes: [ { path: '/main', component: Main, children: [ // 嵌套路由 {path: '/user/profile:id', name: 'UserProfile', component: UserProfile, props: true}, {path: '/user/list', component: UserList}, {path: '/user/telephone', component: Telephone} ] }, { path: '/login', component: Login } ] }) // 绑定id &lt;template&gt; &lt;div&gt; &lt;h1&gt;个人信息&lt;/h1&gt; {{$route.params.id}}&lt;br/&gt; {{id}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: ['id'], name: \"UserProfile\" } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 重定向 import Vue from 'vue' import VueRouter from \"vue-router\" import Main from '../views/Main' import Login from '../views/Login' import UserList from '../views/user/List' import UserProfile from '../views/user/Profile' import Telephone from '../views/user/Telephone' Vue.use(VueRouter) export default new VueRouter({ routes: [ { path: '/main', component: Main, children: [ // 嵌套路由 {path: '/user/profile:id', name: 'UserProfile', component: UserProfile, props: true}, {path: '/user/list', component: UserList}, {path: '/user/telephone', component: Telephone} ] }, { path: '/login', component: Login }, { path: '/goHome', redirect: '/main' } ] }) 4.14. 路由模式和404export default new VueRouter({ mode: 'history', // 不带# }) 路由钩子 &lt;template&gt; &lt;div&gt; &lt;h1&gt;个人信息&lt;/h1&gt; {{$route.params.id}}&lt;br/&gt; {{id}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: ['id'], name: \"UserProfile\", beforeRouteEnter: (to, from, next)=&gt;{ console.log(\"进入钩子之前\"); next(vm =&gt; { vm.getData(); // 进入路由之前，执行我们自定义的getData方法 }); }, beforeRouteLeave: (to, from, next)=&gt;{ console.log(\"离开钩子之前\") next(); }, methods: { getData: function () { this.axios({ method: 'get', url: 'http://localhost:8080/static/data.json' }).then(function (response) { console.log(response) }); } } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; npm install --save axios vue-axios 4.15. Vue的生命周期 4.16. 项目源代码地址https://github.com/fanjianhai/CODE","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://gitee.com/td278121/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2021-05-02T03:37:34.000Z","updated":"2021-07-23T00:30:22.784Z","comments":true,"path":"posts/3bfcc156.html","link":"","permalink":"https://gitee.com/td278121/posts/3bfcc156.html","excerpt":"SpringMVC","text":"SpringMVC 404：路径问题 405：代码问题 500：文件 导包问题 环境问题 Ambiguous ： 方法重复 二义性 SpringMVCssm：mybatis + Spring + MVC三层架构 JavaSE JavaWeb SSM SpringMVC Vue SpringBoot SpringCloud Linux Spring： ＩＯＣ ＡＯＰ SpringMVC的执行流程 MVC思想： Model（dao，service） View（jsp） Controller（Servlet） ​ 业务逻辑 保存数据的状态 显示页面 取得表单数据 调用业务逻辑 转向指定页面 JSP：本质就是Servlet SpringＭＶＣ优点： 轻量级，简单易学 高效，基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESful，数据验证，格式化，本地化，主题等 简洁灵活 用户通过调度器请求Servlet Spring：大杂烩，我们可以将SpringMVC中所有使用的 &lt;!--处理器映射器--&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; &lt;!--处理器适配器--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; &lt;!--视图解析器:DispatcherServlet给他的ModelAndView 模版引擎 Thymeleaf Freemarker--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; Maven可能存在资源过滤的问题，以下配置完善 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 替代默认适配器&lt;!-- 让Spring MVC不处理静态资源 .css .js .html .mp3 .mp4 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 处理器映射器 和一个AnnotationMethodHandlerAdapter实例 处理器适配器 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; 遇到404常见解决： · 导包配置 ·TomCat项目配置 使用注解开发整体流程1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！2、由于Maven可能存在资源过滤的问题，我们将配置完善3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！4、配置web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 注意点： / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=\"com.li.controller\"/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 4. - #### **在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。** - 让IOC的注解生效 - 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ..... - MVC的注解驱动 - 配置视图解析器 - - 1. #### 6.创建Controller 2. #### 编写Java控制类:com.li.controller.HelloController 7. ```java package com.li.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/HelloController\") public class HelloController { //真实访问地址 : 项目名/HelloController/h1 @RequestMapping(\"/h1\") public String sayHello(Model model){ //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(\"msg\",\"hello,SpringMVCAnnotation\"); //web-inf/jsp/hello.jsp return \"hello\"; } } Controller总结 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 //通过以下扫描器配合@Controller注解直接匹配省去bean的配置 &lt;context:component-scan base-package=\"com.li.controller\"/&gt; @Component 组件 @Service service @Controller controller @Repository dao public class ControllerTest2 { @RequestMapping(\"/t2\") public String test1(Model model){ model.addAttribute(\"msg\",\"ControllerTest2\"); return \"test\"; //WEB-INF/jsp/test } @RequestMapping(\"/t3\") public String test2(Model model){ model.addAttribute(\"msg\",\"T3\"); return \"test\"; //WEB-INF/jsp/test } } 我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出 视图是被复用的，而控制器与视图之间是弱偶合关系。 RequestingMapping总结 @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 控制类的加载 @Controller public class ControllerTest3 { @RequestMapping(\"/c/t1\") public String test1(Model model){ model.addAttribute(\"msg\",\"ControllerTest3\"); return \"test\";//WEB-INF/c/t1 } } @Requesting可以加在类的上方，也可以加在方法上方，不同公司规范不同 RestFul 风格概念 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 请求方式有所不同 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 安全性有所提升（隐藏了后台参数） 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 //初试风格： http://localhost:8080/add?a=1&amp;b=2 //RestFul: http://localhost:8080/add/a/b @Controller public class RestFulController { // @RequestMapping(value = \"/add/{a}/{b}\",method = RequestMethod.GET) 与以下简化注解同义 //http://localhost:8080/add/128/2 @PostMapping(\"/add/{a}/{b}\") public String test(@PathVariable int a,@PathVariable int b, Model model){ int res = a + b; model.addAttribute(\"msg\",\"结果1：\" + res); return \"test\"; } //http://localhost:8080/add/128/2 @GetMapping(\"/add/{a}/{b}\") public String test2(@PathVariable int a,@PathVariable int b, Model model){ int res = a + b; model.addAttribute(\"msg\",\"结果2：\" + res); return \"test\"; } } // @PostMapping @GetMapping 代表不同请求方法 括号中是最后执行的地址，不同方法可设定相同地址 所有的地址栏请求默认都会是 HTTP GET 类型的。 方法级别的注解变体有如下几个：组合注解 @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping @GetMapping 是一个组合注解，平时使用的会比较多！ 它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 //redirect 重定向 model.addAttribute(\"msg\",\"ModelTest\"); return \"redirect:/a.jsp\"; 会自动转载路径，大于视图处理器配置权限 结果跳转方式就对于新手而言简单来说使用区别就是： Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。 请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。 @Controller @RequestMapping(\"/user\") public class UserController { //localhost:8080/user/t1 ? name=xxx //在类中用@RequestParam定义请求类名可避免无效请求返回空值 @GetMapping(\"/t1\") public String test1(@RequestParam(\"username\") String name, Model model) { //1·接受前端参数 System.out.println(\"前端参数为： \" + name); // 2·将返回的结果传递给前端 Model model.addAttribute(\"msg\", name); //3`跳转视图 return \"test\"; } /* 前端接受的是一个对象: id name age 1接收前端用户传递的参数，判断参数名字，假设名字直接在方法上，可以直接使用 2·结社传递的是一个对象User，匹配User对象中的字段名，与字段名一致则可以匹配` */ @GetMapping(\"/t2\") public String test2(User user) { System.out.println(user); return \"test\"; } @GetMapping(\"/t3\") public String test3(ModelMap map){ return \"test\"; } } http://localhost:8080/user/t1?username=zy 如果传值（字段）名字不一样就报错 第二种传值，只有字段名一致才会传值（不然就传空）；起到的作用：避免输入错误地址服务器依旧加载浪费内存 http://localhost:8080/user/t2?id=1&amp;name=zy&amp;age=22 SpringMVC乱码过滤，一般情况下的乱码都可正常过滤 &lt;!-- 2.配置SpringMVC的乱码过滤--&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 前后端分离时代后端部署后端，提供接口，提供数据 JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 前端独立部署，负责渲染后端数据 JSON的使用简介 JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率 快速流程首先 导入包&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; xml默认配置web·xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; springmvc-servlet·xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=\"com.kuang.controller\"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 实体类 //Getting Setting 省略 public class User { private String name; private int age; private String sex; } 测试 @Controller public class UserController { @RequestMapping(\"/j1\") //不走视图解析器，直接返回字符串 @ResponseBody public String json1() throws JsonProcessingException { //jackson, ObjectMapper ObjectMapper mapper = new ObjectMapper(); //创建对象 User user = new User(\"ZY\",5,\"man\"); String str = mapper.writeValueAsString(user); return str; } } 乱码配置处理springmvc-servlet·xml &lt;!-- JSON乱码问题配置--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;constructor-arg value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 日期转换工具类 public class JsonUtils { public static String getJson(Object object,String dateFormat){ ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS,false); //自定义时间戳格式 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; } } 调用工具类输出 @RestController public class UserController { @RequestMapping(value = \"/j3\") public String json3() throws JsonProcessingException { Date date = new Date(); return JsonUtils.getJson(date,\"yyyy-MM-dd HH:mm:ss\"); ｝ ｝ 注解解析@Controller 会经过视图解析器 @ResponseBody 配合@Controller使用 @RestController 不经过视图解析 直接返回JSON字符 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ fastjsonfastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.60&lt;/version&gt; &lt;/dependency&gt; SSM整合Mybatis层新建数据库CREATE DATABASE `ssmbuild`; USE `ssmbuild`; DROP TABLE IF EXISTS `books`; CREATE TABLE `books` ( `bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id', `bookName` VARCHAR(100) NOT NULL COMMENT '书名', `bookCounts` INT(11) NOT NULL COMMENT '数量', `detail` VARCHAR(200) NOT NULL COMMENT '描述', KEY `bookID` (`bookID`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES (1,'Java',1,'从入门到放弃'), (2,'MySQL',10,'从删库到跑路'), (3,'Linux',5,'从进门到进牢'); 环境配置&lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 过滤器&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; xml配置 com.kuang.pojo com.kuang.dao com.kuang.service com.kuang.controller mybatis-config.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.li.pojo\"/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=\"com/li/dao/BookMapper.xml\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; applicationContext.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;/beans&gt; data.properties ##如果使用的Mysql8.0+，需要加一个时区的配置 &amp;serverTimezone=Asia/Shanghai jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8 jdbc.username=root jdbc.password=123456 实体类public class Books { private int bookID; private String bookName; private int bookCounts; private String detail; } DAO配置Mapper接口public interface BookMapper { //增加一本书 int addBook(Books books); //删除一本书 int deleteBookById(@Param(\"bookId\") int id); //更改一本书 int updateBook(Books books); //查询一本书 Books queryBookById(@Param(\"bookId\") int id); //查询全部书 List&lt;Books&gt; queryAllBook(); Books queryBookByName(@Param(\"bookName\") String bookName); } Mapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.li.dao.BookMapper\"&gt; &lt;insert id=\"addBook\" parameterType=\"Books\"&gt; insert into ssmbuild.books (bookName, bookCounts, detail) values (#{bookName},#{bookCounts},#{detail}); &lt;/insert&gt; &lt;delete id=\"deleteBookById\" parameterType=\"int\"&gt; delete from ssmbuild.books where bookID = #{bookId} &lt;/delete&gt; &lt;update id=\"updateBook\" parameterType=\"Books\"&gt; update ssmbuild.books set bookName=#{bookName},bookCounts=#{bookCounts},detail=#{detail} where bookID=#{bookID}; &lt;/update&gt; &lt;select id=\"queryBookById\" resultType=\"Books\"&gt; select * from ssmbuild.books where bookID = #{bookId} &lt;/select&gt; &lt;select id=\"queryAllBook\" resultType=\"Books\"&gt; select * from ssmbuild.books &lt;/select&gt; &lt;select id=\"queryBookByName\" resultType=\"Books\"&gt; select * from ssmbuild.books where bookName = #{bookName} &lt;/select&gt; &lt;/mapper&gt; 编写Service层的接口和实现类接口 public interface BookService { //增加一本书 int addBook(Books books); //删除一本书 int deleteBookById(int id); //更新Book int updateBook(Books books); //查询一本书 Books queryBookById(int id); //查询全部一本书 List&lt;Books&gt; queryAllBook(); Books queryBookByName(String bookName); } 实现类 //通过注解与spring-service.xml绑定 @Service public class BookServiceImpl implements BookService{ //service调用dao层，组合Dao @Autowired private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } @Override public int addBook(Books books) { return bookMapper.addBook(books); } @Override public int deleteBookById(int id) { return bookMapper.deleteBookById(id); } public int updateBook(Books books) { return bookMapper.updateBook(books); } @Override public Books queryBookById(int id) { return bookMapper.queryBookById(id); } @Override public List&lt;Books&gt; queryAllBook() { return bookMapper.queryAllBook(); } @Override public Books queryBookByName(String bookName) { return bookMapper.queryBookByName(bookName); } } Spring层spring-dao&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 1.关联数据库--&gt; &lt;context:property-placeholder location=\"classpath:database.properties\"/&gt; &lt;!-- 2、连接池 dbcp:半自动化，不能自动连接 c3p0自动化操作（自动化加在配置文件，并可以自动配置到对象中 druid： hikari--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=\"driverClass\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"jdbcUrl\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"user\" value=\"${jdbc.username}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=\"maxPoolSize\" value=\"30\"/&gt; &lt;property name=\"minPoolSize\" value=\"10\"/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=\"autoCommitOnClose\" value=\"false\"/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=\"checkoutTimeout\" value=\"10000\"/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=\"acquireRetryAttempts\" value=\"2\"/&gt; &lt;/bean&gt; &lt;!-- 3.sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 BookMapperImpl动态注入 --&gt; &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=\"basePackage\" value=\"com.li.dao\"/&gt; &lt;/bean&gt; &lt;/beans&gt; spring-service.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 1 扫描service相关的bean --&gt; &lt;context:component-scan base-package=\"com.li.service\" /&gt; &lt;!--2 BookServiceImpl注入到IOC容器中--&gt; &lt;bean id=\"BookServiceImpl\" class=\"com.li.service.BookServiceImpl\"&gt; &lt;property name=\"bookMapper\" ref=\"bookMapper\"/&gt; &lt;/bean&gt; &lt;!-- 3 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 4 AOP --&gt; &lt;/beans&gt; SpringMVC 层web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!-- DispatchServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 乱码过滤--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*/&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;/web-app&gt; spring-mvc.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" /&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=\"com.li.controller\" /&gt; &lt;/beans&gt; applicationContext.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"spring-dao.xml\"/&gt; &lt;import resource=\"spring-mvc.xml\"/&gt; &lt;import resource=\"spring-service.xml\"/&gt; &lt;/beans&gt; 基础框架配置完成 Controller 和 视图层编写增删改查控制层代码@Controller @RequestMapping(\"/book\") public class BookController { //controller 调 service层 @Autowired @Qualifier(\"BookServiceImpl\") private BookService bookService; // 查询全部书籍并返回一个书籍展示面 @RequestMapping(\"/allBook\") public String list(Model model) { List&lt;Books&gt; list = bookService.queryAllBook(); model.addAttribute(\"list\", list); return \"allBook\"; } //跳转到增加书籍页面 @RequestMapping(\"/toAddBook\") public String toAddPaper(){ return \"addBook\"; } //添加书籍页面的请求 @RequestMapping(\"/addBook\") public String addBook(Books books){ System.out.println(\"addBook=&gt;\" + books); bookService.addBook(books); return \"redirect:/book/allBook\"; //重定向到@RequestMapping（\"allBook\") 请求； } //跳转到修改页面 @RequestMapping(\"/toUpdate\") public String toUpdatePaper(int id,Model model){ Books books = bookService.queryBookById(id); model.addAttribute(\"QBook\",books); return \"updateBook\"; } //修改书籍 @RequestMapping(\"/updateBook\") public String updateBook(Books books){ System.out.println(\"updateBook=&gt;\" + books); bookService.updateBook(books); return \"redirect:/book/allBook\"; } //删除书籍 @RequestMapping(\"/deleteBook/{bookId}\") public String deleteBook(@PathVariable(\"bookId\") int id){ bookService.deleteBookById(id); return \"redirect:/book/allBook\"; } //查询书籍 @RequestMapping(\"/queryBook\") public String queryBook(String queryBookName, Model model){ Books books = bookService.queryBookByName(queryBookName); System.err.println(\"book=&gt;\" + books); List&lt;Books&gt; list = new ArrayList&lt;&gt;(); list.add(books); if (books == null){ list = bookService.queryAllBook(); model.addAttribute(\"error\",\"未查到\"); } model.addAttribute(\"list\",list); return \"allBook\"; } } JSP页面编写allBook.jsp&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;body&gt; &lt;head&gt; &lt;title&gt;书籍展示&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;&lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-l2 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;书籍列表-------显示所有书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 column\"&gt; &lt;%-- toAddBook --%&gt; &lt;a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/book/toAddBook\"&gt;新增书籍&lt;/a&gt; &lt;a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/book/allBook\"&gt;显示全部书籍&lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-md-8column\"&gt;&lt;/div&gt; &lt;%-- 查询书籍 --%&gt; &lt;form action=\"${pageContext.request.contextPath}/book/queryBook\" method=\"post\" style=\"float: right\"&gt; &lt;span style=\"color: #ff0000;font-weight: bold\"&gt;${error}&lt;/span&gt; &lt;input type=\"text\" name=\"queryBookName\" class=\"from-control\" placeholder=\"请输入要查询的书籍名称\"&gt; &lt;input type=\"submit\" value=\"查询\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-l2 column\"&gt; &lt;table class=\"table table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;/th&gt; &lt;th&gt;书籍名称&lt;/th&gt; &lt;th&gt;书籍数量&lt;/th&gt; &lt;th&gt;书籍详情&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;%--书籍从数据库查找出来，从这个list中遍历出来：forEach--%&gt; &lt;tbody&gt; &lt;c:forEach var=\"book\" items=\"${list}\"&gt; &lt;tr&gt; &lt;td&gt;${book.bookID}&lt;/td&gt; &lt;td&gt;${book.bookName}&lt;/td&gt; &lt;td&gt;${book.bookCounts}&lt;/td&gt; &lt;td&gt;${book.detail}&lt;/td&gt; &lt;td&gt; &lt;a href=\"${pageContext.request.contextPath}/book/toUpdate?id=${book.bookID}\"&gt;修改&lt;/a&gt; &amp;nbsp; &amp;nbsp; &lt;a href=\"${pageContext.request.contextPath}/book/deleteBook/${book.bookID}\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; addBook.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;新增书籍&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;&lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-l2 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;新增书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=\"${pageContext.request.contextPath}/book/addBook\" method=\"post\"&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍名称：&lt;/label&gt; &lt;input type=\"text\" name=\"bookName\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍数量：&lt;/label&gt; &lt;input type=\"text\" name=\"bookCounts\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍描述：&lt;/label&gt; &lt;input type=\"text\" name=\"detail\" class=\"form-control\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;input type=\"submit\" class=\"form-control\" value=\"添加\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; updateBook.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;修改书籍&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;&lt;!-- 引入 Bootstrap --&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-l2 column\"&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt; &lt;small&gt;修改书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=\"${pageContext.request.contextPath}/book/updateBook\" method=\"post\"&gt; &lt;%--隐藏域，用于传递书籍ID，不然传的ID默认值为0 无法完成更改--%&gt; &lt;input type=\"hidden\" name=\"bookID\" value=\"${QBook.bookID}\"&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍名称：&lt;/label&gt; &lt;input type=\"text\" name=\"bookName\" class=\"form-control\" value=\"${QBook.bookName}\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍数量：&lt;/label&gt; &lt;input type=\"text\" name=\"bookCounts\" class=\"form-control\" value=\"${QBook.bookCounts}\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;label&gt;书籍描述：&lt;/label&gt; &lt;input type=\"text\" name=\"detail\" class=\"form-control\" value=\"${QBook.detail}\" required&gt; &lt;/div&gt; &lt;div class=\"from-group\"&gt; &lt;input type=\"submit\" class=\"form-control\" value=\"修改\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; index.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style&gt; a{ text-decoration:none; color: black; font-size: 18px; } h3{ width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 5px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt; &lt;a href=\"${pageContext.request.contextPath}/book/allBook\"&gt;进入书籍页面&lt;/a&gt; &lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; Ajax技术 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 作用 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 ….等等 三要素 URL localhost：8080/a1 data:{key:vale} callback funcation(data) 至少应学的知识： HTML（精通） + css（略懂） + js（静通） js： 函数： 闭包（）｛｝ Dom id,name,tag create, remove Bom window document ​ ES6: impotrt require Java全栈工程师 **后台开发 ** 前端：html css JavaScript js jQuery 运维：项目发布 服务器如何运行一个项目 Linux 注册提示效果,异步刷新界面Controller.java@RestController @RequestMapping(\"/a3\") public String a3(String name,String pwd){ String msg = \"\"; if (name != null){ //admin,这些都应该在数据库中查 if (\"admin\".equals(name)){ msg = \"ok\"; }else { msg = \"用户名有误\"; } } if (pwd != null){ //123,这些都应该在数据库中查 if (\"123\".equals(pwd)){ msg = \"ok\"; }else { msg = \"密码有误\"; } } return msg; } login.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"${pageContext.request.contextPath}/statics/js/jquery-3.4.1.js\"&gt;&lt;/script&gt; &lt;script&gt; function a1() { $.get({ url:\"${pageContext.request.contextPath}/a3\", data:{\"name\":$(\"#name\").val()}, success: function (data){ if(data.toString()==='ok'){ $(\"#userInfo\").css(\"color\",\"green\"); }else{ $(\"#userInfo\").css(\"color\",\"red\"); } $(\"#userInfo\").html(data); } }) } function a2() { $.post({ url:\"${pageContext.request.contextPath}/a3\", data:{\"pwd\":$(\"#pwd\").val()}, success: function (data){ if(data.toString()==='ok'){ $(\"#pwdInfo\").css(\"color\",\"green\"); }else { $(\"#pwdInfo\").css(\"color\",\"red\"); } $(\"#pwdInfo\").html(data); } }) } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 用户名：&lt;input type=\"text\" id=\"name\" onblur=\"a1()\"&gt; &lt;span id=\"userInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt; 密码：&lt;input type=\"text\" id=\"pwd\" onblur=\"a2()\"&gt; &lt;span id=\"pwdInfo\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 实现了异步刷新功能，使得用户体验得到提升 拦截器过滤器与拦截器的区别：拦截器是AOP思想的具体应用。 过滤器 servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"JDBC核心技术","slug":"JDBC","date":"2021-05-02T03:37:34.000Z","updated":"2021-05-05T05:53:18.195Z","comments":true,"path":"posts/3bfcc103.html","link":"","permalink":"https://gitee.com/td278121/posts/3bfcc103.html","excerpt":"JDBC核心技术","text":"JDBC核心技术 讲师：宋红康 微博：尚硅谷-宋红康 第1章：JDBC概述1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 1.2 Java中的数据存储技术 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (Java Data Object )技术 第三方O/R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 1.3 JDBC介绍 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC，那么Java程序访问数据库时是这样的： 有了JDBC，Java程序访问数据库时是这样的： 总结如下： 1.4 JDBC体系结构 JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程 1.5 JDBC程序编写步骤 补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。 第2章：获取数据库连接2.1 要素一：Driver接口实现类2.1.1 Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver mySql的驱动： com.mysql.jdbc.Driver 将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。 在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path 注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可 2.1.2 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 2.2 要素二：URL JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 举例： 几种常用数据库的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/atguigu jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456 Oracle 9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:atguigu SQLServer的连接URL编写方式： jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称 jdbc:sqlserver://localhost:1433:DatabaseName=atguigu 2.3 要素三：用户名和密码 user,password可以用“属性名=属性值”方式告诉数据库 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 2.4 数据库连接方式举例2.4.1 连接方式一@Test public void testConnection1() { try { //1.提供java.sql.Driver接口实现类的对象 Driver driver = null; driver = new com.mysql.jdbc.Driver(); //2.提供url，指明具体操作的数据 String url = \"jdbc:mysql://localhost:3306/test\"; //3.提供Properties的对象，指明用户名和密码 Properties info = new Properties(); info.setProperty(\"user\", \"root\"); info.setProperty(\"password\", \"abc123\"); //4.调用driver的connect()，获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); } catch (SQLException e) { e.printStackTrace(); } } 说明：上述代码中显式出现了第三方数据库的API 2.4.2 连接方式二@Test public void testConnection2() { try { //1.实例化Driver String className = \"com.mysql.jdbc.Driver\"; Class clazz = Class.forName(className); Driver driver = (Driver) clazz.newInstance(); //2.提供url，指明具体操作的数据 String url = \"jdbc:mysql://localhost:3306/test\"; //3.提供Properties的对象，指明用户名和密码 Properties info = new Properties(); info.setProperty(\"user\", \"root\"); info.setProperty(\"password\", \"abc123\"); //4.调用driver的connect()，获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); } catch (Exception e) { e.printStackTrace(); } } 说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。 2.4.3 连接方式三@Test public void testConnection3() { try { //1.数据库连接的4个基本要素： String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"abc123\"; String driverName = \"com.mysql.jdbc.Driver\"; //2.实例化Driver Class clazz = Class.forName(driverName); Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 DriverManager.registerDriver(driver); //4.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } catch (Exception e) { e.printStackTrace(); } } 说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。 2.4.4 连接方式四@Test public void testConnection4() { try { //1.数据库连接的4个基本要素： String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"abc123\"; String driverName = \"com.mysql.jdbc.Driver\"; //2.加载驱动 （①实例化Driver ②注册驱动） Class.forName(driverName); //Driver driver = (Driver) clazz.newInstance(); //3.注册驱动 //DriverManager.registerDriver(driver); /* 可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有： static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(\"Can't register driver!\"); } } */ //3.获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } catch (Exception e) { e.printStackTrace(); } } 说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。 2.4.5 连接方式五(最终版)@Test public void testConnection5() throws Exception { //1.加载配置文件 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties pros = new Properties(); pros.load(is); //2.读取配置信息 String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //3.加载驱动 Class.forName(driverClass); //4.获取连接 Connection conn = DriverManager.getConnection(url,user,password); System.out.println(conn); } 其中，配置文件声明在工程的src目录下：【jdbc.properties】 user=root password=abc123 url=jdbc:mysql://localhost:3306/test driverClass=com.mysql.jdbc.Driver 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件 使用配置文件的好处： ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码②如果修改了配置信息，省去重新编译的过程。 第3章：使用PreparedStatement实现CRUD操作3.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 3.2 使用Statement操作数据表的弊端 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETE ResultSet executeQuery(String sql)：执行查询操作SELECT 但是使用Statement操作数据表存在弊端： 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 代码演示： public class StatementTest { // 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题 @Test public void testLogin() { Scanner scan = new Scanner(System.in); System.out.print(\"用户名：\"); String userName = scan.nextLine(); System.out.print(\"密 码：\"); String password = scan.nextLine(); // SELECT user,password FROM user_table WHERE USER = '1' or ' AND PASSWORD = '='1' or '1' = '1'; String sql = \"SELECT user,password FROM user_table WHERE USER = '\" + userName + \"' AND PASSWORD = '\" + password + \"'\"; User user = get(sql, User.class); if (user != null) { System.out.println(\"登陆成功!\"); } else { System.out.println(\"用户名或密码错误！\"); } } // 使用Statement实现对数据表的查询操作 public &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) { T t = null; Connection conn = null; Statement st = null; ResultSet rs = null; try { // 1.加载配置文件 InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties pros = new Properties(); pros.load(is); // 2.读取配置信息 String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); // 3.加载驱动 Class.forName(driverClass); // 4.获取连接 conn = DriverManager.getConnection(url, user, password); st = conn.createStatement(); rs = st.executeQuery(sql); // 获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); // 获取结果集的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) { t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) { // //1. 获取列的名称 // String columnName = rsmd.getColumnName(i+1); // 1. 获取列的别名 String columnName = rsmd.getColumnLabel(i + 1); // 2. 根据列名获取对应数据表中的数据 Object columnVal = rs.getObject(columnName); // 3. 将数据表中得到的数据，封装进对象 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t, columnVal); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { // 关闭资源 if (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (st != null) { try { st.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } return null; } } 综上： 3.3 PreparedStatement的使用3.3.1 PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 3.3.2 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 3.3.3 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 3.3.4 使用PreparedStatement实现增、删、改操作//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表） public void update(String sql,Object ... args){ Connection conn = null; PreparedStatement ps = null; try { //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++){ ps.setObject(i + 1, args[i]); } //4.执行sql语句 ps.execute(); } catch (Exception e) { e.printStackTrace(); }finally{ //5.关闭资源 JDBCUtils.closeResource(conn, ps); } } 3.3.5 使用PreparedStatement实现查询操作// 通用的针对于不同表的查询:返回一个对象 (version 1.0) public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) { T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) {// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { // 7.关闭资源 JDBCUtils.closeResource(conn, ps, rs); } return null; } 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。 3.4 ResultSet与ResultSetMetaData3.4.1 ResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(“name”) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 ResultSet 接口的常用方法： boolean next() getString() … 3.4.2 ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta = rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 isNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？ ​ 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData 问题2：关于ResultSetMetaData 如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可 获取 ResultSet 中有多少列：调用 ResultSetMetaData 的 getColumnCount() 方法 获取 ResultSet 每一列的列的别名是什么：调用 ResultSetMetaData 的getColumnLabel() 方法 3.5 资源的释放 释放ResultSet, Statement,Connection。 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 3.6 JDBC API小结 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 章节练习练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下： 练习题2：创立数据库表 examstudent，表结构如下： 向数据表中添加如下数据： 代码实现1：插入一个新的student 信息 请输入考生的详细信息 Type:IDCard:ExamCard:StudentName:Location:Grade: 信息录入成功! 代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下： 代码实现3：完成学生信息的删除功能 第4章 操作BLOB类型字段4.1 MySQL BLOB类型 MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。 插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。 MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的) 实际使用中根据需要存入的数据大小定义不同的BLOB类型。 需要注意的是：如果存储的文件过大，数据库的性能会下降。 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet=16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。 4.2 向数据表中插入大数据类型//获取连接 Connection conn = JDBCUtils.getConnection(); String sql = \"insert into customers(name,email,birth,photo)values(?,?,?,?)\"; PreparedStatement ps = conn.prepareStatement(sql); // 填充占位符 ps.setString(1, \"徐海强\"); ps.setString(2, \"xhq@126.com\"); ps.setDate(3, new Date(new java.util.Date().getTime())); // 操作Blob类型的变量 FileInputStream fis = new FileInputStream(\"xhq.png\"); ps.setBlob(4, fis); //执行 ps.execute(); fis.close(); JDBCUtils.closeResource(conn, ps); 4.3 修改数据表中的Blob类型字段Connection conn = JDBCUtils.getConnection(); String sql = \"update customers set photo = ? where id = ?\"; PreparedStatement ps = conn.prepareStatement(sql); // 填充占位符 // 操作Blob类型的变量 FileInputStream fis = new FileInputStream(\"coffee.png\"); ps.setBlob(1, fis); ps.setInt(2, 25); ps.execute(); fis.close(); JDBCUtils.closeResource(conn, ps); 4.4 从数据表中读取大数据类型String sql = \"SELECT id, name, email, birth, photo FROM customer WHERE id = ?\"; conn = getConnection(); ps = conn.prepareStatement(sql); ps.setInt(1, 8); rs = ps.executeQuery(); if(rs.next()){ Integer id = rs.getInt(1); String name = rs.getString(2); String email = rs.getString(3); Date birth = rs.getDate(4); Customer cust = new Customer(id, name, email, birth); System.out.println(cust); //读取Blob类型的字段 Blob photo = rs.getBlob(5); InputStream is = photo.getBinaryStream(); OutputStream os = new FileOutputStream(\"c.jpg\"); byte [] buffer = new byte[1024]; int len = 0; while((len = is.read(buffer)) != -1){ os.write(buffer, 0, len); } JDBCUtils.closeResource(conn, ps, rs); if(is != null){ is.close(); } if(os != null){ os.close(); } } 第5章 批量插入5.1 批量执行SQL语句当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率 JDBC的批量处理语句包括下面三个方法： addBatch(String)：添加需要批量处理的SQL语句或是参数； executeBatch()：执行批量处理语句； clearBatch():清空缓存的数据 通常我们会遇到两种批量执行SQL语句的情况： 多条SQL语句的批量处理； 一个SQL语句的批量传参； 5.2 高效的批量插入举例：向数据表中插入20000条数据 数据库中提供一个goods表。创建如下： CREATE TABLE goods( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); 5.2.1 实现层次一：使用StatementConnection conn = JDBCUtils.getConnection(); Statement st = conn.createStatement(); for(int i = 1;i &lt;= 20000;i++){ String sql = \"insert into goods(name) values('name_' + \"+ i +\")\"; st.executeUpdate(sql); } 5.2.2 实现层次二：使用PreparedStatementlong start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name)values(?)\"; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 20000;i++){ ps.setString(1, \"name_\" + i); ps.executeUpdate(); } long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start));//82340 JDBCUtils.closeResource(conn, ps); 5.2.3 实现层次三/* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 * ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar * */ @Test public void testInsert1() throws Exception{ long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name)values(?)\"; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++){ ps.setString(1, \"name_\" + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0){ //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); } } long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start));//20000条：625 //1000000条:14733 JDBCUtils.closeResource(conn, ps); } 5.2.4 实现层次四/* * 层次四：在层次三的基础上操作 * 使用Connection 的 setAutoCommit(false) / commit() */ @Test public void testInsert2() throws Exception{ long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); //1.设置为不自动提交数据 conn.setAutoCommit(false); String sql = \"insert into goods(name)values(?)\"; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++){ ps.setString(1, \"name_\" + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0){ //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); } } //2.提交数据 conn.commit(); long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start));//1000000条:4978 JDBCUtils.closeResource(conn, ps); } 第6章： 数据库事务6.1 数据库事务介绍 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)**，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)**到最初状态。 为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 6.2 JDBC事务处理 数据一旦提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。 JDBC程序中为了让多个 SQL 语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 【案例：用户AA向用户BB转账100】 public void testJDBCTransaction() { Connection conn = null; try { // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.开启事务 conn.setAutoCommit(false); // 3.进行数据库操作 String sql1 = \"update user_table set balance = balance - 100 where user = ?\"; update(conn, sql1, \"AA\"); // 模拟网络异常 //System.out.println(10 / 0); String sql2 = \"update user_table set balance = balance + 100 where user = ?\"; update(conn, sql2, \"BB\"); // 4.若没有异常，则提交事务 conn.commit(); } catch (Exception e) { e.printStackTrace(); // 5.若有异常，则回滚事务 try { conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } } finally { try { //6.恢复每次DML操作的自动提交功能 conn.setAutoCommit(true); } catch (SQLException e) { e.printStackTrace(); } //7.关闭连接 JDBCUtils.closeResource(conn, null, null); } } 其中，对数据库操作的方法为： //使用事务以后的通用的增删改操作（version 2.0） public void update(Connection conn ,String sql, Object... args) { PreparedStatement ps = null; try { // 1.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); // 2.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 3.执行sql语句 ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { // 4.关闭资源 JDBCUtils.closeResource(null, ps); } } 6.3 事务的ACID属性 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 6.3.1 数据库的并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。 6.3.2 四种隔离级别 数据库提供的4种事务隔离级别： Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。 Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。 6.3.3 在MySql中设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。 查看当前的隔离级别: SELECT @@tx_isolation; 设置当前 mySQL 连接的隔离级别: set transaction isolation level read committed; 设置数据库系统的全局的隔离级别: set global transaction isolation level read committed; 补充操作： 创建mysql数据库用户： create user tom identified by 'abc123'; 授予权限 #授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123. grant all privileges on *.* to tom@'%' identified by 'abc123'; #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。 grant select,insert,delete,update on atguigudb.* to tom@localhost identified by 'abc123'; 第7章：DAO及相关实现类 DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级。 下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现： 层次结构： 【BaseDAO.java】package com.atguigu.bookstore.dao; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.sql.Connection; import java.sql.SQLException; import java.util.List; import org.apache.commons.dbutils.QueryRunner; import org.apache.commons.dbutils.handlers.BeanHandler; import org.apache.commons.dbutils.handlers.BeanListHandler; import org.apache.commons.dbutils.handlers.ScalarHandler; /** * 定义一个用来被继承的对数据库进行基本操作的Dao * * @author HanYanBing * * @param &lt;T&gt; */ public abstract class BaseDao&lt;T&gt; { private QueryRunner queryRunner = new QueryRunner(); // 定义一个变量来接收泛型的类型 private Class&lt;T&gt; type; // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定 public BaseDao() { // 获取子类的类型 Class clazz = this.getClass(); // 获取父类的类型 // getGenericSuperclass()用来获取当前类的父类的类型 // ParameterizedType表示的是带泛型的类型 ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型 // 这个方法会返回一个Type的数组 Type[] types = parameterizedType.getActualTypeArguments(); // 获取具体的泛型的类型· this.type = (Class&lt;T&gt;) types[0]; } /** * 通用的增删改操作 * * @param sql * @param params * @return */ public int update(Connection conn,String sql, Object... params) { int count = 0; try { count = queryRunner.update(conn, sql, params); } catch (SQLException e) { e.printStackTrace(); } return count; } /** * 获取一个对象 * * @param sql * @param params * @return */ public T getBean(Connection conn,String sql, Object... params) { T t = null; try { t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params); } catch (SQLException e) { e.printStackTrace(); } return t; } /** * 获取所有对象 * * @param sql * @param params * @return */ public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) { List&lt;T&gt; list = null; try { list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params); } catch (SQLException e) { e.printStackTrace(); } return list; } /** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 * * @param sql * @param params * @return */ public Object getValue(Connection conn,String sql, Object... params) { Object count = null; try { // 调用queryRunner的query方法获取一个单一的值 count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params); } catch (SQLException e) { e.printStackTrace(); } return count; } } 【BookDAO.java】package com.atguigu.bookstore.dao; import java.sql.Connection; import java.util.List; import com.atguigu.bookstore.beans.Book; import com.atguigu.bookstore.beans.Page; public interface BookDao { /** * 从数据库中查询出所有的记录 * * @return */ List&lt;Book&gt; getBooks(Connection conn); /** * 向数据库中插入一条记录 * * @param book */ void saveBook(Connection conn,Book book); /** * 从数据库中根据图书的id删除一条记录 * * @param bookId */ void deleteBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中查询出一条记录 * * @param bookId * @return */ Book getBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中更新一条记录 * * @param book */ void updateBook(Connection conn,Book book); /** * 获取带分页的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page); /** * 获取带分页和价格范围的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice); } 【UserDAO.java】package com.atguigu.bookstore.dao; import java.sql.Connection; import com.atguigu.bookstore.beans.User; public interface UserDao { /** * 根据User对象中的用户名和密码从数据库中获取一条记录 * * @param user * @return User 数据库中有记录 null 数据库中无此记录 */ User getUser(Connection conn,User user); /** * 根据User对象中的用户名从数据库中获取一条记录 * * @param user * @return true 数据库中有记录 false 数据库中无此记录 */ boolean checkUsername(Connection conn,User user); /** * 向数据库中插入User对象 * * @param user */ void saveUser(Connection conn,User user); } 【BookDaoImpl.java】package com.atguigu.bookstore.dao.impl; import java.sql.Connection; import java.util.List; import com.atguigu.bookstore.beans.Book; import com.atguigu.bookstore.beans.Page; import com.atguigu.bookstore.dao.BaseDao; import com.atguigu.bookstore.dao.BookDao; public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao { @Override public List&lt;Book&gt; getBooks(Connection conn) { // 调用BaseDao中得到一个List的方法 List&lt;Book&gt; beanList = null; // 写sql语句 String sql = \"select id,title,author,price,sales,stock,img_path imgPath from books\"; beanList = getBeanList(conn,sql); return beanList; } @Override public void saveBook(Connection conn,Book book) { // 写sql语句 String sql = \"insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)\"; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath()); } @Override public void deleteBookById(Connection conn,String bookId) { // 写sql语句 String sql = \"DELETE FROM books WHERE id = ?\"; // 调用BaseDao中通用增删改的方法 update(conn,sql, bookId); } @Override public Book getBookById(Connection conn,String bookId) { // 调用BaseDao中获取一个对象的方法 Book book = null; // 写sql语句 String sql = \"select id,title,author,price,sales,stock,img_path imgPath from books where id = ?\"; book = getBean(conn,sql, bookId); return book; } @Override public void updateBook(Connection conn,Book book) { // 写sql语句 String sql = \"update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?\"; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId()); } @Override public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) { // 获取数据库中图书的总记录数 String sql = \"select count(*) from books\"; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?\"; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; } @Override public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) { // 获取数据库中图书的总记录数 String sql = \"select count(*) from books where price between ? and ?\"; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = \"select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?\"; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; } } 【UserDaoImpl.java】package com.atguigu.bookstore.dao.impl; import java.sql.Connection; import com.atguigu.bookstore.beans.User; import com.atguigu.bookstore.dao.BaseDao; import com.atguigu.bookstore.dao.UserDao; public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao { @Override public User getUser(Connection conn,User user) { // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = \"select id,username,password,email from users where username = ? and password = ?\"; bean = getBean(conn,sql, user.getUsername(), user.getPassword()); return bean; } @Override public boolean checkUsername(Connection conn,User user) { // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = \"select id,username,password,email from users where username = ?\"; bean = getBean(conn,sql, user.getUsername()); return bean != null; } @Override public void saveUser(Connection conn,User user) { //写sql语句 String sql = \"insert into users(username,password,email) values(?,?,?)\"; //调用BaseDao中通用的增删改的方法 update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail()); } } 【Book.java】package com.atguigu.bookstore.beans; /** * 图书类 * @author songhongkang * */ public class Book { private Integer id; private String title; // 书名 private String author; // 作者 private double price; // 价格 private Integer sales; // 销量 private Integer stock; // 库存 private String imgPath = \"static/./JDBC/default.jpg\"; // 封面图片的路径 //构造器，get()，set()，toString()方法略 } 【Page.java】package com.atguigu.bookstore.beans; import java.util.List; /** * 页码类 * @author songhongkang * */ public class Page&lt;T&gt; { private List&lt;T&gt; list; // 每页查到的记录存放的集合 public static final int PAGE_SIZE = 4; // 每页显示的记录数 private int pageNo; // 当前页 // private int totalPageNo; // 总页数，通过计算得到 private int totalRecord; // 总记录数，通过查询数据库得到 【User.java】package com.atguigu.bookstore.beans; /** * 用户类 * @author songhongkang * */ public class User { private Integer id; private String username; private String password; private String email; 第8章：数据库连接池8.1 JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 8.2 数据库连接池技术 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 工作原理： 数据库连接池技术的优点 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 8.3 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 8.3.1 C3P0数据库连接池 获取连接方式一 //使用C3P0数据库连接池的方式，获取数据库的连接：不推荐 public static Connection getConnection1() throws Exception{ ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass(\"com.mysql.jdbc.Driver\"); cpds.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\"); cpds.setUser(\"root\"); cpds.setPassword(\"abc123\"); // cpds.setMaxPoolSize(100); Connection conn = cpds.getConnection(); return conn; } 获取连接方式二 //使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐 private static DataSource cpds = new ComboPooledDataSource(\"helloc3p0\"); public static Connection getConnection2() throws SQLException{ Connection conn = cpds.getConnection(); return conn; } 其中，src下的配置文件为：【c3p0-config.xml】 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;c3p0-config&gt; &lt;named-config name=\"helloc3p0\"&gt; &lt;!-- 获取连接的4个基本信息 --&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;abc123&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql:///test&lt;/property&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt; &lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt; &lt;property name=\"acquireIncrement\"&gt;5&lt;/property&gt; &lt;!-- 初始化数据库连接池时连接的数量 --&gt; &lt;property name=\"initialPoolSize\"&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最小的数据库连接数 --&gt; &lt;property name=\"minPoolSize\"&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最大的数据库连接数 --&gt; &lt;property name=\"maxPoolSize\"&gt;10&lt;/property&gt; &lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt; &lt;property name=\"maxStatements\"&gt;20&lt;/property&gt; &lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt; &lt;property name=\"maxStatementsPerConnection\"&gt;5&lt;/property&gt; &lt;/named-config&gt; &lt;/c3p0-config&gt; 8.3.2 DBCP数据库连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 获取连接方式一： public static Connection getConnection3() throws Exception { BasicDataSource source = new BasicDataSource(); source.setDriverClassName(\"com.mysql.jdbc.Driver\"); source.setUrl(\"jdbc:mysql:///test\"); source.setUsername(\"root\"); source.setPassword(\"abc123\"); // source.setInitialSize(10); Connection conn = source.getConnection(); return conn; } 获取连接方式二： //使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐 private static DataSource source = null; static{ try { Properties pros = new Properties(); InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(\"dbcp.properties\"); pros.load(is); //根据提供的BasicDataSourceFactory创建对应的DataSource对象 source = BasicDataSourceFactory.createDataSource(pros); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection4() throws Exception { Connection conn = source.getConnection(); return conn; } 其中，src下的配置文件为：【dbcp.properties】 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false username=root password=abc123 initialSize=10 #... 8.3.3 Druid（德鲁伊）数据库连接池Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 package com.atguigu.druid; import java.sql.Connection; import java.util.Properties; import javax.sql.DataSource; import com.alibaba.druid.pool.DruidDataSourceFactory; public class TestDruid { public static void main(String[] args) throws Exception { Properties pro = new Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(\"druid.properties\")); DataSource ds = DruidDataSourceFactory.createDataSource(pro); Connection conn = ds.getConnection(); System.out.println(conn); } } 其中，src下的配置文件为：【druid.properties】 url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true username=root password=123456 driverClassName=com.mysql.jdbc.Driver initialSize=10 maxActive=20 maxWait=1000 filters=wall 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 第9章：Apache-DBUtils实现CRUD操作9.1 Apache-DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils API包说明： 9.2 主要API的使用9.2.1 DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 9.2.2 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 …… 插入 public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值 …. 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 ….. 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 …… 测试 // 测试添加 @Test public void testInsert() throws Exception { QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \"insert into customers(name,email,birth)values(?,?,?)\"; int count = runner.update(conn, sql, \"何成飞\", \"he@qq.com\", \"1992-09-08\"); System.out.println(\"添加了\" + count + \"条记录\"); JDBCUtils.closeResource(conn, null); } // 测试删除 @Test public void testDelete() throws Exception { QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \"delete from customers where id &lt; ?\"; int count = runner.update(conn, sql,3); System.out.println(\"删除了\" + count + \"条记录\"); JDBCUtils.closeResource(conn, null); } 9.2.3 ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 测试 /* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */ @Test public void testQueryInstance() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \"select id,name,email,birth from customers where id = ?\"; // BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null); } /* * 测试查询:查询多条记录构成的集合 * * 使用ResultSetHandler的实现类：BeanListHandler */ @Test public void testQueryList() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \"select id,name,email,birth from customers where id &lt; ?\"; // BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null); } /* * 自定义ResultSetHandler的实现类 */ @Test public void testQueryInstance1() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = \"select id,name,email,birth from customers where id = ?\"; ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() { @Override public Customer handle(ResultSet rs) throws SQLException { System.out.println(\"handle\"); // return new Customer(1,\"Tom\",\"tom@126.com\",new Date(123323432L)); if(rs.next()){ int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String email = rs.getString(\"email\"); Date birth = rs.getDate(\"birth\"); return new Customer(id, name, email, birth); } return null; } }; Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null); } /* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler * */ @Test public void testQueryValue() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); //测试一： // String sql = \"select count(*) from customers where id &lt; ?\"; // ScalarHandler handler = new ScalarHandler(); // long count = (long) runner.query(conn, sql, handler, 20); // System.out.println(count); //测试二： String sql = \"select max(birth) from customers\"; ScalarHandler handler = new ScalarHandler(); Date birth = (Date) runner.query(conn, sql, handler); System.out.println(birth); JDBCUtils.closeResource(conn, null); } JDBC总结总结 @Test public void testUpdateWithTx() { Connection conn = null; try { //1.获取连接的操作（ //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0) //version2.0的增删改public void update(Connection conn,String sql,Object ... args){} //version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args){} //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); } catch (Exception e) { e.printStackTrace(); try { //回滚数据 conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } }finally{ //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 } }","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"2020原生Android基础实用开发","slug":"README","date":"2021-05-02T03:37:34.000Z","updated":"2021-05-03T08:10:25.176Z","comments":true,"path":"posts/6d4a7b1e.html","link":"","permalink":"https://gitee.com/td278121/posts/6d4a7b1e.html","excerpt":"2020原生Android基础实用开发","text":"2020原生Android基础实用开发 1、环境配置 进入官网，下载Android studio安装包 https://developer.android.google.cn/studio/ 安装Android studio 创建项目 构建项目 创建手机模拟器 完成 2、简单熟悉Android sudio开发工具 熟悉界面 界面布局代码以及java代码部分 最后讲几个简单设置 设置开发工具主题:Appearance 设置代码字体大小:font 后面的慢慢教… 3、文本TextView的使用 属性 text:内容 autoLink:设置内容为链接 textIsSelectable：设置可复制 文本内容超过一行，显示三点 singleLine 跑马灯 singleLine:设置一行 ellipsize：设置跑马灯 marqueeRepeatLimit:设置无限轮播 获取组件id设置setSelected 事件 setOnClickListener:点击事件 setOnLongClickListener:长按事件 setText:动态设置内容 4、按钮Button的使用 设置 自动导入java包 autu Import 属性 text:按钮内容 textColor：字体颜色 background:背景颜色 自定义样式: 新建一个shape的xml自定义 solid:背景颜色 corners：边角度 stroke:描边 事件 setOnClickListener:点击事件 setOnLongClickListener:长按事件 android自带的Toast吐司：用来提示用户的 参数1:上下文 参数2：文本 参数3：显示的时间 5、输入框EditText的使用 属性: text:输入内容 hint：提示文本 自定义样式: 新建一个shape的xml自定义 solid:背景颜色 corners：边角度 stroke:描边 事件 setOnFocusChangeListener：获取失去焦点 监听 addTextChangedListener：内容改变的监听 beforeTextChanged：获取并打印 市面上好看的输入框:TextInputLayout+TextInputEditText 在build.gradle(Module:app)引入插件 // 输入框 //noinspection GradleCompatible implementation 'com.android.support:appcompat-v7:27.1.1' //noinspection GradleCompatible implementation 'com.android.support:design:27.+' 使用模板 &lt;com.google.android.material.textfield.TextInputLayout android:layout_margin=\"10dp\" android:padding=\"10dp\" app:passwordToggleEnabled=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" &gt; &lt;com.google.android.material.textfield.TextInputEditText android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"提示\"/&gt; &lt;/com.google.android.material.textfield.TextInputLayout&gt; 6、复选框CheckBox\\单选框RadioButton的使用 属性 text：内容 checked：勾选状态 方法 setChecked：设置选中状态 isChecked：获取当前选中状态 事件 RadioButton setOnCheckedChangeListener:获取选中的是哪个单选框 7、下拉框Spinner使用 属性 entries：设置静态数据 事件 setOnItemSelectedListener:选中事件 方法 setAdapter：设置适配器 适配器 ArrayAdapter：简单的数组适配器 list:数据源 方法 notifyDataSetChanged:属性数据 8、图片ImageView的使用 属性 src:静态图片 scaleType：图片显示类型 fitXY:铺满 center：剧中 fitEnd：尾部 fitCenter：默认剧中 方法： setImageResource：设置静态图片 setImageBitmap：设置Bitmap图片 插件：Glide:显示网络图片 导入 //加载网络图片 implementation 'com.github.bumptech.glide:glide:4.9.0' 配置权限 &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 注意： 这里主要是INTERNET网络权限 9.0以上版本,还得配置 &lt;!--application属性里--&gt; android:usesCleartextTraffic=\"true\" &lt;!--application标签里--&gt; &lt;uses-library android:name=\"org.apache.http.legacy\" android:required=\"true\" /&gt; 显示网络图片 Glide.with(Context).load(\"url\").into(ImageView); 9、布局layout的使用 默认宽/高设定 wrap_content：根据内容大小而改变 match_parent：占满 LinearLayout:线性布局 gravity:控制内容组件 layout_gravity:面向父级控制自己位置 padding：内边距 layout_margin：外边距 orientation:方向 horizontal:横向 vertical:竖向 layout_weight：权重（比例分配） RelativeLayout：针布局 排在越后显示级别越高 按钮特殊需要加：android:stateListAnimator=”@null” gravity:控制内容组件 layout_gravity:面向父级控制自己位置 padding：内边距 layout_margin：外边距 layout_alignParent:面向与父容器控制位置 layout_：面向与控件调整位置 layout_toLeftOf:控件的左边 layout_toRightOf：控件的右边 layout_below：控件的下面 layout_above：控件的上面 10、完成登录界面&amp;&amp;头部Toolbar的使用 Toolbar 属性 title:标题 titleTextColor:标题颜色 完成布局并设置id 开发工具插件 GenerateFindViewById：获取布局id 准备事件 获取账号/密码验证数据 完成登录—跳转页面 startActivity(new Intent(getApplicationContext(),EditTextTest.class)); 11、列表ListView的使用（上） 属性 entries:默认数据 事件 setOnItemClickListener：点击单个列表 适配器 ArrayAdapter：简单的数组适配器 list:数据源 方法 notifyDataSetChanged:属性数据 BaseAdapter:自定义适配器 准备自定义的View模板 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:orientation=\"vertical\" android:padding=\"10dp\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:textSize=\"15dp\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"name\"/&gt; &lt;TextView android:textSize=\"10dp\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"age\"/&gt; &lt;/LinearLayout&gt; 准备数据的实体类 public class ListViewEntity { String name; String age; public ListViewEntity() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } @Override public String toString() { return \"ListViewEntity{\" + \"name='\" + name + '\\'' + \", age='\" + age + '\\'' + '}'; } } 注意：实体类一般是以自定义的View接口来定义的。 准备实体的数据 List&lt;ListViewEntity&gt; listViewEntities; listViewEntities = new ArrayList&lt;&gt;(); listViewEntities.add(new ListViewEntity(\"张三\",12)); listViewEntities.add(new ListViewEntity(\"李四\",13)); listViewEntities.add(new ListViewEntity(\"王五\",14)); 准备一个自定义的BaseAdapter的类 private class BaseAdapterTest extends BaseAdapter{ @Override public int getCount() { return listViewEntities.size(); } @Override public Object getItem(int i) { return listViewEntities.get(i); } @Override public long getItemId(int i) { return i; } @Override public View getView(int i, View view, ViewGroup viewGroup) { ViewHolder viewHolder = null; if (view == null){ viewHolder = new ViewHolder(); view = LayoutInflater.from(getApplicationContext()).inflate(R.layout.adapter_listview,null); viewHolder.tvAge = view.findViewById(R.id.adapter_listView_tv_age); viewHolder.tvName = view.findViewById(R.id.adapter_listView_tv_name); view.setTag(viewHolder); }else { viewHolder = (ViewHolder) view.getTag(); } //做数据的处理 return view; } class ViewHolder { TextView tvName; TextView tvAge; } } 12、列表ListView的使用（下）&amp;&amp;优化界面跳转 插件 android-codegenerator-plugin-intellij：代码生成器 生成findByid 生成adapter 生成fragment的findByid … 下载网站 链接:https://pan.baidu.com/s/1bsZznquq_tVtmx_VzBfslQ 密码:timi 优化跳转界面 共享元素 跳转代码 //跳转 Intent intent = new Intent(getApplicationContext(),ImageViewTest.class); startActivity(intent, ActivityOptions.makeSceneTransitionAnimation( ListViewTest.this, new Pair[]{Pair.&lt;View, String&gt;create(holder.ivTest, \"activtyImageTest_image\")} ).toBundle()); 共享的元素 android:transitionName=\"set_Img\" 13、横向列表HorizontalListView(自定义View)的使用 简单自定义View的理解 通过java程序构成xml样式 直接可以在xml中使用 导出属性 … 网上复制一个横向列表的list public class HorizontalListView extends AdapterView&lt;ListAdapter&gt; { float startX; float startY; public boolean mAlwaysOverrideTouch = true; protected ListAdapter mAdapter; private int mLeftViewIndex = -1; private int mRightViewIndex = 0; protected int mCurrentX; protected int mNextX; private int mMaxX = Integer.MAX_VALUE; private int mDisplayOffset = 0; protected Scroller mScroller; private GestureDetector mGesture; private Queue&lt;View&gt; mRemovedViewQueue = new LinkedList&lt;View&gt;(); private OnItemSelectedListener mOnItemSelected; private OnItemClickListener mOnItemClicked; private OnItemLongClickListener mOnItemLongClicked; private boolean mDataChanged = false; public HorizontalListView(Context context, AttributeSet attrs) { super(context, attrs); initView(); } private synchronized void initView() { mLeftViewIndex = -1; mRightViewIndex = 0; mDisplayOffset = 0; mCurrentX = 0; mNextX = 0; mMaxX = Integer.MAX_VALUE; mScroller = new Scroller(getContext()); mGesture = new GestureDetector(getContext(), mOnGesture); } @Override public void setOnItemSelectedListener(OnItemSelectedListener listener) { mOnItemSelected = listener; } @Override public void setOnItemClickListener(OnItemClickListener listener) { mOnItemClicked = listener; } @Override public void setOnItemLongClickListener(OnItemLongClickListener listener) { mOnItemLongClicked = listener; } private DataSetObserver mDataObserver = new DataSetObserver() { @Override public void onChanged() { synchronized (HorizontalListView.this) { mDataChanged = true; } invalidate(); requestLayout(); } @Override public void onInvalidated() { reset(); invalidate(); requestLayout(); } }; @Override public ListAdapter getAdapter() { return mAdapter; } @Override public View getSelectedView() { return null; } @Override public void setAdapter(ListAdapter adapter) { if (mAdapter != null) { mAdapter.unregisterDataSetObserver(mDataObserver); } mAdapter = adapter; mAdapter.registerDataSetObserver(mDataObserver); reset(); } private synchronized void reset() { initView(); removeAllViewsInLayout(); requestLayout(); } @Override public void setSelection(int position) { } private void addAndMeasureChild(final View child, int viewPos) { LayoutParams params = child.getLayoutParams(); if (params == null) { params = new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT); } addViewInLayout(child, viewPos, params, true); child.measure(MeasureSpec.makeMeasureSpec(getWidth(), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(getHeight(), MeasureSpec.AT_MOST)); } @Override protected synchronized void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); if (mAdapter == null) { return; } if (mDataChanged) { int oldCurrentX = mCurrentX; initView(); removeAllViewsInLayout(); mNextX = oldCurrentX; mDataChanged = false; } if (mScroller.computeScrollOffset()) { int scrollx = mScroller.getCurrX(); mNextX = scrollx; } if (mNextX &lt;= 0) { mNextX = 0; mScroller.forceFinished(true); } if (mNextX &gt;= mMaxX) { mNextX = mMaxX; mScroller.forceFinished(true); } int dx = mCurrentX - mNextX; removeNonVisibleItems(dx); fillList(dx); positionItems(dx); mCurrentX = mNextX; if (!mScroller.isFinished()) { post(new Runnable() { @Override public void run() { requestLayout(); } }); } } private void fillList(final int dx) { int edge = 0; View child = getChildAt(getChildCount() - 1); if (child != null) { edge = child.getRight(); } fillListRight(edge, dx); edge = 0; child = getChildAt(0); if (child != null) { edge = child.getLeft(); } fillListLeft(edge, dx); } private void fillListRight(int rightEdge, final int dx) { while (rightEdge + dx &lt; getWidth() &amp;&amp; mRightViewIndex &lt; mAdapter.getCount()) { View child = mAdapter.getView(mRightViewIndex, mRemovedViewQueue.poll(), this); addAndMeasureChild(child, -1); rightEdge += child.getMeasuredWidth(); if (mRightViewIndex == mAdapter.getCount() - 1) { mMaxX = mCurrentX + rightEdge - getWidth(); } if (mMaxX &lt; 0) { mMaxX = 0; } mRightViewIndex++; } } private void fillListLeft(int leftEdge, final int dx) { while (leftEdge + dx &gt; 0 &amp;&amp; mLeftViewIndex &gt;= 0) { View child = mAdapter.getView(mLeftViewIndex, mRemovedViewQueue.poll(), this); addAndMeasureChild(child, 0); leftEdge -= child.getMeasuredWidth(); mLeftViewIndex--; mDisplayOffset -= child.getMeasuredWidth(); } } private void removeNonVisibleItems(final int dx) { View child = getChildAt(0); while (child != null &amp;&amp; child.getRight() + dx &lt;= 0) { mDisplayOffset += child.getMeasuredWidth(); mRemovedViewQueue.offer(child); removeViewInLayout(child); mLeftViewIndex++; child = getChildAt(0); } child = getChildAt(getChildCount() - 1); while (child != null &amp;&amp; child.getLeft() + dx &gt;= getWidth()) { mRemovedViewQueue.offer(child); removeViewInLayout(child); mRightViewIndex--; child = getChildAt(getChildCount() - 1); } } private void positionItems(final int dx) { if (getChildCount() &gt; 0) { mDisplayOffset += dx; int left = mDisplayOffset; for (int i = 0; i &lt; getChildCount(); i++) { View child = getChildAt(i); int childWidth = child.getMeasuredWidth(); child.layout(left, 0, left + childWidth, child.getMeasuredHeight()); left += childWidth + child.getPaddingRight(); } } } public synchronized void scrollTo(int x) { mScroller.startScroll(mNextX, 0, x - mNextX, 0); requestLayout(); } /** * 上下滑动需要拦截， */ @Override public boolean dispatchTouchEvent(MotionEvent ev) { boolean handled = super.dispatchTouchEvent(ev); handled |= mGesture.onTouchEvent(ev); getParent().requestDisallowInterceptTouchEvent(true); switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: startX = (int) ev.getX(); startY = (int) ev.getY(); break; case MotionEvent.ACTION_MOVE: int endX = (int) ev.getX(); int endY = (int) ev.getY(); int dx = (int) (endX - startX); int dy = (int) (endY - startY); if (Math.abs(dx) + 50 &gt; Math.abs(dy)) { } else { // 上下滑动,需要拦截 getParent().requestDisallowInterceptTouchEvent(false); } break; case MotionEvent.ACTION_UP: break; } return handled | super.dispatchTouchEvent(ev); } protected boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { synchronized (HorizontalListView.this) { mScroller.fling(mNextX, 0, (int) -velocityX, 0, 0, mMaxX, 0, 0); } requestLayout(); return true; } protected boolean onDown(MotionEvent e) { mScroller.forceFinished(true); return true; } private GestureDetector.OnGestureListener mOnGesture = new GestureDetector.SimpleOnGestureListener() { @Override public boolean onDown(MotionEvent e) { return HorizontalListView.this.onDown(e); } @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { return HorizontalListView.this.onFling(e1, e2, velocityX, velocityY); } @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) { synchronized (HorizontalListView.this) { mNextX += (int) distanceX; } requestLayout(); return true; } @Override public boolean onSingleTapConfirmed(MotionEvent e) { for (int i = 0; i &lt; getChildCount(); i++) { View child = getChildAt(i); if (isEventWithinView(e, child)) { if (mOnItemClicked != null) { mOnItemClicked.onItemClick(HorizontalListView.this, child, mLeftViewIndex + 1 + i, mAdapter.getItemId(mLeftViewIndex + 1 + i)); } if (mOnItemSelected != null) { mOnItemSelected.onItemSelected(HorizontalListView.this, child, mLeftViewIndex + 1 + i, mAdapter.getItemId(mLeftViewIndex + 1 + i)); } break; } } return true; } @Override public void onLongPress(MotionEvent e) { int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) { View child = getChildAt(i); if (isEventWithinView(e, child)) { if (mOnItemLongClicked != null) { mOnItemLongClicked.onItemLongClick(HorizontalListView.this, child, mLeftViewIndex + 1 + i, mAdapter.getItemId(mLeftViewIndex + 1 + i)); } break; } } } private boolean isEventWithinView(MotionEvent e, View child) { Rect viewRect = new Rect(); int[] childPosition = new int[2]; child.getLocationOnScreen(childPosition); int left = childPosition[0]; int right = left + child.getWidth(); int top = childPosition[1]; int bottom = top + child.getHeight(); viewRect.set(left, top, right, bottom); return viewRect.contains((int) e.getRawX(), (int) e.getRawY()); } }; //解决滑动和点击冲突问题 @Override public boolean onInterceptTouchEvent(MotionEvent ev) { switch (ev.getAction()) { case MotionEvent.ACTION_DOWN: startX = ev.getX(); startY = ev.getY(); break; case MotionEvent.ACTION_MOVE: float endX = ev.getX(); float endY = ev.getY(); float dx = endX - startX; float dy = endY - startY; if (Math.abs(dx) - 10 &gt; Math.abs(dy)) { return true; } else if (Math.abs(dx) &lt; Math.abs(dy) - 10) { return true; } break; case MotionEvent.ACTION_UP: break; } return super.onInterceptTouchEvent(ev); } } 在xml中使用 &lt;com.example.myapplication.customView.HorizontalListView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; HorizontalListView联系BaseAdapter使用 14、网格列表GridView的使用 属性 numColumns：列数 verticalSpacing：行距 horizontalSpacing：列距离 columnWidth：每列的宽 transcriptMode：加载数据会自动下滑 联系BaseAdapter适配器 事件 setOnItemClickListener：点击事件 15、静态进度条xxxBar的使用（上） SeekBar:拖动条 属性 max：设置最大值 progress：设置当前值 secondaryProgress：缓存条 事件 setOnSeekBarChangeListener：监听 onProgressChanged：进度发生改变时会触发 onStartTrackingTouch：按住SeekBar时会触发 onStopTrackingTouch：放开SeekBar时触发 ProgressBar：加载条 属性 max：设置最大值 progress：设置当前值 secondaryProgress：缓存条 方法 setProgress/getProgress:设置/获取当前值 RatingBar：评价条 属性 numStars：设置最大值 rating：设置当前值 方法 setProgress/getProgress:设置/获取当前值 （全部组件）组件属性 visibility gone：消失 visible：可见 （全部组件）组件方法 setEnabled：设置触摸激活状态 自定义样式:drawable文件创建xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;!-- 进度条背景色 --&gt; &lt;item android:id=\"@android:id/background\"&gt; &lt;shape&gt; &lt;solid android:color=\"#03A9F4\" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; 16、动态进度条xxxBar+线程的使用（下） 多种方法 Handler+Thread AsyncTask ThreadPoolExecutor IntentService 简书解释：https://www.jianshu.com/p/2b634a7c49ec Handler+Thread：线程（定时器/监听器） Thread启动线程 解析 如果启动线程，线程里的所有逻辑代码就会脱离住ui线程。 启动模板 Thread thread = new Thread(){ //准备一个线程 @Override public void run() { while (true){ //这是一个无限运行的线程 try { sleep(1000); //Thread内置的方法：1秒跑一次，相当于停顿1秒，这里单位是毫秒所以得使用1000 } catch (InterruptedException e) { e.printStackTrace(); } //编写逻辑代码 } } }; thread.start();//自动线程 &gt; 注意： &gt; &gt; + 如果要修改ui主线程的组件，得加上Handler的使用。负责会包错 &gt; &gt; &gt; Only the original thread that created a view hierarchy can touch its views. Handler主线程ui机制 解析 他是通过Message传递消息，然后Handler接受消息并修改组件。 发送消息模板 //准备一个消息 private int MESSAGE_TEST1 = 0x01; //发送消息 Message message = new Message(); message.arg1 = MESSAGE_TEST1; handler.sendMessage(message); &gt; 注意： &gt; &gt; + 如果是循环的线程，一定每次循环都得重新new一个新的Message对象 + 接受并处理模板 ```java Handler handler = new Handler(){ @Override public void handleMessage(@NonNull Message msg) { if (msg.arg1 == MESSAGE_TEST1){ //处理逻辑 } } }; 17、网页显示WebView的使用 权限 网络权限 &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 应用领域 app显示网页 简单浏览器 前端App 方法 //常用设置 webview.setWebViewClient(new WebViewClient());//设置可操作 WebSettings settings = webview.getSettings();//获得浏览器设置 settings.setJavaScriptEnabled(true); //支持js settings.setUseWideViewPort(true); //将图片调整到适合webview的大小 settings.setSupportZoom(true); //支持缩放 settings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.SINGLE_COLUMN); //支持内容重 新布局 settings.supportMultipleWindows(); //多窗口 settings.setCacheMode(WebSettings.LOAD_NO_CACHE); //关闭webview中缓存 settings.setAllowFileAccess(true); //设置可以访问文件 settings.setNeedInitialFocus(true); //当webview调用requestFocus时为webview设置节点 settings.setBuiltInZoomControls(true); //设置支持缩放 settings.setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口 settings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小 settings.setLoadsImagesAutomatically(true); //支持自动加载图片 settings.setSavePassword(true);//关闭WebView的自动保存密码功能 //常用方法 webview.goBack();//返回上一级 wwebview.canGoBack();//返回是否可以返回上一级 webview.goForward();//前进 webview.canGoForward();//判断是否可以前进 使用 显示html代码 webview.loadDataWithBaseURL(\"about:blank\", html,\"text/html\", \"UTF-8\",null); 显示网页地址 webview.loadUrl(\"https://www.baidu.com\"); 监听 setWebViewClient onPageFinished：监听加载完成 setWebChromeClient onProgressChanged：监听加载进度，100为完成 18、碎片界面Fragment的使用 简述 使用Fragment可以把屏幕划分成几块，然后进行分组，进行一个模块化管理。Fragment不能够单独使用，需要嵌套在Activity中使用，其生命周期也受到宿主Activity的生命周期的影响 网站解析 https://www.jianshu.com/p/a4c51309bc19 使用 步骤一：首先准备一个碎片存放处（占位） //这里我使用线性布局，可以使用任意一个布局不会有任何影响 &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 步骤二：准备一个Fregment碎片界面 public class FragmentTest extends Fragment { View view; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { view = inflater.inflate(R.layout.activity_fragment_test,container,false); return view; } } 步骤三:替换占位 方法一：连点 getSupportFragmentManager().beginTransaction().replace(R.id.layout,new FragmentTest()).commit(); 方法一：分步骤 FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction(); // 开启一个事务 transaction.replace(R.id.right_layout, fragment); transaction.commit(); 方法三：状态保持 //准备一个隐藏全部fragment的方法 public void hintFragment(FragmentTransaction ft) { if (f1 != null) { ft.hide(f1); } if (f2 != null) { ft.hide(f2); } } //准备方法显示需要显示的一个fragment， public void showFragment(int index) { // Fragment事务管理器 FragmentTransaction ft = getSupportFragmentManager().beginTransaction(); // 隐藏已加载过的Fragment hintFragment(ft); switch (index) { // 判断Fragment是否实例化，实例化过直接显示出来，否者实例化 case 1: if (f1 != null) { ft.show(f1); } else { f1 = new Fragment01(); ft.add(R.id.content, f1); } break; case 2: if (f2 != null) { ft.show(f2); } else { f2 = new Fragment02(); ft.add(R.id.content, f2); } break; } ft.commit(); } //最后通过点击事件显示需要显示的fragemtn showFragment(1); 19、轮播组件ViewPager的使用(上) 使用范围 图片查看器 首页轮播图片 首页多页面(fragment) …. 方法 setCurrentItem：跳转界面 第二个参数为false:没有动画 setOffscreenPageLimit：设置缓存界面个数 使用 准备n个xml的界面 准备一个集合，存入所有的xml界面 pageView = new ArrayList&lt;View&gt;(); pageView.add(LayoutInflater.from(getApplicationContext()).inflate(R.layout.activity_button_test, null)); 设置适配器，并配置适配器 viewPager.setAdapter(new PagerAdapter() { @Override // 获取当前窗体界面数 public int getCount() { // TODO Auto-generated method stub return pageView.size(); } @Override // 断是否由对象生成界面 public boolean isViewFromObject(View arg0, Object arg1) { // TODO Auto-generated method stub return arg0 == arg1; } // 是从ViewGroup中移出当前View public void destroyItem(View arg0, int arg1, Object arg2) { ((ViewPager) arg0).removeView(pageView.get(arg1)); } // 返回一个对象，这个对象表明了PagerAdapter适配器选择哪个对象放在当前的ViewPager中 public Object instantiateItem(View arg0, int arg1) { ((ViewPager) arg0).addView(pageView.get(arg1)); return pageView.get(arg1); } }); 20、轮播组件ViewPager+Fragment+Tab的使用(下) 三方插件:TabLayout implementation 'com.android.support:design:23.1.1' ViewPage+Fragment //---准备数据 final List&lt;Fragment&gt; list2 = new ArrayList&lt;&gt;(); list2.add(new Fragment01()); list2.add(new Fragment02()); //----设置显示 mPageViewVpTest.setAdapter(new FragmentStatePagerAdapter(getSupportFragmentManager()) { @NonNull @Override public Fragment getItem(int position) { return list2.get(position); } @Override public int getCount() { return list2.size(); } @Nullable @Override public CharSequence getPageTitle(int position) { return titles.get(position); } }); 使用场景 主页 轮播图 引导页面 … TabLayout使用 //---准备标题数据 final List&lt;String&gt; titles = new ArrayList&lt;&gt;(); titles.add(\"标题1\"); titles.add(\"标题2\"); //---重写适配器方法 @Nullable @Override public CharSequence getPageTitle(int position) { return titles.get(position); } //---设置关联 TabLayout.setupWithViewPager(viewPager); 过时处理 FragmentPagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT; 兼容以前那种方式实现的懒加载 21、侧滑菜单栏 SlidingPaneLayout||DrawerLayout 的使用 SlidingPaneLayout 推荐简述 https://www.jianshu.com/p/feaf6cc7406e 简单实现 &lt;androidx.slidingpanelayout.widget.SlidingPaneLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:background=\"#123\" android:layout_width=\"240dp\" android:layout_gravity=\"left\" android:layout_height=\"match_parent\"&gt;&lt;/LinearLayout&gt; &lt;LinearLayout android:background=\"#543\" android:layout_gravity=\"right\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;/LinearLayout&gt; &lt;/androidx.slidingpanelayout.widget.SlidingPaneLayout&gt; 注意： layout_gravity：设置模块类型 配合Fragment使用 getSupportFragmentManager().beginTransaction().replace(R.id.layout,new Fragment()).commit(); 注意： 其实就是利用Fragment的特性，替换Layout 属性 设置透明颜色 SlidingPaneLayout.setSliderFadeColor(Color.TRANSPARENT);//设置面板的侧滑渐变色 打开/关闭-Api SlidingPaneLayout.openPane();//SlidingPaneLayout.closePane();/ 设置显示样式 final View leftView = SlidingPaneLayout.getChildAt(0); //获取滑动的第一个View //设置滑动样式监听 SlidingPaneLayout.setPanelSlideListener(new SlidingPaneLayout.PanelSlideListener() { @Override public void onPanelSlide(View panel, float slideOffset) { //panel：移动的View,slideOffset：移动的值 //覆盖界面 leftView.setScaleX(0.8f + 0.2f * slideOffset);//0.8~1//设置X偏移 leftView.setScaleY(0.8f + 0.2f * slideOffset);//0.8~1//设置y偏移 leftView.setAlpha(0.8f + 0.2f * slideOffset);//0.8~1//设置透明度 //主界面 panel.setScaleX(1 - 0.2f * slideOffset);//1~0.8 //设置X偏移 panel.setScaleY(1 - 0.2f * slideOffset);//1~0.8//设置y偏移 panel.setAlpha(1 - 0.8f * slideOffset);//1~0.8//设置透明度 } @Override public void onPanelOpened(View panel) { } @Override public void onPanelClosed(View panel) { } }); DrawerLayout 简单使用 &lt;androidx.drawerlayout.widget.DrawerLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; &lt;LinearLayout android:background=\"#432\" android:layout_gravity=\"start\" android:layout_width=\"240dp\" android:layout_height=\"match_parent\"/&gt; &lt;/androidx.drawerlayout.widget.DrawerLayout&gt; 注意： layout_gravity=”start”:决定覆盖模块 属性方法:打开/关闭 DrawerLayout.openDrawer(Gravity.LEFT);// DrawerLayout.closeDrawer(Gravity.LEFT);// 默认侧拉模块 完全恢复工具 22、下拉刷新SwipeRefreshLayout的使用 条件 只能有一个根元素 使用 &lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!--其他元素--&gt; &lt;/LinearLayout&gt; &lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout&gt; 方法属性 setRefreshing:设置显示/隐藏 setOnRefreshListener:监听下拉事件 setColorSchemeResources：设置多个颜色 setEnabled：设置是否可以滑动 23、测试网络接口-动态权限获取（上） Android 9.0 及以上 获取权限简述 网络权限声明 //声明 &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; //配置application android:usesCleartextTraffic=\"true\" //加入http &lt;uses-library android:name=\"org.apache.http.legacy\" android:required=\"true\" /&gt; 手机交互权限 //声明 &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt; 弹出获取/动态获取 public static void getPermissions(Activity activity){ //判断sdk版本 if (Build.VERSION.SDK_INT&gt;=23) { //获取管理器 int request= ContextCompat.checkSelfPermission(activity, Manifest.permission.CAMERA); if (request!= PackageManager.PERMISSION_GRANTED)//如果缺少权限，进行权限申请 { //准备缺少权限的集合,并准备一个回调id ActivityCompat.requestPermissions(activity,new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.READ_EXTERNAL_STORAGE},20); return;// } } } activity回调是否获取 //获取权限监听 @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { switch (requestCode) { case 20: if (grantResults.length &gt; 0 &amp;&amp; (grantResults[0] == PackageManager.PERMISSION_GRANTED &amp;&amp; grantResults[1] == PackageManager.PERMISSION_GRANTED)) { //同意了 } else { //拒绝权限 finish(); } break; } } 获取根目录 Environment.getExternalStorageDirectory()//--/storage/emulated/0/----这是sd卡的根目录 getFilesDir().getAbsolutePath()//--/data/user/0/com.example.myapplication/files/--这是软件权限目录 24、测试网络接口-Vollery网络调用+gson解析json数据（下） Vollery：调用接口 测试接口：一言开放接口 https://v1.hitokoto.cn/ 简单版调用 RequestQueue queue = Volley.newRequestQueue(getApplicationContext()); queue.add(new JsonObjectRequest(\"https://api.uixsj.cn/hitokoto/get?type=hitokoto&amp;code=json\", new Response.Listener&lt;JSONObject&gt;() { @Override public void onResponse(JSONObject jsonObject) { Log.d(\"Toast\",jsonObject.toString()); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError volleyError) { } })); 自定义包装为工具 final RequestQueue queue; public static void get( String path, final Context context, Response.Listener&lt;JSONObject&gt; res) { if(queue==null){ queue = Volley.newRequestQueue(context); } queue.add(new JsonObjectRequest(path, res, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError volleyError) { } })); } 解析接口 插件：转为Class实体对象 // gson转换导入 implementation 'com.google.code.gson:gson:2.8.5' 软件插件：json转为Class实体对象 JsonFormat：快捷键alt+s 解析成对象 Gson gson = new Gson(); Object text = gson.fromJson(jsonObject.toString(), Object.class); 25、Activity、Fragment+ViewPager的常用生命周期 Activity 简图 onCreate：入口 onStart：渲染 onResume：渲染数据 onRestart：重复渲染界面 onPause：页面显示完成 onStop：隐藏/离开界面 onDestroy:销毁界面 Fragment 简图 以上方法相似 … setUserVisibleHint：切换可见监听 @Override public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); if (isVisibleToUser){ //当前页面可见 Log.d(\"TestLog\",\"可见\"); }else { //滑动并不可见了 Log.d(\"TestLog\",\"不可见\"); } } 注意： 不能开启懒路由 26、交互对话框 Toast、Dialog、下弹框的使用 Toast:提示框 setDuration：显示时间 setGravity：显示位置 setText：显示文字 AlertDialog：对话框 简单使用 new AlertDialog.Builder(ViewPagerTest.this) .setCancelable(false) //是否可以主动取消 .setTitle(\"标题\") .setIcon(R.mipmap.ic_launcher) .setMessage(\"内容\") .show(); 注意：上下文不能乱给 属性方法 cancel：消失 自定义显示View View view = LayoutInflater.from(getApplicationContext()).inflate(R.layout.layout,null); //setView:填入 三方插件下弹框：BottomSheetDialog 推荐简书 https://www.jianshu.com/p/859943121b05 导入 //底部对话框 implementation 'com.github.rey5137:material:1.2.5' 使用 BottomSheetDialog bottomSheetDialog = new BottomSheetDialog(getApplicationContext()); bottomSheetDialog .contentView(view) .inDuration(100) .outDuration(100) .cancelable(true) .show(); 注意：上下文不能乱给 27、Animation动画、属性动画（上） 动画 帧动画:连续的播放每一帧的图片 准备图片资源 准备帧动画资源:在drawable文件中创建即可 &lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@drawable/listimage01\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/listimage02\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/listimage03\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/listimage04\" android:duration=\"100\"/&gt; &lt;/animation-list&gt; 给图片作为背景 获取背景并播放 ImageView imageView = findViewById(R.id.test); //获取背景，并将其强转成AnimationDrawable AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getBackground(); //判断是否在运行 if(!animationDrawable.isRunning()){ //开启帧动画 animationDrawable.start(); } 补间动画 创建动画文件包:anim 准备动画资源文件（注意名字不能大写） 使用动画 Animation animation = AnimationUtils.loadAnimation(getApplicationContext(),R.anim.anim); test.startAnimation(animation); translate：平移动画 &lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:fromXDelta=\"0%\" android:fromYDelta=\"0%\" android:toXDelta=\"50%\" android:toYDelta=\"0%\" android:duration=\"1000\" &gt; &lt;/translate&gt; fromXDelta：起始X轴位置 fromYDelta：起始Y轴位置 toXDelta：到X的位置 toYDelta：到Y的位置 duration：中间动画的时间（注意这个不提示，需要手写） 注意：这里通常使用%计算单位，面向与父容器的宽高 scale：缩放动画 &lt;scale android:fromXScale=\"100%\" android:fromYScale=\"0%\" android:toXScale=\"80%\" android:toYScale=\"80%\" android:pivotY=\"50%\" android:pivotX=\"50%\" android:duration=\"1000\" xmlns:android=\"http://schemas.android.com/apk/res/android\" /&gt; fromXScale：初始X大小 toXScale：缩小后的X大小 pivotX、pivotY：X、Y的中心点 rotate：旋转动画 &lt;rotate android:fromDegrees=\"0\" android:toDegrees=\"360\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:duration=\"4000\" xmlns:android=\"http://schemas.android.com/apk/res/android\" /&gt; fromDegrees：初始角度 toDegrees：旋转后角度 pivotX、pivotY：X、Y的中心点 alpha：透明度动画 &lt;alpha android:fromAlpha=\"0\" android:toAlpha=\"1\" android:duration=\"3000\" xmlns:android=\"http://schemas.android.com/apk/res/android\" /&gt; fromAlpha：初始透明度 toAlpha：最后透明度 &gt; + 注意：这里范围是:0.0-1.0 属性动画 方法一: 属性动画简述 以动画的形式改变像素位置 动画结束后组件固定位置 简单使用 final ValueAnimator animator; animator = ValueAnimator.ofInt(0,330); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator valueAnimator) { //获取当前的height值 //动态更新view的高度 mBt.getLayoutParams().height = (int) (Integer)animator.getAnimatedValue(); mBt.requestLayout(); } }); animator.setDuration(1000); animator.start(); 通过ValueAnimator获取动态值 通过动态值，改变组件的物理高度 注意：这里的单位是一致的 方法二: ObjectAnimator objectAnimatorX = ObjectAnimator.ofFloat(imageView, \"scaleX\", 1f,2f); ObjectAnimator objectAnimatorY = ObjectAnimator.ofFloat(imageView, \"scaleY\", 2f,1f); objectAnimatorX.setDuration(1000); objectAnimatorY.setDuration(1000); objectAnimatorX.start(); objectAnimatorY.start(); 28、Animation动画、属性动画（下） 技巧动画 + listView子级动画 + 创建一个子级的组合动画: list_item_set_anim.xml &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"10%\" android:toXDelta=\"0%\" android:duration=\"500\"/&gt; &lt;alpha android:fromAlpha=\"0.6\" android:toAlpha=\"1\" android:duration=\"500\"/&gt; &lt;/set&gt; + 创建一个layoutAnimation父级动画:list_anim.xml &lt;layoutAnimation android:animation=\"@anim/list_item_set_anim\" android:animationOrder=\"normal\" android:delay=\"0.5\" xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;/layoutAnimation&gt; &gt; + animationOrder:子级显示模式 &gt; &gt; + normal：按顺序 &gt; &gt; + reverse：倒序 &gt; &gt; + random：随机 &gt; &gt; + delay:每个子级间隔 &gt; &gt; + animation：子集动画 + 最后给listView使用 android:layoutAnimation=\"@anim/list_anim\" + 跳转Activit使用动画 Intent intent = new Intent(); intent.setClass(getApplicationContext(),Activity.class); startActivity(intent); overridePendingTransition(R.anim.anim_in,R.anim.anim_out); &gt; 注意： &gt; &gt; + overridePendingTransition方法一定在startActivity后面 &gt; + overridePendingTransition：参数1：当前页面消失动画，参数2：下个页面进入动画 + 普通模板跳转 + 跳转页面 startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(ButtonTest.this).toBundle()); &gt; 这个是默认自带的一个跳转 + 设置接收动画 getWindow().setEnterTransition(new Explode());//需要接收动画 &gt; 在跳转的界面接受即可 *共享元素跳转 跳转界面 startActivity(intent,ActivityOptions.makeSceneTransitionAnimation( ButtonTest.this, Pair.&lt;View, String&gt;create(mBt,\"btn-image\")).toBundle() ); 同样使用ActivityOptions Pair：添加共享元素的集合即可:==一个组件和一个共享名== 最后.toBundel() 设置接受动画的组件 android:transitionName=\"image\" 接受的组件的共享名 29、Media媒体播放音乐、视频 音乐 播放本地资源 软件资源 MediaPlayer.create(AnimationTest.this, R.raw.test); sd资源 try { mediaPlayer.setDataSource(\"../music/samsara.mp3\") ; } catch (IOException e) { e.printStackTrace(); } 播放网络资源 mMediaPlayer.setDataSource(\"http://..../xxx.mp3\") ; 使用异步：prepareAsync 并缓存完成才能播放：setOnPreparedListener 设置 需使用异步缓冲 mMediaPlayer.prepareAsync() ; 缓存完成后 setOnPreparedListener 监听缓存进度+ setOnBufferingUpdateListener 播放完成后 setOnCompletionListener 获取当前进度 mediaPlayer.getCurrentPosition(); 获取总播放进度：帧 mediaPlayer.getDuration() 设置进度 mediaPlayer.seekTo() 暂停 mediaPlayer.pause(); 继续/播放 mediaPlayer.start(); 停止 mediaPlayer.stop(); 视频 设置资源 sd资源 setVideoURI(Uri.parse(\"android.resource://\"+getPackageName()+\"/\"+R.raw.test_mp4)); 静态资源 setVideoPath(\"android.resource://\"+getPackageName()+\"/\"+R.raw.test_mp4); 播放网络视频 videoView.setVideoPath(\"https:/...\"); 并缓存完成才能播放：setOnPreparedListener 设置 绑定进度条 //设置进度条 MediaController mc = new MediaController(AnimationTest.this); //注意上下文 videoView.setMediaController(mc); 缓存完成 setOnPreparedListener 播放结束 setOnCompletionListener 设置进度 seekTo 使用相似… 推荐三方播放插件 哔哩哔哩开源:ijkplayer 30、SensorManager传感器的使用（隐式跳转）（上） 推荐网站 https://blog.csdn.net/weixin_38379772/article/details/79069494 初始化 SensorManager mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);//获取传感器管理器 //创建一个SensorManager来获取系统的传感器服务 SensorManager sm = (SensorManager) getSystemService(Context.SENSOR_SERVICE); 继承接口并实现方法 implements SensorEventListener{} @Override public void onSensorChanged(SensorEvent sensorEvent) { //监听回调 } @Override public void onAccuracyChanged(Sensor sensor, int i) { } 获取手机支持的所有传感器 List&lt;Sensor&gt; sensorList; // 实例化传感器管理者 // 得到设置支持的所有传感器的List sensorList = mSensorManager.getSensorList(Sensor.TYPE_ALL); for (Sensor sensor : sensorList) { Log.d(\"FDFDS\", \"onResume: \" + sensor.getName()); } 重力感应 注册传感器 //注册传感器 sm.registerListener(this, sm.getDefaultSensor(Sensor.TYPE_GRAVITY), SensorManager.SENSOR_DELAY_NORMAL); 监听判断 if(sensorEvent.sensor.getType() == Sensor.TYPE_GRAVITY) { float X = sensorEvent.values[0]; float Y = sensorEvent.values[1]; float Z = sensorEvent.values[2]; Log.d(\"FDFDS\",\"x方向的重力加速度\\n\" + X); Log.d(\"FDFDS\",\"Y方向的重力加速度\\n\" + Y); Log.d(\"FDFDS\",\"Z方向的重力加速度\\n\" + Z); } 就是把重力加速度分解到xyz三个方向上 光照感应器 注册传感器 // 为光传感器注册监听器 sm.registerListener(this, sm.getDefaultSensor(Sensor.TYPE_LIGHT), SensorManager.SENSOR_DELAY_NORMAL); 监听判断 if(sensorEvent.sensor.getType() == Sensor.TYPE_LIGHT){ float X = sensorEvent.values[0]; Log.d(\"FDFDS\",\"光强度为为\"+ X ); } 外部对手机的光照 隐式跳转 跳转电话 Intent Intent = new Intent(android.content.Intent.ACTION_DIAL, Uri.parse(\"tel:\" + \"123123123\"));//跳转到拨号界面，同时传递电话号码 startActivity(Intent); 跳转短信 //指定联系人 Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse(\"smsto:我是指定联系人\")); intent.putExtra(\"sms_body\", \"内容\"); startActivity(intent); 跳转相机 申请权限 &lt;!--拍照--&gt; &lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt; 动态获取权限… 隐式跳转 //跳转相机 private void toCamera() { Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); //跳转到 ACTION_IMAGE_CAPTURE //判断内存卡是否可用，可用的话就进行存储 //putExtra：取值，Uri.fromFile：传一个拍照所得到的文件，fileImg.jpg：文件名 intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(Environment.getExternalStorageDirectory(),\"fileImg.jpg\"))); startActivityForResult(intent,101); // 101: 相机的返回码参数（随便一个值就行，只要不冲突就好） } 6.0以上版本闪退问题 //跳转相机动态权限 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { StrictMode.VmPolicy.Builder builder = new StrictMode.VmPolicy.Builder(); StrictMode.setVmPolicy(builder.build()); } 31、SensorManager传感器的使用（指纹+NFC）（下） 系统指纹识别 推荐网站:https://www.jb51.net/article/92042.htm 初始化 FingerprintManager manager; KeyguardManager mKeyManager; private final static int REQUEST_CODE_CONFIRM_DEVICE_CREDENTIALS = 0; private final static String TAG = \"finger_log\"; manager = (FingerprintManager) this.getSystemService(Context.FINGERPRINT_SERVICE); mKeyManager = (KeyguardManager) this.getSystemService(Context.KEYGUARD_SERVICE); 识别代码 @RequiresApi(api = Build.VERSION_CODES.M) public boolean isFinger() { //android studio 上，没有这个会报错 if (ActivityCompat.checkSelfPermission(this, Manifest.permission.USE_FINGERPRINT) != PackageManager.PERMISSION_GRANTED) { Toast.makeText(this, \"没有指纹识别权限\", Toast.LENGTH_SHORT).show(); return false; } Log(TAG, \"有指纹权限\"); //判断硬件是否支持指纹识别 if (!manager.isHardwareDetected()) { Toast.makeText(this, \"没有指纹识别模块\", Toast.LENGTH_SHORT).show(); return false; } Log(TAG, \"有指纹模块\"); //判断 是否开启锁屏密码 if (!mKeyManager.isKeyguardSecure()) { Toast.makeText(this, \"没有开启锁屏密码\", Toast.LENGTH_SHORT).show(); return false; } Log(TAG, \"已开启锁屏密码\"); //判断是否有指纹录入 if (!manager.hasEnrolledFingerprints()) { Toast.makeText(this, \"没有录入指纹\", Toast.LENGTH_SHORT).show(); return false; } Log(TAG, \"已录入指纹\"); return true; } CancellationSignal mCancellationSignal = new CancellationSignal(); //回调方法 FingerprintManager.AuthenticationCallback mSelfCancelled = new FingerprintManager.AuthenticationCallback() { @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) @Override public void onAuthenticationError(int errorCode, CharSequence errString) { //但多次指纹密码验证错误后，进入此方法；并且，不能短时间内调用指纹验证 Toast.makeText(MediaTest.this, errString, Toast.LENGTH_SHORT).show(); showAuthenticationScreen(); } @Override public void onAuthenticationHelp(int helpCode, CharSequence helpString) { Toast.makeText(MediaTest.this, helpString, Toast.LENGTH_SHORT).show(); } @Override public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) { Toast.makeText(MediaTest.this, \"指纹识别成功\", Toast.LENGTH_SHORT).show(); } @Override public void onAuthenticationFailed() { Toast.makeText(MediaTest.this, \"指纹识别失败\", Toast.LENGTH_SHORT).show(); } }; @RequiresApi(api = Build.VERSION_CODES.M) public void startListening(FingerprintManager.CryptoObject cryptoObject) { //android studio 上，没有这个会报错 if (ActivityCompat.checkSelfPermission(this, Manifest.permission.USE_FINGERPRINT) != PackageManager.PERMISSION_GRANTED) { Toast.makeText(this, \"没有指纹识别权限\", Toast.LENGTH_SHORT).show(); return; } manager.authenticate(cryptoObject, mCancellationSignal, 0, mSelfCancelled, null); } /** * 锁屏密码 */ @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) private void showAuthenticationScreen() { Intent intent = mKeyManager.createConfirmDeviceCredentialIntent(\"finger\", \"测试指纹识别\"); if (intent != null) { startActivityForResult(intent, REQUEST_CODE_CONFIRM_DEVICE_CREDENTIALS); } } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE_CONFIRM_DEVICE_CREDENTIALS) { // Challenge completed, proceed with using cipher if (resultCode == RESULT_OK) { Toast.makeText(this, \"识别成功\", Toast.LENGTH_SHORT).show(); } else { Toast.makeText(this, \"识别失败\", Toast.LENGTH_SHORT).show(); } } } private void Log(String tag, String msg) { Log.d(tag, msg); } 最后判断使用 if (isFinger()) { Toast.makeText(MediaTest.this, \"请进行指纹识别\", Toast.LENGTH_LONG).show(); startListening(null); } NFC感应使用 申请权限 &lt;uses-feature android:name=\"android.hardware.nfc\" android:required=\"true\" /&gt; &lt;uses-permission android:name=\"android.permission.NFC\" /&gt; 动态申请权限… 准备一个NFC的工具类 public class NfcUtils { //nfc public NfcAdapter mNfcAdapter; public static IntentFilter[] mIntentFilter = null; public static PendingIntent mPendingIntent = null; public static String[][] mTechList = null; public NfcUtils(Activity activity) { mNfcAdapter = NfcCheck(activity); NfcInit(activity); } /** * 检查NFC是否打开 */ public static NfcAdapter NfcCheck(Activity activity) { NfcAdapter mNfcAdapter = NfcAdapter.getDefaultAdapter(activity); if (mNfcAdapter == null) { Toast.makeText(activity, \"设备不支持NFC功能!\", Toast.LENGTH_SHORT).show(); return null; } else { if (!mNfcAdapter.isEnabled()) { IsToSet(activity); } else { Toast.makeText(activity, \"NFC功能已打开!\", Toast.LENGTH_SHORT).show(); } } return mNfcAdapter; } /** * 初始化nfc设置 */ public static void NfcInit(Activity activity) { Intent intent = new Intent(activity, activity.getClass()); intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); mPendingIntent = PendingIntent.getActivity(activity, 0, intent, 0); //做一个IntentFilter过滤你想要的action 这里过滤的是ndef IntentFilter filter = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED); //如果你对action的定义有更高的要求，比如data的要求，你可以使用如下的代码来定义intentFilter // IntentFilter filter2 = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED); // try { // filter.addDataType(\"*/*\"); // } catch (IntentFilter.MalformedMimeTypeException e) { // e.printStackTrace(); // } // mIntentFilter = new IntentFilter[]{filter, filter2}; // mTechList = null; try { filter.addDataType(\"*/*\"); } catch (IntentFilter.MalformedMimeTypeException e) { e.printStackTrace(); } mTechList = new String[][]{{MifareClassic.class.getName()}, {NfcA.class.getName()}}; //生成intentFilter mIntentFilter = new IntentFilter[]{filter}; } /** * 读取NFC的数据 */ public static String readNFCFromTag(Intent intent) throws UnsupportedEncodingException { Parcelable[] rawArray = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES); if (rawArray != null) { NdefMessage mNdefMsg = (NdefMessage) rawArray[0]; NdefRecord mNdefRecord = mNdefMsg.getRecords()[0]; if (mNdefRecord != null) { String readResult = new String(mNdefRecord.getPayload(), \"UTF-8\"); return readResult; } } return \"\"; } /** * 往nfc写入数据 */ public static void writeNFCToTag(String data, Intent intent) throws IOException, FormatException { Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG); Ndef ndef = Ndef.get(tag); ndef.connect(); NdefRecord ndefRecord = null; if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) { ndefRecord = NdefRecord.createTextRecord(null, data); } NdefRecord[] records = {ndefRecord}; NdefMessage ndefMessage = new NdefMessage(records); ndef.writeNdefMessage(ndefMessage); } /** * 读取nfcID */ public static String readNFCId(Intent intent) throws UnsupportedEncodingException { Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG); String id = ByteArrayToHexString(tag.getId()); return id; } /** * 将字节数组转换为字符串 */ private static String ByteArrayToHexString(byte[] inarray) { int i, j, in; String[] hex = {\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"}; String out = \"\"; for (j = 0; j &lt; inarray.length; ++j) { in = (int) inarray[j] &amp; 0xff; i = (in &gt;&gt; 4) &amp; 0x0f; out += hex[i]; i = in &amp; 0x0f; out += hex[i]; } return out; } private static void IsToSet(final Activity activity) { AlertDialog.Builder builder = new AlertDialog.Builder(activity); builder.setMessage(\"是否跳转到设置页面打开NFC功能\"); // builder.setTitle(\"提示\"); builder.setPositiveButton(\"确认\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { goToSet(activity); dialog.dismiss(); } }); builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }); builder.create().show(); } private static void goToSet(Activity activity) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.BASE) { // 进入设置系统应用权限界面 Intent intent = new Intent(Settings.ACTION_SETTINGS); activity.startActivity(intent); return; } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {// 运行系统在5.x环境使用 // 进入设置系统应用权限界面 Intent intent = new Intent(Settings.ACTION_SETTINGS); activity.startActivity(intent); return; } } } 初始化 NfcUtils nfcUtils = new NfcUtils(this); 检测是否拥有/开启nfc //设定intentfilter和tech-list。如果两个都为null就代表优先接收任何形式的TAG action。也就是说系统会主动发TAG intent。 if (nfcUtils.mNfcAdapter != null) { nfcUtils.mNfcAdapter.enableForegroundDispatch(this, NfcUtils.mPendingIntent, NfcUtils.mIntentFilter, NfcUtils.mTechList); }else { Toast.makeText(this, \"调用失败\", Toast.LENGTH_SHORT).show(); } 一般在生命周期的onResume方法中判断 优化清空缓存 @Override protected void onDestroy() { super.onDestroy(); nfcUtils.mNfcAdapter = null; } @Override protected void onPause() { super.onPause(); if (nfcUtils.mNfcAdapter != null) { nfcUtils.mNfcAdapter.disableForegroundDispatch(this); } } 传感回调 //在onNewIntent中处理由NFC设备传递过来的intent @Override protected void onNewIntent(Intent intent) { super.onNewIntent(intent); Log.e(TAG, \"--------------NFC-------------\" ); processIntent(intent); } 获取数据 // 这块的processIntent() 就是处理卡中数据的方法 public void processIntent(Intent intent) { Parcelable[] rawmsgs = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);//获取数据 Toast.makeText(this, \"读取成功!\", Toast.LENGTH_SHORT).show(); } 32、Service服务+广播的简单使用（理解）（上） 理解service和广播 四大组件之一 activity（活动/界面） service（服务） Broadcast Receive（广播） Content Provider（内容提供者） 可以比作为线程的逻辑 服务与全软件界面 广播发送全软件界面 构造 package com.example.t_world.service; import androidx.annotation.NonNull; import androidx.annotation.RequiresApi; import androidx.localbroadcastmanager.content.LocalBroadcastManager; public class MyService extends Service { @Override public void onDestroy() { super.onDestroy(); Log.d(BasDataUtil.LOG_TOAST, \"服务销毁;\"); } @Override public void onCreate() { super.onCreate(); Log.d(BasDataUtil.LOG_TOAST, \"服务创建----Create\"); } public MyService() { Log.d(BasDataUtil.LOG_TOAST, \"实例化MyService服务\"); } @Override public IBinder onBind(Intent intent) { Log.d(BasDataUtil.LOG_TOAST, \"服务----绑定成功\"); // TODO: Return the communication channel to the service. //返回到服务的通信通道。 return new PlayMusicBinder(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { try { String activityKey = intent.getStringExtra(\"data\"); if (activityKey!=null){ //intent传入的参数接收 } }catch (Exception e){ Log.d(BasDataUtil.LOG_TOAST,\"播放音乐服务--发广播/收广播错误:\"+e.toString()); } return super.onStartCommand(intent, flags, startId); } @Override public boolean onUnbind(Intent intent) { Log.d(BasDataUtil.LOG_TOAST, \"解绑MyService成功\"); return super.onUnbind(intent); } } 注意: 启动服务调用的是onCreate 关闭服务调用的是:onDestroy 绑定服务调用的是onBind 取消绑定调用的是:onUnbind intent传参数跳转服务，需要接收使用:onStartCommand Intent intent = new Intent(this, MyService.class); startService(intent); 33、service服务+广播的简单使用（交互）（下） 服务(Service)向外互动 发送广播 服务准备代码 private LocalBroadcastManager localBroadcastManager; //准备发送广播控制器 @Override public void onCreate() { localBroadcastManager = LocalBroadcastManager.getInstance(this); //实例化 super.onCreate(); Log.d(BasDataUtil.LOG_TOAST, \"服务----Create\"); } //--------发送广播 Intent intent = new Intent(\"com.example.Service\"); //准备一个intent：并实例一个标识:可使用自己的包名 intent.putExtra(\"dataKey\", \"dataKey的值\");//需要传入的参数 localBroadcastManager.sendBroadcast(intent); //使用广播发送器发送 接收广播 private LocalReceiver localReceiver; private IntentFilter intentFilter; ///--提供广播监听 //监听广播 class LocalReceiver extends BroadcastReceiver { public void onReceive(Context context, Intent intent) { try { String dataKey = intent.getStringExtra(\"dataKey\"); //判定获取是否成功 }catch (Exception e){ Log.d(BasDataUtil.LOG_TOAST,\"播放接收广播错误：\"+e.toString()); } } } //--在该页注册广播 @Override protected void onStart() { //注册本地广播监听器 intentFilter = new IntentFilter(); //实例 intentFilter.addAction(\"com.example.Service\");//绑定标识 localReceiver = new LocalReceiver(); //实例 //广播 LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(PlayListActivity.this);//通过getInstance()得到LocalBroadcastManager的实例; localBroadcastManager.registerReceiver(localReceiver, intentFilter);//启动广播接收 super.onStart(); } 页面向服务(Service)交互 ​ 绑定服务，就可以交互 Service准备代码 //准备一个给页面调用的类 class PlayMusicBinder extends Binder {//例如这里可以直接播放，暂停，继续...各种操作 public PlayMusicBinder() { //初始化控制器 mediaPlayer = new MediaPlayer(); } public String getData(){ return \"这是服务中的方法\"; } } //准备一个IBinder，与页面交互:绑定立马调用 @Override public IBinder onBind(Intent intent) { Log.d(BasDataUtil.LOG_TOAST, \"服务----绑定成功\"); // TODO: Return the communication channel to the service. return new PlayMusicBinder(); //返回服务中的Binder类 } 页面绑定服务(Service)并，使用服务的方法 PlayMusicBinder playMusicBinder; //--准备一个接收服务管理器:绑定后直接调用 private ServiceConnection connection = new ServiceConnection() { /** * 连接到服务 * @param name * @param service */ @Override public void onServiceConnected(ComponentName name, IBinder service) { //连接服务成功 playMusicBinder = (PlayMusicBinder) service;//这里就直接获取了playMusicBinder控制 } /** * 断开连接 * @param name */ @Override public void onServiceDisconnected(ComponentName name) { } }; //--绑定服务 @Override protected void onStart() { // 绑定服务 bindService(new Intent(getApplicationContext(), AudioService.class), connection, Service.BIND_AUTO_CREATE); super.onStart(); } //---这个时候就可以直接使用了 playMusicBinder.getData(); 34、Android中的数据存储/传输（本地数据)（上) 变量 int i; String s; 使用范围：当前代码块 全局变量 public static int i; public static String s; 使用范围：跨类可以使用 跳转界面传入数据 传入基础数据 跳转传入数据 Intent intent =new Intent(getApplicationContext(), Activity2.class); intent.putExtra(\"key01\",\"value01\"); startActivity(intent); 接受传入的数据 Intent intent= getIntent(); Log.d(BaseData.LOG_TOAST,intent.getStringExtra(\"key01\")); 这里注意获取可能为null 传入对象 准备一个对象类 public class User implements Serializable { String name; int id; ... 该类需要继承 implements Serializable ，才能被存入 跳转传入数据 Intent intent =new Intent(getApplicationContext(), ServiceTset2.class); User user = new User(\"12\",1); Bundle bundle = new Bundle(); bundle.putSerializable(\"user\", user); intent.putExtras(bundle); startActivity(intent); 注意： 这里使用Bundle来存入数据，使用方法和intent类似 它相当于一个集合 接受传入的数据 Bundle intent= getIntent().getExtras(); User user= (User) intent.get(\"user\"); Log.d(BaseData.LOG_TOAST,user.toString()); 使用Bundle设置就得使用Bundle接受 使用SharedPreferences实现本地储存 使用范围：全软件,并与软件共存（因为它存在软件里的文件夹里(data/data/shared_perfs/文件名.xml)） 初始化 SharedPreferences sharedPreferences = getSharedPreferences(\"testSp\",MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); testSp：文件名.xml 模式 MODE_PRIVATE:默认模式，创建的文件只能由 调用的应用程序（或者共享相同用户ID的应用程序）访问。 sharedPreferences：用来读取文件中的键值 editor：用于写入文件中的键值 使用SharedPreferences 它的数据会一直保存只能自己删除或卸载软件 存入/更新 editor.putString(\"key\",\"testKey\"); editor.apply(); 删除 editor.remove(\"key\");//根据键删除 editor.clear();//清空 35、Android中的数据存储/传输（Sqlite)（下) 数据库的概率 可以拿表格办公软件理解 一个数据库包含多个表格 一个表格包含多个属性 一个属性有多个数据 简单使用SQLiteOpenHelper 首先准备一个Helpter的实例类(创建的数据库文件：data/data/软件软件/databases/数据库名.db) public class SqlitHelper extends SQLiteOpenHelper { private static String SQL_NAME = \"testSql.db\"; private static int SQL_VERSION = 1; public SqlitHelper(@Nullable Context context) { super(context, SQL_NAME, null, SQL_VERSION); } //注意这个方法只执行一次，所以在这创建表格 @Override public void onCreate(SQLiteDatabase db) { String sql = \"create table tb_user(name varchar(20),pwd varchar(20))\"; db.execSQL(sql); } //注意这个是数据库更新才调用 @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) { } } 注意： 这个可以当成模板，不需要死记 onCreate：注意这个方法只执行一次，所以在这创建表格 数据库的查删修 插入 SqlitHelper sqlitHelper = new SqlitHelper(this); SQLiteDatabase db = sqlitHelper.getWritableDatabase(); ContentValues values = new ContentValues(); values.put(\"name\",\"张三\"); values.put(\"pwd\",\"123\"); db.insert(\"tb_user\",null,values); 查询 SqlitHelper sqlitHelper = new SqlitHelper(this); SQLiteDatabase db = sqlitHelper.getWritableDatabase(); //创建游标对象 Cursor cursor = db.query(\"tb_user\", new String[]{\"name\",\"pwd\"}, null, null, null, null, null); //利用游标遍历所有数据对象 while(cursor.moveToNext()){ String name = cursor.getString(cursor.getColumnIndex(\"name\")); String pwd = cursor.getString(cursor.getColumnIndex(\"pwd\")); Log.d(BaseData.LOG_TOAST,\"数据库:\"+name+\",\"+pwd); } 删除：db.delete()… 使用Ormlite插件调用sqlite数据库 减少了sql语句操作 增加了对类的面向对象 简单使用 准备一个数据库的实体类 @DatabaseTable(tableName = \"tb_user2\")//创建表名 public class UserEntity implements Serializable { @DatabaseField() String name; @DatabaseField() String pwd; @DatabaseField() String age; ... 注意： DatabaseTable：注释写法，说明这个类对应表格名 DatabaseField：这个属性就是一个键 其他写法 @ DatabaseField注解可以有以下字段： columnName 列名，未指定时为字段名 dataType DataType类的类型的字段。通常的类型是从Java类的领域，并不需要指定。 defaultValue 默认值 width 宽度 默认是0，表示不限 canBeNull 是否允许为空，默认为true id 主键 默认为false generatedId 自增长的主键 默认值是false generatedIdSequence 字符串名称的序列号 类同generatedId，但您可以指定序列的名称使用。默认为null foreign 外键，默认为false,字段不能是一个原始类型。在外键对象的类中，必须要有一个ID字段（ID， generatedId，generatedIdSequence） useGetSet 应用get和set方法访问。默认为false unknownEnumName 表示该字段是一个Java的枚举类型 throwIfNull 如果为空值，抛出一个异常 默认为false persisted 是否在数据库中存储这个领域 默认为true format 指定某一特定领域的信息格式,如指定日期字符串的格式 unique 唯一约束，默认为false uniqueCombo 唯一行，该行内所有字段成为一个唯一约束，如有firstName 和 lastName两个字段，为\"张\"和\"梅\"，那么该表内不可再插 入\"张\"，\"梅\"， 但你可插入\"张\"，\"全梅\"。 index 是否建立索引 默认为false uniqueIndex 唯一索引 默认为false indexName 为这一领域的索引添加一个名字 uniqueIndexName 为这一领域的索引添加一个唯一的名字 foreignAutoRefresh 当查询到一个外键对象时，是否自动刷新 如 Order表中有Account外键对象，当返回Order的记录时是否也返回Account的记录， 默认为false maxForeignAutoRefreshLevel 为了防止无限递归或者无限循环时 需要用到该属性设置自动刷新的最高级别 allowGeneratedIdInsert 插入一个ID字段是否覆盖它生成的ID的对象 默认为false columnDefinition 定义列，默认情况下，数据库类型是用于自动生成所需的SQL来创建列，所以该属性并不常用 foreignAutoCreate 在插入一个有外键对象的对象时，是否自动插入这个外键对象 version 行版本 当一个对象被更新，以防止数据损坏多个实体时更新在同一时间进行的保护 实例OrmLiteSqliteOpenHelper public class SqlitOrmHelper extends OrmLiteSqliteOpenHelper { private static String SQL_NAME = \"testSql.db\"; private static int SQL_VERSION = 1; public SqlitOrmHelper(Context context) { super(context, SQL_NAME, null, SQL_VERSION); } @Override public void onCreate(SQLiteDatabase sqLiteDatabase, ConnectionSource connectionSource) { //创建表格 try { TableUtils.createTable(connectionSource, UserEntity.class); } catch (java.sql.SQLException e) { e.printStackTrace(); } } @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, ConnectionSource connectionSource, int i, int i1) { } } 查/删/改操作 首先获取它自带的dao文件 SqlitOrmHelper sqlitOrmHelper = new SqlitOrmHelper(this); try { Dao&lt;UserEntity, ?&gt; dao = sqlitOrmHelper.getDao(UserEntity.class); }catch (SQLException e) { e.printStackTrace(); } 插入 Dao&lt;UserEntity, ?&gt; dao = sqlitOrmHelper.getDao(UserEntity.class); UserEntity userEntity = new UserEntity(); userEntity.setName(\"张三orm\"); userEntity.setPwd(\"张三orm\"); userEntity.setAge(\"2\"); dao.create(userEntity); 查询 List&lt;UserEntity&gt; userEntities = dao.queryForAll(); Log.d(BaseData.LOG_TOAST,\"查询成功：\"+userEntities.toString()); 删除:复杂操作 DeleteBuilder&lt;UserEntity, ?&gt; userEntityDeleteBuilder = dao.deleteBuilder(); userEntityDeleteBuilder.where().eq(\"name\",\"张三orm\"); userEntityDeleteBuilder.delete();","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"LuckyBlog开源搭建教程","slug":"BlogOpen","date":"2020-09-16T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"posts/d74d8b76.html","link":"","permalink":"https://gitee.com/td278121/posts/d74d8b76.html","excerpt":"","text":"前言之前在B站上发布了个人博客的视频，播放量也破千了，有网友私聊也想要搭建一个这样的博客。经过一段时间的准备，现将本人博客的源代码公布出来，大家只需要根据以下的步骤，即可快速搭建一个漂亮完善的博客。 0x01 LuckyBlog 介绍上一个LuckyBlog版本发布于2020年的9月份，是在 洪卫の博客 基础上进行修改的。自从发布以来有很多网友都私信搭建了博客，同时也发现了旧版本中存在的一些问题需要解决，例如：搜索框不适配XML代码搜索，部分图片失效，代码块问题以及各种小问题。现在将最新的LuckyBlog版本代码发布出来，修复改进了不少的BUG，使其更加稳定运行。同时完善了博客的基础功能，例如：音乐、视频、相册、百宝箱等页面。同时增加了不少的新功能，例如：适配Hexo5.x、黑白天浏览模式、仿Windows页面，站点统计等。 博客演示地址：http://luckyzmj.cn/ 开源项目地址：https://github.com/LuckyZmj/LuckyBlog 主题特性 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录，优化了目录显示效果 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Valine） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 修改了原主题以及基础主题中的一些BUG 加入图片懒加载功能，在根目录配置文件开启和关闭 增加留言板功能 在关于板块,加入简历功能页 增加完善音乐、相册、视频等功能页面 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情 增加网站运行时间显示 增加live2d 动漫人物模型 整体替换Banner图片和文章特色图片 增加实用的快捷导航栏功能 修改了一些控件的参数以及部分样式 优化了代码显示块的效果 增加页面樱花飘落动效 增加鼠标点击烟花爆炸动效 增加页面雪花飘落动效 增加博客白云背景效果 增加天气接口控件 加入鼠标点击文字特效 增加DaoVoice在线聊天插件 增加博客代码、图片压缩功能 增加黑白天浏览模式功能 增加仿Windows功能 增加站点统计功能 增加留言版一言功能 其他 0x02 LuckyBlog 安装1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git的作用是将本地的网页文件传到github上。 Git下载地址 Git教程 windows： 到git官网上下载.exe文件,Download git,安装选项全部默认即可。 2. 安装node.jsHexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。 windows： 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 3. 添加npm国内源使用阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4. 安装Hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接鼠标右键git bash打开）。 比如我的博客文件都存放在C:\\MyBlog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v验证是否安装成功。 接下来初始化一下hexo,即初始化我们的博客网站。例如我的在C:\\MyBlog文件夹下的命令行中，输入hexo init初始化文件夹 hexo init 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 到此为止，本地的Hexo基础环境搭建完成了。 5. 安装LuckyBlog下载源代码到本地文件下 git clone https://github.com/LuckyZmj/LuckyBlog.git 将下载好的LuckyBlog全部复制到MyBlog目录下，如果复制过程中出现重复文件，点击替换。 最后使用 npm i 或者 npm install 安装依赖环境包即可。 如果安装依赖环境出错，可以参考这篇文章。 最后执行 hexo clean 和 hexo s -g 启动Hexo本地预览，即可看到效果。 到此为止LuckyBlog安装完成，接下来就是个性化设置了。 0x03 LuckyBlog 个性化 注意！注意！注意！在阅读以下博客个性化之前，最好希望大家有Hexo博客配置主题的基础。如果是完全小白，建议去网上搜索学习相关Hexo搭建博客的过程，另外去B站上也有很多视频教程。博客个性化是需要大家有耐心的，因为每个人的操作不同，在配置过程中可能会遇到一些不可预期的问题，希望大家可以克服这些困难，如有需要帮助，也可以私信博主帮助大家解决问题。 1. 修改部署平台编辑根目录下的配置文件MyBlog/_config.yml，找到如下内容并修改 deploy: - type: git repo: git@github.com:LuckyZmj/LuckyZmj.github.io.git # 替换为你的部署平台地址 branch: master 2. 修改网站信息编辑根目录下的配置文件MyBlog/_config.yml，找到如下内容并修改 # Site title: Luckey subtitle: 'Luckeyの博客' description: '本科 | 计算机科学与技术 | 网络安全' keywords: 'luckyzmj 计算机 网络安全 渗透测试' # 博客网站关键词 author: Luckey # 博主名称 language: zh-CN timezone: '' # URL ## If your site is put in a subdirectory, set url as 'http://example.com/child' and root as '/child/' url: http://www.luckyzmj.cn # 更改为你的博客地址 root: / # permalink: :year/:month/:day/:title/ permalink: posts/:abbrlink.html # p 是自定义的前缀 abbrlink: alg: crc32 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hex permalink_defaults: pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks 3. 修改博客头像编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 # Configure website favicon and LOGO # 将以下改为自己的头像链接即可 favicon: https://s1.ax1x.com/2020/05/17/YR20js.jpg logo: https://s1.ax1x.com/2020/05/17/YRWsYT.png 4. 修改留言板简介演示效果如下： 编辑 /MyBlog/contact/index.md，修改你想要内容即可 --- title: contact date: 2019-10-25 00:00:00 type: \"contact\" layout: \"contact\" --- ## 畅所欲言 --- 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ ## 友链 --- Lucky_Meの友链信息 博客名称: Lucky_Meの博客 博客网址: http://luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: 知识面决定攻击面，知识链决定攻击深度！ 5. 修改音乐列表想要修改自己喜欢的音乐之前，需要先获取音乐列表的id。 以QQ音乐为例：先登录QQ音乐网页版，点击打开自己喜欢的音乐列表，在网页的URL处包含了音乐列表的id，如下图所示 编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 # 默认是博主的QQ音乐的id，大家可以改为自己音乐喜欢列表的id # 更新完id，就可以同步加载自己喜欢的列表音乐了 # Whether to display the musics. # 是否在首页显示音乐. music: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 autoHide: true # hide automaticaly server: tencent #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 1776127550 #require song id / playlist id / album id / search keyword fixed: true # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 hideLrc: true # 隐藏歌词 # Whether to display the musics. # 单独的音乐页面. musics: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 server: tencent #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 1776127550 #require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: true # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: \"525px\" #列表最大高度 6. 绑定 Valine 评论编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 # Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey. valine: enable: true appId: Ucrxxxxxxxxxxxxxxxx-xxxxsz # 自行注册valine获取 appKey: zPsLxxxxxxxxxxxxxxerLmd # 自行注册valine获取 notify: true verify: true visitor: true avatar: 'monsterid' # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide pageSize: 10 placeholder: '留下你的足迹..' # Comment Box placeholder background: /medias/comment_bg.png count: true enableQQ: 16463223 # 改为自己的QQ号 recordIP: true requiredFields: - nick - mail guest_info: - nick - mail - link master: - 46606772953bed0812789d6dc955614e # md5加密后的博主邮箱 metaPlaceholder: # 输入框的背景文字 nick: 昵称/QQ号(必填) mail: 邮箱(必填) link: 网址(https://) lang: zh-CN tagMeta: # The String Array of Words to show Flag.[Just Only xCss Style mode] - 博主 - 小伙伴 - 访客 friends: # The MD5 String Array of friends Email to show friends Flag.[Just Only xCss Style mode] - cb3e577ff029d6073400d5557effd41f - 7. 绑定 DaoVoice 在线聊天编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 daovoice: enable: true app_id: 4xxxxxxxe #DaoVoice中的app_id 8. 快捷导航页面个性化编辑文件MyBlog/source/tools/index.html，以下简单标记出几处，还有其他涉及到博客信息的内容都需要改为你自己的博客信息即可。 9. 添加友情链接编辑文件MyBlog/suorce/_data/friends.json，按如下格式添加友情 [ { \"avatar\": \"https://s1.ax1x.com/2020/05/17/YRWsYT.png\", \"name\": \"Luckey\", \"introduction\": \"越努力，越幸运\", \"url\": \"http://www.luckyzmj.cn\", \"title\": \"访问主页\" },{ \"avatar\": \"https://sunhwee.com/hwsun.jpg\", \"name\": \"洪卫の博客\", \"introduction\": \"UESTC CVer\", \"url\": \"http://sunhwee.com\", \"title\": \"访问主页\" } ] 10. 添加相册比如你的图片上传图床后，链接地址如下 https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/璀璨星空/01.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/璀璨星空/02.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/动漫风景/01.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/动漫风景/02.jpg ... 首先提取出图片链接公共的部分，作为图床地址 https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/ 然后再提取图片地址中不同的部分，作为图片地址 璀璨星空/01.jpg 璀璨星空/02.jpg 动漫风景/01.jpg 动漫风景/03.jpg ... 具体怎么分割根据你自己图床的链接格式而定，以上为我的github图床格式为例。 将相册图床的地址改为你自己的图床地址，需要更改两处文件 # 例如我的图床地址为： https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/ themes/matery/layout/galleries.ejs themes/matery/layout/gallerie.ejs 为每个相册添加链接地址，在根目录/source/List/galleries/下新建 相册名称 文件夹，并在该文件夹下新建 index.md 最后，在根目录/source/_data/galleries.json中添加图片链接，格式如下, [ { \"name\": \"璀璨星空\", \"cover\": \"璀璨星空/01.jpg\", \"description\": \"璀璨星空\", \"photos\": [ \"璀璨星空/01.jpg\", \"璀璨星空/02.jpg\", \"璀璨星空/03.jpg\", \"璀璨星空/04.jpg\", \"璀璨星空/05.jpg\", \"璀璨星空/06.jpg\", \"璀璨星空/07.jpg\", \"璀璨星空/08.jpg\", \"璀璨星空/09.jpg\", \"璀璨星空/10.jpg\", \"璀璨星空/11.jpg\", \"璀璨星空/12.jpg\", \"璀璨星空/13.jpg\", \"璀璨星空/14.jpg\", \"璀璨星空/15.jpg\", \"璀璨星空/16.jpg\" ] }, { \"name\": \"动漫风景\", \"cover\": \"动漫风景/01.jpg\", \"description\": \"动漫风景\", \"photos\": [ \"动漫风景/01.jpg\", \"动漫风景/02.jpg\", \"动漫风景/03.jpg\", \"动漫风景/04.jpg\", \"动漫风景/05.jpg\", \"动漫风景/06.jpg\", \"动漫风景/07.jpg\", \"动漫风景/08.jpg\", \"动漫风景/09.jpg\", \"动漫风景/10.jpg\", \"动漫风景/11.jpg\", \"动漫风景/12.jpg\", \"动漫风景/13.jpg\", \"动漫风景/14.jpg\", \"动漫风景/15.jpg\", \"动漫风景/16.jpg\" ] } ] 11. 站点统计功能站点统计的数据来源于百度统计,当你的网站被百度收录后就会在百度统计中出现数据，具体效果如下： 由于博客的统计页面数据不能直接从百度站点中调用，因此需要自行从百度站点中将相应数据填入博客站点统计页面的源代码文件中，个人建议每隔一个月手动更新一次数据。 打开MyBlog\\themes\\matery\\layout\\census.ejs文件，将百度统计中的数据填入源代码中，修改代码如下： 11. 仿Windows个性化仿Windows页面是采用YLUI实现的，YLUI提供了社区版本供大家学习使用，具体效果如下： 大家可以查看YLUI官方的开发文档进行开发，有不懂的可以加官方的QQ群：191372634 进行讨论。 12. 博客动漫风格背景图因为在上一个LuckyBlog版本发布的网站风格是偏向动漫风格的，如果大家喜欢动漫风格，只需要替换以下配置即可。 博客每日轮播图： 以下链接图片全部下载保存到MyBlog\\themes\\matery\\source\\medias\\banner中，以0~7.jpg的文件名格式命名即可。 https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/0.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/1.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/2.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/3.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/4.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/5.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/6.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/7.jpg 无文章特色背景图： 打开主题配置文件MyBlog\\themes\\matery\\_config.yml，修改替换如下代码即可： # The post featured images that needs to be displayed when there is no image. # 无文章特色图片时需要显示的文章特色图片. featureImages: - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/01.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/02.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/04.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/06.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/07.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/10.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/11.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/12.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/09.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/14.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/15.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/16.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/06.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/02.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/03.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/04.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/07.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/08.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/11.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/10.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/09.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/12.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/13.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/14.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/16.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/15.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/11.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/09.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/03.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/08.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/03.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/13.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/01.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/05.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/14.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/01.jpg 0x04 更多内容优化以上简单介绍了 LuckyBlog 中一些要修改的个性化地方，其他更详细的优化参考其他关于Matery的文章。以下几篇文章都是基于hexo-theme-matery主题优化的教程，大家如果遇到问题，可以参考其中的方法。 个人博客搭建 Hexo+Github博客搭建完全教程 hexo-theme-matery作者教程 Hexo+github搭建博客(超级详细版，精细入微) hexo（matery）背景、滚动条优化+增加点击跳评论","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://gitee.com/td278121/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"hexo-blog-lucky","slug":"hexo-blog-lucky","permalink":"https://gitee.com/td278121/tags/hexo-blog-lucky/"},{"name":"博客搭建教程","slug":"博客搭建教程","permalink":"https://gitee.com/td278121/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"}],"author":"luckyzmj"},{"title":"Hexo之渲染绕过","slug":"Hexo-xr","date":"2020-04-27T16:00:00.000Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"posts/17fd92ae.html","link":"","permalink":"https://gitee.com/td278121/posts/17fd92ae.html","excerpt":"","text":"0x001 Hexo 渲染 在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。因此对某个文件或者目录进行排除渲染是非常必要的。 0x002 方法一：font matterHexo新建网站页面，然后将你的代码直接写入 index.md 中 在 Front matter 中添加 layout: false，此方法适用于单一的纯HTMLCSS 页面。 --- title: tools date: 2020-04-28 00:00:00 type: \"tools\" layout: false --- 0x003 方法二：skip render在博客根目录下的 _config.yml，找到 skip_render，大概在32行左右，写入你想要的跳过渲染的路径，注意缩进和空格。 # 指定目录跳过hexo渲染 skip_render: - 'tools/*' - 'tools/**' 注释：tools/* 表示在目录 source/fireworks 下的文件全部跳过渲染，tools/** 表示在博客根目录 source/tools/ 文件夹下的文件全部跳过渲染（例如页面的 js、css 在另一个文件夹中）。 0x004 案例：webstack 导航webstack是一个纯静态的网址导航网站，内容均由viggo收集并整理。项目基于bootstrap前端框架开发。 Github：https://github.com/WebStackPage/WebStackPage.github.io 在博客根目录 source/下新建tools，然后新建index.html,将webstack网页源码全选复制粘贴到里面。 本站的webstack源码：view-source:http://luckyzmj.cn/tools/ 注意：将源码里的部分信息以及跳转链接按照你真实个人博客的环境进行修改。 然后打开博客根目录下配置文件_config.yml，找到skip_render，做如下修改： skip_render: - 'tools/*' - 'tools/**' 最后执行hexo clean和hexo s -g 本地预览，检查无误后hexo g -d部署到服务器上即可。 参考文章 https://xiabor.com/2020/04/21/hexo3/#%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87hexo%E7%9A%84%E6%B8%B2%E6%9F%93","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://gitee.com/td278121/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://gitee.com/td278121/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"https://gitee.com/td278121/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"}],"author":"luckyzmj"},{"title":"文字背景粒子特效","slug":"jQuery+CSS3","date":"2020-03-26T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"posts/4b3510a4.html","link":"","permalink":"https://gitee.com/td278121/posts/4b3510a4.html","excerpt":"","text":"前言一款jQuery+CSS3的文字背景粒子动画特效，一共6种粒子效果，每种文字背景的粒子效果都不同，有漂浮的有坠落的等等。 0x001 特效演示 This is fires This is lines This is hearts This is bubbles This is confetti This is sunbeams .particletext { } .fire > .particle { position: absolute; background-color: rgba(255, 193, 7, 0.5); border-radius: 40px; border-top-right-radius: 0px; -webkit-animation: fires 0.8s linear infinite; animation: fires 0.8s linear infinite; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); opacity: 0; } /*css keyframes 动画*/ @-webkit-keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } @keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } function fire() { $.each($(\".particletext.fire\"), function(){ var firecount = ($(this).width()/50)*20; for(var i = 0; i .particle { position: absolute; background-color: rgba(244, 67, 54, 0.5); -webkit-animation: lines 3s linear infinite; animation: lines 3s linear infinite; } @-webkit-keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } @keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } function lines() { $.each($(\".particletext.lines\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: #cc2a5d; -webkit-animation: hearts 3s ease-in infinite; animation: hearts 3s ease-in infinite; } .hearts > .particle:before,.hearts > .particle:after { position: absolute; content: ''; border-radius: 100px; top: 0px; left: 0px; width: 100%; height: 100%; background-color: #cc2a5d; } .hearts > .particle:before { -webkit-transform: translateX(-50%); transform: translateX(-50%); } .hearts > .particle:after { -webkit-transform: translateY(-50%); transform: translateY(-50%); } @-webkit-keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } @keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } function hearts() { $.each($(\".particletext.hearts\"), function(){ var heartcount = ($(this).width()/50)*5; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: rgba(33, 150, 243, 0.5); -webkit-animation: bubbles 3s ease-in infinite; animation: bubbles 3s ease-in infinite; border-radius: 100%; } @-webkit-keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } @keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } function bubbles() { $.each($(\".particletext.bubbles\"), function(){ var bubblecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; -webkit-animation: confetti 3s ease-in infinite; animation: confetti 3s ease-in infinite; } .confetti > .particle.c1 { background-color: rgba(76, 175, 80, 0.5); } .confetti > .particle.c2 { background-color: rgba(156, 39, 176, 0.5); } @-webkit-keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } @keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } function confetti() { $.each($(\".particletext.confetti\"), function(){ var confetticount = ($(this).width()/50)*10; for(var i = 0; i .particle { position: absolute; background-color: rgba(253, 216, 53, 0.5); -webkit-animation: sunbeams 3s linear infinite; animation: sunbeams 3s linear infinite; } @-webkit-keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } @keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } function sunbeams() { $.each($(\".particletext.sunbeams\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i","categories":[{"name":"前端篇","slug":"前端篇","permalink":"https://gitee.com/td278121/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"jQuery+CSS3","slug":"jQuery-CSS3","permalink":"https://gitee.com/td278121/tags/jQuery-CSS3/"},{"name":"粒子特效","slug":"粒子特效","permalink":"https://gitee.com/td278121/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"}],"author":"Luckey"},{"title":"PicGo+GitHub 图床搭建","slug":"PicGo-GitHub","date":"2020-03-14T16:00:00.000Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"posts/7a46f93c.html","link":"","permalink":"https://gitee.com/td278121/posts/7a46f93c.html","excerpt":"","text":"前言用GitHub搭建图床，在很久之前我就有了解，但由于市面上有挺多免费的图床，比如我之前一直在用的 路过图床，所以一直懒得动手搭建GitHub图床。一直到前两天我在完善博客的相册时，发现 路过图床 免费版的有这么多限制，比如：每小时限制上传50张图片，每天限制上传100张图片，而且免费版用户的存储容量貌似不过300M，这才意识到有一个自己的GitHub图床是多么重要。 0x001 PicGO 介绍PicGo是一款图片上传工具，目前支持 SM.MS图床、腾讯云COS、GitHub图床、七牛图床、Imgur图床、阿里云OSS、又拍云图床，未来将支持更多图床。 在支持的这些图床中，SM.MS和Imgur有免费版和收费版，免费版的肯定有很多的使用限制，比如每小时限制上传次数，限制用户的上传容量等等；腾讯云COS、阿里云、有拍云都是要收费使用的；七牛云貌似前期使用免费，后期又要收费才能使用，就剩下的GitHub才是免费且最可靠的。 PicGo源项目GitHub地址已给出，但是去GitHub下载速度非常慢，这里额外提供一个蓝奏云的快速下载地址。 GitHub地址：https://github.com/Molunerfinn/PicGo 蓝奏云地址：https://luckyzmj.lanzous.com/id3e0id 0x002 GitHub 图床1. 创建GitHub图床仓库首先需要有一个登录GitHub的账号，没有的话去GitHub官网注册一个 创建一个新的图床仓库，点击右上角的New repository 填写如下配置信息，然后Create创建仓库 2. 获取GitHub token值点击右上的头像，选择设置Setting 点击选择Developer settings 点击 Generate New token 填写如下配置信息，只要勾选repo选项即可，然后页面拉到底部点击Generate token 即可 此时会跳转到带有token的页面，将token值复制记录下来，之后用PicGo绑定GitHub图床时会利用到 0x003 PicGo 配置1. 绑定GitHub图床首先下载安装好PicGo软件，然后在右列表找到GitHub图床配置 1. 设定仓库名(必填)： 按照“GitHub账户名/仓库名的格式填写”，比如我的是：Luckyzmj/imgbed 2. 设定分支名(必填)： 分支名统一填写“master” 3. 设定Token(必填)： 将之前步骤的Token值复制粘贴到这里 4. 指定存储路径： 这个选项可以为空，如果想将图片上传到仓库的指定目录下，可以填写目录名加/，比如我的imgbed仓库下有个posts文件夹，需设置为 posts/ 5. 设定自定义域名： 这里统一用jsdelivr的CDN加速域名，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接 自定义域名格式：https://cdn.jsdelivr.net/gh/GitHub账户名/仓库名 以我的格式为例：https://cdn.jsdelivr.net/gh/Luckyzmj/imgbed 配置完全部信息后，点击 设为默认图床，最后点击确定即可 2. 上传图片到图床在上传区上传图片，可支持本地图片上传(可多选图片)、剪贴板上传、URL上传等三种方式。上传图片成功后，选择你想要生成的图片链接格式 在图片区，可以看到成功上传的图片，选择相应的图片进行操作即可 3. PicGo 注意事项如果配置完PicGo后却上传图片失败，可以参考以下方法： 检查自定义域名是否正确 仓库名不要有空格 图片名字不要带有特殊符号，如：%、+、*、空格等 建议开启时间戳重命名，防止图片名字重复 上传图片间歇太短，需在PicGo设置中关闭Server选项 PicGo应用不稳定因素，需重启应用 参考文章 https://blog.csdn.net/sunhwee/article/details/100109956","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://gitee.com/td278121/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://gitee.com/td278121/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"https://gitee.com/td278121/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"luckyzmj"},{"title":"阿里云服务器部署Hexo博客","slug":"blog-aliyun","date":"2020-02-26T16:00:00.000Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"posts/19d2a4e6.html","link":"","permalink":"https://gitee.com/td278121/posts/19d2a4e6.html","excerpt":"","text":"前言 相信大部分人使用Hexo搭建个人博客都会部署到一些免费的代码托管平台上，但这些免费的平台总是差强人意，比如国外的GitHub平台虽然完全免费，但在国内访问加载速度非常慢，又或者是国内的码云平台免费版有许多功能被阉割掉了，比如不能自定义域名，不能每次自动刷新提交的代码，需要到码云平台上手动刷新，如此一来非常繁琐。 为了有效解决上诉的一些问题，有条件的话，不妨在自己的云服务器上搭建Hexo博客。 效果演示 这是Hexo博客部署到GitHub上的网站测速效果 这是Hexo博客部署到阿里云服务器后的网站测速效果 环境准备 本地环境：Windows 10 云服务器环境：阿里云ECS（CentOS7.x） 开始部署 本地环境搭建1.安装Git 到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择Use Git from the Windows Command Prompt。 Git下载地址 Git教程 2.安装Nodejs 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 使用npm阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4.安装Hexo 先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash here打开）。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v,若出现版本号则，说明安装成功。 接下来初始化一下hexo,即初始化我们的博客，输入hexo init初始化文件夹 hexo init MyBlog 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 输入hexo g生成静态网页，然后输入hexo s打开本地服务器预览 hexo g hexo s 生成ssh公钥在本地桌面点击右键Git Bash Here打开Git终端，执行如下命令`,一路回车 ssh-keygen -t rsa 这个时候它会告诉你已经生成了.ssh的文件夹。在git bash中输入 cat ~/.ssh/id_rsa.pub 输出的内容就是公钥信息了 阿里云服务器环境搭建安装Git yum install git 创建Git账户 adduser git 添加账户权限 chmod 740 /etc/sudoers vim /etc/sudoers 找到 ## Allow root to run any commands anywhere root ALL=(ALL) ALL 添加以下内容 git ALL=(ALL) ALL 保存退出并改回权限 chmod 400 /etc/sudoers 设置git账户密码 sudo passwd git 切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，并赋予相应的权限 su git mkdir ~/.ssh vim ~/.ssh/authorized_keys # 然后将win10中生成的id_rsa.pub文件中的公钥复制到authorized_keys chmod 600 /home/git/.ssh/authorized_keys chmod 700 /home/git/.ssh 在本地Git终端中测试是否能免密登录git，其中SERVER为填写自己的云主机IP，执行输入yes后不用密码就说明好了 ssh -v git@SERVER 创建目录 #repo作为为Git仓库目录 mkdir /var/repo chown -R git:git /var/repo chmod -R 755 /var/repo #hexo作为网站根目录 mkdir /var/www/hexo chown -R git:git /var/www/hexo chmod -R 755 /var/www/hexo 然后创建一个裸的 Git 仓库 cd var/repo git init --bare hexoBlog.git 创建一个新的 Git 钩子，用于自动部署 在 /var/repo/hexoBlog.git 下，有一个自动生成的 hooks 文件夹。我们需要在里边新建一个新的钩子文件 post-receive。 vim /var/repo/hexoBlog.git/hooks/post-receive 按 i 键进入文件的编辑模式，在该文件中添加两行代码（将下边的代码粘贴进去)，指定 Git 的工作树（源代码）和 Git 目录（配置文件等） #!/bin/bash git --work-tree=/var/www/hexo --git-dir=/var/repo/hexoBlog.git checkout -f 然后，按 Esc 键退出编辑模式，输入”:wq” 保存退出。 修改文件权限，使得其可执行 chown -R git:git /var/repo/hexoBlog.git/hooks/post-receive chmod +x /var/repo/hexoBlog.git/hooks/post-receive 到此为止 Git 仓库就搭建完成了。 阿里云服务器配置Nginx用宝塔面板来一键部署Nginx Linux面板6.0安装命令(暂时仅兼容Centos7.x，其它系统版本请安装5.9稳定版)： yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh Linux面板6.0升级专业版 curl http://download.bt.cn/install/update6.sh|bash 安装完成后会显示面板后台地址·账号·密码。打开面板后台地址登陆面板，选择Nginx的部署方案，静静等待部署。 部署完成，点击网站-添加站点-输入域名(没有域名的输入自己的IP地址)-底部的PHP版本选择”纯静态”-提交。 网站创建完成后点击设置-配置文件 server { listen 80; # server_name 填写自己的域名 server_name luckyzmj.cn blog.luckyzmj.cn; index index.php index.html index.htm default.php default.htm default.html; # 这里root填写自己的网站根目录，修改为/var/www/hexo root /var/www/hexo; -保存 点击设置-网站目录，修改为/var/www/hexo ，保存 重启宝塔面板服务 service bt restart 本地Hexo部署到阿里云服务器进入到本地Hexo博客的文件夹MyBlog,右键点击Git Bash Here，输入命令 #定义邮箱(更换为你的邮箱地址就行) git config --global user.email \"you@example.com\" #定义名称(更换自定义一个名称就行) git config --global user.name \"Your Name\" 配置_config.yml,完成自动化部署 打开本地Hexo博客的文件夹MyBlog文件夹下的_config.yml, 找到deploy deploy: type: git #server改为你的服务IP地址或解析后的域名 #例如我改为repo: git@luckyzmj.cn:/var/repo/blog.git repo: git@server:/var/repo/blog.git branch: master 保存后，即可测试部署 再进入到本地Hexo博客的文件夹MyBlog,右键点击Git Bash Here，输入命令 hexo clean hexo g -d 不报错说明完成，打开浏览器输入你的域名或ip地址就可以看到你部署的Hexo博客了。 到此为止，我们已经成功部完成，并且访问自己的服务器端比访问Github快多了。 小贴士 在部署过程中，执行 hexo d发现部署老是出错，什么权限不允许之类的，这里我们需要检查我们在上述的git操作部署是否使用了git用户操作，若是没有，需要给相应的目录更改用户组 使用 chown -R git:git /var/repo/ 这条命令递归的将repo目录及其子目录用户组设置为git。 同时使用 chown -R git:git /var/www/hexo 这样即可解决此类问题。 还有一个问题就是绑定域名后不能访问。原因是在国内任何域名只要绑定到国内的服务器主机上都必须去工信部和公安部备案完后才能正常使用。如果是港澳台的服务器或者是国外的服务器则可以不需要备案。 参考文章 https://blog.csdn.net/weixin_33907511/article/details/91398208?utm_source=distribute.pc_relevant.none-task","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://gitee.com/td278121/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://gitee.com/td278121/tags/Hexo/"},{"name":"阿里云","slug":"阿里云","permalink":"https://gitee.com/td278121/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"博客","slug":"博客","permalink":"https://gitee.com/td278121/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"luckyzmj"},{"title":"个人博客搭建","slug":"Blog","date":"2019-08-27T03:41:03.000Z","updated":"2020-10-08T11:03:24.000Z","comments":true,"path":"posts/e3e08109.html","link":"","permalink":"https://gitee.com/td278121/posts/e3e08109.html","excerpt":"","text":"0x001 效果演示 0x002 简单介绍 前前后后大概花了一周多的时间，目前个人博客已经完善的差不多了，现在写个文章做个阶段总结，后续如果有更新的地方，会及时补充。本博客基于Hexo框架，采用hexo-theme-matery主题，在这里非常感谢作者洪卫的hexo-blog-fly博客开源，极大简化了构建博客的工作量和复杂度。在此开源博客的基础上做了改进，修复了一些bug，顺利搭建完成了我的个人博客。大家对此主题有兴趣的可以下载源代码，搭建属于自己的个性化博客。 个人博客 演示：http://luckyzmj.cn 0x003 Hexo 初级搭建 1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git的作用是将本地的网页文件传到github上。 Git下载地址 Git教程 windows： 到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择Use Git from the Windows Command Prompt。 2. 安装node.jsHexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。 windows： 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 3. 添加npm国内源使用阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4. 安装Hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 比如我的博客文件都存放在E:\\MyBlog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v验证是否安装成功。 到此为止hexo就安装完了。 接下来初始化一下hexo,即初始化我们的网站，输入hexo init初始化文件夹 hexo init MyBlog 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 到此为止，本地的网站配置完成了。 输入hexo g生成静态网页，然后输入hexo s打开本地服务器 hexo g hexo s 5. 注册Github账号创建个人仓库接下来就去注册一个github账号，用来存放我们的网站。 打开https://github.com/，新建一个项目仓库New repository，如下所示： 然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上 要创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。例如我的：http://LuckyZmj.github.io 6. 生成SSH添加到GitHub生成SSH添加到GitHub，连接Github与本地。右键打开git bash here，然后输入下面命令： git config --global user.name \"注册GitHub用户名\" git config --global user.email \"注册GitHub的邮箱\" 用以下两条，检查一下你有没有输对 git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C \"注册GitHub的邮箱\" 这个时候它会告诉你已经生成了.ssh的文件夹。在git bash中输入 cat ~/.ssh/id_rsa.pub 将输出的内容复制到框中，点击确定保存。 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。如图： 在git bash输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。 ssh -T git@github.com 7. 将hexo部署到GitHub将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。找到如下配置进行修改： deploy: type: git repository: https://github.com/LuckyZmj/LuckyZmj.github.io branch: master repository修改为你自己的github项目地址即可，就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 npm install hexo-deployer-git --save 然后就可以部署提交到github，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了 hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西。 hexo generate，生成静态文章，可以用 hexo g缩写 ，hexo deploy部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 8. 写文章和发布文章首先在博客根目录下右键打开git bash here，安装一个扩展npm i hexo-deployer-git。 npm i hexo-deployer-git 然后输入hexo new post \"article title\"，新建一篇文章。 hexo new post \"article title\" 然后打开E:\\MyBlog\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件。 另外推荐直接使用有道云编写markdown文章，不仅可以实时预览，还可以快捷的生成markdown语法格式，具体效果如下图所示。 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章了。 到此为止，Hexo初级搭建就已经完成了。 0x004 Hexo 优化定制 1. Hexo相关目录文件1.1 博客目录构成介绍node_modules是node.js各种库的目录，public是生成的网页文件目录，scaffolds里面就三个文件，存储着新文章和新页面的初始设置，source是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件，themes存放着主题文件，一般也用不到。 我们平时写文章只需要关注source/_posts这个文件夹就行了。 - node_modules - public - scaffolds - source - _data - _posts - about - archives - categories - friends - tags - themes 1.2 hexo基本配置在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 1.2.1 网站参数描述title网站标题subtitle网站副标题description网站描述author您的名字language网站使用的语言timezone网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 1.2.2 网址参数描述url网址root网站根目录 permalink文章的永久链接格式permalink_defaults永久链接中各部分的默认值 在这里，你需要把url改成你的网站域名。 permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找永久链接 。 参数结果 :year/:month/:day/:title /2019/08/10/hello-world :year-:month-:day-:title.html 2019-08-10-hello-world.html :category/:titlefoo /bar/hello-world 2. 定制主题这里推荐作者洪卫的hexo-blog-fly博客主题，该主题是基于hexo-theme-matery优化的，需要把博客相关信息换成您自己的就可以部署了，极大简化了构建博客的工作量和复杂度。 2.1 简单使用方法 安装Git, 安装nodeJS，安装Hexo 你可以直接fork一份源码到你的仓库，clone到本地博客文件夹内 在本地博客仓库运行npm i命令安装依赖包 直接修改配置信息，改成自己的信息 运行命令hexo clean（清除生成文件），hexo g（生成网页）， hexo s（本地预览），hexo d（部署） 2.2 原主题特性: 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 2.3 新增加特性: 修改了原主题的一些很多bug 加入图片懒加载功能，在根目录配置文件开启和关闭 增加留言板功能 在关于板块,加入简历功能页 增加视听[视觉听觉影音]板块 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。 增加网站运行时间显示 增加动漫模型 整体替换Banner图片和文章特色图片 增加分类相册功能 修改了一些控件的参数 修改部分样式,比如: 文章卡片,固定高度,使其不至于因为文章摘要的长短不同导致卡片大小不一使页面布局很不美观,类似的还有友链卡片,优化了页面内容布局,视觉更整齐美观 解决首页文章列表卡片上方 border-radius圆角失效的bug 添加页面樱花飘落动效 添加鼠标点击烟花爆炸动效 加入天气接口控件 加入鼠标点击文字特效 添加页面雪花飘落动效 添加在线聊天插件 调整线聊天插件参数，使之能够随着鼠标滑动位置自适应调整 持续更新… 2.4 切换主题如果想自己动手对hexo-theme-matery优化的话，可以修改Hexo根目录下的 _config.yml的 theme 的值 theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 2.5 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： --- title: categories date: 2018-09-30 17:25:30 type: \"categories\" layout: \"categories\" --- 2.6 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： --- title: tags date: 2018-09-30 18:23:38 type: \"tags\" layout: \"tags\" --- 2.7 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： --- title: about date: 2018-09-30 17:25:30 type: \"about\" layout: \"about\" --- 2.8 新建留言板 contact 页（可选的）contact 页是用来展示留言板信息的页面，前提是已经开启了第三方评论系统才能显示。如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： --- title: contact date: 2018-09-30 17:25:30 type: \"contact\" layout: \"contact\" --- 2.9 新建友情链接 friends 页（可选的）friends 页是用来展示友情链接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： --- title: friends date: 2018-12-12 21:25:30 type: \"friends\" layout: \"friends\" --- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： [{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\" }] 2.10 一级菜单导航配置配置基本菜单导航的名称、路径url和图标icon 菜单导航名称可以是中文也可以是英文(如：Index或主页) 图标icon 可以在Font Awesome 中查找 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 2.11 二级菜单配置方法如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作 在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children) 在children下创建二级菜单的 名称name,路径url和图标icon. 注意每个二级菜单模块前要加 -. 注意缩进格式 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件。 2.12 代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： npm i -S hexo-prism-plugin 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： highlight: enable: false prism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 更多代码块优化详细内容请访问：http://luckyzmj.cn/posts/1b9a9e28.html 2.13 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： search: path: search.xml field: post 2.14 文章字数统计插件（建议安装）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount 插件。 安装命令如下： npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 2.15 添加emoji表情支持（可选的）本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下： npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 2.16 添加 RSS 订阅支持（可选的）本主题中还使用到了hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 2.17 添加 DaoVoice 在线聊天功能（可选的）前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。 2.18 添加 Tidio 在线聊天功能（可选的）前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 2.19 修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 2.20 修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： &lt;% if (theme.socialLink.github) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.github %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-github\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 2.21 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 2.22 配置音乐播放器（可选的）要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可 # 是否在首页显示音乐 music: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 server: netease #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 503838841 #require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 提示： server可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐）。 type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） id获取示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，地址栏有一串数字，playlist的id即为这串数字。 2.23文章 Front-matter 介绍Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。最简示例 --- title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 --- 最全示例 --- title: theme主题介绍 date: 2018-09-07 09:25:00 author: 赵奇 img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown --- 2.24 自定制修改在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的’爱心’效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：修改主题颜色 在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： /* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */ .bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); } @-webkit-keyframes rainbow { /* 动态切换背景颜色. */ } @keyframes rainbow { /* 动态切换背景颜色. */ } body { /* background-color: #eaeaea; */ /* 增加背景壁纸*/ background: url(\"https://ae01.alicdn.com/kf/H18a4b998752a4ae68b8e85d432a5aef0l.png\"), url(\"http://luckyzmj.cn/img/yun.jpg\") 0px 0px; background-attachment: fixed; margin: 0; color: #34495e; } 2.25 修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。 2.26 优化目录栏在 themes\\Matery\\layout\\_partial\\post-detail-toc.ejs，修改内容如下： .toc-widget { padding-left: 20px; width: 345px; background-color: rgb(255, 255, 255,0.7); border-radius: 10px; box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important; } #toc-content { margin-bottom: 20px; } 0x005 更多详细教程以下几篇文章都是基于Hexo框架和hexo-theme-matery主题优化的教程，大家如果遇到问题，可以参考其中的方法。 Hexo+Github博客搭建完全教程 hexo-theme-matery作者教程 Hexo+github搭建博客(超级详细版，精细入微) hexo（matery）背景、滚动条优化+增加点击跳评论","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://gitee.com/td278121/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://gitee.com/td278121/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://gitee.com/td278121/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Github","slug":"Github","permalink":"https://gitee.com/td278121/tags/Github/"}],"author":"luckyzmj"}],"categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://gitee.com/td278121/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"前端篇","slug":"前端篇","permalink":"https://gitee.com/td278121/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://gitee.com/td278121/tags/%E9%9A%8F%E7%AC%94/"},{"name":"笔记","slug":"笔记","permalink":"https://gitee.com/td278121/tags/%E7%AC%94%E8%AE%B0/"},{"name":"hexo-blog-lucky","slug":"hexo-blog-lucky","permalink":"https://gitee.com/td278121/tags/hexo-blog-lucky/"},{"name":"博客搭建教程","slug":"博客搭建教程","permalink":"https://gitee.com/td278121/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"https://gitee.com/td278121/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"https://gitee.com/td278121/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"},{"name":"jQuery+CSS3","slug":"jQuery-CSS3","permalink":"https://gitee.com/td278121/tags/jQuery-CSS3/"},{"name":"粒子特效","slug":"粒子特效","permalink":"https://gitee.com/td278121/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"},{"name":"PicGo","slug":"PicGo","permalink":"https://gitee.com/td278121/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"https://gitee.com/td278121/tags/GitHub%E5%9B%BE%E5%BA%8A/"},{"name":"阿里云","slug":"阿里云","permalink":"https://gitee.com/td278121/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"博客","slug":"博客","permalink":"https://gitee.com/td278121/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Github","slug":"Github","permalink":"https://gitee.com/td278121/tags/Github/"}]}